---
title: rs-async-p2-异步简介
comments: false
abbrlink: posts/rs-async-p2
date: 2021-09-12 12:04:09
top: 9998
tags: rust
keywords: [async, 异步, Rust]
---
> 来简单介绍一下异步吧  
<!-- more -->

同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)

# 开篇

**异步编程** (Asynchronous programming)  
是一种**并发编程模型** 

特点是通过少量`OS_thread(系统线程)`  
即可运行大量`并发任务`  
在某些场景下,可以疯狂压榨cpu的性能
~~(好吧,有点废话......)~~
- - -
# 模型对比
为何选择异步,它的优势有哪些?  

对于这个问题,我们将对比**异步**与其他**并发模型**  
以此来告诉大家,为什么选择异步:  

1.`OS Thread (系统线程)`  
由操作系统提供线程,进行并发,如std::thread  
Good_1:  
简单易使用,建模能力强,足够传统  
Good_2:  
操作系统就是运行时,与C语言交互方便  
Bad_1:  
数据同步困难,易发生数据竞争  
Bad_2:  
小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低


2.`Green Thread (绿色线程)`  
它几乎与系统线程一样,不过`Runtime(运行时,jvm/.net听说过吗?)`从操作系统变为了程序本身  
绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程  
Good:  
这意味着,程序本身对绿色线程有绝对的管理权  
所以内存分配等方面的粒度更细,根据任务大小调度内存  
因此堆栈大小,能够随时间推移而增长  
并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务  
Bad_1:  
它是程序本身实现模拟出来的线程,Runtime较巨大  
运行时会一直存在,即使你不用该特性,导致拖累全局程序性能  
并且难以与C库交互  
这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象  
它无法在语言层面被Rust支持  
Bad_2:  
绿色线程在不同平台上,其实现可能不同  
对多平台的支持/维护/改进得靠实现者保证  

`OS Thread`与`Green Thread`与Rust关系比较大:  
一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的  

- - -
# 异步
我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !     
 ~~(没把你憋坏吧伙计?)~~  
 
我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一  
假设我们正在单线程下,读取文件,并进行一个计算:  
```rust
// 定义文件
let file = /*  */

// 读取文件, 获取数据 
let data = read(file);

// 进行一个计算
compute()
```
以上面代码为例子,我们会读取 `file` 获取 `data`   
期间,我们的程序,做不了任何其他事情  
只有等待`IO操作(Input/Output, 输入/输出)`完毕,我们才能进行接下来的 `compute`  

`读取文件`,属于`IO操作`  
众所周知,IO操作很耗时,等待它完成的时间可能会很长  

有没有什么办法加快速度?  
没错,系统线程yyds:

```rust
// 定义文件
let file = /*  */

// 为每个读取任务新建线程, 并获取句柄
let handle_a = thread::spawan(|| read(file) );
let handle_b = thread::spawan(|| compute() );

// 使用join阻塞调用线程, 确保句柄线程执行结束
let data = handle_a.join().unwrap();
handle_b.join().unwrap();
```

因为两个任务`read`与`compute`是独立的,无依赖性  
所以我们`spawn`了两个线程  
第一个: 用于读取文件,获取数据
第二个: 用于在读取文件的同时,执行着 `compute`    
虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销   
而异步,就是只依靠单线程,也能够完成上面的操作  

单线程中的异步(伪)代码如下:
```rust
// 定义文件
let file = /*  */

// 读取文件, 获取数据 
let data = read_async(file);

// 进行一个计算
compute_async()
```

你会注意到:  
`read` -> `read_async`  
`compute` -> `compute_async`  

我用伪代码表示,这两个操作变成了异步操作  
你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念  
如下:    

- `read`:  
它会阻塞调用线程,等待该操作完毕后  
才继续往下执行`compute`  

阻塞期间是几乎不需要cpu参与运行的  
程序此时傻乎乎地等待阻塞结束  
无疑是对性能的浪费,对cpu的不尊重  

- `read_async`:  
它处于阻塞时,会运行`compute_async`  
线程由`read_async`接管变为由`compute_async`接管  
当阻塞时间结束,则程序继续变为运行`read_async`

`read_async`阻塞时,程序是不会傻傻等待的:  

若检测到它处于阻塞,无法取得进展    
则会运行其他异步任务,由其他异步任务接管线程  

总而言之,异步操作,其实就是:  
若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)  
使得cpu一直处于运算,性能被极限压榨  

异步操作,就像是可以随意`start/stop`一般  
调度程序能够对它们进行调度,决定当前要运算哪个操作  
确保不会因为阻塞而傻傻等待

只需单线程,就可以做到同时运行多个 `Task(异步任务)`  
异步当然也不排斥多线程:  
一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?

- - -

# 尾声
Q:  
阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  
A:  
现代电脑发展出了一些分担IO操作压力的高科技  
所以cpu对IO操作的压力较小/没有, IO时能进行其他运算  
只需要最后接收数据时, 出个场就行了  

所以我们的程序不需要在等待输入输出时就那样等着  
给它们找事情, 让它们闲不下来吧!  

