---
title: rs-async-p2-异步简介
abbrlink: rs-async-p2
top: 9998
tags: rust
categories: rust-async
date: 2021-09-12 12:04:09
---
> 来简单介绍一下异步吧  
<!-- more -->

# 开篇

**异步编程** (Asynchronous programming)  
是一种 **并发编程模型** 

特点是通过少量 `OS_thread (系统线程)`  
即可运行大量 `并发任务`  
在某些场景下, 可以疯狂压榨cpu的性能
~~(好吧, 有点废话......)~~
- - -
# 模型对比
为何选择异步, 它的优势有哪些?  

对于这个问题, 我们将对比 **异步** 与 其他 **并发模型**  
以此来告诉大家, 为什么选择异步:  

1.`OS Thread (系统线程)`  
由操作系统提供线程, 进行并发, 如std::thread  
Good_1:  
简单易使用, 建模能力强, 足够传统  
Good_2:  
操作系统就是运行时, 与C语言交互方便  
Bad_1:  
数据同步困难, 易发生数据竞争  
Bad_2:  
小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低


2.`Green Thread (绿色线程)`  
它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身  
绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程  
Good:  
这意味着, 程序本身对 Green_thread 有绝对的管理权  
所以内存分配等方面的粒度更细, 根据任务大小调度内存  
因此堆栈大小, 能够随时间推移而增长  
并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  
Bad_1:  
它是程序本身实现模拟出来的线程, Runtime 比较巨大  
运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互  
这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象  
它无法在语言层面被Rust支持  
Bad_2:  
绿色线程在不同平台上, 其实现可能不同  
对多平台的 支持/维护/改进 得靠实现者保证  

`OS Thread` 与 `Green Thread` 与 Rust 关系比较大:  
一个是Rust支持的传统并发, 一个是Rust在1.0之后便舍弃的  

- - -
# 异步
我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !     
 ~~(没把你憋坏吧伙计?)~~  
 
我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一  
假设我们正在单线程下, 读取文件, 并进行一个计算:  
```rust
// 定义文件
let file = /*  */

// 读取文件, 获取数据 
let data = read(file);

// 进行一个计算
compute()
```
以上面代码为例子, 我们会读取 `file` 获取 `data`   
期间, 我们的程序, 做不了任何其他事情  
只有等待 `IO操作 (Input/Output, 输入/输出)` 完毕, 我们才能进行接下来的 `compute`  

`读取文件`, 属于 `IO操作`  
众所周知, IO操作很耗时, 等待它完成的时间可能会很长  

有没有什么办法加快速度?  
没错, 系统线程yyds:

```rust
// 定义文件
let file = /*  */

// 为每个读取任务新建线程, 并获取句柄
let handle_a = thread::spawan(|| read(file) );
let handle_b = thread::spawan(|| compute() );

// 使用join阻塞调用线程, 确保句柄线程执行结束
let data = handle_a.join().unwrap();
handle_b.join().unwrap();
```

因为两个任务 `read` 与 `compute` 是独立的, 无依赖性  
所以我们 `spawn` 了两个线程  
第一个, 用于读取文件, 获取数据
第二个, 用于在读取文件的同时, 执行着 `compute`    
虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销   
而异步, 就是只依靠单线程, 也能够完成上面的操作  

(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  

单线程中的异步(伪)代码如下:
```rust
// 定义文件
let file = /*  */

// 读取文件, 获取数据 
let data = read_async(file);

// 进行一个计算
compute_async()
```

你会注意到:  
`read` -> `read_async`  
`compute` -> `compute_async`  

我用伪代码表示, 这两个操作变成了异步操作  
你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念  
如下:    

- `read`:  
它会阻塞调用线程, 等待该操作完毕后  
才继续往下执行 `compute`  

阻塞期间是几乎不需要cpu参与运行的  
程序此时傻乎乎地等待阻塞结束  
无疑是对性能的浪费, 对cpu的不尊重  

- `read_async`:  
它处于阻塞时, 会运行`compute_async`  
线程由 `read_async` 接管变为由 `compute_async`接管  
当阻塞时间结束, 则程序继续变为运行 `read_async`

`read_async` 阻塞时, 程序是不会傻傻等待的:  

若检测到它处于阻塞, 无法取得进展    
则会运行其他异步任务, 由其他异步任务接管线程  

总而言之, 异步操作, 其实就是:  
若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)  
使得cpu一直处于运算, 性能被极限压榨  

异步操作, 就像是可以随意 `start/stop` 一般  
调度程序能够对它们进行调度, 决定当前要运算哪个操作  
确保不会因为阻塞而傻傻等待

只需单线程, 就可以做到同时运行多个 `Task(异步任务)`  
异步当然也不排斥多线程:  
一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?

- - -

# 尾声
Q:  
阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  
A:  
现代电脑发展出了一些分担IO操作压力的高科技  
所以cpu对IO操作的压力较小/没有, IO时能进行其他运算  
只需要最后接收数据时, 出个场就行了  

所以我们的程序不需要在等待输入输出时就那样等着  
给它们找事情, 让它们闲不下来吧!  

