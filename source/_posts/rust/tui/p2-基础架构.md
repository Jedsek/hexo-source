---
title: "rust-tui-p2~> 基础架构"
abbrlink: posts/rust-tui/p2
hidden: false
date: 2023-06-22 19:07:34
top: 9798
tags: [Rust, TUI]
keywords: [Terminal, 终端, TUI, Rust]
is_series: true
series_link: rust-tui
prev_post: [posts/rust-tui/p1, "系列说明"]
next_post: [posts/rust-tui/p3, "基础架构"]
---
> 本节我们将学习一个 tui 应用的基本架构
<!-- more -->

同系列传送门: [rust-tui](/categories/rust-tui)

# 参考项目
本节的内容大致是带你捋下一个 tui 应用的基本架构， 参考项目是官方的 [github.com/tui-rs-revival/rust-tui-template](https://github.com/tui-rs-revival/rust-tui-template)  
在这之前, 你可以选择下载 `cargo-generate` 来快速开发 (当然光看下面的代码与概念也不是不行):  

```bash
cargo install cargo-generate
```

上面的项目是一个模板项目, 专门为了让别人快速开始敲代码, 而不是将时间浪费在编写大量重复代码身上  
如果你选择下载了 `cargo-generate`, 你可以通过如下命令快速搭建一个叫做 `tui-demo` 的项目 (为了网速考虑已经换成gitee镜像仓库了):  

```bash
cargo generate --git https://gitee.com/jedsek/rust-tui-template --name tui-demo
```

你会获得一个经典的双按钮应用: 显示一个数字, 随着按键而 +1 或 -1
搭建过程讲完了, 下面开始正文, 关于架构的讲解  

- - -

# 架构说明

```bash
src/
├── app.rs     -> 保存状态与应用逻辑
├── event.rs   -> 将待处理的终端事件包装成我们自己定义的事件模型, 并且分发事件 (key-event, mouse-event, resize-event 等)
├── handler.rs -> 接受分发的事件, 并让具体的处理函数与其一一匹配 (本系列我们只处理按键事件, 即 key-event)
├── lib.rs     -> 定义模块 (单纯的别把 `pub mod xxx` 写在 `main.rs` 里面而已) 
├── main.rs    -> 应用程序的入口
├── tui.rs     -> 初始化/退出tui时的一些操作
└── ui.rs      -> 渲染组件ui
```

项目中同时存在 `lib.rs` 与 `main.rs`, 因此存在两个crate, 前者是lib_crate, 后者是bin_crate  

```rust src/lib.rs
/// Application.
pub mod app;

/// Terminal events handler.
pub mod event;

/// Widget renderer.
pub mod ui;

/// Terminal user interface.
pub mod tui;

/// Event handler.
pub mod handler;
```

`lib.rs` 定义了这些模块, 因此我们不必在 `main.rs` 的头部再定义了  
**注意:**  
当 `lib.rs` 与 `main.rs` 同时存在时, 视 `lib.rs` 为项目根, 调用里面的东西用 `crate::xxx`  
而 `main.rs` 则视作作为依赖的bin_crate, 比如你的项目叫 `tui_app`, 调用里面的东西时就用 `tui_app::xxx` 即可  

看着这些架构, 你可能会有点懵, 没事, 爷慢慢跟你说, 保证你能明白  

## 状态管理

我们从简单开始, 先看 `app.rs`:  

+++ **点击展开/隐藏代码**
```rust src/app.rs
use std::error;

/// Application result type.
pub type AppResult<T> = std::result::Result<T, Box<dyn error::Error>>;

/// Application.
#[derive(Debug)]
pub struct App {
    /// Is the application running?
    pub running: bool,
    /// counter
    pub counter: u8,
}

impl Default for App {
    fn default() -> Self {
        Self {
            running: true,
            counter: 0,
        }
    }
}

impl App {
    /// Constructs a new instance of [`App`].
    pub fn new() -> Self {
        Self::default()
    }

    /// Handles the tick event of the terminal.
    pub fn tick(&self) {}

    /// Set running to false to quit the application.
    pub fn quit(&mut self) {
        self.running = false;
    }

    pub fn increment_counter(&mut self) {
        if let Some(res) = self.counter.checked_add(1) {
            self.counter = res;
        }
    }

    pub fn decrement_counter(&mut self) {
        if let Some(res) = self.counter.checked_sub(1) {
            self.counter = res;
        }
    }
}
```
+++

逻辑很简单, `App` 结构体里装着随应用运行而可能被改变的状态, 除此以外, 我们还定义了一些方法来修改这些状态  

比如 `quit()` 会让 `running` 变成 false, 以此来退出程序  
比如 `inc()/dec()` 会让要显示的数字的值 +1/-1, 并保证处于 0..=255 的范围内不产生溢出  

你可能会问, `tick()` 这玩意是干啥的? 空方法有啥用?  

在这之前, 你需要了解下 `Tick` 的概念, 其意思是时钟秒针的滴答声, 用来表示时间的最小化单位  
现实世界中目前可观测到的时间的最小单位是普朗克时间, 但一个运行在计算机里面的应用肯定不能这么算啊  

举个例子, 在著名的MMO类型游戏, Screeps 中, 游戏的基本时间单位就叫 `tick`  
所有玩家的代码会在同一时间并行执行, 随后以最后一份代码执行的结束, 代表着这一 `tick` 的结束  
再举个例子, 在大部分枪战fps游戏中, 也有 `tick` 这个概念, 代表每秒钟可以刷新多少次  

在该模板项目中, 会在一个设定好的时间如 200ms 后, 尝试着捕获一次终端事件, 若什么事件也没, 那就分发一个 Event::Tick 给我们的处理程序  
在处理程序中, 当接受到 Tick 事件时, 我们返回一个 (), 以此来无视它, 状态的变化啊, 视图的更改啊什么的, 也就根本不会发生  

这里的 `tick()` 方法, 也就是我们对 Event::Tick 事件的处理函数啦! 函数体是空的也就表示着无视它哦  


## 处理程序
讲完了 `app.rs` 中 `状态的保存` 与 `状态的更改` 之后, 我们会来看下 `handler.rs`, 即对事件的处理部分  
代码如下:  

+++ **点击展开/隐藏代码**
```rust src/handler.rs
use crate::app::{App, AppResult};
use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};

/// Handles the key events and updates the state of [`App`].
pub fn handle_key_events(key_event: KeyEvent, app: &mut App) -> AppResult<()> {
    match key_event.code {
        // Exit application on `ESC` or `q`
        KeyCode::Esc | KeyCode::Char('q') => {
            app.quit();
        }
        // Exit application on `Ctrl-C`
        KeyCode::Char('c') | KeyCode::Char('C') => {
            if key_event.modifiers == KeyModifiers::CONTROL {
                app.quit();
            }
        }
        // Counter handlers
        KeyCode::Right => {
            app.increment_counter();
        }
        KeyCode::Left => {
            app.decrement_counter();
        }
        // Other handlers you could add here.
        _ => {}
    }
    Ok(())
}
```
+++

`crossterm` 是一个用于操作终端的跨平台库, 提供了一些抽象与封装, 比如 `KeyEvent`:  

```rust
pub struct KeyEvent {
    /// The key itself.
    pub code: KeyCode,
    /// Additional key modifiers.
    pub modifiers: KeyModifiers,
    
    // ......
    // ......
    // ......
}
```

- `code`: 表示你按下的比如字母啊数字啊这种  
- `modifiers`: 表示修饰键, 如 `Shift`/`Ctrl`/`Alt`/`Super (windows里的图标键, 或macos里的cmd键)`  

顺带一提, 类似的终端操作库还有:  

- `termion`: 不跨平台, 仅限linux  
- `termwiz`: `wezterm` 的配套终端操作库, 有很多高级特性 + 跨终端, 但文档少而且api有亿点难用  

`ratatui-rs` 对其都有适配与支持, 比如当你如果想使用 `termwiz` + `ratatui`, 可以这样:  

```toml Cargo.toml
tui = { package = "ratatui", version = "0.21", default_features = false, features = ["crossterm", "macros"] }
termwiz = { version = "0.20.0", features = ["use_image"] }
```

本系列都将使用 `crossterm`, 因为资料多文档全 ~~(加上懒)~~  

位于 `handler.rs` 中的代码很好理解, 不过你可能还会再问:  
实际的处理程序, 好像就是 `app.rs` 里面的方法啊?  
那能不能取消这个模块, 全装到 `App` 里面去呢?  

刑, 当然可刑, 只是耦合度太高了, 不能想现在这样一目了然  

你想啊, 如果你全装到 `app.rs` 里面去, 本来只需要管理状态, 对状态进行保存与更改  
但现在就得与其他模块, 比如 `event.rs` 接轨打交道, 接受分发过来的事件并匹配相应的处理函数  
耦合度太高了!  各种事情粘在一起, 耦合在一起, 复杂啊!  

因此, `handler.rs` 是必不可少的, 其作用就像是网页中的路由那样, 调用着 `app.rs` 中改变状态的方法, 降低了耦合度  

**注意:**  
此处仅处理按键事件, 这也是大多数 tui 应用会处理的唯一事件  
你没有看见 `app::tick()`, 是因为 Event::Tick 不是按键事件, 自然没有在处理按键的相应函数中看见  
在 `main.rs` 中, 对全部终端事件的处理是这样的 (后面会讲) :  

```rust src/main.rs
// ......
    // Handle events.
    match tui.events.next()? {
        Event::Tick => app.tick(),
        Event::Key(key_event) => handle_key_events(key_event, &mut app)?,
        Event::Mouse(_) => {}
        Event::Resize(_, _) => {}
    }
// ......
```

## 视图渲染
一样, 我们先把简单的模块看了:  

+++ **点击展开/隐藏代码**
```rust src/ui.rs
use tui::{
    backend::Backend,
    layout::Alignment,
    style::{Color, Style},
    widgets::{Block, BorderType, Borders, Paragraph},
    Frame,
};

use crate::app::App;

/// Renders the user interface widgets.
pub fn render<B: Backend>(app: &mut App, frame: &mut Frame<B>) {
    // This is where you add new widgets.
    // See the following resources:
    // - https://docs.rs/ratatui/latest/ratatui/widgets/index.html
    // - https://github.com/tui-rs-revival/ratatui/tree/master/examples
    frame.render_widget(
        Paragraph::new(format!(
            "This is a tui template.\n\
                Press `Esc`, `Ctrl-C` or `q` to stop running.\n\
                Press left and right to increment and decrement the counter respectively.\n\
                Counter: {}",
            app.counter
        ))
        .block(
            Block::default()
                .title("Template")
                .title_alignment(Alignment::Center)
                .borders(Borders::ALL)
                .border_type(BorderType::Rounded),
        )
        .style(Style::default().fg(Color::Cyan).bg(Color::Black))
        .alignment(Alignment::Center),
        frame.size(),
    )
}
```
+++

看懂就行, 渲染了一个组件叫 `Paragraph`, 将 `app` 里面的状态, 即 `app.counter` 放上去显示  
因为 `ratatui-rs` 是 `即时模式` 的渲染策略, 所以用起来会比较简单, 当按下按键后counter加减, 视图会因为重渲染自己更新  

根据 [github仓库](https://github.com/tui-rs-revival/ratatui) 里的介绍, 它会在每一个新帧渲染所有 UI  
这虽然为丰富的交互式 UI 提供了极大的灵活性，但也可能会因高度动态的内容而带来开销  
~~(根据这份README所说, 实际上鉴于Rust的速度, 开销一般来自于终端, 而不是库本身)~~  


## 事件捕获
接下来, 我们将学习 `event.rs` 里的代码:  

+++ **点击展开/隐藏代码**
```rust src/event.rs
use crate::app::AppResult;
use crossterm::event::{self, Event as CrosstermEvent, KeyEvent, MouseEvent};
use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};

/// Terminal events.
#[derive(Clone, Copy, Debug)]
pub enum Event {
    /// Terminal tick.
    Tick,
    /// Key press.
    Key(KeyEvent),
    /// Mouse click/scroll.
    Mouse(MouseEvent),
    /// Terminal resize.
    Resize(u16, u16),
}

/// Terminal event handler.
#[allow(dead_code)]
#[derive(Debug)]
pub struct EventHandler {
    /// Event sender channel.
    sender: mpsc::Sender<Event>,
    /// Event receiver channel.
    receiver: mpsc::Receiver<Event>,
    /// Event handler thread.
    handler: thread::JoinHandle<()>,
}

impl EventHandler {
    /// Constructs a new instance of [`EventHandler`].
    pub fn new(tick_rate: u64) -> Self {
        let tick_rate = Duration::from_millis(tick_rate);
        let (sender, receiver) = mpsc::channel();
        let handler = {
            let sender = sender.clone();
            thread::spawn(move || {
                let mut last_tick = Instant::now();
                loop {
                    let timeout = tick_rate
                        .checked_sub(last_tick.elapsed())
                        .unwrap_or(tick_rate);

                    if event::poll(timeout).expect("no events available") {
                        match event::read().expect("unable to read event") {
                            CrosstermEvent::Key(e) => sender.send(Event::Key(e)),
                            CrosstermEvent::Mouse(e) => sender.send(Event::Mouse(e)),
                            CrosstermEvent::Resize(w, h) => sender.send(Event::Resize(w, h)),
                            _ => unimplemented!(),
                        }
                        .expect("failed to send terminal event")
                    }

                    if last_tick.elapsed() >= tick_rate {
                        sender.send(Event::Tick).expect("failed to send tick event");
                        last_tick = Instant::now();
                    }
                }
            })
        };
        Self {
            sender,
            receiver,
            handler,
        }
    }

    /// Receive the next event from the handler thread.
    ///
    /// This function will always block the current thread if
    /// there is no data available and it's possible for more data to be sent.
    pub fn next(&self) -> AppResult<Event> {
        Ok(self.receiver.recv()?)
    }
}
```
+++

在这里, 我们定义了自己的 Event 枚举, 


## 终端设置
呕吼, 你即将观看的代码, 其作用是设置与调整终端的环境, 以便我们的 tui 应用更好的运行, 接下来会逐步讲解相关概念  
代码如下:  


+++ **点击展开/隐藏代码**
```rust src/tui.rs
use crate::app::{App, AppResult};
use crate::event::EventHandler;
use crate::ui;
use crossterm::event::{DisableMouseCapture, EnableMouseCapture};
use crossterm::terminal::{self, EnterAlternateScreen, LeaveAlternateScreen};
use std::io;
use tui::backend::Backend;
use tui::Terminal;

/// Representation of a terminal user interface.
///
/// It is responsible for setting up the terminal,
/// initializing the interface and handling the draw events.
#[derive(Debug)]
pub struct Tui<B: Backend> {
    /// Interface to the Terminal.
    terminal: Terminal<B>,
    /// Terminal event handler.
    pub events: EventHandler,
}

impl<B: Backend> Tui<B> {
    /// Constructs a new instance of [`Tui`].
    pub fn new(terminal: Terminal<B>, events: EventHandler) -> Self {
        Self { terminal, events }
    }

    /// Initializes the terminal interface.
    ///
    /// It enables the raw mode and sets terminal properties.
    pub fn init(&mut self) -> AppResult<()> {
        terminal::enable_raw_mode()?;
        crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;
        self.terminal.hide_cursor()?;
        self.terminal.clear()?;
        Ok(())
    }

    /// [`Draw`] the terminal interface by [`rendering`] the widgets.
    ///
    /// [`Draw`]: tui::Terminal::draw
    /// [`rendering`]: crate::ui:render
    pub fn draw(&mut self, app: &mut App) -> AppResult<()> {
        self.terminal.draw(|frame| ui::render(app, frame))?;
        Ok(())
    }

    /// Exits the terminal interface.
    ///
    /// It disables the raw mode and reverts back the terminal properties.
    pub fn exit(&mut self) -> AppResult<()> {
        terminal::disable_raw_mode()?;
        crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;
        self.terminal.show_cursor()?;
        Ok(())
    }
}
```
+++

我们创建了一个叫做 `TUI` 的结构体, 它保存了
