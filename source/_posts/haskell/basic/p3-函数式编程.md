---
title: haskell-basic-p3-函数式介绍
abbrlink: posts/haskell-basic/p3
hidden: false
date: 2022-06-26 16:16:10
top: 10997
tags: [Haskell]
keywords: [Haskell, 函数式]
---
> 何为函数式编程(FP, 即Functional Programming) ?
<!-- more -->

同系列传送门: [haskell-basic](/categories/haskell-basic)

本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西  
那么, 开始吧!  

# 编程范式
## 概览
FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式  

编程范式是一种思考方式, 技术, 语言范式, 编程模型  
在世界上, 有许多编程范式, 最主要的有:  

|简称|中文名|英文名|
|--|--|--|
|FP|函数式编程|Functional Programming|
|OOP|面向对象编程|Object-Oriented Programming|
|POP|面向过程编程|Procedure-Oriented Programming|
|LP |逻辑式编程|Logic Programming|
|DP |声明式编程|Declarative Programming|
|IP |命令式编程|Imperative Programming|


编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西  
记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆  

编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响  
比如:  
(如果你已经了解过以下范式, 直接跳到 [**总结**](#总结) 吧)

- 面向过程:  
优点:  
解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉  
缺点:  
代码复用能力差, 扩展性差, 繁琐  

- 面向对象:  
优点:  
将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍  
缺点:  
不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐  

- 逻辑式:
优点:  
通过建立 `事实`, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇  
缺点:
玄学编程, 可能想象不到怎么样建立出 `能正确求解的前提条件/定义`, 也可能因推理过于复杂, 导致性能低下  

- 函数式:
优点:
通过以数学中的 `函数` 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性  
缺点:  
学习难度较大, 性能因不可变数据, 不可避免地会低下一些  

- 命令式:  
有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已  
我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可  
毕竟都2022年了, 现在不太需要关注这些低级层面的差异了  
现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等  

- 声明式:  
指你编程依靠描述, 而非面向过程地去思考  
这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发  
DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库  
特点是一旦脱离相关领域, 语法就不再便利  


## 总结
各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式  
编程范式并非严格的互相独立的, 它们大多在概念上也存在交集  

比如:
- 面向过程/面向对象 && 命令式 
- 函数式/逻辑式 && 声明式
- 混合一种, 两种, 甚至各种范式

再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想  
比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力  
再比如 Rust 中的 Option/Result, 有着 Haskell 的影子  

相信经过本小节, 你对什么是编程范式有了一个初步的认知  
接下来, 我们就要专注于本节的主角, 函数式  

简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中  
让我们开始对函数式的正式介绍吧!

- - -

# 高阶函数
高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数  

你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民  
函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较  
比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)  
~~(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)~~  

一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民  

- - -

# 不可变数据
不可变数据(Immutable Data), 指你无法修改已经存在的数据  

换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它  
被创建的值, 你将永远无法修改, 就如同数学里那样  
相信我, 当你第一次学编程时, 总会因 `修改值` 这个操作而困惑  

这意味着, Haskell 具有强大的并发性  
并发时的数据竞争, 不就是因为有人访问数据时, 也有人想要修改它, 导致发生矛盾吗?  
但假设我根本就不去修改数据, 只进行访问呢?  天底下的麻烦事是不是就少了一大堆了?  

这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身  
但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费  

不过也不必太担心, 效率肯定会低点, 但也没小瞧现代编译器的疯狂优化啊  

- - -

# 副作用
副作用(Side Effects), 指与外界发生的交互  

假设有这么一个函数:  
它接受一个参数作为文件名, 进行读取, 输出内容  
即使这么简单, 也做不到相同的输入, 能得到相同的输出  

可能你无权读取文件, 可能文件不存在, 可能文件被修改过......  
所以, 输入一个固定路径, 不一定能得到固定的输出  

因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情  
这种超脱于语言, 来自更真实世界的交互, 我们称之为 `副作用`  

副作用包括, 但不限于:  
- 发送网络请求  
- 访问系统状态
- 操作数据库
- 操作DOM
- IO操作
- 修改函数外部的变量  

你会注意到 `修改函数外部的变量`, 它也可以看作 `与外界的交互`  
比如, 若该函数修改了一个函数外部的值, 并且使用了它, 那么这将无法保证相同输入, 能得到相同输出  

但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互  
绝对的没有副作用, 意味着这个程序绝对的没用  

- - -

# 引用透明
引用透明(Referential Transparency), 指某个表达式, 能替换为它的值, 且替换前后的语义一定等价  

引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等  
以下是数学中的 `引用透明性`, 简单来讲, 就是等式推导:  

f(x) = (x+1)^2^
f(2) = (2+1)^2^ = (3)^2^ = 9

可以看到,`2+1`可以被`3`代替, 替换前后的语义一致, 但这只是数学中的  


  



当某个函数绝对不可能出现这种威胁, 即相同输入, 能得到相同输出时, 我们称这个函数为 `纯函数`  
即, 这个编程意义上的函数, 能如同数学上的函数一样, 是纯粹的, 不受现实而影响  
~~(当然, 像世界毁灭, 电脑崩溃这种脱离函数涉及的, 就不归属于上面的 "现实" 了)~~  

纯函数比非纯函数, 绝对是更加有利于分析, 不易出错的  
Haskell 也不是神, 也无可避免地要依靠副作用, 因此, Haskell 中有一种强大的概念, 叫做 `Monad`  
Monad 可以用来将 `副作用` 与 `纯计算(没有副作用的那一部分)` 分离, 尽量保持纯度  


