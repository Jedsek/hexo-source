---
title: haskell-basic-p3-函数式介绍
abbrlink: posts/haskell-basic/p3
hidden: false
date: 2022-06-26 16:16:10
top: 10997
tags: [Haskell]
keywords: [Haskell, 函数式]
---
> 何为函数式编程(FP, 即Functional Programming) ?
<!-- more -->

同系列传送门: [haskell-basic](/categories/haskell-basic)

# 学习目标
本节我们将介绍下函数式编程的概念, 基本不涉及代码  
那么, 开始吧!  

- - -

# 编程范式
## 概览
FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式  

编程范式是一种思考方式, 技术, 语言范式, 编程模型  
在世界上, 有许多编程范式, 最主要的有:  

|简称|中文名|英文名|
|--|--|--|
|FP|函数式编程|Functional Programming|
|OOP|面向对象编程|Object-Oriented Programming|
|POP|面向过程编程|Procedure-Oriented Programming|
|LP |逻辑式编程|Logic Programming|
|DP |声明式编程|Declarative Programming|
|IP |命令式编程|Imperative Programming|


编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西  
记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆  

编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响  
比如:  
(如果你已经了解过以下范式, 直接跳到 [**总结**](#总结) 吧)

- 面向过程:  
优点:  
解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉  
缺点:  
代码复用能力差, 扩展性差, 繁琐  

- 面向对象:  
优点:  
将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍  
缺点:  
不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐  

- 逻辑式:
优点:  
通过建立 `事实`, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇  
缺点:
玄学编程, 可能想象不到怎么样建立出 `能正确求解的前提条件/定义`, 也可能因推理过于复杂, 导致性能低下  

- 函数式:
优点:
通过以数学中的 `函数` 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性  
缺点:  
学习难度较大, 性能因不可变数据, 不可避免地会低下一些  

- 命令式:  
有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已  
我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可  
毕竟都2022年了, 现在不太需要关注这些低级层面的差异了  
现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等  

- 声明式:  
指你编程依靠描述, 而非面向过程地去思考  
这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发  
DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库  
特点是一旦脱离相关领域, 语法就不再便利  


## 总结
各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式  
编程范式并非严格的互相独立的, 它们大多在概念上也存在交集  

比如:
- 面向过程/面向对象 && 命令式 
- 函数式/逻辑式 && 声明式
- 混合一种, 两种, 甚至各种范式

再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想  
比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力  
再比如 Rust 中的 Option/Result, 有着 Haskell 的影子  

相信经过本小节, 你对什么是编程范式有了一个初步的认知  
接下来, 我们就要专注于本节的主角, 函数式  

让我们开始正式的, 对函数式的介绍吧!
- - -
# 函数式
简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中  

## 高阶函数
高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数  

你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民  
函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较  
比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)  
~~(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)~~  

一句话概括: 函数能被轻松随意地传递, 用来简化编程, 提高抽象  

## 不可变数据
不可变数据(Immutable Data), 指你无法修改已经存在的数据  

换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它  
被创建的值, 你将永远无法修改, 就如同数学里那样  
相信我, 当你第一次学编程时, 总会因 `修改值` 这个操作而困惑  

这意味着, Haskell 具有强大的并发性  
并发时的数据竞争, 不就是因为有人访问数据时, 也有人想要修改它, 导致发生矛盾吗?  
但假设我根本就不去修改数据, 只进行访问呢?  天底下的麻烦事是不是就少了一大堆了?  

这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身  
但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费  

不过也不必太过担心, 效率低肯定会低点, 但也没小瞧GHC(Haskell的编译器)的疯狂优化啊  
比如, 有两段数据, 都由另外一段相同的数据组成, 那当然就是共享这份内容, 而不是新建副本  
~~(还有许多本菜鸡不明白的优化)~~

## 纯函数 
纯函数(Pure Functions), 指没有副作用(Side Effects)的函数  

为什么要叫它纯函数? 副作用又是什么意思?  

别急, 我们先来看下为什么叫它纯函数:  
先前提到, 函数式编程就喜欢尽可能地去模拟数学, 因为数学实在是太干净纯粹理想了  
你想一下, 在数学中的函数是个啥? 不就是类似于 f(x)=x^2^+2x+1 的形式吗?  

如果某个编程语言中的函数, 也能做到想数学这样, 做到一个固定输入, 对应着一个固定输出, 就称它为 `纯函数`  
你可能由不理解了, 这有什么好纯函数的, 难道编程世界中的函数不是这样的?  

还真不是, 你想想, 假设有这么一个函数: 它接受一个参数作为文件名, 进行读取, 输出内容  

即使是这么简单的一个函数, 也做不到每次传入相同的文件名, 能得到相同的结果  
原因很简单, 可能你没有权限读取这个文件, 可能这个文件不存在, 可能文件已经被修改过了......  
那么现在, 你能信誓旦旦地说, 输入一个固定的文件名, 就一定能得到固定的输出吗?  

像上述的, 涉及IO操作的函数, 即使输入每次都相同, 但输出仍然可能不同  
这种现象, 表示了现实是残酷的, 不可能一直理想下去, 现实与理想间存在着可能会产生的偏差, 这永远是个威胁  
这种威胁/现象, 我们称之为 `副作用`  

再比如修改全局变量, 返回一个外部的可能被更改的值, 等等等等......
但值得注意的是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 这是不得不做的事情  

当某个函数绝对不可能出现这种威胁, 即相同输入, 能得到相同输出时, 我们称这个函数为 `纯函数`  
即, 这个编程意义上的函数, 能如同数学上的函数一样, 是纯粹的, 不受现实而影响  
~~(当然, 像世界毁灭, 电脑崩溃这种脱离函数涉及的, 就不归属于上面的 "现实" 了)~~  

纯函数比非纯函数, 绝对是更加有利于分析, 不易出错的  
Haskell 也不是神, 也无可避免地要依靠副作用, 因此, Haskell 中有一种强大的概念, 叫做 `Monad`  
Monad 可以用来将 `副作用` 与 `纯计算(没有副作用的那一部分)` 分离, 尽量保持纯度  

(概念来自数学上的范畴论(Category Theory), 但你不必学习范畴论, 后面的章节会教)  

## 引用透明