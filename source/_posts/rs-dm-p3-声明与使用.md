---
title: rs-dm-p3-声明与使用
abbrlink: rs-dm-p3
top: 9897
date: 2021-09-20 20:06:15
tags: rust
categories: rust-declarative-macro
---
> 正式的关于 macro 的 声明与使用
<!-- more -->  
前一节, 我们大概清楚了 macro 的结构  
现在让我们再来简单复习一遍:  

1. `macro_rules! (这是特点语法)` 来创建一个 macro
2. `rule(s) (匹配分支: 参数 => 展开代码)` 放在最外层的花括号内  
3. 调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 `println!()`

- - -
# 参数 && 展开
是时候引入一些新的东西了, 让我们来看个例子:  

```rust
macro_rules! my_macro {
	($a: expr) => {
		$a
	};

	($a: expr, $b: expr) => {
		$a + $b
	}
}

fn main() {
	my_macro!(1);      // 1
	my_macro!(1, 2);   // 1 + 2
}
```

你会注意到, 每个 rule 之间的参数, 都有点奇怪:  
$ + 参数名 + 类型说明, 如 `$a: expr`  
为何需要特意加上 $ 这个前缀? 马上就要讲到啦~  

先来专注于 `expr` 这个后置的类型:  
`expr`, 全称为 `expression (表达式)`  
在第一次宏调用, 我们传入了 `1 (i32类型的字面量)`, 这当然是个表达式, 会与第一个 rule 成功匹配  
这时, `my_macro!(1)` 这个部分, 就会被替换为 `相应的展开代码`  

当全部的宏, 都被 替换/展开 后, 再编译这些生成的最终版本代码 

对于每个 rule, 实际上可以这么抽象它: `(pattern) => (expansion)` 
即 `(模式) => (展开代码)` 

macro 的本质, 是根据传入的参数, 将调用部分给 替换/展开 为相应代码  
即一个AST (Abstract Syntax Tree, 抽象语法树) 的节点 (设计编译原理, 马上就讲)
简单理解: `macro 的本质, 就是代码生成器, 一段用于生成代码的代码`  


为了加深印象, 我们来玩个对应游戏:  
```rust
($a: expr) => {$a};                     // the first rule
  |             |  
  |         	|
( 1      )      1                       // pass && expand 



($a: expr, $b: expr) => { $a + $b};    // the second rule
  |      |  |              |    |
  |      |  |              |    |
( 1      ,  2      ) =>    1 +  2      // pass && expand
```

我使用 `|` 来联系 `形参 && 实参`  
你会惊讶的发现, 传参时的对应关系们, 除了 `$a && 1` 与 `$b && 2`, 还有个 `, && ,`  

因此, 假若 rule 中的参数没有 $前缀 进行区分:  

```rust
macro_rules! my {
	(a:expr) => {
		
	};
}
fn main() {
	my!(1);      // no
	my!(a:expr);  // yes
}
```
是不是特别狗日?  

接下来, 就要正式地讲讲本质了
- - -

# 本质
刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  

为了理解这段话, 让我先来介绍一个概念: `token`  

在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将"xx"视作&str类型  
而是继续地进行抽象, 将这些值, 通通归类于 `expr类型(表达式类型)` 之下    

`token类型`, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型  
比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    

实际上, 你写出来的Rust源代码, 就是一大堆准备被解析为 AST(抽象语法树) 的 token  
你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助
~~(其实你不明白也不是太影响写代码)~~
~~(不明白也根本没有关系, 因为我根本就不想讲编译方面)~~  

macro 中, 其参数的类型, 便是token类型:  
```rust
// 定义一个macro, 求和传入的参数
macro_rules! sum {
	() => {};                            // 空参时, 啥也不干
	($a: expr) => { $a };                // 一个参数时, 求和结果是自己
	($a: expr and $b:expr) => { $a + $b}    // 两个参数, 正常求和
	                                     // 更多参数, 等我们学 `重复` 语法后再说  
}

fn main() {
	sum!();        // 与第一个rule匹配, 木有展开的实际代码
	sum!(1);       // 与第二个rule匹配, 展开/替换为: 1
	sum!(1 and 2); // 与第三个rule匹配, 展开为: 1 + 2
}
```

我们通过使用宏, 便能够站在更加抽象的视角上  
操控传入的 token, 组成新的AST节点, 














