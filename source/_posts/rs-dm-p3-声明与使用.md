---
title: rs-dm-p3-声明与使用
abbrlink: rs-dm-p3
top: 9897
date: 2021-09-20 20:06:15
tags: rust
categories: rust-declarative-macro
---
> 正式系统的关于 macro 的 声明与使用
<!-- more -->  
前一节, 我们大概清楚了 macro 的结构  
现在让我们再来简单复习一遍:  

1. `macro_rules! (这是特点语法)` 来创建一个 macro
2. `rule(s) (匹配分支: 参数 => 展开代码)` 放在最外层的花括号内  
3. 调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 `println!()`

- - -
# 参数 && 展开
是时候引入一些新的东西了, 让我们来看个例子:  

```rust
macro_rules! my_macro {
	($a: expr) => {
		$a
	};

	($a: expr, $b: expr) => {
		$a + $b
	}
}

fn main() {
	my_macro!(1);      // 1
	my_macro!(1, 2);   // 1 + 2
}
```

你会注意到, 每个 rule 之间的参数, 都有点奇怪:  
$ + 参数名 + 类型说明, 如 `$a: expr`  
为何需要特意加上 $ 这个前缀? 马上就要讲到啦~  

先来专注于 `expr` 这个后置的类型:  
`expr`, 全称为 `expression (表达式)`  
在第一次宏调用, 我们传入了 `1 (i32类型的字面量)`, 这当然是个表达式, 会与第一个 rule 成功匹配  
这时, `my_macro!(1)` 这个部分, 就会被替换为 `相应的展开代码`  

当全部的宏, 都被 替换/展开 后, 再编译这些生成的最终版本代码 

对于每个 rule, 实际上可以这么抽象它: `(pattern) => (expansion)` 
即 `(模式) => (展开代码)` 

macro 的本质, 是根据传入的参数, 将调用部分给 替换/展开 为相应代码  
即一个AST (Abstract Syntax Tree, 抽象语法树) 的节点 (设计编译原理, 马上就讲)
简单理解: `macro 的本质, 就是代码生成器, 一段用于生成代码的代码`  


为了加深印象, 我们来玩个对应游戏:  
```rust
($a: expr) => {$a};                     // the first rule
  |             |  
  |         	|
( 1      )      1                       // pass && expand 



($a: expr, $b: expr) => { $a + $b};    // the second rule
  |      |  |              |    |
  |      |  |              |    |
( 1      ,  2      ) =>    1 +  2      // pass && expand
```

我使用 `|` 来联系 `形参 && 实参`  
你会惊讶的发现, 传参时的对应关系们, 除了 `$a && 1` 与 `$b && 2`, 还有个 `, && ,`  

对于第三组关系, 其实它也是参数, 不过已经固定死了  
这种固定的, 如同字面量一样的参数, 其类型其实叫做 `Literal Token Tree(字面量标记树)`  
  

因此, 假若 rule 中的参数没有 $前缀 进行区分:  

```rust
macro_rules! my {
	(a:expr) => {
		
	};
}
fn main() {
	my!(1);      // no
	my!(a:expr);  // yes
}
```
是不是特别狗日?  

切记: `当你需要在传参时, 传入非字面量参数, 参数名前必须加上 $前缀 进行修饰`  

接下来, 就要正式地讲讲本质了
- - -

# 本质  
## 引入
刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  

为了理解这段话, 让我先来介绍一个概念: `token`  

在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将"xx"视作&str类型  
而是继续地进行抽象, 将这些值, 通通归类于 `expr类型(表达式类型)` 之下    

`token类型`, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型  
比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    

实际上, 你写出来的Rust源代码, 将被解析为一大堆 `token`  
而这些 token, 之后又会被解析为 `AST (抽象语法树)`  

## 关于AST
你想想, 假若由你来设计一个Rust编译器  
首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  
一步登天, 直接由源码生成目标码是不现实的, 难度太大  

因此啊, 得有一些介于 源码与目标码 之间的 `中间表示/代码`, 层层递进, 以达目的  
注意, 是一些, 而不是一个, 这很好理解, 因为一层可能不够嘛  
所以多来几层 `中间代码` , 顺便进行下分工 (每一层都处理了些特定的事情), 这也增强了可维护性  

比如 `AST` , 它就是一种 中间代码, 它是目标码被生成的关键, 是代码的骨架  
编译器在AST的基础上, 可能会再来几层中间代码 (进行优化或者其他什么功能), 最后生成目标码  

而生成AST需要点啥? 需要一些 `token`  
比如 expr(表达式), stmt(语句), ident(标识符) 等  

在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构  
它将tokens组织起来, 表达了代码的逻辑  
这个庞然大物便是 AST 了  

而 token 的生成, 是万里长征的第一步  
只有正确地将 token 分门别类, 你才能创建正确的AST (这里的正确不包括逻辑错误)

还记得之前在对应游戏中的一对吗: `, && ,`  
我们说它是 `Literal Token Tree(字面量标记树)`  
字面上的意思: 这个 token 是字面量  

但为什么它是单个token, 却又叫做token tree?  
因为 `tree` 是可以只有一个节点的嘛  
看下面的宏:  
```rust
macro_rules! my {
	// `a:expr` 是 `literal token tree`
	(a:expr) => { };
}
```


## 回到macro
通过中间代码, 我们层层递进, 向最终的目标码前进  

其实你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助
~~(不明白也根本没有关系, 因为我实在懒得多讲编译方面了, 真的麻烦)~~

macro 中, 其参数的类型, 便是token类型:  
```rust
// 定义一个macro, 求和传入的参数
macro_rules! sum {
	() => {};                            // 空参时, 啥也不干
	($a: expr) => { $a };                // 一个参数时, 求和结果是自己
	($a: expr ; $b:expr) => { $a + $b}    // 两个参数, 正常求和
	                                     // 更多参数, 等我们学 `重复` 语法后再说  
}

fn main() {
	sum!();        // 与第一个rule匹配, 木有展开的实际代码
	sum!(1);       // 与第二个rule匹配, 展开/替换为: 1
	sum!(1 ; 2); // 与第三个rule匹配, 展开为: 1 + 2
}
```

我们通过使用 macro , 便能够站在更加抽象的视角上  
操控传入的 token, 组成新的AST节点(生成新的代码), 参与编译的过程, 形成可执行的程序  

像这种用代码生成代码的手段, 我们称之为 `Meta Programming (元编程)`  
比如标准库的一些骚操作: 一个宏, 传入参数为 `i32 i64 u32 u64`, 便能为这些类型自动实现一些trait  

因为我们还没有学习牛逼哄哄的 `重复` 语法, 这里就随便写个宏, 作用是创建函数, 来演示下:  
```rust
macro_rules! create_func {
	($fn_name: ident) => {
		fn $fn_name() {
			println!("{}", stringify!($fn_name)); 
			// stringify 是内置宏, 将传入的token字符串化
			// 这里使用它, 是因为无法直接打印 $fn_name, 不信你试试, 道理很简单, 懒得细讲了
		}
	};
}
fn main() {
	create_func!(foo);
	foo();
}

/* 最后生成的代码:
fn main() {
    fn foo() {
        println!("{}", "foo");
    }
    foo();
}
*/
```
像标准库那种定义一个宏, 为传入的类型批量地自动化, 生成实现trait的代码  
这事情函数做不到吧? 这就是元编程的魅力, 大幅度减少手写代码量, 提高幸福感  
rust 中重要的元编程手段之一, 就是声明宏了  
- - -
# 

