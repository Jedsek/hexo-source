---
title: rs-dm-p3-声明与使用
abbrlink: rs-dm-p3
top: 9897
date: 2021-09-20 20:06:15
tags: rust
categories: rust-decl-macro
---
> 正式系统的关于 macro 的 声明与使用
<!-- more -->  
# 框架建立
前一节, 我们大概清楚了 macro 的结构  
现在让我们再来简单复习一遍:  
1. `macro_rules! (这是特点语法)` 来创建一个 macro
2. `rule(s) (匹配分支, 以 "参数 => 展开代码" 的形式)` 放在最外层的花括号内  
3. 调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 `println!()`  

现在稍微深入一点:  
一个 `rule` 可以被这样抽象地表示 : (matcher) => (transcriber)   
它由三个重要的部分组成:
- `matcher (匹配器)`: 用来匹配传入的参数  
- `metavariable/literal (元 变量/字面量)`: 绑定传入的参数到变量上, 出现在 `matcher` 中
- `transcriber (转录器)`: 用来在宏匹配成功后, 进行代码替换

以 `println!` 为例子, 我们向其传入了一些参数, 它给我们打印到标准输出上  
因为原本的 `println!` 涉及到 `卫生性`, `重复语法`, `路径作用域` 等, 不适合新鸟阅读, 所以我抽象了它: 
```rust
macro_rules! println {
    (/* 空参匹配 */) => (/* `换行` 的代码 */);
    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)
}
```
`println` 由两个 `rule` 组成, 每个的形式都是: `matcher => transcriber`  
从上往下, 每个 rule 的 `matcher` 会与传入参数尝试匹配, 匹配到, 就替换为 `transcriber` 里面的代码  
所有 `matcher` 都无法与 `传入参数` 进行匹配, 则报错  

同时, `matcher` 与 `transcriber` 的括号, 分别可以是 (), [], {} 三种之一  
即, 对于一个rule, 它可以是: `(pattern) => (expansion)`, 也可以是 `[pattern] => {expansion}`  
在调用时, 包裹参数的括号也可以在这三种之一切换, 比如 `vec![0, 1,2,3` 与 `pritnln!("xx")`

而 `metavariable/literal` 则出现在 `matcher` 中, 用于匹配并捕获 代码片段  
在对应的 `transcriber` 中, 则可以操控这些 `元值`, 即操控 捕获到的代码片段  

稍微有点蒙? 我也没让你背哟, 多看多用就会了  
- - -
# 两种宏参数
是时候引入一些新的东西了, 顺便加深下你的印象  

## 元变量(Metavariable)
让我们来看个例子:  

```rust
macro_rules! my_macro {
	($a: expr) => {
		$a
	};

	($a: expr, $b: expr) => {
		$a + $b
	}
}

fn main() {
	my_macro!(1);
	my_macro!(1, 2);
}

/* 宏全部展开后, 可以理解为下面: 
fn main() {
    1;
    1 + 2;
}
*/
```

你会注意到, 每个 rule 之间的参数, 其声明都有点奇怪:  
比如 `$a:expr` -> `$ + 参数标识符 + 类型`  

`$` 这个前缀干嘛的?  
这显式地说明了, 它是 `metavariable`, 可以匹配并捕获相应类型的代码片段, 这里会捕获表达式  
至于为何要特意加$前缀来说明, 本节下面就要讲到啦, 别着急~  

来看看 `expr` 这个后置的类型:  
`expr`, 全称为 `expression (表达式)`  
在第一次宏调用, 我们传入了 `1 (i32类型的字面量)`, 这当然是个表达式, 会与第一个 rule 成功匹配  
这时, `my_macro!(1)` 这个部分, 就会被替换为 `相应的展开代码`  
(matcher(匹配器), metavariable(元变量), transcriber(转录器) 都用到了)    

简单来讲, macro 的本质, 就是匹配捕获传入参数, 将调用部分 替换/展开 为相应代码  
macro 不就是个代码生成器, 一段用来生成代码的代码吗  

注意: macro实际上是将传入部分解析为一个AST节点, 然后替换/展开调用部分, 变成一个AST节点  
在本节下面的本质篇, 会更详细地讲讲

## 元字面量(Metaliteral)
为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  
```rust
($a: expr) => {$a};                     // the first rule
  |             |  
  |         	|
( 1      )      1                       // pass && expand 



($a: expr, $b: expr) => { $a + $b};    // the second rule
  |      |  |              |    |
  |      |  |              |    |
( 1      ,  2      ) =>    1 +  2      // pass && expand
```

我使用 `|` 来联系 `形参 -- 实参`  
你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  

其实, 你往括号里传入的东西, 都是参数 (除了空格)  
对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  
这种固定的, 如同字面量一样的参数, 只能被形如 `$xx:tt (tt代表token tree)` 所匹配  
我姑且称它为 `Literal Token Tree(字面量标记树)`, 或者 `Metaliteral (元字面量)`
(因为我也不知道有什么对应术语, 所以用了 "姑且", 知道的麻烦告诉我)  

因此, 假若 rule 中的参数没有 $前缀 进行区分:  

```rust
macro_rules! fuck {
	(a:expr) => {
		
	};
}
fn main() {
	fuck!(1);       // No
	fuck!(a:expr);  // Yes ~~(Oh~)~~
}
```

`a:expr` 的类型为 `tt`, 而非 `expr`, 只能传入固定形式的 `a:expr` 才发生匹配 (即它是 `MetaLiteral`)
是不是感觉一切都特别狗日?  

切记:  
`当你想在传参时, 绑定一段代码片段, 参数名前必须加上 $前缀 进行修饰`  

`Meta variable/literal` 到底有啥用? 你用着用着就明白了......  
但我可以提一嘴: ~~(为了自由)~~ 可以方便DSL/生成代码
接下来, 我们用一个例子, 来说明两者的缺一不可:  

## 例子
假设有这么个宏 `map!` (有没有想到 `vec!`)  
它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  
如下:  

```rust
fn main() {
	let m = map![
		"吉良吉影" => 33,
		"空条承太郎" => 41,
	]
	// `m` 的类型为: std::collections::HashMap<&str, i32>
}
```

我们来写一个这样的宏吧!  
不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  

```rust
macro_rules! map {
	($key:expr => $val:expr) => {{
		let mut m = std::collections::HashMap::<_,_>::new();
		m.insert($key, $val);
		m
	}};
}
fn main() {
	let m = map!("普通上班族" => 33);
	println!("{:?}",m);
}


/* 展开后, 可以看作是:
fn main() {
    let m = {
        let mut m = std::collections::HashMap::<_,_>::new();
        m.insert("普通上班族", 33);
        m
    };
    println!("{:?}",m);
}
*/
```
这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key => Value`  
来看看两种宏参数在宏中, 发挥着怎样的作用:  
- `Metavariable`: 将捕获的传入的代码片段绑定到自身  
并在 `Transcriber` 中被使用, 最后展开为新代码  

- `Metaliteral `: 限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配
若改成 `map!("普通上班族", 33)`, 则每个rule的 `Matcher` 都无法匹配上  
(这里只有一个rule, 空匹配的懒得放里面了)  

其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  
考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  
(之后会讲几个实战: 比如B站视频中已经讲过的递推序列生成器, 博客的话, 我周六放学回来慢慢更吧......)
- - -

# 本质  
## 引入
刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  

为了更加深入, 让我介绍一些概念

在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将"xx"视作&str类型  
而是继续地进行抽象, 将这些值, 通通归类于 `expr类型(表达式类型)` 之下    

`token类型`, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型  
比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    

实际上, 你写出来的Rust源代码, 将被解析为一大堆 `token`  
而这些 token, 之后又会被解析为 `AST (抽象语法树)`  

## 关于AST
你想想, 假若由你来设计一个Rust编译器  
首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  
一步登天, 直接由源码生成目标码是不现实的, 难度太大  

因此啊, 得有一些介于 源码与目标码 之间的 `中间表示/代码 (IR)`, 层层递进, 以达目的  
注意, 是一些, 而不是一个, 这很好理解, 因为一层可能不够嘛  
所以多来几层 `IR (中间代码)` , 顺便进行下分工 (每一层都处理了些特定的事情), 这也增强了可维护性  

比如 `AST` , 它就是一种 IR, 它是目标码被生成的关键, 是代码的骨架  
编译器在AST的基础上, 可能会再来几层中间代码 (进行优化或者其他什么功能), 最后生成目标码  
(以 Rust 为例, 出现的大致IR: AST -> HIR -> MIR -> LLVM_IR)

而生成AST需要点啥? 需要一些 `token`  
比如 expr(表达式), stmt(语句), ident(标识符) 等  

在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构  
它将tokens组织起来, 表达了代码的逻辑  
这个庞然大物便是 AST 了  

而 token 的生成, 是万里长征的第一步  
只有正确地将 token 分门别类, 你才能创建正确的AST (这里的正确不包括逻辑正确)

还记得之前在对应游戏中的一对吗: `, && ,`  
我们说它是 `Literal Token Tree(字面量标记树)`  
字面上的意思: 这个 token 是字面量  

但为什么它是单个token, 却又叫做token tree?  
因为 `tree` 是可以只有一个节点的嘛  
还可以有比较长的, 比如我们之前用来实例的宏:  
```rust
macro_rules! my {
	// `a:expr` 是 `literal token tree`
	(a:expr) => { };
}
```

- - - 
# 回到macro  
## 例子
通过中间代码, 我们层层递进, 向最终的目标码前进  

其实你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助
~~(不明白也没多大关系, 因为我实在懒得多讲编译方面了, 真的麻烦)~~

macro 中, 其参数的类型, 便是token类型:  
```rust
// 定义一个macro, 求和传入的参数
macro_rules! sum {
	() => {};                            // 空参时, 啥也不干
	($a: expr) => { $a };                // 一个参数时, 求和结果是自己
	($a: expr ; $b:expr) => { $a + $b}   // 两个参数, 正常求和
	                                     // 更多参数, 等我们学 `重复` 语法后再说  
}

fn main() {
	sum!();        // 与第一个rule匹配, 木有展开的实际代码
	sum!(1);       // 与第二个rule匹配, 展开/替换为: 1
	sum!(1 ; 2);   // 与第三个rule匹配, 展开为: 1 + 2
}
```

我们通过使用 macro , 便能够站在更加抽象的视角上  
操控传入的 token, 组成新的AST节点(生成新的代码), 参与编译的过程, 形成可执行的程序  

像这种用代码生成代码的手段, 我们称之为 `Meta Programming (元编程)`  
比如标准库的一些骚操作: 一个宏, 传入参数为 `i32 i64 u32 u64`, 便能为这些类型自动实现一些trait  

因为我们还没有学习牛逼哄哄的 `重复` 语法, 这里就随便写个宏, 作用是创建函数, 来演示下:  
```rust
macro_rules! create_func {
	($fn_name: ident) => {
		fn $fn_name() {
			println!("{}", stringify!($fn_name)); 
			// stringify 可以将传入的token字符串化, 记住就好, 内置的: `compiler built-in`
			// 这里使用它, 是因为无法直接打印 $fn_name, 不信你试试, 道理很简单, 懒得细讲了
		}
	};
}
fn main() {
	create_func!(foo);
	foo();
}

/* 最后生成的代码, 如下:
fn main() {
    fn foo() {
        println!("{}", "foo");
    }
    foo();
}
*/
```
像标准库那种定义一个宏, 为传入的类型批量地自动化, 生成实现trait的代码  
这事情函数做不到吧? 这就是元编程的魅力, 大幅度减少手写代码量, 提高幸福感  
rust 中重要的元编程手段之一, 就是声明宏了  


## token类型对照
macro通过操控传入的token, 生成相应的代码  
编译器再通过这些代码, 生成目标码(这里指可执行的二进制程序)  

既然macro是要操控这些传入的token, 我们总得知道token类型吧?  
只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指非字面量的参数)  

所以, 辛苦你将下面的东西记一下哈  
稍微记一下, 有个对照/印象就行, 多用几下保证你熟悉得不行:  

- `ident` -> 标识符, 如函数名字, 变量名字, 关键字  
- `stmt` -> statemen, 语句
- `expr` -> expression, 表达式
- `literal` -> literal expression, 字面量表达式, expr的子集
- `block` -> 代码块
- `pat` -> pattern, 比如在match表达式下的 (pattern) => todo!(),
- `path` -> 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径
- `ty` -> type, 如i32, u32, String, Option<T>等  
- `tt` -> token tree, 之后我会单独再讲解下它的  
- `item` -> 条目/项, 例如函数定义  
- `meta` -> 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)
- `lifetime` -> 生命周期  
- `vis` -> visibility, 可见性, 比如pub等, 也可能为空  


那么今天就到这了, b站上的视频我会在周末一点点传到这个博客上的  
视频上的文章内容, 当时没放到github上, 电脑坏了后直接没了......
我索性来一点点重写/补充好了, 顺便来个备份  

tmd还有作业, 中秋放假等于没放, 真棒啊 (怒)
咋们下节见~  
