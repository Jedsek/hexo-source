[{"title":"rs-async-p1-系列说明","url":"/posts/rs-async-p1.html","content":"\n欢迎大家来到 Rust 的 异步(async) 系列  \n\n\n系列说明传送门如下:  \n\n博客: Rust异步系列 \nB站视频: Rust编程语言-异步(Async)\n\n博客的更新速度,快于视频博客若经过重写,则会抽时间更新视频     \n此系列,我们将学习Rust中的 异步 (Async)当然也会介绍异步方面的相关概念咯\n不过介于本人能力有限,更底层一些的东西可能理解的不是很到位,为不误导,需要补些知识因此该系列花费时间可能会很久\n\n资料来源\n书籍  \n\n\nasync-book\nasync_std/tutorials\ntokio/tutorials\nFutures Explained in 200 Lines of Rust\n\n\n博客\n\n\nWithoutboats’s blogs  \n\n\n欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习\n可以通过博客侧边栏上的联系方式找到我  \n欢迎在留言版中留言,本人会定期查看  \n\n最后,谢谢你的观看 :)\n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-async-p2-异步简介","url":"/posts/rs-async-p2.html","content":"\n来简单介绍一下异步吧  \n\n\n\n开篇异步编程 (Asynchronous programming)是一种并发编程模型 \n特点是通过少量OS_thread(系统线程)即可运行大量并发任务在某些场景下,可以疯狂压榨cpu的性能(好吧,有点废话……)\n\n模型对比为何选择异步,它的优势有哪些?  \n对于这个问题,我们将对比异步与其他并发模型以此来告诉大家,为什么选择异步:  \n1.OS Thread (系统线程)由操作系统提供线程,进行并发,如std::threadGood_1:简单易使用,建模能力强,足够传统Good_2:操作系统就是运行时,与C语言交互方便Bad_1:数据同步困难,易发生数据竞争Bad_2:小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低\n2.Green Thread (绿色线程)它几乎与系统线程一样,不过Runtime(运行时,jvm/.net听说过吗?)从操作系统变为了程序本身绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程Good:这意味着,程序本身对绿色线程有绝对的管理权所以内存分配等方面的粒度更细,根据任务大小调度内存因此堆栈大小,能够随时间推移而增长并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务Bad_1:它是程序本身实现模拟出来的线程,Runtime较巨大运行时会一直存在,即使你不用该特性,导致拖累全局程序性能并且难以与C库交互这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象它无法在语言层面被Rust支持Bad_2:绿色线程在不同平台上,其实现可能不同对多平台的支持/维护/改进得靠实现者保证  \nOS Thread与Green Thread与Rust关系比较大:一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的  \n\n异步我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! ! (没把你憋坏吧伙计?)  \n我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一假设我们正在单线程下,读取文件,并进行一个计算:  \n// 定义文件let file = /*  */// 读取文件, 获取数据 let data = read(file);// 进行一个计算compute()\n以上面代码为例子,我们会读取 file 获取 data期间,我们的程序,做不了任何其他事情只有等待IO操作(Input/Output, 输入/输出)完毕,我们才能进行接下来的 compute  \n读取文件,属于IO操作众所周知,IO操作很耗时,等待它完成的时间可能会很长  \n有没有什么办法加快速度?没错,系统线程yyds:\n// 定义文件let file = /*  */// 为每个读取任务新建线程, 并获取句柄let handle_a = thread::spawan(|| read(file) );let handle_b = thread::spawan(|| compute() );// 使用join阻塞调用线程, 确保句柄线程执行结束let data = handle_a.join().unwrap();handle_b.join().unwrap();\n\n因为两个任务read与compute是独立的,无依赖性所以我们spawn了两个线程第一个: 用于读取文件,获取数据第二个: 用于在读取文件的同时,执行着 compute虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销而异步,就是只依靠单线程,也能够完成上面的操作  \n单线程中的异步(伪)代码如下:\n// 定义文件let file = /*  */// 读取文件, 获取数据 let data = read_async(file);// 进行一个计算compute_async()\n\n你会注意到:read -&gt; read_asynccompute -&gt; compute_async  \n我用伪代码表示,这两个操作变成了异步操作你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念如下:    \n\nread:它会阻塞调用线程,等待该操作完毕后才继续往下执行compute  \n\n阻塞期间是几乎不需要cpu参与运行的程序此时傻乎乎地等待阻塞结束无疑是对性能的浪费,对cpu的不尊重  \n\nread_async:它处于阻塞时,会运行compute_async线程由read_async接管变为由compute_async接管当阻塞时间结束,则程序继续变为运行read_async\n\nread_async阻塞时,程序是不会傻傻等待的:  \n若检测到它处于阻塞,无法取得进展则会运行其他异步任务,由其他异步任务接管线程  \n总而言之,异步操作,其实就是:若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)使得cpu一直处于运算,性能被极限压榨  \n异步操作,就像是可以随意start/stop一般调度程序能够对它们进行调度,决定当前要运算哪个操作确保不会因为阻塞而傻傻等待\n只需单线程,就可以做到同时运行多个 Task(异步任务)异步当然也不排斥多线程:一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?\n\n尾声Q:阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?A:现代电脑发展出了一些分担IO操作压力的高科技所以cpu对IO操作的压力较小/没有, IO时能进行其他运算只需要最后接收数据时, 出个场就行了  \n所以我们的程序不需要在等待输入输出时就那样等着给它们找事情, 让它们闲不下来吧!  \n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-async-p3-Future","url":"/posts/rs-async-p3.html","content":"\nRust 中的 Future/async/.await 说明  \n\n  \n开篇大家好! 我们上一节已经知晓异步的基础概念现在,来看看Rust中的异步语法吧    \n在本节,我们会知晓以下三个概念的大致含义:(暂时不涉及背后原理,原理之后专门出好几节来讲)   \n\nFuture (trait)  \nasync (keyword)\n.await (keyword)\n\n开始旅途吧  \n\nFuture概念Future,一个标准/核心库中的trait其完整路径为std/core::future::Future   \n此节我只会讲它的大致含义,原理则放到后面几节专门来讲 (原理太难, 一节根本不够)  \n在Rust中,一个实现了Future(trait)的类型该类型的实例(有时候直接被简称为 一个Future实例)便代表 一次异步计算可以将其交给Runtime(运行时),从而异步执行   \n异步执行, 也就是指:当其他异步任务阻塞时,当前异步任务有机会执行或当前异步任务阻塞时,其他异步任务有机会执行总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n注意两个名词的区别:  \n\n异步 计算  \n异步 任务\n\n两者有着区别,举个例子你就明白了:  \n假设有这么个父计算, 由两个子计算组成:   \n\nOpen: 先异步打开一个文件(async open)  \nRead: 再异步读取该文件(async read)   \n\n我们可以看出,一次计算, 是可以由多个子计算组成的同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期因为子计算们可能存在依赖关系 (在这里的例子中也确实存在) \n因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算(我们将最顶层的父计算(top-level Future, 即最顶层的Future实例)称为Task(任务))  \n当前Task阻塞时,接管执行权的,不能是当前Task中的其他子计算只能是其他Task中的子计算  \n来点总结吧:  \n\nTask是一个顶层Future实例 (即一次顶层异步计算) \n\n一个Future可以由多个Future组成,即一个Future里可以执行多个Future\n\nTask_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算\n\nTask可以只是一次单独计算\n\n\n一个Future (一次异步计算)可理解为,是组成一个Task (一个异步任务)的最小单位 \n了解到了那么一点点后,现在来正式看看呗 ?  \n定义让我们来看看它的定义:\npub trait Future &#123;    type Output;    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Self::Output&gt;;&#125;\n下面简单了解一下:  \n\nFuture:代表一次异步计算  \n\nOutput:代表该Future,异步执行完毕后,产出的值的类型   \n\npoll:所有执行操作都会放在该函数中Runtime 会不断调用poll函数来推进该异步计算的完成每次poll的返回值是一个枚举变体,代表是否完成\n\nPoll:枚举类型,作为poll函数的返回值类型,其变体有:Poll::Pending:指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)Poll::Ready(T):指明该计算执行完毕,并产出一个类型为T的值   \n\n\n若只是普通使用者,并不需了解Future的定义背后之原理但若不了解它,又如何为某类型实现 Future 呢?  \n别急,Rust为我们提供了关键字async,接着往下看吧   \n\nAsyncasync: 一个关键字用来创建一个匿名结构体的实例, 该结构体实现了Future即,它用来创建一个 Future实例  \n来个例子,看看async的好处:   \n// 1 async fn hello_str_1() -&gt; String &#123;     String::from(&quot;Hello! World!&quot;)&#125;// 2 struct HelloStr;impl Future for HelloStr &#123;    type Output = String;    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;        let str = String::from(&quot;Hello! World!&quot;);        Poll::Ready(str)    &#125;&#125;fn hello_str_2() -&gt; impl Future&lt;Output = String&gt; &#123;    HelloStr&#125;\n\n你可以观察到,使用 async 进行了符合直觉的简化这两种函数,实际上是等价的  \n看看它们两的返回值,如下:  \n// 1async fn hello_str_1() -&gt; String &#123;     String::from(&quot;Hello! World!&quot;)&#125;hello_str_1() // 返回值为 `impl Future&lt;Output = String&gt;`// 2fn hello_str_2() -&gt; impl Future&lt;Output = String&gt; &#123;    HelloStr // Future&lt;Output = String&gt; 的实例&#125;hello_str_2() // 返回值为 `impl Future&lt;Output = String&gt;`  \n\n\n注意,异步函数的调用,只是返回一个 Future实例但并没有开始执行, 它是惰性的只有调用Future的poll方法, 才能推动它的执行而调用poll方法的工作, 则交给了运行时(执行器)  \n这样的好处就在于:将一个异步计算看作一个变量,方便了传参等工作  \n比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可\nasync的作用就是创建一个Future实例:  \n\nasync fn: 异步函数, 要求返回一个 Future实例   \nasync block: 异步代码块, 创建一个 Future实例  \nasync closure: 异步闭包, (目前是不稳定特性) 创建一个 Future实例  \n\n// 1// 返回值为 `impl Future&lt;Output = String&gt;`async fn hello() -&gt; String &#123;    String::from(&quot;Hello&quot;)&#125;// 2// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例async &#123;    let a = 1_i32;    a&#125;// `async block` 也可以使用move  // 获得其中使用的变量的所有权  let s = String::new();async move &#123;    &amp;s &#125;s; // Error: use of moved value// 3// 闭包因为不稳定, 我也懒得讲了......\n\n创建一个Future实例, 想必大家已经了解一二但是如何执行一个Future实例?  \n请接着往下看\n\n执行背景介绍Rust本身并不提供 异步运行时 (async runtime), 以便语言内核精小, 便于进化/迭代/维护异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n可以仔细看看 Future 的完整路径: std::future/core::Future注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) \n这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义再加上异步运行时是可选的, 凭借 cartes.io 上提供的异步运行时相关的carte在嵌入式环境下, 也能够轻松运行异步程序   \n在正式开始之前请确保你已经在 Cargo.toml 中添加了如下代码:   \n[dependencies]async-std = &#123; version = &quot;1.9&quot;, features = [&quot;attributes&quot;] &#125;\n\n以 async-std 这个比较主流, 对新人友好的 异步运行时crate 为例子我们指定了版本, 并且启用了 attributes 这个特性  \nRuntime执行我们先来创建一个 打印 &quot;hello world&quot; 的Future 吧并且使用 async-std 这个异步运行时环境来执行它:   \nuse async_std::task;async fn hello_world() &#123;     println!(&quot;Hello wrold!&quot;);&#125;fn main() &#123;     let fut = hello_world();    task::block_on(fut);&#125;\n还记得我们在本节开始不久,就提到过的异步任务 (Top-level Future, 即顶层的异步计算) 吗?async_std::task,该模块,为我们提供了大量api,来执行/操控 这些 Task  \n比如这里出现的task::block_on:传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程该任务执行完毕后产出的值,会作为block_on的返回值  \n我们执行了一个Task,并且这个Task是单个的Future但若我们想执行由多个子Future所组成的Task,又该怎么办?  \n.await 关键字出场了! \n\nAwait.await 只能出现在 async fn/block 内部在某个Future实例的后面,增加.await,那么该Future实例则会执行但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future   \n来看看它的使用:  \nuse async_std::task;async fn hello() &#123;      print!(&quot;Hello &quot;);&#125;async fn world() &#123;    println!(&quot;world!&quot;);&#125;async fn hello_world() &#123;     hello().await;    world().await;&#125;fn main() &#123;     let fut = hello_world();    task::block_on(fut);&#125;\n\n.await是一个标记点,可以理解为是一个yield pointRuntime执行到xxx.await时,先会执行一次xxx  \n一开始,会调用一次poll函数,推动执行进度通过它的返回值,Poll&lt;T&gt;枚举的变体,即Pending或Ready(T)来决定: \n\n让其他Task接管执行权(yield)  \n该Future执行完毕,继续执行当前Task  \n\n若为Ready: 则选 2,继续往下执行(一个Task可能是由多个Future所组成)若为Pending: 则选 1,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)  \n稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:  \n.await会指明执行某个Future 这一逻辑当xxx.await所在的Task交给Runtime执行,并执行到xxx.await 时xxx 这个Future实例会执行  \n若它阻塞(这意味着该Future所在的Task也阻塞)所以调度程序安排其他Task,在该空档期执行若不阻塞,就继续往下执行(可能还有碰见.await哟), 直到该Task结束   \n\n补充\n#[async_std::main]这玩意无比常见,是个属性宏,要加在main函数头上使得main前面能被async所修饰程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:  \n\n#[async_std::main]async fn main() &#123;    hello_world().await&#125;// 等价于:fn main() &#123;    async_std::task::block_on( async &#123;        hello_world().await    &#125;)&#125;\n\n\n\nasync_std::task::spawn因为这玩意也很常见,所以就讲一讲:向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例它实现了Future,与标准库中的JoinHandle无比相似不过那个运行Thread,而这个运行Task,join相应地变成.await想让该handle代表的Task运行完毕,应该在该handle前放上.await,如下:  \n\nuse async_std::task;#[async_std::main]async fn main() &#123;     let handle = task::spawn(async &#123;        1 + 1    &#125;);    let two:i32 = handle.await;&#125;\n\n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-async-p4-状态的保存/变换","url":"/posts/rs-async-p4.html","content":"\n浅显的原理第一篇: 状态的保存/变换\n\n\n开篇注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看为了更好地理解Rust异步背后的原理,我们先来了解下一些概念当然,不用太深入,只是小补充而已:   \n\n抢占式/协作式多任务  \n状态机  \n自引用结构体   \n\n现在,让我们开始吧!  \n\n两种多任务介绍抢占式多任务与协作式多任务,都属于多任务  \n\n抢占式多任务:操作系统决定CPU的运行权比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种任务们同时运行的感觉这是强迫/抢占的    \n\n协作式多任务:任务们本身进行协调,决定CPU的运行权比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending自己放弃继续执行,并通知运行时执行其他Task这是自愿/协作的,Task们自愿放弃CPU的执行权(上文中的任务与Task请区分一下,前者比后者广泛,后者在这用于Rust的举例)  \n\n\n状态的恢复/保存既然任务们能互相切换执行,那么,当再次轮到某任务执行时该任务,应当从先前暂停的地方开始,继续执行因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是状态保存  \n对于抢占式与协作式,处理状态保存的思路是不一样的:\n\n抢占式:因为是强迫切换执行的,任务会在任意某个时刻被中断任务此时运行到了哪里?我们不知道啊!那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)    \n\n反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大  \n\n协作式:因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的这种放弃执行权的操作,我们称为yield    \n\n比如在Rust中,xxx.await会执行一个Future意味着当程序执行到这里时,可能会yield(poll返回Poll::Pending,自愿放弃执行权)  \nxxx.await就是一个stop/yield point,代表执行到此处时,可能会发生暂停并yield瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)因此,我们可以准确分配Future执行所需要的最大空间  \n其实,每个.await(也就是yield point),就代表着一种状态(之后会讲)\n协作式的好处在于:能自己掌握所有yield point,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理毕竟机器定义的分配策略, 总是没有比不过我们特意设计的在任务暂停并转让执行权前,准确保存下次继续所需要的状态,内存/性能优势很大但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行  \n\n状态机的概念在Rust中的异步,我们之前也说过,属于协作式多任务而其状态保存的实现,就是利用状态机(state machine)来实现  \n状态机(state machine)一般指有限状态自动机,是一种数学模型  \n\n状态(state):比如有一扇门,它的状态就处于以下两种之一: Open or Closed\n事件(event):某事件发生后,会触发相应动作,可能改变状态比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)   \n动作 (action):事件发生后,会触发动作  \n变换 (transition):State_X=&gt;State_Y就叫变换,比如门的状态从Open=&gt;Closed  \n\n稍微了解下状态机的概念即可  \n那么现在,就要看具体代码了  \n如果你想亲自运行一下,先确保你的Cargo.toml中的依赖如下:  \n[dependencies]async-std = &#123;version = &quot;1&quot;, features = [&quot;attributes&quot;, &quot;unstable&quot;]&#125;\n\n如下代码,读取一个文件的行数你可以通过 cargo run -- ./src/main.rs 运行(通过target目录下的可执行文件,加上参数后运行,也可以哦)  \nuse std::&#123;    env::args,    process,&#125;;use async_std::&#123;    prelude::*,    fs::File,    io::&#123;self,BufReader&#125;,&#125;;#[async_std::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;              // Start    let path = args().nth(1).unwrap_or_else(||&#123;        eprintln!(&quot;Fuck you! No path for reading&quot;);        process::exit(1);    &#125;);     let file = File::open(path).await?;          // Yield point    let lines = BufReader::new(file).lines();    let count = lines.count().await;             // Yield point    println!(&quot;This file contains &#123;&#125; lines&quot;,count);    Ok(())&#125;                                                // Done\n\n\nmian()产生一个新实例,异步运行open(path)与count()对于编译器,每一个.await其实都代表一种状态  \nFuture实例,实际上是个状态机在这里共有四种状态/阶段(其中包括两个.await point(yield point)):  \n\nStart: 此Future刚开始执行  \nYield1: 第一个 yield point\nYield2: 第二个 yield point\nDone: 此Future执行完毕\n\n这些状态的含义是: 表示当前Future执行到了哪一个阶段执行器调用当前Future的poll推动进度时,若在某一阶段返回了Poll::Pending,则放弃执行权当再次调用当前Future的poll推动进度时,则从上次暂停的状态恢复(resume),继续执行  \n官方目前似乎采用Generator(生成器)为异步语法生成状态机每一个状态都会存储一些数据, 便于进入下一个状态  \nNote 1:Start状态,会存储传入函数的参数(如果有参数)\nNote 2:Done状态下,若进行resume,则可能得到panic!因为恢复已结束的计算是不可能, 也不应该的  \nNote 3:怎么判断每个状态需要保存哪些变量? 很简单的一句话:某个yield point之前定义, 且point之后还需要使用的变量如上段代码中的 file 与 count就需要被保存,因为从暂停中恢复后还需要使用其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象所以不需要特殊的持久化操作\n\n自引用结构体保存引用当每个状态存储数据时,可能会导致发生自引用,比如:  \nasync fn example() -&gt; i32 &#123;                            // Start    let arr = [1, 2, 3];    let element = &amp;arr[2];    write_file(&quot;foo.txt&quot;, element.to_string()).await;  // Yield1    *element                                           // Done&#125;\n\n这里有三个状态: Start,Yield1,Done而在Yield1这个状态,存储的数据如下:  \n// 状态的定义struct Yield1State &#123;    arr: [i32; 3],    element: *const i32, // 数组最后一个元素的地址&#125;// 状态的实例Yield1State &#123;    arr: [1,2,3],    element: &amp;arr[2] as *const i32,&#125;\n\n等等,你可能会对上面的代码有疑惑:不是说,状态只需要保存 在yield point之前定义, 并且该point之后还需要使用的变量 吗上面的代码,只有element这个引用需要被保存吧?  \n这是因为,它是引用嘛!没了引用背后的实际数据,那它还有啥用,不就是悬垂引用了吗?  \n因此我们还得保存,该引用指向的背后数据: arr并一起存储在同个struct(代表同一状态)中  \n像这种 结构体内部的指针,指向结构体本身就叫 自引用结构  \n比如上面代码: 同一结构体下,成员element指向了成员arr  \n内存移动问题如上所述, 这可能导致悬垂引用的产生:若该struct实例的内存地址发生改变(比如使用std::mem,让struct实例的内存地址,发生移动)  \n以上面的那段代码为例,如下:  \n\narr:内存地址会跟着结构体实例而改变但是, 值仍然是 [1,2,3]\n\nelement:内存地址会跟着结构体实例而改变但是,值仍然是先前arr的地址注意,是先前的 ! 而不是后来arr的新地址\n\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n官方提出了std::pin::Pin(trait)来解决自引用结构体方面的悬垂指针/引用问题 \n其实你听名字也很好理解:Pin(中文意思是钉子)的作用是,防止内存地址发生改变(给爷钉死吧!)  \n但是它又是怎么pin住的呢?下一节再慢慢讲吧  \n那又是一个值得探讨的话题了欲知后事如何, 且听下回分解  \n(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)  \n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-dm-p1-系列说明","url":"/posts/rs-decl-macro-p1.html","content":"\n欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n\n\n系列说明:注: 请注意是声明宏传送门如下:  \n\n博客: Rust声明宏系列 \nB站视频: Rust编程语言-声明宏\n\n博客的更新速度,快于视频博客若经过重写,则会抽时间更新视频  \n此系列,我们将学习Rust中的声明宏  \n\n参考资料\n书籍\n\n\n宏小册  \nRustPrimer\nTRPL\n\n\n文章  \n\n\n【译】Rust宏: 教程与示例 (一)\n【译】Rust宏: 教程与示例 (二)\n\n\n欢迎骚扰\n发现错误的话, 请及时跟我联系  \n可以通过博客侧边栏上的联系方式找到我  \n欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p2-从println开始","url":"/posts/rs-decl-macro-p2.html","content":"\n我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n\n\n开篇大家应该都用过一个宏它就是println!:  \nfn main() &#123;    let s = &quot;Rush B!!!!&quot;;    println!(&quot;&#123;&#125;&quot;,s);    println!()&#125;\n\n当你刚刚接触它的时候, 可能会感到些许疑惑:为什么后面要跟个感叹号?为什么括号里面的参数可以不一样?  \n亲爱的TRPl在教你写 Hello World! 的时候告诉过你: 名字后加个感叹号,就是个宏(macro)注: macro 的读音: [ˈmækroʊ]\n可是macro到底是啥?(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)  \n\n查看定义让我们按住Ctrl,鼠标左键点击println!(以 VSCode 为例)  \nmacro_rules! println &#123;    () =&gt; ($crate::print!(&quot;\\n&quot;));    ($($arg:tt)*) =&gt; (&#123;        $crate::io::_print($crate::format_args_nl!($($arg)*));    &#125;)&#125;// 你可能会看到, 在 println! 的上面// 有着类似下面的玩意:  // // #[macro_export]// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]// #[allow_internal_unstable(print_internals, format_args_nl)]// // 这些也属于宏, 不过是 `过程宏`// 而该系列要讲的是 `声明宏`, 因此略过\n\n你悲催地发现根本看不懂这一大堆鬼画符……但看不懂根本没关系,后面几节过后,你肯定懂了现在只需明白的,是大致结构:  \n\n我们将macro_rules!放在println前面,说明后者是个宏(macro_rules!当作特定语法即可)  \n\n之后用花括号包起来,里面是该宏的具体定义  \n\n\n问题来了,关键是println的具体定义花括号内,到底在讲述着啥?  \n请容许我来帮你粗暴地类比一下match表达式 &amp;&amp; macro:  \n// matchmatch num &#123;    1 =&gt; &quot;1&quot;.repeat(10),    2 =&gt; &#123;        &quot;2&quot;.repeat(10)    &#125;    _ =&gt; panic!(&quot;Fuck you! I just want the  numer 1 or 2&quot;)&#125;// macromacro_rules! println &#123;    () =&gt; ($crate::print!(&quot;\\n&quot;));    ($($arg:tt)*) =&gt; (&#123;        $crate::io::_print($crate::format_args_nl!($($arg)*));    &#125;)&#125;\n\nmacro有点像是match,能根据不同参数,展开不同的代码在macro最外层的花括号中,有许多匹配分支  \nmatch表达式,称呼每个匹配分支为arm逗号分割它们彼此,或者不用逗号而用花括号包裹来分割最后一个arm可省略逗号  \nmacro,则称呼每个匹配分支为rule(明白为什么使用macro_rules!创建宏了吗)必须使用花括号包裹,使用分号分隔彼此最后一个rule可省略分号  \n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可现在再来看看 println,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n// 定义部分macro_rules! println &#123;    // 空参时, 只输出换行符    () =&gt; ($crate::print!(&quot;\\n&quot;));    // 有参时, 输出参数, 并换行    ($($arg:tt)*) =&gt; (&#123;        $crate::io::_print($crate::format_args_nl!($($arg)*));    &#125;)&#125;// 使用部分let s = &quot;xxx&quot;;println!(&quot;&#123;&#125;&quot;,s);println!();\n\n总结\n创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\nmacro_rules! xxx &#123;&#125;fn main() &#123;&#125;\n\n\n然后创建两个匹配分支:(匹配空参 =&gt; 不做任何事)(匹配123 =&gt; 打印123)  \n\nmacro_rules! xxx &#123;    () =&gt; &#123;&#125;;    (123) =&gt; &#123;println!(&quot;123&quot;)&#125;&#125;fn main() &#123;&#125;\n\n\n调用时, 要做到: 宏名+感叹号+传参:(传入的参数,若与任何rule都不匹配,则报错)\n\nmacro_rules! xxx &#123;    () =&gt; &#123;&#125;;    (123) =&gt; &#123;println!(&quot;123&quot;)&#125;&#125;fn main() &#123;    xxx!();      // Nothing    xxx!(123);   // println!(&quot;123&quot;);&#125;\n\n本节只是为了留个大致印象, 建立一个整体结构的认知相信你肯定还有一些疑惑, 后面会比较系统地讲解咱们下期见  \n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p3-声明与使用","url":"/posts/rs-decl-macro-p3.html","content":"\n正式系统的关于 macro 的 声明与使用\n\n  \n框架建立前一节,我们大概清楚了macro的结构现在让我们再来简单复习一遍:  \n\nmacro_rules!(这是特点语法)来创建一个macro\nrule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)放在最外层的花括号内  \n调用宏时,宏名+感叹号+括号内传参,比如: println!(some_str)  \n\n现在稍微深入一点:一个 rule 可以被这样抽象地表示: (matcher)=&gt;(transcriber)它由三个重要的部分组成:\n\nmatcher (匹配器): 用来匹配传入的参数  \nmetavariable/literal (元变量/字面量): 绑定传入的代码片段,出现于 matcher\ntranscriber (转录器): 用来在宏匹配成功后,进行代码替换\n\n以println!为例子,我们向其传入了一些参数,它给我们打印到标准输出上因为原本的println!涉及到卫生性,重复语法,路径作用域等,不适合新鸟阅读,所以我抽象了它:  \nmacro_rules! println &#123;    (/* 空参匹配 */) =&gt; (/* `换行` 的代码 */);    (/* 有参匹配 */) =&gt; (/* `打印参数 + 换行` 的代码 */)&#125;\n\nprintln由两个rule组成,每个的形式都是: matcher=&gt;transcriber从上往下,每个rule的matcher会与传入参数尝试匹配匹配时, 括号具有多样性, 请看下面  \n匹配规则:  \n\n匹配到: 就替换为transcriber里面的代码  \n匹配不到: 所有matcher都无法与传入参数进行匹配,则编译报错  \n\n括号多样性: \n\n概念: matcher与transcriber的括号,可以是(),[],{}三种之一  \n定义宏时: 一个rule可以写成 (pattern)=&gt;(expansion) 或 [pattern]=&gt;&#123;expansion&#125;  \n调用宏时: 包裹参数的括号,也遵从该规则,vec![0, 1,2,3]与pritnln!(&quot;xx&quot;)\n\n而metavariable/literal则出现在matcher中,用于匹配并捕获代码片段在对应的transcriber中,则可以操控这些元值,即操控捕获到的代码片段  \n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n\n两种宏参数是时候引入一些新的东西了, 顺便加深下你的印象  \n元变量元变量, 即Metavariable让我们来看个例子:  \nmacro_rules! my_macro &#123;    ($a: expr) =&gt; &#123;        $a    &#125;;    ($a: expr, $b: expr) =&gt; &#123;        $a + $b    &#125;&#125;fn main() &#123;    my_macro!(1);    my_macro!(1, 2);&#125;/* 宏全部展开后, 可以理解为下面: fn main() &#123;    1;    1 + 2;&#125;*/\n\n你会注意到,每个rule之间的参数,其声明都有点奇怪:比如: $a:expr -&gt; $+参数标识符+类型  \n\n$ 这个前缀是干嘛的?这显式说明,它是metavariable,可以匹配并捕获相应类型的代码片段,这里会捕获表达式至于为何要特意加$前缀来说明,像函数参数那样直接用不行吗?本节下面就要讲到啦,别着急~  \n\n先看看 expr 类型:expr,全称为expression(表达式)在第一次宏调用,我们传入了1(一个字面量),这当然是个expr,会与第一个rule成功匹配这时,my_macro!(1)这个部分,就会被替换为相应的展开代码(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n\n\n简单来讲,macro的本质,就是匹配捕获传入参数,将调用部分替换/展开为相应代码macro不就是个code generator,一段用来生成code的code吗  \n注意: macro实际上,是将传入部分解析为一个AST节点,然后替换/展开调用部分,变成一个AST节点在本节下面, 会更详细地讲讲\n元字面量元字面量, 即Metaliteral为了加深印象与引出 metaliteral , 我们来玩个对应游戏:  \n($a: expr) =&gt; &#123;$a&#125;;                     // the first rule  |             |    |         \t|( 1      )      1                       // pass &amp;&amp; expand ($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    // the second rule  |      |  |              |    |  |      |  |              |    |( 1      ,  2      ) =&gt;    1 +  2      // pass &amp;&amp; expand\n\n我使用 | 来联系 形参 -- 实参你会惊讶的发现, 传参时的对应关系们, 除了 $a -- 1 与 $b -- 2, 还有个 , -- ,  \n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参这种固定的参数, 如同token中的字面量一样我姑且称它为 Literal Token(字面量标记), 或者 Metaliteral (元字面量)(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)  \n假若 rule 中的参数没有 $前缀 进行区分:  \nmacro_rules! fuck &#123;    (a:expr) =&gt; &#123;            &#125;;&#125;fn main() &#123;    fuck!(1);       // No    fuck!(a:expr);  // Yes ~~(Oh~)~~&#125;\n\n对于定义中的 “a:expr” 只能传入固定形式的 “a:expr” 才可匹配 (即它是 MetaLiteral)\n切记:当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰    \n例子假设有这么个宏map!(想一下vec!)它能根据=&gt;判断出Key/Value,然后生成一个HashMap如下:  \nfn main() &#123;    let m = map![        &quot;吉良吉影&quot; =&gt; 33,        &quot;空条承太郎&quot; =&gt; 41,    ]    // `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;&#125;\n\n我们来写一个这样的宏吧!不过我们还未学习 重复语法, 无法写出接收可变参数的 map!, 所以现在只讨论简陋版:  \nmacro_rules! map &#123;    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert($key, $val);        m    &#125;&#125;;&#125;fn main() &#123;    let m = map!(&quot;普通上班族&quot; =&gt; 33);    println!(&quot;&#123;:?&#125;&quot;,m);&#125;/* 展开后, 可以看作是:fn main() &#123;    let m = &#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert(&quot;普通上班族&quot;, 33);        m    &#125;;    println!(&quot;&#123;:?&#125;&quot;,m);&#125;*/\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: Key=&gt;Value来看看两种宏参数在宏中, 发挥着怎样的作用:  \n\nMetavariable: 将捕获的传入的代码片段绑定到自身并在 Transcriber 中被使用, 最后展开为新代码  \n\nMetaliteral : 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 map!(&quot;普通上班族&quot;, 33), 则每个rule的 Matcher 都无法匹配上(这里只有一个rule, 空匹配的懒得放里面了)  \n\n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已之后会讲几个小例子: 比如我在B站上已经录过的递推序列生成器(宏小册上看到的, 稍微改进了下)(博客的话, 我周六放学回来慢慢更吧……)(潜台词是随时会鸽子)\n\n本质macro的本质, 是生成一个AST节点可以配套看看我在B站上宏视频, 视频讲得很浅  \n假若由你来设计一个Rust编译器首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n若我们将每遍扫描并做点事情的过程, 称为passpass一次就生成了, 对于很大的源码来说, 这不现实吧  \n那我们就pass多次, 将 从源码编译为目标码 这个大问题, 分解为一大堆小问题每一次pass都解决一个小问题, 那不就Ok了吗\n这种 中间表示, 就称为 IR (Intermediate Representation )  \n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)那是一种代码被抽象后的树状结构比如我们用Rust的enum表示一下:  \n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  enum ASTNode &#123;    Int(i32),     BinaryExpr &#123;        op: Op,        lhs: Box&lt;ASTNode&gt;,        rhs: Box&lt;ASTNode&gt;,    &#125;&#125;// 二元运算的符号: 这里只抽象了加法enum Op &#123;    Plus, &#125;\n\n你只需明白AST是对源码的一层抽象产物就可以了  \n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小但是, 如果源码很大呢? AST已经很复杂了那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n基于AST, 我们可以再来一些IR, 层层递进, 以达目的注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛  \nAST很重要, 是生成目标码的关键, 是代码的骨架而另外的IR, 也是有必要的, 这也增强了可维护性编译器在AST的基础上, 最终生成了目标码(像Lisp之类的比较特殊, 源码就已经形如AST, 可能很多人写的第一个编译器就是Lisp了……)  \n生成AST需要点啥? 或者说, 它由什么组成?由 expr(表达式), stmt(语句), ;(标点符号) 等组成这些都叫做 token  \n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构它将token们联系起来, 表达了代码的骨架这个庞然大物便是 AST 了  \n\n回到MacroToken类型表生成AST需要Token协助  \nmacro 中, 其参数的类型, 便是token类型  \n既然macro是要操控这些传入的token (或AST节点, 等会讲), 我们总得知道token类型吧?只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 Metavariable)  \n所以, 辛苦你将下面的记一下稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\nident -&gt; 标识符,如函数名字,变量名字,关键字  \nstmt -&gt; statemen,语句\nexpr -&gt; expression,表达式,如x与1_i32\nliteral -&gt; literal expression,字面量表达式,expr的子集\nblock -&gt; 代码块  \npat -&gt; pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),\npath -&gt; 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径\nty -&gt; type, 如i32,u32,String,Option等  \ntt -&gt; token tree, 之后我会单独再讲解下它的  \nitem -&gt; 条目/项, 例如函数定义  \nmeta -&gt; 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)\nlifetime -&gt; 生命周期  \nvis -&gt; visibility, 可见性, 比如pub等, 也可能为空  \n\nTT这里有个比较特殊的类型 tt (Token Tree)从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗(废话)  \ntt,可以捕获Single Token,或由(),[],{}及括号包裹起来的东西作为 Token Tree 的根节点, 先让我们来点例子:  \nmacro_rules! aa &#123;    ($a:tt) =&gt; &#123;        println!(&quot;&#123;&#125;&quot;, stringify!($a));    &#125;;&#125;fn main() &#123;    // Single Token    aa!(123);          // Yes: 123    aa!(FuckYou);      // Yes: FuckYou    // aa!(Fuck You);     // No    // aa!(123 + 11);     // No    // (), [], &#123;&#125;    aa!([123]);        // Yes: [123]    aa!(&#123;123 + 123&#125;);  // Yes: &#123; 123 + 123 &#125;&#125;\n上面的代码, 展示了 tt 可以匹配捕获哪些东西再来看看下面的内容, 理解理解它:(我们以&lt;&lt;xxx&gt;&gt;, 来表示xxx是一颗 Token Tree)  \n// 你的眼中:1 + 2 + (3 + 4)// tt的眼中:&lt;&lt;1&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;2&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;                           |                           |                   &lt;&lt;3&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;4&gt;&gt;\n这段代码的Token Tree共有5个:  \n\n&lt;&lt;1&gt;&gt;\n&lt;&lt;+&gt;&gt;\n&lt;&lt;2&gt;&gt;\n&lt;&lt;+&gt;&gt;\n&lt;&lt;(3 + 4)&gt;&gt;\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点 (这里正好处于同层)  \n有没有对 Token后面跟着Tree 更加理解?  \nAST节点macro 会将传入的token, 解析为对应类型的AST节点 (除了少量token类型, 等下会讲到)比如 map! 中, $key:value 与 $val:expr, 都会被解析为expr类型的AST节点:  \nmacro_rules! map &#123;    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert($key, $val);        m    &#125;&#125;;&#125;fn main() &#123;    let m = map!(&quot;普通上班族&quot; =&gt; 33);    println!(&quot;&#123;:?&#125;&quot;,m);&#125;/* 展开后, 可以看作是:fn main() &#123;    let m = &#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert(&quot;普通上班族&quot;, 33);        m    &#125;;    println!(&quot;&#123;:?&#125;&quot;,m);&#125;*/\n\n我们通过使用 macro , 站在了更抽象的视角上操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n这可以大量简化手写代码量, 如std中, 向宏传入类型, 自动生成为这些类型实现trait的代码\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果我直接用 宏小册 上面的代码了:  \nmacro_rules! capture_then_match_tokens &#123;    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;&#125;macro_rules! match_tokens &#123;    ($a:tt + $b:tt) =&gt; &#123;&quot;got an addition&quot;&#125;;    (($i:ident)) =&gt; &#123;&quot;got an identifier&quot;&#125;;    ($($other:tt)*) =&gt; &#123;&quot;got something else&quot;&#125;;&#125;fn main() &#123;    println!(&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;,        match_tokens!((caravan)),        match_tokens!(3 + 6),        match_tokens!(5)    );    println!(&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;,        capture_then_match_tokens!((caravan)),        capture_then_match_tokens!(3 + 6),        capture_then_match_tokens!(5)    );&#125;\n\n输出结果会是:  \ngot an identifiergot an additiongot something elsegot something elsegot something elsegot something else\n\n比如这里, match_tokens 捕获token, 然后将参数解析为一个expr类型的AST节点它不再是token, 而是个AST节点了!  \n比如 5 + 7, 原本是可以与 $a:tt + $b:tt 相匹配, 也可以与 $a: expr 匹配但是经过二次传入(向 capture_then_match_tokens 传入的参数又传给 match_tokens) 后5 + 7 变成AST表达式节点, 只能与 $a: expr 匹配, 而不能与 $a:tt + $b:tt 匹配  \n只有 tt, ident, lifetime 能免遭 AST节点化, 可以好好理解下这块  \n总结:宏将一些捕获的token所AST节点化, 随后又展开为一个新AST节点, 来替换宏调用部分的AST节点  \n宏展开的结果是个某类型的AST节点, 这相比于C语言的 #define 宏, 有什么好处?最直接的好处, 如下 (相当于自动给你加上了括号):\n// C语言, 基于简单的文本替换#define SUM(a,b) a+bint main(void) &#123;    SUM(2, 2);     // 2 * 2    5 * SUM(2, 2); // 5 * 2 + 2    return 0;&#125;// Rust语言, 根据上下文推测出宏调用的AST节点应该被展开/替换为一个表达式类型的AST节点macro_rules! sum &#123;    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;&#125;fn main() &#123;    sum!(2,2);     // 2 + 2    5 * sum!(2,2); // 5 * (2 + 2)&#125;\n\n\n匹配注意点在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制即下面要讲的东西, 有时间的也可以去看看 宏小册\n匹配误区来看看下面一段代码:\nmacro_rules! aa &#123;    ($a: expr) =&gt; &#123;&#125;;    ($a: ident +) =&gt; &#123;&#125;&#125;fn main() &#123;    aa!(a);   // Yes    aa!(a+);  // No&#125;\n\n按照你的直觉, aa!(a+) 应该会与第二个 rule 相匹配但是实际上会报这么一个错误:  \nexpected expression, found end of macro arguments// 期望表达式, 却发现宏参数结束了\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \na (lhs, left hand side) 能被第一个rule匹配而 + (二元加) 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 rhs, 此时会直接报错, 而不是去尝试匹配下一个rule  \n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n歧义限制由于一些歧义, 为了向后兼容性与不破坏代码当前对 Metavariable 后面可以跟的内容有所限制, 详情可见 Rust-Reference: 限制这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)(因为我也没有全部搞懂)  \n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n那么, 今天就到这了, 谢谢您的观看 :)\n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p4-重复","url":"/posts/rs-decl-macro-p4.html","content":"\n宏中非常重要的语法: 重复(repetition)\n\n\n介绍重复 (Repetition) 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n\nMatcher: 将一段指定的模式, 重复地匹配与捕获\nTranscriber: 将一段指定的模式, 重复地展开\n\n(废话, Rust的声明宏不就这两个主要部分嘛)  \n假设你要设计一个宏, 进行求和(参数个数不确定):  \n// Examples:assert_eq!( 0,  sum!() );assert_eq!( 15, sum!(1,2,3,4,5) );\n让我们来看看, 如何使用重复吧\n语法关键在于参数的个数不确定, 因此我们应使用重复语法:  \nmacro_rules! sum &#123;    ($($a:expr),*) =&gt; &#123;        0 $(+ $a)*    &#125;&#125;fn main() &#123;    sum!();          // 0    sum!(5);         // 5    sum!(1,2,3,4,5); // 15&#125;\n\n伪代码表示:  \n$( Pattern )   Sep    RepOp$(   模式   )  分隔符  重复符号\n\n它可以被分为三个部分:  \n\n模式: 被包裹于$( ), 表明它被重复匹配捕获(在Matcher),或重复展开(在Transcriber)  \n分隔符(Separator): 用来分割重复模式  \n重复符号(Repetition Operator): 对模式匹配的次数,进行说明与限制,不符合就编译报错  \n\n以 sum! 为例子, 它在第二个rule中用到了重复:  \n\nIn matcher:模式: $a:expr 是重复的模式, 表示重复地匹配与捕获expr分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0  \n\nIn transcriber:模式: + $a 是重复模式, 比如传入 1,2,3,4,5 时, 会被展开为 0+1+2+3+4+5分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep次数:     同 Matcher  \n\n\n$() 与 RepOp 是必填的, Sep 是可选的  \nRepOp 有三种可选项, 有点像正则:\n\n* 表示 模式匹配的次数 &gt;= 0记忆法-&gt; 该符号看上去像是一个点, 联想为0\n+ 表示 模式匹配的次数 &gt;= 1记忆法-&gt; 联想为正数, 那就&gt;=1\n? 表示 模式匹配的次数 = 0 or 1记忆法-&gt; 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n\n当 RepOp 为 ? 时, 不可以添加 Sep (因为最多也就匹配到一次, 你怎么分割?)  \nSep 是有限制的, p3 提到过, 详情可见 rust-reference\n\n以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看  \n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p5-卫生性","url":"/posts/rs-decl-macro-p5.html","content":"\n本节将介绍宏的 卫生性(hygienic)\n\n\n开篇什么是 卫生性(Hygienic) 呢?简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染如果你是第一次接触此概念, 我不信你不会懵逼不过实际上, 这个概念理解起来不算困难  \n让我们先来讨论一个问题, 请看下面的代码:\nmacro_rules! create_var &#123;    () =&gt; &#123;        let a = 1;    &#125;;&#125;fn main() &#123;    create_var!();    println!(&quot;&#123;&#125;&quot;,a);&#125;\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-gtk4-p1-系列说明","url":"/posts/rs-gtk4-p1.html","content":"\n欢迎大家来到 Rust 的 gkt-rs 系列\n\n\n系列说明Gtk, 是一个著名的GUI库, 是 GNOME 项目的关键组成由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发  \nRust语言自是其中之一, 具有相关的绑定库: gtk-rs (gtk官方网页所指定)同时, 非常建议你使用Linux作为开发环境, 因为GTK专注于Linux版本  \n我也是 gtk-rs 的新手, 依靠发表博客来巩固所学顺便也能帮助和我一样的新鸟们 (老鸟别笑我啊喂!)  \n不定期更新, 毕竟我只有周末才能碰到电脑(碰到了我也不一定来写博客, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)\n\n参考资料资料正在持续更新ing. . .\n\n书籍\n\n\nGUI development with Rust and GTK 4\n\n\n博客/文档\n\n\nRust Vs GUI\nGObject Introspection\nGNOME Developer Doc/Tutorials\n\n\n环境配置首先, 你得参照 GTK官方页面 上的信息, 根据你的操作系统, 进行相应操作, 下载 GTK (版本是GTK4)  \n本人的环境为 ArchLinux(WSL), 选择它是因为不需要过多的操心配置方面比如gtk的安装, ArchLinux可以直接一行命令解决:  \nsudo pacman -S gtk4\n\n其他系统, 请自己找下资料, 善用搜索引擎与官方文档(gtk的安装其实还是有点让人头大的)  \n本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进  \n\n欢迎骚扰\n发现错误的话, 请及时跟我联系  \n可以通过博客侧边栏上的联系方式找到我  \n欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","categories":["rust-gtk4"],"tags":["rust","gui"]},{"title":"rs-gtk4-p2-创建HelloWorld窗口","url":"/posts/rs-gtk4-p2.html","content":"\n让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧\n\n\n背景GTK是什么GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n其特点之一, 是能轻松地创建绑定:在gtk3后, 由于GI(GObject Introspection) 的应用, 可以轻松地, 创建其他语言的绑定  \n这使你能利用不同语言编写GUI比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言而不是用C去编写(用C会很繁杂, 不清晰)  \n基本上名气稍微大点的语言, 都有对应的GTK绑定    \ngtk-rs目前有个项目, 叫做 gtk-rs, 负责GTK的Rust语言绑定你在 crates.io 上搜索 gtk, 所看到的 gtk 与 gtk4, 就属于gtk-rs项目\n前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍gtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)  \n对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本不然crate会装不上  \n\n配置首先, 你需要创建一个新项目随后修改 Cargo.toml, 如下:  \n[dependencies]gtk = &#123;version = &quot;0.3.1&quot;, package = &quot;gtk4&quot;&#125;\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写 (这是个惯例)随后, 请run一下, 安装依赖 (请确保安装了gtk4)  \n下面就是正式的编码环节了\n\n编写一个GTK4应用的创建, 需要用到 gtk::Application同时, 我们还需 use gtk::prelude::*, 原因与 std::prelude 或 std::io::prelude 一样  \n先创建一个应用, 它目前连窗口也没有:  \nuse gtk::prelude::*;use gtk::Application;fn main() &#123;    let app = Application::builder()        .application_id(&quot;io.github.jedsek.myapp&quot;)        .build();    app.run();&#125;\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\nBuilder Pattern (一种Rust中常见的设计模式):这个无需多言, 我们可以利用它, 进行链式构造, 让构造的过程更加清晰在这里, 我们只调用了一次链式函数: application_id(id: &amp;str)比如 std::fs::OpenOptions 就使用了构造者模式在学习gtk4时, 它将被较高频次地使用, 最后使用 build 生成\n\napplication_id:每个GTK应用, 都带有一个id, 即 application_id, 它必须是全世界唯一的一般使用反域名, 作为id, 示例有: “org.gnome.gedit” , “io.github.jedsek.myapp”  \n\n\n但当你跃跃欲试, cargo run之后, 会看到:  \nGLib-GIO-WARNING : Your application does not implement g_application_activate()and has no handlers connected to the &#x27;activate&#x27; signal.  It should do one of these.\n\n我们实际上还要添加一个名为 activate 的信号量(Signal), 信号量的概念之后会再讲现在只需明白, 你得像下面这样写:  \nuse gtk::prelude::*;use gtk::Application;fn main() &#123;    let app = Application::builder()        .application_id(&quot;io.github.jedsek.demo&quot;)        .build();    app.connect_activate(on_activate);    app.run();&#125;fn on_activate(app: &amp;Application) &#123;    todo!()&#125;\n\n请容许我对上面的东西来点小小的解释:当一个gtk应用开始运行之\n","categories":["rust-gtk4"],"tags":["rust","gui"]}]