[{"title":"rs-async-p1-系列说明","url":"/posts/rs-async-p1.html","content":"\n欢迎大家来到 Rust 的 异步(async) 系列  \n\n\n系列说明传送门如下:  \n\n博客 : Rust异步系列 \nB站视频 : Rust编程语言-异步(Async)\n\n博客 的更新速度, 快于 视频博客 若经过重写, 则会抽时间更新 视频     \n此系列, 我们将学习Rust中的 异步 (Async)当然也会介绍异步方面的相关概念咯\n不过介于本人能力有限, 更底层一些的东西可能理解的不是很到位, 为了不误导, 需要补一些知识所以该系列花费时间可能会很久\n\n资料来源\n书籍  \n\n\nasync-book\nasync_std/tutorials\ntokio/tutorials\nFutures Explained in 200 Lines of Rust\n\n\n博客\n\n\nWithoutboats’s blogs  \n\n\n欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习\n可以通过博客侧边栏上的联系方式找到我  \n欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-async-p2-异步简介","url":"/posts/rs-async-p2.html","content":"\n来简单介绍一下异步吧  \n\n\n\n开篇异步编程 (Asynchronous programming)是一种 并发编程模型 \n特点是通过少量 OS_thread (系统线程)即可运行大量 并发任务在某些场景下, 可以疯狂压榨cpu的性能(好吧, 有点废话……)\n\n模型对比为何选择异步, 它的优势有哪些?  \n对于这个问题, 我们将对比 异步 与 其他 并发模型以此来告诉大家, 为什么选择异步:  \n1.OS Thread (系统线程)由操作系统提供线程, 进行并发, 如std::threadGood_1:简单易使用, 建模能力强, 足够传统Good_2:操作系统就是运行时, 与C语言交互方便Bad_1:数据同步困难, 易发生数据竞争Bad_2:小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n2.Green Thread (绿色线程)它几乎与系统线程一样, 不过 Runtime(运行时,jvm/.net听说过吗?) 从操作系统变为了程序本身绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程Good:这意味着, 程序本身对 Green_thread 有绝对的管理权所以内存分配等方面的粒度更细, 根据任务大小调度内存因此堆栈大小, 能够随时间推移而增长并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务Bad_1:它是程序本身实现模拟出来的线程, Runtime 比较巨大运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象它无法在语言层面被Rust支持Bad_2:绿色线程在不同平台上, 其实现可能不同对多平台的 支持/维护/改进 得靠实现者保证  \nOS Thread 与 Green Thread 与 Rust 关系比较大:一个是Rust支持的传统并发, 一个是Rust在1.0之后便舍弃的  \n\n异步我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! ! (没把你憋坏吧伙计?)  \n我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一假设我们正在单线程下, 读取文件, 并进行一个计算:  \n// 定义文件let file = /*  */// 读取文件, 获取数据 let data = read(file);// 进行一个计算compute()\n以上面代码为例子, 我们会读取 file 获取 data期间, 我们的程序, 做不了任何其他事情只有等待 IO操作 (Input/Output, 输入/输出) 完毕, 我们才能进行接下来的 compute  \n读取文件, 属于 IO操作众所周知, IO操作很耗时, 等待它完成的时间可能会很长  \n有没有什么办法加快速度?没错, 系统线程yyds:\n// 定义文件let file = /*  */// 为每个读取任务新建线程, 并获取句柄let handle_a = thread::spawan(|| read(file) );let handle_b = thread::spawan(|| compute() );// 使用join阻塞调用线程, 确保句柄线程执行结束let data = handle_a.join().unwrap();handle_b.join().unwrap();\n\n因为两个任务 read 与 compute 是独立的, 无依赖性所以我们 spawn 了两个线程第一个, 用于读取文件, 获取数据第二个, 用于在读取文件的同时, 执行着 compute虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销而异步, 就是只依靠单线程, 也能够完成上面的操作  \n(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  \n单线程中的异步(伪)代码如下:\n// 定义文件let file = /*  */// 读取文件, 获取数据 let data = read_async(file);// 进行一个计算compute_async()\n\n你会注意到:read -&gt; read_asynccompute -&gt; compute_async  \n我用伪代码表示, 这两个操作变成了异步操作你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念如下:    \n\nread:它会阻塞调用线程, 等待该操作完毕后才继续往下执行 compute  \n\n阻塞期间是几乎不需要cpu参与运行的程序此时傻乎乎地等待阻塞结束无疑是对性能的浪费, 对cpu的不尊重  \n\nread_async:它处于阻塞时, 会运行compute_async线程由 read_async 接管变为由 compute_async接管当阻塞时间结束, 则程序继续变为运行 read_async\n\nread_async 阻塞时, 程序是不会傻傻等待的:  \n若检测到它处于阻塞, 无法取得进展则会运行其他异步任务, 由其他异步任务接管线程  \n总而言之, 异步操作, 其实就是:若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)使得cpu一直处于运算, 性能被极限压榨  \n异步操作, 就像是可以随意 start/stop 一般调度程序能够对它们进行调度, 决定当前要运算哪个操作确保不会因为阻塞而傻傻等待\n只需单线程, 就可以做到同时运行多个 Task(异步任务)异步当然也不排斥多线程:一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?\n\n尾声Q:阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?A:现代电脑发展出了一些分担IO操作压力的高科技所以cpu对IO操作的压力较小/没有, IO时能进行其他运算只需要最后接收数据时, 出个场就行了  \n所以我们的程序不需要在等待输入输出时就那样等着给它们找事情, 让它们闲不下来吧!  \n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-async-p3-Future","url":"/posts/rs-async-p3.html","content":"\nRust 中的 Future/async/.await 说明  \n\n  \n开篇大家好! 我们上一节已经知晓异步的基础概念现在, 来看看Rust中的异步语法吧    \n在本节, 我们会知晓以下三个概念的大致含义:(暂时不涉及背后原理, 原理之后专门出好几节来讲)   \n\nFuture (trait)  \nasync (keyword)\n.await (keyword)\n\n开始旅途吧  \n\nFuture概念Future, 一个标准/核心库中的trait其完整路径为 std/core::future::Future   \n此节我只会讲它的大致含义, 原理则放到后面几节专门来讲 (原理太难, 一节根本不够)  \n在Rust中, 一个实现了 Future(trait) 的类型该类型的实例 (有时候直接被简称为 一个Future实例) 便代表 一次异步计算可以将其交给 Runtime(运行时), 从而异步执行   \n异步执行, 也就是指:当其他 异步任务 阻塞时, 当前 异步任务 有机会执行或当前 异步任务 阻塞时, 其他 异步任务 有机会执行总而言之, 阻塞时期执行其他任务, 不给cpu空闲的机会\n注意两个名词的区别:  \n\n异步 计算  \n异步 任务\n\n两者有着区别, 举个例子你就明白了:  \n假设有这么个 父计算, 由两个 子计算 组成:   \n\nOpen: 先异步打开一个文件(async open)  \nRead: 再异步读取该文件(async read)   \n\n我们可以看出, 一次 计算, 是可以由多个 子计算 组成的同时, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期因为 子计算们可能存在依赖关系 (在这里的例子中确实存在) \n因此, 当某个 子计算 阻塞时, 它所属的最顶层的 父计算 也会阻塞, 避免了 Runtime 调度非法计算(我们将 最顶层的父计算 (top-level Future, 即最顶层的Future实例) 称为 Task(任务))  \n当前Task 阻塞时, 接管执行权的, 不能是 当前Task 中的 其他子计算只能是 其他Task中的子计算  \n来点总结吧:  \n\nTask 是一个顶层Future实例 (即一次顶层异步计算) \n\n一个Future可以由多个Future组成, 即一个Future里可以执行多个Future\n\nTask_A阻塞时, 接管执行的是其他Task中的子计算, 不能是Task_A中的子计算\n\nTask可以只是一次单独计算\n\n\n一个Future (一次异步计算)可理解为, 是组成 一个Task (一个异步任务) 的最小单位 \n了解到了那么一点点后, 现在来正式看看呗 ?  \n定义让我们来看看它的定义:\npub trait Future &#123;    type Output;    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Self::Output&gt;;&#125;\n下面简单了解一下:  \n\nFuture:代表一次异步计算  \n\nOutput:代表 该Future, 异步执行完毕后, 产出的值的类型   \n\npoll:所有执行操作都会放在该函数中Runtime 会不断调用 poll函数 来推进 该异步计算 的完成每次 poll 的返回值是一个 枚举变体, 代表 是否完成\n\nPoll:枚举类型, 作为 poll函数 的返回值类型, 其 变体 有:Poll::Pending:指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)Poll::Ready(T):指明该计算执行完毕, 并产出一个类型为T的值   \n\n\n若只是普通使用者, 并不需了解 Future的定义 背后之原理但若不了解它, 又如何为某类型实现 Future 呢?  \n别急, Rust 为我们提供了关键字 async, 接着往下看吧   \n\nAsyncasync, 一个关键字用来创建 一个匿名结构体的实例, 该结构体实现了Future即, 它创建一个 Future实例  \n来个例子, 看看 async 的好处:   \n// 1 async fn hello_str_1() -&gt; String &#123;     String::from(&quot;Hello! World!&quot;)&#125;// 2 struct HelloStr;impl Future for HelloStr &#123;    type Output = String;    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;        let str = String::from(&quot;Hello! World!&quot;);        Poll::Ready(str)    &#125;&#125;fn hello_str_2() -&gt; impl Future&lt;Output = String&gt; &#123;    HelloStr&#125;\n\n你可以观察到, 使用 async 进行了符合直觉的简化这两种函数, 实际上是等价的  \n看看它们两的返回值, 如下:  \n// 1async fn hello_str_1() -&gt; String &#123;     String::from(&quot;Hello! World!&quot;)&#125;hello_str_1() // 返回值为 `impl Future&lt;Output = String&gt;`// 2fn hello_str_2() -&gt; impl Future&lt;Output = String&gt; &#123;    HelloStr // Future&lt;Output = String&gt; 的实例&#125;hello_str_2() // 返回值为 `impl Future&lt;Output = String&gt;`  \n\n\n注意, 异步函数的调用, 只是返回一个 Future实例但并没有开始执行, 它是惰性的只有调用Future的poll方法, 才能推动它的执行而调用poll方法的工作, 则交给了运行时(执行器)  \n这样的好处就在于:将一个异步计算看作一个变量, 方便了传参等工作  \n比如, 你想舍弃某次 异步任务, 你只需要将 对应的Future实例 给 drop 掉, 使其所有权丢失即可\nasync 的作用就是创建一个 Future实例:  \n\nasync fn 异步函数, 要求返回一个 Future实例   \nasync block 异步代码块, 创建一个 Future实例  \nasync closure 异步闭包, (目前是不稳定特性) 创建一个 Future实例  \n\n// 1// 返回值为 `impl Future&lt;Output = String&gt;`async fn hello() -&gt; String &#123;    String::from(&quot;Hello&quot;)&#125;// 2// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例async &#123;    let a = 1_i32;    a&#125;// `async block` 也可以使用move  // 获得其中使用的变量的所有权  let s = String::new();async move &#123;    &amp;s &#125;s; // Error: use of moved value// 3// 闭包因为不稳定, 我也懒得讲了......\n\n创建一个Future实例, 想必大家已经了解一二但是如何执行一个Future实例?  \n请接着往下看\n\n执行背景介绍Rust语言本身并不提供 异步运行时 (async runtime), 以便于语言内核保持精小, 便于进化/迭代/维护异步运行时 由社区提供, 围绕语言本身提供的定义 (比如 Future) 进行支持/扩充, 来运行异步程序  \n可以仔细看看 Future 的完整路径: std::future/core::Future注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) \n这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义再加上异步运行时是可选的, 凭借 cartes.io 上提供的异步运行时相关的carte在嵌入式环境下, 也能够轻松运行异步程序   \n在正式开始之前请确保你已经在 Cargo.toml 中添加了如下代码:   \n[dependencies]async-std = &#123; version = &quot;1.9&quot;, features = [&quot;attributes&quot;] &#125;\n\n以 async-std 这个比较主流, 对新人友好的 异步运行时crate 为例子我们指定了版本, 并且启用了 attributes 这个特性  \nRuntime执行我们先来创建一个 打印 &quot;hello world&quot; 的Future 吧并且使用 async-std 这个异步运行时环境来执行它:   \nuse async_std::task;async fn hello_world() &#123;     println!(&quot;Hello wrold!&quot;);&#125;fn main() &#123;     let fut = hello_world();    task::block_on(fut);&#125;\n还记得我们在本节开始不久, 就提到过的 异步任务 (Top-level Future, 即顶层的异步计算) 吗?async_std::task, 该模块, 为我们提供了大量api, 来执行/操控 这些 Task  \n比如这里出现的 task::block_on:传入一个 Future实例, Runtime 会执行它(调用poll方法), 并阻塞调用线程该任务执行完毕后产出的值, 会作为 block_on 的返回值  \n我们执行了一个 Task, 并且这个 Task 是单个的 Future但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n.await 关键字出场了! \n\nAwait.await 只能出现在 async fn/block 内部在某个 Future实例 的后面, 增加 .await, 那么 该Future实例 则会执行但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)真正执行的话, 得将 Future实例 交给运行时, 带动着执行里面的 子Future   \n来看看它的使用:  \nuse async_std::task;async fn hello() &#123;      print!(&quot;Hello &quot;);&#125;async fn world() &#123;    println!(&quot;world!&quot;);&#125;async fn hello_world() &#123;     hello().await;    world().await;&#125;fn main() &#123;     let fut = hello_world();    task::block_on(fut);&#125;\n\n.await 是一个标记点, 可以理解为是一个 yield pointRuntime 执行到 xxx.await 时, 先会执行一次 xxx  \n一开始, 会调用一次poll函数, 推动执行进度通过它的返回值, Poll&lt;T&gt;枚举的变体, 即 Pending 或 Ready(T)来决定: \n\n让 其他Task 接管执行权 (yield)  \n该Future执行完毕, 继续执行当前 Task  \n\n若为 Ready, 则选 2, 继续往下执行 (一个 Task 可能是由多个 Future 所组成)若为 Pending, 则选 1, 让其他任务接管执行权 (比如IO操作的阻塞期间, 让其他任务执行)  \n稍微有点涉及原理部分, 可能有点难理解, 来个简单粗暴理解版:  \n.await 会指明 执行某个Future 这一逻辑当 xxx.await 所在的 Task 交给 Runtime 执行, 并执行到 xxx.await 时xxx 这个Future实例会执行  \n若它阻塞 (这意味着 该Future所在的Task 也阻塞)所以调度程序安排 其他Task, 在该空档期执行若不阻塞, 就继续往下执行 (可能还有碰见 .await 哟), 直到 该Task 结束   \n\n补充\n#[async_std::main]这玩意无比常见, 是个属性宏, 要加在 main函数 头上使得 main 前面能被 async 所修饰程序运行时, main函数返回的 Future, 会自动交给 Runtime 开始运行, 如下:  \n\n#[async_std::main]async fn main() &#123;    hello_world().await&#125;// 等价于:fn main() &#123;    async_std::task::block_on( async &#123;        hello_world().await    &#125;)&#125;\n\n\n\nasync_std::task::spawn因为这玩意也很常见, 所以就讲一讲:向其传入 Future, 运行时会开始运行 该Task, 并返回 async_std::task::JoinHandle 的实例它实现了 Future, 与标准库中的 JoinHandle 无比相似不过那个运行 Thread, 而这个运行 Task, join 相应地变成 .await想让 该handle代表的Task 运行完毕, 应该在 该handle 前放上 .await:  \n\nuse async_std::task;#[async_std::main]async fn main() &#123;     let handle = task::spawn(async &#123;        1 + 1    &#125;);    let two:i32 = handle.await;&#125;\n\n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-async-p4-状态的保存/变换","url":"/posts/rs-async-p4.html","content":"\n浅显的原理第一篇: 状态的保存/变换\n\n\n开篇注: 参考了 《Writing an OS in Rust》中的async篇, 可以自己搜索下看看为了更好地理解 Rust异步 背后的原理, 我们先来了解下一些概念当然, 不用太深入, 只是小补充而已:   \n\n抢占式/协作式多任务  \n状态机  \n自引用结构体   \n\n现在, 让我们开始吧!  \n\n两种多任务介绍抢占式多任务 与 协作式多任务, 都属于 多任务         \n\n抢占式多任务:操作系统决定CPU的运行权比如, 操作系统先让 网易云音乐 运行一会, 再让 VSCode 运行一会各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种 任务们同时运行 的感觉这是强迫/抢占的     \n\n协作式多任务:任务们本身进行协调, 决定CPU的运行权比如Rust中, 运行时调用 某Task(top-level Future) 的 poll方法 阻塞时, 返回 Poll::Pending自己放弃继续执行, 并通知运行时执行 其他Task这是自愿/协作的, Task们 自愿放弃CPU的执行权(上文中的 任务 与 Task 请区分一下, 前者比后者广泛, 后者在这, 用于Rust的举例)  \n\n\n状态的恢复/保存既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时该任务, 应当从先前暂停的地方开始, 继续执行因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存  \n对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:\n\n抢占式:因为是强迫切换执行的, 任务会在任意某个时刻被中断任务此时运行到了哪里? 我们不知道啊!那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n协作式:因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的这种放弃执行权的操作, 我们称为 yield    \n\n比如在Rust中, xxx.await 会执行一个Future意味着当程序执行到这里时, 可能会 yield (poll 返回 Poll::Pending, 自愿放弃执行权)  \nxxx.await 就是一个 stop/yield point, 代表执行到此处时, 可能会发生暂停并yield瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)因此, 我们可以准确分配 Future 执行所需要的最大空间  \n其实, 每个 .await (也就是yield point), 就代表着 一种状态 (之后会讲)\n协作式 的好处在于便于掌握所有的 yield point在暂停之前, 准确保存 下次继续所需要的状态, 内存/性能优势很大但坏处也有, 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n\n状态机的概念在Rust中的异步, 我们之前也说过, 属于 协作式多任务而其 状态保存 的实现, 就是利用 状态机(state machine) 来实现  \n状态机 (state machine) 一般指 有限状态自动机, 是一种 数学模型  \n\n状态 (state):比如有一扇门, 它的状态就处于以下两种之一: Open or Closed    \n\n事件 (event):某事件 发生后, 会触发相应 动作, 可能改变状态, 比如: 用钥匙锁门(event) =&gt; 关门(action) =&gt; 门被锁住(state)   \n\n动作 (action):事件 发生后, 会触发 动作  \n\n变换 (transition):State_X =&gt; State_Y 就叫 变换, 比如门的状态从 Open =&gt; Closed  \n\n\n稍微了解下 状态机 的概念即可  \n那么现在, 就要看具体代码了  \n如果你想亲自运行一下, 先确保你的 Cargo.toml 中的依赖如下:  \n[dependencies]async-std = &#123;version = &quot;1&quot;, features = [&quot;attributes&quot;, &quot;unstable&quot;]&#125;\n\n如下代码, 读取一个文件的行数你可以通过 cargo run -- ./src/main.rs 运行(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)\nuse std::&#123;    env::args,    process,&#125;;use async_std::&#123;    prelude::*,    fs::File,    io::&#123;self,BufReader&#125;,&#125;;#[async_std::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;              // Start    let path = args().nth(1).unwrap_or_else(||&#123;        eprintln!(&quot;Fuck you! No path for reading&quot;);        process::exit(1);    &#125;);     let file = File::open(path).await?;          // Yield point    let lines = BufReader::new(file).lines();    let count = lines.count().await;             // Yield point    println!(&quot;This file contains &#123;&#125; lines&quot;,count);    Ok(())&#125;                                                // Done\nmian() 产生一个新实例, 异步运行 open(path) 与 count()对于编译器, 每一个 .await 其实都代表一种状态  \nFuture实例, 实际上是个 状态机在这里共有四种状态/阶段 (其中包括两个 .await point(yield point)):  \n\nStart: 此Future刚开始执行  \nYield1: 第一个 yield point\nYield2: 第二个 yield point\nDone: 此Future执行完毕\n\n这些状态的含义是: 表示当前Future执行到了哪一个阶段执行器调用 当前Future 的 poll 推动进度时, 若在 某一阶段 返回了 Poll::Pending, 则放弃执行权当再次调用 当前Future 的 poll 推动进度时, 则从上次暂停的状态 恢复 (resume), 继续执行  \n官方目前似乎采用 Generator (生成器) 为异步语法生成状态机每一个状态都会存储一些数据, 便于进入下一个状态  \nNote 1:Start状态, 会存储传入函数的参数 (如果有参数)\nNote 2:Done状态下, 若进行 resume, 则可能得到 panic!恢复已结束的计算是不应该的  \nNote 3:怎么判断每个状态需要保存哪些变量? 很简单的一句话:某个yield point之前定义, 且point之后还需要使用的变量如上段代码中的 file, count 就需要被保存, 因为从暂停中恢复后还需要使用其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象所以不需要特殊的持久化操作\n\n自引用结构体保存引用当每一个状态存储数据时, 可能会导致发生 自引用, 比如:  \nasync fn example() -&gt; i32 &#123;                            // Start    let arr = [1, 2, 3];    let element = &amp;arr[2];    write_file(&quot;foo.txt&quot;, element.to_string()).await;  // Yield1    *element                                           // Done&#125;\n这里有三个状态: Start, Yield1, Done而在 Yield1 这个状态, 存储的数据如下:\n// 状态的定义\nstruct Yield1State &#123;\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n&#125;\n\n// 状态的实例\nYield1State &#123;\n    arr: [1,2,3],\n    element: &amp;arr[2] as *const i32,\n&#125;\n\n等等, 你可能会对上面的代码有疑惑:不是说, 状态 只需要保存 在yield point之前定义, 并且该point之后还需要使用的变量 吗上面的代码, 只有 element 这个 引用 需要被保存吧?  \n这是因为, 它是 引用 嘛!没了 引用 背后的实际数据, 那它还有啥用, 不就是 悬垂引用 了吗?  \n因此我们还得保存, 该引用 指向的背后数据: arr并 一起 存储在同个 struct (代表同一状态)中  \n像这种 结构体内部的指针, 指向结构体本身就叫 自引用结构  \n比如上面代码: 同一结构体下, 成员 element 指向了成员 arr  \n内存移动问题如上所述, 这可能导致悬垂引用的产生:若 该struct实例 的 内存地址发生改变(比如使用 std::mem, 让 struct实例 的内存地址, 发生移动)  \n以上面的那段代码为例, 如下:  \n\narr:内存地址会跟着结构体实例而改变但是, 值仍然是 [1,2,3]\n\nelement:内存地址会跟着结构体实例而改变但是, 值仍然是 先前arr的地址注意, 是先前的 ! 而不是后来arr的新地址\n\n\n这就产生了一个问题: 引用可能是失效/错误的 (悬垂引用)  \n官方提出了 std::pin::Pin (trait)来解决 自引用结构体 方面的 悬垂指针/引用问题 \n其实你听名字也很好理解:Pin(中文意思是钉子) 的作用是, 防止内存地址发生改变 (给爷钉死吧!)  \n但是它又是怎么pin住的呢?下一节再慢慢讲吧  \n那又是一个值得探讨的话题了欲知后事如何, 且听下回分解  \n(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)  \n","categories":["rust-async"],"tags":["rust"]},{"title":"rs-dm-p1-系列说明","url":"/posts/rs-decl-macro-p1.html","content":"\n欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n\n\n系列说明:注: 请注意是 声明宏传送门如下:  \n\n博客 : Rust声明宏系列 \nB站视频 : Rust编程语言-声明宏\n\n博客 的更新速度, 快于 视频博客 若经过重写, 则会抽时间更新 视频  \n此系列, 我们将学习Rust中的 声明宏  \n\n参考资料\n书籍\n\n\n宏小册  \nRustPrimer\nTRPL\n\n\n文章  \n\n\n【译】Rust宏: 教程与示例 (一)\n【译】Rust宏: 教程与示例 (二)\n\n\n欢迎骚扰\n发现错误的话, 请及时跟我联系  \n可以通过博客侧边栏上的联系方式找到我  \n欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p2-从println开始","url":"/posts/rs-decl-macro-p2.html","content":"\n我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n\n\n开篇大家应该都用过一个宏它就是 println!:  \nfn main() &#123;    let s = &quot;Rush B!!!!&quot;;    println!(&quot;&#123;&#125;&quot;,s);    println!()&#125;\n\n当你刚刚接触它的时候, 可能会感到些许疑惑:为什么后面要跟个感叹号?为什么括号里面的参数可以不一样?  \n亲爱的 TRPl 在教你写 Hello World! 的时候, 告诉过你: 名字后加个感叹号, 就是个 宏(macro)注: macro 的读音: [ˈmækroʊ]\n可是 macro 到底是啥?(算了算了, 反正只要会用就行了, 于是你点击了该网页的叉叉)  \n\n查看定义让我们按住Ctrl, 鼠标左键 println!(以 VSCode 为例)  \nmacro_rules! println &#123;    () =&gt; ($crate::print!(&quot;\\n&quot;));    ($($arg:tt)*) =&gt; (&#123;        $crate::io::_print($crate::format_args_nl!($($arg)*));    &#125;)&#125;// 你可能会看到, 在 println! 的上面// 有着类似下面的玩意:  // // #[macro_export]// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]// #[allow_internal_unstable(print_internals, format_args_nl)]// // 这些也属于宏, 不过是 `过程宏`// 而该系列要讲的是 `声明宏`, 因此略过\n\n你悲催地发现根本看不懂这一大堆鬼画符……但看不懂根本没关系, 后面几节过后, 你肯定懂了现在只需明白的, 是大致结构:  \n\n我们将 macro_rules! 放在 println 前面, 说明后者是个宏(macro_rules! 当作特定语法即可)  \n\n之后用花括号包起来, 里面是该宏的具体定义  \n\n\n问题来了, 关键是 println 的具体定义花括号内, 到底在讲述着啥?  \n请容许我来帮你粗暴地类比一下 match表达式 &amp;&amp; macro:  \n// matchmatch num &#123;    1 =&gt; &quot;1&quot;.repeat(10),    2 =&gt; &#123;        &quot;2&quot;.repeat(10)    &#125;    _ =&gt; panic!(&quot;Fuck you! I just want the  numer 1 or 2&quot;)&#125;// macromacro_rules! println &#123;    () =&gt; ($crate::print!(&quot;\\n&quot;));    ($($arg:tt)*) =&gt; (&#123;        $crate::io::_print($crate::format_args_nl!($($arg)*));    &#125;)&#125;\n\nmacro 有点像是 match, 能根据不同参数, 展开不同的代码在 macro 最外层的花括号中, 有许多匹配分支  \nmatch表达式, 称呼每个匹配分支为 arm逗号分割它们彼此, 或者不用逗号而用花括号包裹来分割最后一个 arm 可省略逗号  \nmacro, 则称呼每个匹配分支为 rule (明白为什么使用 macro_rules! 创建宏了吗)必须使用花括号包裹, 使用分号分隔彼此最后一个 rule 可省略分号  \n你并不需搞清所有细节, 现在先不用试图记忆具体语法, 有印象即可现在再来看看 println, 是不是稍微有点感觉了 (看不懂的地方依然直接跳即可):  \n// 定义部分macro_rules! println &#123;    // 空参时, 只输出换行符    () =&gt; ($crate::print!(&quot;\\n&quot;));    // 有参时, 输出参数, 并换行    ($($arg:tt)*) =&gt; (&#123;        $crate::io::_print($crate::format_args_nl!($($arg)*));    &#125;)&#125;// 使用部分let s = &quot;xxx&quot;;println!(&quot;&#123;&#125;&quot;,s);println!();\n\n总结\n创建 macro, 名字就叫 xxx, 花括号包裹具体定义:  \n\nmacro_rules! xxx &#123;&#125;fn main() &#123;&#125;\n\n\n创建两个匹配分支:(匹配空参 =&gt; 不做任何事)(匹配123 =&gt; 打印123)  \n\nmacro_rules! xxx &#123;    () =&gt; &#123;&#125;;    (123) =&gt; &#123;println!(&quot;123&quot;)&#125;&#125;fn main() &#123;&#125;\n\n\n调用, 宏名+感叹号+传参:(传入的参数, 若与任何 rule 都不匹配, 则报错)\n\nmacro_rules! xxx &#123;    () =&gt; &#123;&#125;;    (123) =&gt; &#123;println!(&quot;123&quot;)&#125;&#125;fn main() &#123;    xxx!();      // Nothing    xxx!(123);   // println!(&quot;123&quot;);&#125;\n\n本节只是为了留个大致印象, 建立一个整体结构的认知相信你肯定还有一些疑惑, 后面会比较系统地讲解咱们下期见  \n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p3-声明与使用","url":"/posts/rs-decl-macro-p3.html","content":"\n正式系统的关于 macro 的 声明与使用\n\n  \n框架建立前一节, 我们大概清楚了 macro 的结构现在让我们再来简单复习一遍:  \n\nmacro_rules! (这是特点语法) 来创建一个 macro\nrule(s) (匹配分支, 以 &quot;参数 =&gt; 展开代码&quot; 的形式) 放在最外层的花括号内  \n调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 println!()  \n\n现在稍微深入一点:一个 rule 可以被这样抽象地表示 : (matcher) =&gt; (transcriber)它由三个重要的部分组成:\n\nmatcher (匹配器): 用来匹配传入的参数  \nmetavariable/literal (元 变量/字面量): 绑定传入的参数到变量上, 出现在 matcher 中\ntranscriber (转录器): 用来在宏匹配成功后, 进行代码替换\n\n以 println! 为例子, 我们向其传入了一些参数, 它给我们打印到标准输出上因为原本的 println! 涉及到 卫生性, 重复语法, 路径作用域 等, 不适合新鸟阅读, 所以我抽象了它: \nmacro_rules! println &#123;    (/* 空参匹配 */) =&gt; (/* `换行` 的代码 */);    (/* 有参匹配 */) =&gt; (/* `打印参数 + 换行` 的代码 */)&#125;\nprintln 由两个 rule 组成, 每个的形式都是: matcher =&gt; transcriber从上往下, 每个 rule 的 matcher 会与传入参数尝试匹配, 匹配到, 就替换为 transcriber 里面的代码所有 matcher 都无法与 传入参数 进行匹配, 则报错  \n同时, matcher 与 transcriber 的括号, 分别可以是 (), [], {} 三种之一即, 对于一个rule, 它可以是: (pattern) =&gt; (expansion), 也可以是 [pattern] =&gt; &#123;expansion&#125;在调用时, 包裹参数的括号也可以在这三种之一切换, 比如 vec![0, 1,2,3 与 pritnln!(&quot;xx&quot;)\n而 metavariable/literal 则出现在 matcher 中, 用于匹配并捕获 代码片段在对应的 transcriber 中, 则可以操控这些 元值, 即操控 捕获到的代码片段  \n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n\n两种宏参数是时候引入一些新的东西了, 顺便加深下你的印象  \n元变量(Metavariable)让我们来看个例子:  \nmacro_rules! my_macro &#123;    ($a: expr) =&gt; &#123;        $a    &#125;;    ($a: expr, $b: expr) =&gt; &#123;        $a + $b    &#125;&#125;fn main() &#123;    my_macro!(1);    my_macro!(1, 2);&#125;/* 宏全部展开后, 可以理解为下面: fn main() &#123;    1;    1 + 2;&#125;*/\n\n你会注意到, 每个 rule 之间的参数, 其声明都有点奇怪:比如 $a:expr -&gt; $ + 参数标识符 + 类型  \n$ 这个前缀干嘛的?这显式地说明了, 它是 metavariable, 可以匹配并捕获相应类型的代码片段, 这里会捕获表达式至于为何要特意加$前缀来说明, 本节下面就要讲到啦, 别着急~  \n来看看 expr 这个后置的类型:expr, 全称为 expression (表达式)在第一次宏调用, 我们传入了 1 (i32类型的字面量), 这当然是个表达式, 会与第一个 rule 成功匹配这时, my_macro!(1) 这个部分, 就会被替换为 相应的展开代码(matcher(匹配器), metavariable(元变量), transcriber(转录器) 都用到了)    \n简单来讲, macro 的本质, 就是匹配捕获传入参数, 将调用部分 替换/展开 为相应代码macro 不就是个代码生成器, 一段用来生成代码的代码吗  \n注意: macro实际上是将传入部分解析为一个AST节点, 然后替换/展开调用部分, 变成一个AST节点在本节下面的本质篇, 会更详细地讲讲\n元字面量(Metaliteral)为了加深印象与引出 metaliteral , 我们来玩个对应游戏:  \n($a: expr) =&gt; &#123;$a&#125;;                     // the first rule  |             |    |         \t|( 1      )      1                       // pass &amp;&amp; expand ($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    // the second rule  |      |  |              |    |  |      |  |              |    |( 1      ,  2      ) =&gt;    1 +  2      // pass &amp;&amp; expand\n\n我使用 | 来联系 形参 -- 实参你会惊讶的发现, 传参时的对应关系们, 除了 $a -- 1 与 $b -- 2, 还有个 , -- ,  \n其实, 你往括号里传入的东西, 都是参数 (除了空格)对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参这种固定的参数, 如同token中的字面量一样我姑且称它为 Literal Token(字面量标记), 或者 Metaliteral (元字面量)(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)  \n因此, 假若 rule 中的参数没有 $前缀 进行区分:  \nmacro_rules! fuck &#123;    (a:expr) =&gt; &#123;            &#125;;&#125;fn main() &#123;    fuck!(1);       // No    fuck!(a:expr);  // Yes ~~(Oh~)~~&#125;\n\na:expr 的类型为 tt, 而非 expr, 只能传入固定形式的 a:expr 才发生匹配 (即它是 MetaLiteral)是不是感觉一切都特别狗日?  \n切记:当你想在传参时, 绑定一段代码片段, 参数名前必须加上 $前缀 进行修饰  \nMeta variable/literal 到底有啥用? 你用着用着就明白了……但我可以提一嘴: (为了自由) 可以方便DSL/生成代码接下来, 我们用一个例子, 来说明两者的缺一不可:  \n例子假设有这么个宏 map! (有没有想到 vec!)它能根据 =&gt; 判断出 Key/Value, 然后生成一个 HashMap如下:  \nfn main() &#123;    let m = map![        &quot;吉良吉影&quot; =&gt; 33,        &quot;空条承太郎&quot; =&gt; 41,    ]    // `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;&#125;\n\n我们来写一个这样的宏吧!不过我们还未学习 重复语法, 无法写出接收可变参数的 map!, 所以现在只讨论简陋版:  \nmacro_rules! map &#123;    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert($key, $val);        m    &#125;&#125;;&#125;fn main() &#123;    let m = map!(&quot;普通上班族&quot; =&gt; 33);    println!(&quot;&#123;:?&#125;&quot;,m);&#125;/* 展开后, 可以看作是:fn main() &#123;    let m = &#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert(&quot;普通上班族&quot;, 33);        m    &#125;;    println!(&quot;&#123;:?&#125;&quot;,m);&#125;*/\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: Key =&gt; Value来看看两种宏参数在宏中, 发挥着怎样的作用:  \n\nMetavariable: 将捕获的传入的代码片段绑定到自身并在 Transcriber 中被使用, 最后展开为新代码  \n\nMetaliteral : 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 map!(&quot;普通上班族&quot;, 33), 则每个rule的 Matcher 都无法匹配上(这里只有一个rule, 空匹配的懒得放里面了)  \n\n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已(之后会讲几个实战: 比如B站视频中已经讲过的递推序列生成器, 博客的话, 我周六放学回来慢慢更吧……)\n\n本质 (AST 与 Token)(如果还是不理解, 可以随便找个编译原理教程, 自己看看前几节即可)(或者看看我B站的视频, 视频讲得比较浅, 比较通俗)  \n假若由你来设计一个Rust编译器首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n若我们将每遍扫描并做点事情的过程, 称为 passpass 一次就生成了, 对于很大的源码来说, 这不现实吧  \n那我们就pass多次, 将 从源码编译为目标码 这个大问题, 分解为一大堆小问题每一次pass都解决一个小问题, 那不就Ok了吗\n这种 中间表示, 就称为 IR (Intermediate Representation )  \n我们可以先把源码抽象为AST (源码被抽象后的树状表示, 抽象语法树, Abstract Syntax Tree)比如我们用Rust的enum表示一下:  \n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  enum ASTNode &#123;    Int(i32),     BinaryExpr &#123;        op: Op,        lhs: Box&lt;ASTNode&gt;,        rhs: Box&lt;ASTNode&gt;,    &#125;&#125;// 二元运算的符号: 这里只抽象了加法enum Op &#123;    Plus, &#125;\n你只需明白AST是对源码的一层抽象产物就可以了  \n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小但是, 如果源码很大呢? AST已经很复杂了那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n基于AST, 我们可以再来一些 IR, 层层递进, 以达目的注意, 是一些, 而不是一个, 这很好理解, 因为一层可能还是不够嘛  \nAST 很重要, 是生成目标码的关键, 是代码的骨架而另外的IR, 也是有必要的, 这也增强了可维护性编译器在AST的基础上, 最终生成了目标码(像Lisp之类的比较特殊, 源码就已经形如AST, 可能很多人写的第一个编译器就是Lisp了……)  \n生成AST需要点啥? 或者说, 它由什么组成?由 expr(表达式), stmt(语句), ;(标点符号) 等组成这些都叫做 token  \n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构它将token们联系起来, 表达了代码的骨架这个庞然大物便是 AST 了  \n\n回到MacroToken类型表生成AST需要Token协助  \nmacro 中, 其参数的类型, 便是token类型  \n既然macro是要操控这些传入的token (或AST节点, 等会讲), 我们总得知道token类型吧?只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 Metavariable)  \n所以, 辛苦你将下面的记一下稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\nident -&gt; 标识符, 如函数名字, 变量名字, 关键字  \nstmt -&gt; statemen, 语句\nexpr -&gt; expression, 表达式, 如 x 与 1_i32\nliteral -&gt; literal expression, 字面量表达式, expr的子集\nblock -&gt; 代码块  \npat -&gt; pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),\npath -&gt; 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径\nty -&gt; type, 如i32, u32, String, Option等  \ntt -&gt; token tree, 之后我会单独再讲解下它的  \nitem -&gt; 条目/项, 例如函数定义  \nmeta -&gt; 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)\nlifetime -&gt; 生命周期  \nvis -&gt; visibility, 可见性, 比如pub等, 也可能为空  \n\nTT这里有个比较特殊的类型 tt (Token Tree)从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗(废话)  \ntt, 可以捕获 Single Token, 或者由 (), [], {} 及括号包裹起来的东西作为 Token Tree 的根节点, 先让我们来点例子:  \nmacro_rules! aa &#123;    ($a:tt) =&gt; &#123;        println!(&quot;&#123;&#125;&quot;, stringify!($a));    &#125;;&#125;fn main() &#123;    // Single Token    aa!(123);          // Yes: 123    aa!(FuckYou);      // Yes: FuckYou    // aa!(Fuck You);     // No    // aa!(123 + 11);     // No    // (), [], &#123;&#125;    aa!([123]);        // Yes: [123]    aa!(&#123;123 + 123&#125;);  // Yes: &#123; 123 + 123 &#125;&#125;\n上面的代码, 展示了 tt 可以匹配捕获哪些东西再来看看下面的内容, 理解理解它:(我们以&lt;&lt;xxx&gt;&gt;, 来表示xxx是一颗 Token Tree)  \n// 你的眼中:1 + 2 + (3 + 4)// tt的眼中:&lt;&lt;1&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;2&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;                           |                           |                   &lt;&lt;3&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;4&gt;&gt;\n这段代码的Token Tree共有5个:  \n\n&lt;&lt;1&gt;&gt;\n&lt;&lt;+&gt;&gt;\n&lt;&lt;2&gt;&gt;\n&lt;&lt;+&gt;&gt;\n&lt;&lt;(3 + 4)&gt;&gt;\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点 (这里正好处于同层)  \n有没有对 Token后面跟着Tree 更加理解?  \nAST节点macro 会将传入的token, 解析为对应类型的AST节点 (除了少量token类型, 等下会讲到)比如 map! 中, $key:value 与 $val:expr, 都会被解析为expr类型的AST节点:  \nmacro_rules! map &#123;    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert($key, $val);        m    &#125;&#125;;&#125;fn main() &#123;    let m = map!(&quot;普通上班族&quot; =&gt; 33);    println!(&quot;&#123;:?&#125;&quot;,m);&#125;/* 展开后, 可以看作是:fn main() &#123;    let m = &#123;        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();        m.insert(&quot;普通上班族&quot;, 33);        m    &#125;;    println!(&quot;&#123;:?&#125;&quot;,m);&#125;*/\n\n我们通过使用 macro , 站在了更抽象的视角上操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n这有时会大大简化手写代码量, 如std中, 向宏传入些类型, 能自动生成为这些类型实现trait的代码\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果我直接用 宏小册 上面的代码了:  \nmacro_rules! capture_then_match_tokens &#123;    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;&#125;macro_rules! match_tokens &#123;    ($a:tt + $b:tt) =&gt; &#123;&quot;got an addition&quot;&#125;;    (($i:ident)) =&gt; &#123;&quot;got an identifier&quot;&#125;;    ($($other:tt)*) =&gt; &#123;&quot;got something else&quot;&#125;;&#125;fn main() &#123;    println!(&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;,        match_tokens!((caravan)),        match_tokens!(3 + 6),        match_tokens!(5)    );    println!(&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;,        capture_then_match_tokens!((caravan)),        capture_then_match_tokens!(3 + 6),        capture_then_match_tokens!(5)    );&#125;\n\n输出结果会是:  \ngot an identifiergot an additiongot something elsegot something elsegot something elsegot something else\n\n比如这里, match_tokens 捕获token, 然后将参数解析为一个expr类型的AST节点它不再是token, 而是个AST节点了!  \n比如 5 + 7, 原本是可以与 $a:tt + $b:tt 相匹配, 也可以与 $a: expr 匹配但是经过二次传入(向 capture_then_match_tokens 传入的参数又传给 match_tokens) 后5 + 7 变成AST表达式节点, 只能与 $a: expr 匹配, 而不能与 $a:tt + $b:tt 匹配  \n只有 tt, ident, lifetime 能免遭 AST节点化, 可以好好理解下这块  \n总结: 宏将一些捕获的token所AST节点化, 随后又展开为一个新AST节点, 来替换宏调用部分的AST节点  \n宏展开的结果是个某类型的AST节点, 这相比于C语言的 #define 宏, 有什么好处?最直接的好处, 如下 (相当于自动给你加上了括号):\n// C语言, 基于简单的文本替换#define SUM(a,b) a+bint main(void) &#123;    SUM(2, 2);     // 2 * 2    5 * SUM(2, 2); // 5 * 2 + 2    return 0;&#125;// Rust语言, 根据上下文推测出宏调用的AST节点应该被展开/替换为一个表达式类型的AST节点macro_rules! sum &#123;    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;&#125;fn main() &#123;    sum!(2,2);     // 2 + 2    5 * sum!(2,2); // 5 * (2 + 2)&#125;\n\n\n匹配注意点在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制即下面要讲的东西, 有时间的也可以去看看 宏小册\n匹配误区来看看下面一段代码:\nmacro_rules! aa &#123;    ($a: expr) =&gt; &#123;&#125;;    ($a: ident +) =&gt; &#123;&#125;&#125;fn main() &#123;    aa!(a);   // Yes    aa!(a+);  // No&#125;\n\n按照你的直觉, aa!(a+) 应该会与第二个 rule 相匹配但是实际上会报这么一个错误:  \nexpected expression, found end of macro arguments// 期望表达式, 却发现宏参数结束了\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \na (lhs, left hand side) 能被第一个rule匹配而 + (二元加) 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 rhs, 此时会直接报错, 而不是去尝试匹配下一个rule  \n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n歧义限制由于一些歧义, 为了向后兼容性与不破坏代码当前对 Metavariable 后面可以跟的内容有所限制, 详情可见 Rust-Reference: 限制这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)(因为我也没有全部搞懂)  \n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n那么, 今天就到这了, 谢谢您的观看 :)\n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p4-重复","url":"/posts/rs-decl-macro-p4.html","content":"\n宏中非常重要的语法: 重复(repetition)\n\n\n介绍重复 (Repetition) 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n\nMatcher: 将一段指定的模式, 重复地匹配与捕获\nTranscriber: 将一段指定的模式, 重复地展开\n\n(废话, Rust的声明宏不就这两个主要部分嘛)  \n假设你要设计一个宏, 模拟下面代码的传参时语法, 传入一些数字(不确定个数), 然后获取求和结果:  \n// Examples:assert_eq!( 0,  sum!() );assert_eq!( 15, sum!(1,2,3,4,5) );\n让我们来看看, 如何使用重复吧\n语法关键在于参数的个数不确定, 因此我们应使用重复语法:  \nmacro_rules! sum &#123;    ($($a:expr),*) =&gt; &#123;        0 $(+ $a)*    &#125;&#125;fn main() &#123;    sum!();          // 0    sum!(5);         // 5    sum!(1,2,3,4,5); // 15&#125;\n\n伪代码表示:  \n$( Pattern )   Sep    RepOp$(   模式   )  分隔符  重复符号\n\n它可以被分为三个部分:  \n\n模式: 被包裹在 $( ) 里面, 表面它被重复匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n分隔符(Separator): 用来分割重复模式  \n重复符号(Repetition Operator): 对可以匹配多少次模式, 进行说明与限制, 不符合就编译报错  \n\n以 sum! 为例子, 它在第二个rule中用到了重复:  \n\nIn matcher:模式-&gt; $a:expr 是重复的模式, 表示重复地匹配与捕获expr分割-&gt; 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配次数-&gt; *号, 说明了重复模式的个数, 它被限制为&gt;=0  \n\nIn transcriber:模式-&gt; + $a 是重复模式, 比如传入 1,2,3,4,5 时, 会被展开为 0+1+2+3+4+5分割-&gt; 没添加分割符号, 表示展开时, 每个模式之间不会添加sep次数-&gt; 同 Matcher  \n\n\n$() 与 RepOp 是必填的, Sep 是可选的  \nRepOp 有三种可选项, 有点像正则:\n\n* 表示 模式匹配的次数 &gt;= 0记忆法-&gt; 该符号看上去像是一个点, 联想为0\n+ 表示 模式匹配的次数 &gt;= 1记忆法-&gt; 联想为正数, 那就&gt;=1\n? 表示 模式匹配的次数 = 0 or 1记忆法-&gt; 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n\n当 RepOp 为 ? 时, 不可以添加 Sep (因为最多也就匹配到一次, 你怎么分割?)  \nSep 是有限制的, p3 提到过, 详情可见 rust-reference\n\n以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看  \n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-dm-p5-卫生性","url":"/posts/rs-decl-macro-p5.html","content":"\n本节将介绍宏的 卫生性(hygienic)\n\n\n开篇什么是 卫生性(Hygienic) 呢?简单来说, 就是标识符(ident)在宏的处理与展开过程中是唯一的, 无歧义的, 不被同名标识符污染的如果你是第一次接触此概念, 我不信你不会懵逼不过实际上, 这个概念理解起来不算困难  \n让我们先来讨论一个问题, 请看下面的代码:\nmacro_rules! create_var &#123;    () =&gt; &#123;        let a = 1;    &#125;;&#125;fn main() &#123;    create_var!();    println!(&quot;&#123;&#125;&quot;,a);&#125;\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","categories":["rust-decl-macro"],"tags":["rust"]},{"title":"rs-gtk4-p1-系列说明","url":"/posts/rs-gtk4-p1.html","content":"\n欢迎大家来到 Rust 的 gkt-rs 系列\n\n\n系列说明Gtk, 是一个著名的GUI库由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发Rust语言自是其中之一, 具有相关的绑定库: gtk-rs (gtk官方网页所指定)同时, 非常建议你使用Linux作为开发环境, 因为GTK专注于Linux版本  \n我也是 gtk-rs 的新手, 依靠发表博客来巩固所学顺便也能帮助和我一样的新鸟们 (老鸟别笑我啊喂!)  \n不定期更新, 毕竟我只有周末才能碰到电脑(碰到了我也不一定来写博客, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)\n\n参考资料资料正在持续更新ing. . .\n\n书籍\n\n\nGUI development with Rust and GTK 4\n\n\n博客/文档\n\n\nRust Vs GUI\nGObject Introspection\nGNOME Developer Doc/Tutorials\n\n\n环境配置首先, 你得参照 GTK官方页面 上的信息, 根据你的操作系统, 进行相应操作, 下载 GTK (版本是GTK4)  \n本人的环境为 ArchLinux(WSL), 选择它是因为不需要过多的操心配置方面比如gtk的安装, ArchLinux可以直接一行命令解决:  \nsudo pacman -S gtk4\n\n其他系统, 请自己找下资料, 善用搜索引擎与官方文档(gtk的安装其实还是有点让人头大的)  \n本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进  \n\n欢迎骚扰\n发现错误的话, 请及时跟我联系  \n可以通过博客侧边栏上的联系方式找到我  \n欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","categories":["rust-gtk4"],"tags":["rust","gui"]},{"title":"rs-gtk4-p2-创建HelloWorld窗口","url":"/posts/rs-gtk4-p2.html","content":"\n让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧\n\n\n背景介绍GTK是什么GTK, 是个很有名的, 用C编写的开源GUI库, 跨平台, 对Linux的支持最好   \nGTK的特点之一, 在于能够轻松创建语言绑定:在gtk3后, 由于GI(GObject Introspection) 的应用, 可以轻松地, 创建其他语言的绑定基本上名气稍微大点的语言, 都有对应的GTK绑定  \n这是GTK的重要特性, 使你可以利用不同语言编写GUI比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言而不是用C去编写(用C会很繁杂, 不清晰)  \n本文发布时, 其最新大版本是gtk4  \ngtk-rs目前有个项目, 叫做 gtk-rs, 负责GTK的Rust语言绑定你在 crates.io 上搜索 gtk, 所看到的 gtk 与 gtk4, 就属于gtk-rs项目\n前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍gtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)  \n对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本不然crate会装不上  \n\n项目配置首先, 你需要创建一个新项目, 并修改 Cargo.toml, 如下:  \n[dependencies]gtk = &#123;version = &quot;0.3.1&quot;, package = &quot;gtk4&quot;&#125;\n\n我们从 crates.io 上下载gtk4这个crate, 并且重命名为gtk, 方便之后编写因此, 之后代码中出现的gtk, 实际上指的是gtk4  \n随后, run一下, 安装依赖 (请确保安装了gtk4)那么下面就是正式的编码环节了\n\n编写代码我们要创建一个GTK4的程序, 因此需要用到 gtk::Application同时, 我们还需要 use gtk::prelude::*, 原因与 std::prelude 或 std::io::prelude 一样代码如下, 创建了一个啥也没有的GTK程序:  \n// src/main.rsuse gtk::prelude::*;use gtk::Application;fn main() &#123;    let app = Application::builder()        .application_id(&quot;io.github.jedsek.myapp&quot;)        .build();    app.run();&#125;\n别急着运行! 先搞懂这段代码中的两个地方  \n\nBuilder Pattern:这个不需多言, 我们可以通过该设计模式进行链式构造, 清楚直观地表达构造的过程在这里, 我们只调用了一次关联函数 -&gt; application_id(id: &amp;str)比如 std::fs::OpenOptions 就使用了构造者模式在使用gtk绑定时, 我们会较高频次地用到该模式, 将一个多参数构造函数, 分解为链式单参构造\n\napplication_id:每个GTK应用, 都有一个应用标识符, 即 application_id, 必须是全世界唯一的如果同时运行的应用们, 其id相同, 则会发生不期望的结果, 因此一般使用反序域名作为应用的id示例: “org.gnome.gedit”, “io.github.jedsek.myapp”  \n\n\n然后再run一下试试吧(阴笑), 如下:  \ncargo run\n\n","categories":["rust-gtk4"],"tags":["rust","gui"]}]