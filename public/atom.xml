<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jedsek&#39;s blog</title>
  
  <subtitle>与其浊富 | 宁比清贫</subtitle>
  <link href="https://jedsek.xyz/atom.xml" rel="self"/>
  
  <link href="https://jedsek.xyz/"/>
  <updated>2022-07-20T03:22:42.000Z</updated>
  <id>https://jedsek.xyz/</id>
  
  <author>
    <name>Jedsek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNOME 入坑指南</title>
    <link href="https://jedsek.xyz/posts/GNOME"/>
    <id>https://jedsek.xyz/posts/GNOME</id>
    <published>2022-07-20T03:22:42.000Z</published>
    <updated>2022-07-20T03:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p></blockquote><span id="more"></span><div class="tips"><p><strong>提示</strong><br>本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式/炫酷效果/更多功能的, 请自行配置<br>请注意GNOME版本是否相符, 有少许地方或因版本差异而不同<br>该篇文章的GNOME 版本为: <strong>42</strong></p></div><h1 id="cheng-pin-zhan-shi">成品展示</h1><p>2022年了, 有些人的 GNOME, 还像是十年前的感觉…<br>以下是成品展示, 我个人认为简洁+美观比较重要, 当然, 炫酷的效果也完全可以达到, 但我不喜欢, 自己动手吧!</p><details open><summary><span class="pre-summary">&nbsp;</span><strong>点击隐藏/展开图像</strong></summary><p><img data-src="/images/GNOME/overview.png" alt="按下Super后的概览"><br><img data-src="/images/GNOME/workspaces-indicator.png" alt="用键盘跳转工作区后的指示"></p></details><hr><h1 id="dconf-amp-amp-gsettings">dconf &amp;&amp; gsettings</h1><ul class="lvl-0"><li class="lvl-2"><p><code>dconf</code>:<br>是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p></li><li class="lvl-2"><p><code>gsettings</code>:<br>是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p></li></ul><p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p><p>接下来的大部分配置, 都会使用 <code>gsettings</code></p><hr><h1 id="hong-mo-ban">触摸板</h1><p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p><p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p><p>你可以在终端输入如下命令进行调整:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class="literal">true</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>分别对应:</p><ul class="lvl-0"><li class="lvl-2"><p><code>轻击模拟鼠标点击</code>, 默认为false</p></li><li class="lvl-2"><p><code>调整触摸板速度</code>, 默认为0</p></li><li class="lvl-2"><p><code>打字时禁用触摸板</code>, 默认为true</p></li></ul><hr><h1 id="cha-jian-kuo-zhan">插件/扩展</h1><hr><h1 id="mei-hua">美化</h1><hr><h1 id="zi-ding-yi-kuai-jie-jian">自定义快捷键</h1><hr><h1 id="wen-jian-guan-li-qi">文件管理器</h1><hr><h1 id="jia-zai-pei-zhi">加载配置</h1><p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p><h2 id="dui-yu-fei-nixos" id="对于非Nixos">对于非Nixos</h2><p>对于普通的Linux发行版, 直接按下面的方式</p><ul class="lvl-0"><li class="lvl-2"><p>导出当前的dconf数据到某个文件:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>加载/导入某个dconf文件到当前系统:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure><p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p><h2 id="dui-yu-nixos" id="对于Nixos">对于Nixos</h2><p>如果你使用 Nixos, 请先确保已经安装了 <a href="https://github.com/nix-community/home-manager">HomeManager</a><br>HomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p><p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br><span class="line">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure><p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nixpkgs/</span><br><span class="line">├── gnome</span><br><span class="line">│   ├── .background</span><br><span class="line">│   ├── .face</span><br><span class="line">│   └── dconf.nix</span><br><span class="line">└── home.nix</span><br></pre></td></tr></table></figure><p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imports = [</span><br><span class="line">  ./gnome/dconf.nix</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p><ul class="lvl-0"><li class="lvl-2"><p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class="line"><span class="keyword">let</span> <span class="attr">picture</span> = ../.background.png; <span class="keyword">in</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">picture-uri</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">  <span class="attr">picture-uri-dark</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">home.file.<span class="string">&quot;.face&quot;</span>.<span class="attr">source</span> = ./.face;</span><br></pre></td></tr></table></figure><p>大功告成!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="GNOME" scheme="https://jedsek.xyz/tags/GNOME/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p5: 类型与类型类</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p5"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p5</id>
    <published>2022-07-18T08:24:44.000Z</published>
    <updated>2022-07-18T08:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="kai-pian">开篇</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Haskell 中的类型(Type), 与类型类(Typeclass)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p4: 基础语法</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p4"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p4</id>
    <published>2022-07-12T13:46:05.000Z</published>
    <updated>2022-07-12T13:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Haskell 的数字, Bool, List, If语句</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p><h1 id="shu-zi">数字</h1><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span> + <span class="number">8</span>) * <span class="number">9</span> - <span class="number">10</span>   <span class="comment">-- 80</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>              <span class="comment">-- 2.5</span></span><br><span class="line"><span class="number">5</span> ^ <span class="number">2</span>              <span class="comment">-- 25</span></span><br><span class="line"><span class="number">5</span> ^  (<span class="number">2.0</span>)         <span class="comment">-- error</span></span><br><span class="line"><span class="number">5</span> ** (<span class="number">2.0</span>)         <span class="comment">-- 25.0 </span></span><br></pre></td></tr></table></figure><p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>以上的运算符号, 实际上都是函数</p><p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p><code>=&gt;</code> 后面的表示参数与返回值的类型<br><code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p><p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>以上的东西, 实际上类似于:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="params">(+)</span>&lt;<span class="title">a</span>: <span class="title">Num</span>&gt; <span class="params">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure><p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>Num 这个类型类了, 便起到一个约束的作用</p><p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p><hr><h1 id="bool">Bool</h1><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">True</span> &amp;&amp; <span class="type">False</span>      <span class="comment">-- False</span></span><br><span class="line"><span class="type">True</span> || <span class="type">False</span>      <span class="comment">-- True</span></span><br><span class="line"><span class="title">not</span> <span class="type">True</span>           <span class="comment">-- False</span></span><br></pre></td></tr></table></figure><p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">0</span>             <span class="comment">-- False</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> == <span class="number">1</span> + <span class="number">4</span>     <span class="comment">-- True</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span> /= <span class="string">&quot;AB&quot;</span>      <span class="comment">-- True</span></span><br></pre></td></tr></table></figure><p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>可以键入 <code>:t (==)</code> 查看其类型:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>表示接受的两个参数, 其类型相同, 都是a<br>并且a类型必须具有相等性, 返回值是Bool类型</p><p>注意:<br>由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>原因与先前的加法函数同理</p><p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>甚至连 If语句, 我们都可以自己写个函数来代替</p><p>If语句在 Haskell 中仅仅是个语法糖而已<br>在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>感兴趣的话, 可以自己去看下: <a href="https://wiki.haskell.org/If-then-else">传送门</a></p><hr><h1 id="list">List</h1><p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>就像是其他语言的数组一样, 但却更加强大</p><h2 id="sheng-lue-you-duan" id="省略右端">省略右端</h2><p>像下面, 就创建了一个有十个元素的List:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>a 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p><p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>你可以查看它的类型:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure><p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>比如:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]      <span class="comment">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p><p>回到刚才, 你可以一个个地输入元素, 创建List<br>不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.100</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.1000</span>]</span><br></pre></td></tr></table></figure><p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p><p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p><p>值得注意的是, 忽略右端点时, 生成的List可能会无穷大, 也可能遇到有界, 我们先假设元素的类型为a<br>当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p><p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p><p>事实上, 这是 Haskell 中为数不多的隐式行为<br>任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p><p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">a</span> = <span class="number">100</span>::<span class="type">Integer</span>      <span class="comment">-- 100</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>                 <span class="comment">-- 101</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>::<span class="type">Int</span>            <span class="comment">-- error</span></span><br></pre></td></tr></table></figure><p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>根据 <a href="#shu-zi">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p><p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p><h2 id="she-zhi-bu-chang" id="设置步长">设置步长</h2><p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>同时, 取决于元素的类型, 会产生无限或有界的List</p><p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>如果你想调整步长的话, 可以像下面这样:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3.</span>.]          <span class="comment">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">10.</span>.]         <span class="comment">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure><p>你还可以设置小数的步长, 比如:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>..]     <span class="comment">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure><p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p><h2 id="lie-biao-tui-dao" id="列表推导">列表推导</h2><p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x | x &lt;- [<span class="number">1.</span>.], mod x <span class="number">2</span> == <span class="number">0</span>]  <span class="comment">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure><p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p><p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p></li><li class="lvl-2"><p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p></li><li class="lvl-2"><p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p></li></ul><p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x + y | x &lt;- [<span class="number">1.</span><span class="number">.3</span>], y &lt;- [<span class="number">1.</span><span class="number">.3</span>]]                   <span class="comment">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class="line">[x | x &lt;- [<span class="number">1.</span><span class="number">.100</span>], x `mod` <span class="number">2</span> == <span class="number">0</span>, x `mod` <span class="number">3</span> == <span class="number">0</span>]  <span class="comment">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure><p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p><ul class="lvl-0"><li class="lvl-2"><p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">100</span>]</span><br><span class="line">  <span class="keyword">if</span> x `<span class="keyword">mod</span>` <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x `<span class="keyword">mod</span>` <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure><p>因此, 你可以对比下下面两种式子:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x * y | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], y &lt;- [<span class="number">1.</span>.x]  ]</span><br><span class="line">[ x * y | x &lt;- [<span class="number">1.</span>.y],  y &lt;- [<span class="number">1.</span><span class="number">.10</span>] ]</span><br></pre></td></tr></table></figure><p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p><p>好了, 关于List, 暂时先到这吧<br>其实后面还有很多关于List的, 毕竟它太重要了</p><hr><h1 id="if-yu-ju">If语句</h1><p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p><p>毕竟 Haskell 比较特殊, 为了函数的 <a href="/posts/haskell-basic/p3/#chun-han-shu">纯度</a> , 特意搞了一堆东西<br>再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p><p>开始吧!</p><h2 id="dan-if" id="单if">单if</h2><p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p><p>BMI, Body Mass Index (身体质量指数)<br>它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p><p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p><div class="tips"><p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p><ol><li class="lvl-3">在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</li><li class="lvl-3">输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></li></ol></div><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>  bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p><p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">    <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>也蛮美观的, 但我更喜欢压行 😃</p><h2 id="duo-if" id="多If">多If</h2><p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p><p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &gt; <span class="number">25</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt;= <span class="number">18.5</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Healthy!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>哇, 看着好美, 好熟悉!<br>所以你为什么说没有多重If呢?</p><p>别急, 格式化之后:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">        <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt; <span class="number">18.5</span></span><br><span class="line">            <span class="keyword">then</span> putStrLn <span class="string">&quot;12&quot;</span></span><br><span class="line">            <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p><p>这节就到这, 看辉夜3的最后一集去了~~</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Haskell 的数字, Bool, List, If语句&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p3: 函数式介绍</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p3"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p3</id>
    <published>2022-06-26T08:16:10.000Z</published>
    <updated>2022-06-26T08:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>何为函数式编程(FP, 即Functional Programming) ?</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>那么, 开始吧!</p><h1 id="bian-cheng-fan-shi">编程范式</h1><h2 id="gai-lan" id="概览">概览</h2><p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p><p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>在世界上, 有许多编程范式, 最主要的有:</p><table><thead><tr><th>简称</th><th>中文名</th><th>英文名</th></tr></thead><tbody><tr><td>FP</td><td>函数式编程</td><td>Functional Programming</td></tr><tr><td>OOP</td><td>面向对象编程</td><td>Object-Oriented Programming</td></tr><tr><td>POP</td><td>面向过程编程</td><td>Procedure-Oriented Programming</td></tr><tr><td>LP</td><td>逻辑式编程</td><td>Logic Programming</td></tr><tr><td>DP</td><td>声明式编程</td><td>Declarative Programming</td></tr><tr><td>IP</td><td>命令式编程</td><td>Imperative Programming</td></tr></tbody></table><p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p><p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>下面是一些编程范式的例子:</p><div class="tips"><p><strong>提示</strong><br>如果你已经了解过以下范式, 直接跳到 <a href="#zong-jie"><strong>总结</strong></a> 吧</p></div><ul class="lvl-0"><li class="lvl-2"><p>面向过程:<br>优点:<br>解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>缺点:<br>代码复用能力差, 扩展性差, 繁琐</p></li><li class="lvl-2"><p>面向对象:<br>优点:<br>将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>缺点:<br>不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p></li><li class="lvl-2"><p>逻辑式:<br>优点:<br>通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>缺点:<br>玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p></li><li class="lvl-2"><p>函数式:<br>优点:<br>通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>缺点:<br>学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p></li><li class="lvl-2"><p>命令式:<br>有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p></li><li class="lvl-2"><p>声明式:<br>指你编程依靠描述, 而非面向过程地去思考<br>这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>特点是一旦脱离相关领域, 语法就不再便利</p></li></ul><h2 id="zong-jie" id="总结">总结</h2><p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p><p>比如:</p><ul class="lvl-0"><li class="lvl-2"><p>面向过程/面向对象 &amp;&amp; 命令式</p></li><li class="lvl-2"><p>函数式/逻辑式 &amp;&amp; 声明式</p></li><li class="lvl-2"><p>混合一种, 两种, 甚至各种范式</p></li></ul><p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p><p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>接下来, 我们就要专注于本节的主角, 函数式</p><p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>让我们开始对函数式的正式介绍吧!</p><hr><h1 id="gao-jie-han-shu">高阶函数</h1><p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p><p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br><s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p><p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p><hr><h1 id="bu-ke-bian-shu-ju">不可变数据</h1><p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p><p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p><p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p><p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>但不可变的数据能够有效降低并发的难度</p><p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p><hr><h1 id="fu-zuo-yong">副作用</h1><p>副作用(Side Effects), 指与外界发生的交互</p><p>假设有这么一个函数:<br>它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p><p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p><p>副作用包括, 但不限于:</p><ul class="lvl-0"><li class="lvl-2"><p>发送网络请求</p></li><li class="lvl-2"><p>访问系统状态</p></li><li class="lvl-2"><p>操作数据库</p></li><li class="lvl-2"><p>操作DOM</p></li><li class="lvl-2"><p>IO操作</p></li><li class="lvl-2"><p>修改函数外部的变量</p></li><li class="lvl-2"><p>使用具有副作用的函数 (传播性)</p></li></ul><p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>那么这将无法保证相同输入, 能得到相同输出</p><p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>绝对的没有副作用, 意味着这个程序绝对的没用</p><hr><h1 id="yin-yong-tou-ming">引用透明</h1><p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p><p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>以下是数学中的 RT, 简单来讲, 就是等式推导:</p><p>f(x) = (x+1)<sup>2</sup><br>f(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p><p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p><p>总而言之, 就是替换, 替换, 还是替换<br>即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p><p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>若有这么个函数:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">double_x</span>(x: <span class="type">Int</span>): <span class="type">Int</span> &#123;</span><br><span class="line">    println(x);</span><br><span class="line">    return x+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p><p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>这通常是一些 BUG 的来源</p><p>RT, 即引用透明, 注定与副作用互斥</p><hr><h1 id="chun-han-shu">纯函数</h1><p>纯函数(Pure Functions), 表示引用透明的函数</p><p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p><p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p><p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p><p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p><hr><h1 id="qi-ta">其他</h1><p>以上是对函数式的小小概括<br>还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p><p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p><ul class="lvl-0"><li class="lvl-2"><p>埃氏筛求素数:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">primes</span> = filterPrime [<span class="number">2.</span>.]</span><br><span class="line">  <span class="keyword">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>斐波那契数列:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fibs</span> = <span class="number">0</span> : <span class="number">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>快速排列:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">qsort</span> [] = []</span><br><span class="line"><span class="title">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class="line">  <span class="keyword">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>辗转相除法求最大公约数:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">gcd&#x27;</span> x y</span><br><span class="line">  | y == <span class="number">0</span> = x</span><br><span class="line">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure><p>感谢你的观看, 咋们下期见!!<br>先让我鸽几天 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;何为函数式编程(FP, 即Functional Programming) ?&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p2: 环境搭建</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p2"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p2</id>
    <published>2022-06-25T13:57:14.000Z</published>
    <updated>2022-06-25T13:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先, 我们得搭建好 Haskell 的环境</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="bian-yi-qi-amp-amp-bao-guan-li">编译器 &amp;&amp; 包管理</h1><p>本文假设你使用的是Linux系统</p><p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p><ul class="lvl-0"><li class="lvl-2"><p><code>ghc</code>: Haskell 的编译器</p></li><li class="lvl-2"><p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p></li><li class="lvl-2"><p><code>cabal</code>: Hsakell的包管理器</p></li></ul><p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal</code>, 仅此而已)</p><p>请确保都能正确显示版本:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ghc -V</span><br><span class="line">ghci -V</span><br><span class="line">cabal -V</span><br></pre></td></tr></table></figure><p>本系列暂时只会涉及到 Haskell 的语法部分， 所以 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p><hr><h1 id="dai-ma-bian-ji">代码编辑</h1><p>推荐的代码编辑器:</p><ul class="lvl-0"><li class="lvl-2"><p>Helix (强推)</p></li><li class="lvl-2"><p>Nvim/Vim</p></li><li class="lvl-2"><p>Vscode</p></li></ul><p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>如果你使用的是Vim/Helix, 要下载对应的LSP: <code>haskell-language-server</code></p><p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf copr <span class="built_in">enable</span> -y petersen/haskell-language-server</span><br><span class="line">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure><p>如果你使用的是 <a href="https://helix-editor.com/">Helix</a>, LSP将会直接启用</p><p>当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p><hr><h1 id="huan-yuan">换源</h1><p>Haskell的包都放在 <a href="https://hackage.haskell.org/">hackage</a>, 下载依赖时, 速度可能极慢<br>这时, 我们应该进行将其换成镜像源</p><p>若你使用cabal, 可以按照下面的做:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cabal user-config init</span><br><span class="line">sed -i <span class="string">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/hackage.haskell.org\//http:\/\/mirrors.ustc.edu.cn\/hackage\//g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class="line">cabal update</span><br></pre></td></tr></table></figure><p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p><p>至此, 环境准备工作已全部完成<br>下一节, 我们将正式开始学习 Haskell</p><hr><h1 id="geng-gai-ghci-ti-shi-fu">更改ghci提示符</h1><p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p><p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p><p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class="line">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure><p>第一行更改提示符<br>第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;首先, 我们得搭建好 Haskell 的环境&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p1"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p1</id>
    <published>2022-06-25T13:22:14.000Z</published>
    <updated>2022-06-25T13:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Haskell 的学习系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="xi-lie-shuo-ming">系列说明</h1><p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br><s>(毕竟是Haskell)</s></p><hr><h1 id="can-kao-zi-liao">参考资料</h1><ol><li class="lvl-3"><p>书籍</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good! (趣学指南)</a></p></li><li class="lvl-2"><p><a href="https://www.haskell.org/tutorial/">A Gentle Introduction to Haskell, Version 98</a></p></li></ul><ol start="2"><li class="lvl-3"><p>论坛</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://discourse.haskell.org/">Haskell Discourse</a></p></li></ul><ol start="3"><li class="lvl-3"><p>博客</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97">Lambda Calculus (Lambda演算)</a></p></li><li class="lvl-2"><p><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors In Pictures (图解函子)</a></p></li></ul><ol start="4"><li class="lvl-3"><p>Wiki</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://wiki.haskell.org/">Haskell Wiki</a></p></li></ul><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后,谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Haskell 的学习系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>rust-tui-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-tui/p1"/>
    <id>https://jedsek.xyz/posts/rust-tui/p1</id>
    <published>2022-06-19T04:59:50.000Z</published>
    <updated>2022-06-19T04:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Rust 的 TUI 系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-tui">rust-tui</a></p><h1 id="xi-lie-shuo-ming">系列说明</h1><p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>当然, 还会介绍Rust中的两个crate: <code>tui</code> &amp;&amp; <code>crossterm</code></p><hr><h1 id="can-kao-zi-liao">参考资料</h1><ol><li class="lvl-3"><p>博客:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/">Playing with tui-rs</a></p></li><li class="lvl-2"><p><a href="https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/">Building a command-line interface in Rust</a></p></li></ul><ol start="2"><li class="lvl-3"><p>文档:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://docs.rs/tui/latest/tui/">tui-rs</a></p></li><li class="lvl-2"><p><a href="https://docs.rs/crossterm/latest/crossterm/">crossterm</a></p></li></ul><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话, 请及时跟我联系<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后, 谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Rust 的 TUI 系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="TUI" scheme="https://jedsek.xyz/tags/TUI/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p3: GObject-内存管理</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p3"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p3</id>
    <published>2022-01-30T04:01:22.000Z</published>
    <updated>2022-01-30T04:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来看看什么是Widget(部件), 由此出发, 去探讨内存管理(Memory Management)</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a></p><h1 id="widget">Widget</h1><p>任何Gtk应用, 都由许多组件组成, 而这些组件, 就叫Widget(部件)</p><p>Gtk提供了许多Widget, 比如我们上一节的 <code>ApplicationWindow</code> 就是一个Widget<br>比如, Button(按钮), Container(容器)都属于Widget</p><p><a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> 是Gtk提供的网站, 帮助我们选择Widget</p><p>你甚至可以定义自己的Widget, 通过继承 (因为Gtk是面向对象的框架)<br>比如 <code>Button</code>, 它的继承树如下:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">GObject</span><br><span class="line">└── Widget</span><br><span class="line">    └── <span class="selector-tag">Button</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来看看什么是Widget(部件), 由此出发, 去探讨内存管理(Memory Management)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p2: 创建窗口</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p2"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p2</id>
    <published>2021-11-07T02:16:57.000Z</published>
    <updated>2021-11-07T02:16:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>让我们创建一个GTK窗口, 开始旅途吧</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a></p><h1 id="bei-jing">背景</h1><h2 id="gtk-shi-shi-yao" id="GTK是什么">GTK是什么</h2><p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写</p><p>其特点之一, 是能轻松地创建绑定:<br>在gtk3后, 由于GI(<a href="https://gi.readthedocs.io/en/latest/">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定</p><p>这使你能利用不同语言编写GUI<br>比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言<br>而不是用C去编写(用C会很繁杂, 不清晰)</p><p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p><h2 id="gtk-rs" id="gtk-rs">gtk-rs</h2><p>目前有个项目, 叫做 <a href="https://gtk-rs.org/">gtk-rs</a>, 负责GTK的Rust语言绑定<br>你在 <a href="http://crates.io">crates.io</a> 上搜索 gtk, 所看到的 <a href="https://crates.io/crates/gtk">gtk</a> 与 <a href="https://crates.io/crates/gtk4">gtk4</a>, 就属于gtk-rs项目</p><p>前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍<br>gtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)</p><p>对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)<br>所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本<br>不然crate会装不上</p><hr><h1 id="pei-zhi">配置</h1><p>首先, 你需要创建一个新项目<br>随后修改 Cargo.toml, 如下:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">gtk</span> = &#123;version = <span class="string">&quot;0.3.1&quot;</span>, package = <span class="string">&quot;gtk4&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写 (这是个惯例)<br>随后, 请run一下, 安装依赖 (请确保安装了gtk4)</p><p>下面就是正式的编码环节了</p><hr><h1 id="bian-xie">编写</h1><p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>同时, 我们还需 <code>use gtk::prelude::*</code><br>原因与 <a href="https://doc.rust-lang.org/std/prelude/index.html">std::prelude</a> 或 std::io::prelude 一样</p><p>先创建一个应用, 它目前连窗口也没有:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder()</span><br><span class="line">        .application_id(<span class="string">&quot;io.gitee.jedsek.myapp&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧? 但别急着运行, 先看看下面两处:</p><ul class="lvl-0"><li class="lvl-2"><p><a href="http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>这个无需多言, 我们可以利用它, 进行链式构造, 让构造的过程更加清晰<br>在这里, 我们只调用了一次链式函数: application_id(id: &amp;str)<br>比如 <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html">std::fs::OpenOptions</a> 就使用了构造者模式<br>在学习gtk4时, 它将被较高频次地使用, 最后调用的 build 会生成对应的struct</p></li><li class="lvl-2"><p><a href="https://developer.gnome.org/documentation/tutorials/application-id.html">application_id</a>:<br>每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的<br>一般使用反域名, 作为id, 比如 “org.gnome.gedit”<br>app_id作为App的唯一标识符, 用于App之间的通信与识别<br>更改一个大型App的app_id会导致很多麻烦, 因此要慎重考虑!</p></li></ul><p>当你跃跃欲试, cargo run之后, 会看到:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">GLib-GIO-<span class="builtin-name">WARNING</span> : Your application does <span class="keyword">not</span> implement g_application_activate()</span><br><span class="line"><span class="keyword">and</span> has <span class="literal">no</span> handlers connected <span class="keyword">to</span> the <span class="string">&#x27;activate&#x27;</span> signal.  </span><br><span class="line">It should <span class="keyword">do</span> one of these.</span><br></pre></td></tr></table></figure><p>我们实际上还要添加一个名为 activate 的信号量(Signal)<br>你得像下面这样写:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder()</span><br><span class="line">        .application_id(<span class="string">&quot;io.gitee.jedsek.demo&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 还无法执行, 因为我想逐步地讲解一下<br>请容许我对上面的东西来点小小的解释</p><p>Gtk应用的理念是: App只关心在特定的时候需要做什么事<br>什么时候做 ? Gtk已经帮我们安排好了<br>至于 <code>事情的内容</code>, 则交由开发者自己决定</p><p>接口方面, Gtk已经帮我们分类好一些虚函数, 它们也被称为 <code>信号(Signal)</code><br>我们只需要实现这些虚函数即可<br>(顾名思义, 虚函数是还不真正的函数, 你可以理解为它们的函数体是空的)<br>(不过库的作者已经帮我们安排好了它们的调用顺序, 等待我们实现函数体而已)</p><p>下面是四个待响应的信号, 也就是待实现的虚函数:</p><ul class="lvl-0"><li class="lvl-2"><p>startup:<br>在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p></li><li class="lvl-2"><p>shutdown:<br>在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p></li><li class="lvl-2"><p>activate:<br>GtkApp总得有至少一个窗口, 该函数决定第一个窗口如何显示</p></li><li class="lvl-2"><p>open<br>当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p></li></ul><p>注:<br>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>当单实例App试图打开第二个窗口, Gtk全局系统会发送Signal(activate/open)给第一个窗口</p><p>注:<br>所有的初始化工作都应在startup中完成<br>哪怕是第二个窗口相关的初始化</p><p>这些只是Gtk给我们的虚函数中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App</p><p>回到之前的代码, 如下:<br>(我粘贴了一份上面的代码, 方便你看)</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder()</span><br><span class="line">        .application_id(<span class="string">&quot;io.gitee.jedsek.demo&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Your <span class="built_in">application</span> <span class="keyword">does</span> <span class="keyword">not</span> implement g_application_activate()</span><br><span class="line"><span class="keyword">and</span> has no handlers connected <span class="keyword">to</span> <span class="keyword">the</span> &#x27;<span class="built_in">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure><p>我们得创建一个函数, 并将其作为参数, 传给 <code>connect_activate</code><br>现在你应该明白, 为什么之前会报出一个警告, 要求连接activate这个信号了吧?<br>(<code>connect_xxxx</code> 相关的方法, 代表着连接信号/实现虚函数)</p><p>我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除这个警告, 真正显示窗口<br>毕竟如果一个GUI应用没有任何显示, 这. . .啧, 不太聪明的感觉?</p><p>直接上 <code>build_ui</code> 的代码(注意use一下):</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder()</span><br><span class="line">        .application_id(<span class="string">&quot;io.gitee.jedsek.demo&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> window = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    window.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咋们用builder模式指定了窗口对应的App是谁, 窗口标题是啥, 并显示它<br>如果你处于GNOME-DE, 并启用了暗主题/调色盘, 将会看见一个暗色窗口</p><p>在App启动之后的某一时刻, <code>activate</code> 信号对应的虚函数被调用<br>不过我们已经将它覆盖成自己的 <code>build_ui</code> 了</p><p>你会发现, 写代码的事情其实并不多, 重点在于理解背后的原理</p><p>至此, 本小节结束~<br>又要愉快地鸽鸽鸽了呢 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;让我们创建一个GTK窗口, 开始旅途吧&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p1"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p1</id>
    <published>2021-10-23T12:18:17.000Z</published>
    <updated>2021-10-23T12:18:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Rust 的 gkt-rs 系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a></p><h1 id="xi-lie-shuo-ming">系列说明</h1><p><a href="https://www.gtk.org/">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成<br>由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发</p><p>Rust语言自是其中之一, 具有相关的绑定库: <a href="https://gtk-rs.org/">gtk-rs</a> (gtk官方网页所指定)<br>同时, 非常建议你使用Linux作为开发环境</p><p>不定期更新, 毕竟我只有周末才能碰到电脑<br><s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p><hr><h1 id="can-kao-zi-liao">参考资料</h1><p>资料正在持续更新ing. . .</p><ol><li class="lvl-3"><p>书籍(官方圣经, 质量杠杆的)</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://gtk-rs.org/gtk4-rs/stable/latest/book/">GUI development with Rust and GTK 4</a></p></li></ul><ol start="2"><li class="lvl-3"><p>博客/文档</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html">Rust Vs GUI</a></p></li><li class="lvl-2"><p><a href="https://gi.readthedocs.io/en/latest/#gobject-introspection">GObject Introspection</a></p></li><li class="lvl-2"><p><a href="https://developer.gnome.org/documentation/tutorials.html">GNOME Developer Doc/Tutorials</a></p></li></ul><hr><h1 id="huan-jing-pei-zhi">环境配置</h1><p>首先请参照 <a href="https://www.gtk.org/docs/installations/">GTK官方页面</a> , 根据相应操作系统, 下载 GTK(版本是GTK4)</p><p>像Ubuntu系统, 听说2021版已经使用gnome作为桌面环境了(gnome用gtk写的)</p><p>windows系统建议使用wsl2(亲测可以做gui, 虽然目前还有警告 <s>但无视即可</s>)<br>比如wsl2是arch-linux时, 安装gtk4的开发包很方便:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gtk4-devel</span><br></pre></td></tr></table></figure><p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p><p>本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进</p><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后, 谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Rust 的 gkt-rs 系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>rust-dm-p5: 卫生性</title>
    <link href="https://jedsek.xyz/posts/rust-decl-macro/p5"/>
    <id>https://jedsek.xyz/posts/rust-decl-macro/p5</id>
    <published>2021-10-16T06:04:12.000Z</published>
    <updated>2021-10-16T06:04:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将介绍宏的 卫生性(hygienic)</p></blockquote><span id="more"></span><p>同系列传送门:</p><ul class="lvl-0"><li class="lvl-2"><p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p></li><li class="lvl-2"><p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p></li></ul><h1 id="kai-pian">开篇</h1><p>什么是 卫生性(Hygienic) 呢?<br>简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>如果你是第一次接触此概念, 我不信你不会懵逼<br>不过实际上, 这个概念理解起来不算困难</p><p>让我们先来讨论一个问题, 请看下面的代码:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> create_var &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    create_var!();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将介绍宏的 卫生性(hygienic)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Macro" scheme="https://jedsek.xyz/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>rust-dm-p4: 重复</title>
    <link href="https://jedsek.xyz/posts/rust-decl-macro/p4"/>
    <id>https://jedsek.xyz/posts/rust-decl-macro/p4</id>
    <published>2021-10-09T14:36:00.000Z</published>
    <updated>2021-10-09T14:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>宏中非常重要的语法: 重复(repetition)</p></blockquote><span id="more"></span><p>同系列传送门:</p><ul class="lvl-0"><li class="lvl-2"><p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p></li><li class="lvl-2"><p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p></li></ul><h1 id="jie-shao">介绍</h1><p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p><p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p><ul class="lvl-0"><li class="lvl-2"><p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p></li><li class="lvl-2"><p>Transcriber: 将一段指定的模式, 重复地展开</p></li></ul><p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p><p>假设你要设计一个宏, 进行求和(参数个数不确定):</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="built_in">assert_eq!</span>( <span class="number">0</span>,  sum!() );</span><br><span class="line"><span class="built_in">assert_eq!</span>( <span class="number">15</span>, sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) );</span><br></pre></td></tr></table></figure><p>让我们来看看, 如何使用重复吧</p><h1 id="yu-fa">语法</h1><p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($($a:expr),*) =&gt; &#123;</span><br><span class="line">        <span class="number">0</span> $(+ $a)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    sum!();          <span class="comment">// 0</span></span><br><span class="line">    sum!(<span class="number">5</span>);         <span class="comment">// 5</span></span><br><span class="line">    sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码表示:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$( Pattern )   Sep    RepOp</span><br><span class="line">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure><p>它可以被分为三个部分:</p><ul class="lvl-0"><li class="lvl-2"><p>模式(Pattern):<br>被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p></li><li class="lvl-2"><p>分隔符(Separator):<br>用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p></li><li class="lvl-2"><p>重复符号(Repetition Operator):<br>对模式匹配次数, 进行说明限制, 不符合就编译报错</p></li></ul><p>以 <code>sum!</code> 为例子<br>它在第二个rule中用到了重复:</p><ul class="lvl-0"><li class="lvl-2"><p>In Matcher:<br>模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p></li><li class="lvl-2"><p>In Transcriber:<br>模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>次数: 同 Matcher</p></li></ul><p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p><p>RepOp 有三种可选项, 有点像正则:</p><ul class="lvl-0"><li class="lvl-2"><p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>记忆法-&gt; 该符号看上去像是一个点, 联想为0</p></li><li class="lvl-2"><p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>记忆法-&gt; 联想为正数, 那就&gt;=1</p></li><li class="lvl-2"><p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p></li></ul><p>有一些注意点:</p><ol><li class="lvl-3"><p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p></li><li class="lvl-3"><p>Sep 是有限制的, <a href="/posts/rust-decl-macro/p3#qi-yi-xian-zhi">p3#歧义限制</a> 提到过, 详情可见 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">rust-reference</a></p></li></ol><p>以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;宏中非常重要的语法: 重复(repetition)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Macro" scheme="https://jedsek.xyz/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>rust-dm-p3: 声明与使用</title>
    <link href="https://jedsek.xyz/posts/rust-decl-macro/p3"/>
    <id>https://jedsek.xyz/posts/rust-decl-macro/p3</id>
    <published>2021-09-20T12:06:15.000Z</published>
    <updated>2021-09-20T12:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正式系统的关于 macro 的 声明与使用</p></blockquote><span id="more"></span>  <p>同系列传送门:</p><ul class="lvl-0"><li class="lvl-2"><p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p></li><li class="lvl-2"><p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p></li></ul><h1 id="kuang-jia-jian-li">框架建立</h1><p>前一节,我们大概清楚了macro的结构<br>现在让我们再来简单复习一遍:</p><ol><li class="lvl-3"><p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p></li><li class="lvl-3"><p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p></li><li class="lvl-3"><p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p></li></ol><p>现在稍微深入一点:<br>一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber)<br>它由三个重要的部分组成:</p><ul class="lvl-0"><li class="lvl-2"><p><code>matcher (匹配器)</code>:<br>用来匹配传入的参数</p></li><li class="lvl-2"><p><code>metavariable/literal (元变量/字面量)</code>:<br>绑定传入的代码片段,出现于 <code>matcher</code></p></li><li class="lvl-2"><p><code>transcriber (转录器)</code>:<br>用来在宏匹配成功后,进行代码替换</p></li></ul><p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    (<span class="comment">/* 空参匹配 */</span>) =&gt; (<span class="comment">/* `换行` 的代码 */</span>);</span><br><span class="line">    (<span class="comment">/* 有参匹配 */</span>) =&gt; (<span class="comment">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code><br>从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配<br>匹配时, 括号具有多样性, 请看下面</p><ol><li class="lvl-3"><p>匹配规则:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>匹配到: 就替换为<code>transcriber</code>里面的代码</p></li><li class="lvl-2"><p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p></li></ul><ol start="2"><li class="lvl-3"><p>括号多样性:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p></li><li class="lvl-2"><p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p></li><li class="lvl-2"><p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p></li></ul><p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p><p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p><hr><h1 id="liang-chong-hong-can-shu">两种宏参数</h1><p>是时候引入一些新的东西了, 顺便加深下你的印象</p><h2 id="yuan-bian-liang" id="元变量">元变量</h2><p>元变量, 即Metavariable<br>让我们来看个例子:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class="line">        $a + $b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    my_macro!(<span class="number">1</span>);</span><br><span class="line">    my_macro!(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    1;</span></span><br><span class="line"><span class="comment">    1 + 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p><ol><li class="lvl-3"><p><code>$</code> 这个前缀是干嘛的?<br>这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗?<br>下面就要讲到啦, 别着急~</p></li><li class="lvl-3"><p>先看看 <code>expr</code> 类型:<br><code>expr</code>, 全称为 <code>expression(表达式)</code><br>第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)</p></li></ol><p>简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>macro就像个code generator: 一段用来生成code的code</p><p>注意:<br>macro实际上, 是将传入部分解析为一个AST节点<br>然后将调用部分, 替换为一个新的AST节点<br>在本节下面, 会更详细地讲讲</p><h2 id="yuan-zi-mian-liang" id="元字面量">元字面量</h2><p>元字面量, 即Metaliteral<br>为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">($a: expr) =&gt; &#123;$a&#125;;                     <span class="comment">// the first rule</span></span><br><span class="line">  |             |  </span><br><span class="line">  |         |</span><br><span class="line">( <span class="number">1</span>      )      <span class="number">1</span>                       <span class="comment">// pass &amp;&amp; expand </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class="comment">// the second rule</span></span><br><span class="line">  |      |  |              |    |</span><br><span class="line">  |      |  |              |    |</span><br><span class="line">( <span class="number">1</span>      ,  <span class="number">2</span>      ) =&gt;    <span class="number">1</span> +  <span class="number">2</span>      <span class="comment">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure><p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p><p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>这种固定的参数, 如同token中的字面量一样<br>我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p><p>假若 rule 中的参数没有 $前缀 进行区分:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> fuck &#123;</span><br><span class="line">    (a:expr) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    fuck!(<span class="number">1</span>);       <span class="comment">// No</span></span><br><span class="line">    fuck!(a:expr);  <span class="comment">// Yes ~~(Oh~)~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>)<br>传入固定形式的 “a:expr” 时才可发生匹配</p><p>切记:<br>当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰</p><h2 id="li-zi" id="例子">例子</h2><p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>如下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map![</span><br><span class="line">        <span class="string">&quot;吉良吉影&quot;</span> =&gt; <span class="number">33</span>,</span><br><span class="line">        <span class="string">&quot;空条承太郎&quot;</span> =&gt; <span class="number">41</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写一个这样的宏吧!<br>不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>来看看两种宏参数在宏中, 发挥着怎样的作用:</p><ul class="lvl-0"><li class="lvl-2"><p><code>Metavariable</code>: 将捕获的传入的代码片段绑定到自身<br>并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p></li><li class="lvl-2"><p><code>Metaliteral </code>: 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>(这里只有一个rule, 空匹配的懒得放里面了)</p></li></ul><p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>(博客的话, 我周六放学回来慢慢更吧…)<br><s>(潜台词是随时会鸽子)</s></p><hr><h1 id="ben-zhi">本质</h1><p>macro的本质, 是生成一个AST节点可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p><p>假若由你来设计一个Rust编译器<br>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?</p><p>若我们将每遍扫描并做点事情的过程, 称为<code>pass</code><br>pass一次就生成了, 对于很大的源码来说, 这不现实吧</p><p>那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题<br>每一次pass都解决一个小问题, 那不就Ok了吗</p><p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p><p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)<br>那是一种代码被抽象后的树状结构<br>比如我们用Rust的enum表示一下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASTNode</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>), </span><br><span class="line">    BinaryExpr &#123;</span><br><span class="line">        op: Op,</span><br><span class="line">        lhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">        rhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Op</span></span> &#123;</span><br><span class="line">    Plus, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你只需明白AST是对源码封装的一层抽象产物就可以了</p><p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小<br>但是, 如果源码很大呢? AST已经很复杂了那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p><p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的<br>注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛</p><p><code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架<br>而另外的IR, 也是有必要的, 这也增强了可维护性<br>编译器在AST的基础上, 最终生成了目标码</p><p>问: 生成AST需要点啥? 或者说, 它由什么组成?<br>答: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p><p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>它将token们联系起来, 表达了代码的骨架<br>这个庞然大物便是 AST 了</p><hr><h1 id="hui-dao-macro">回到Macro</h1><h2 id="token-lei-xing-biao" id="Token类型表">Token类型表</h2><p>生成AST需要Token协助<br>macro 中, 其参数的类型, 便是token类型</p><p>macro要操控传入的token (或AST节点, 等会讲)<br>那么我们总得知道token类型吧, 不然怎知咋操控?</p><p>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p><p>所以, 辛苦你将下面的记一下<br>稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p><table><thead><tr><th>名称</th><th>对应</th></tr></thead><tbody><tr><td>ident</td><td>标识符, 如函数名, 变量名, 关键字</td></tr><tr><td>expr</td><td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td></tr><tr><td>literal</td><td>literal expression, 即字面量表达式, 是expr的子集</td></tr><tr><td>pat</td><td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td></tr><tr><td>path</td><td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td></tr><tr><td>ty</td><td>type, 如 i32, u32, String, Option<T>等</td></tr><tr><td>tt</td><td>token tree, 之后我会单独再讲解下它的</td></tr><tr><td>meta</td><td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td></tr><tr><td>vis</td><td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td></tr><tr><td>lifetime</td><td>生命周期</td></tr><tr><td>item</td><td>条目/项, 例如函数定义</td></tr><tr><td>block</td><td>代码块</td></tr><tr><td>stmt</td><td>statemen, 语句</td></tr></tbody></table><h2 id="tt" id="TT">TT</h2><p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p><p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>作为 Token Tree 的根节点, 先让我们来点例子:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a:tt) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>($a));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Single Token</span></span><br><span class="line">    aa!(<span class="number">123</span>);          <span class="comment">// Yes: 123</span></span><br><span class="line">    aa!(FuckYou);      <span class="comment">// Yes: FuckYou</span></span><br><span class="line">    <span class="comment">// aa!(Fuck You);     // No</span></span><br><span class="line">    <span class="comment">// aa!(123 + 11);     // No</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (), [], &#123;&#125;</span></span><br><span class="line">    aa!([<span class="number">123</span>]);        <span class="comment">// Yes: [123]</span></span><br><span class="line">    aa!(&#123;<span class="number">123</span> + <span class="number">123</span>&#125;);  <span class="comment">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的眼中:</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + (<span class="number">3</span> + <span class="number">4</span>)</span><br><span class="line"><span class="comment">// tt的眼中:</span></span><br><span class="line">&lt;&lt;<span class="number">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class="number">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">                   &lt;&lt;<span class="number">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class="number">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure><p>这段代码的Token Tree共有5个:</p><ol><li class="lvl-3"><p>&lt;&lt;1&gt;&gt;</p></li><li class="lvl-3"><p>&lt;&lt;+&gt;&gt;</p></li><li class="lvl-3"><p>&lt;&lt;2&gt;&gt;</p></li><li class="lvl-3"><p>&lt;&lt;+&gt;&gt;</p></li><li class="lvl-3"><p>&lt;&lt;(3 + 4)&gt;&gt;</p></li></ol><p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p><p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p><h2 id="ast-jie-dian" id="AST节点">AST节点</h2><p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们通过使用 macro , 站在了更抽象的视角上<br>操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)</p><p>这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p><p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果<br>我直接用 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a> 上面的代码了:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class="line">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> match_tokens &#123;</span><br><span class="line">    ($a:tt + $b:tt) =&gt; &#123;<span class="string">&quot;got an addition&quot;</span>&#125;;</span><br><span class="line">    (($i:ident)) =&gt; &#123;<span class="string">&quot;got an identifier&quot;</span>&#125;;</span><br><span class="line">    ($($other:tt)*) =&gt; &#123;<span class="string">&quot;got something else&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;\n&quot;</span>,</span><br><span class="line">        match_tokens!((caravan)),</span><br><span class="line">        match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;&quot;</span>,</span><br><span class="line">        capture_then_match_tokens!((caravan)),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果会是:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">got an identifier</span><br><span class="line">got an addition</span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br></pre></td></tr></table></figure><p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点<br>它不再是token, 而是个AST节点了!</p><p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br><code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p><p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p><p>总结:<br>宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏<br>(只要宏展开的AST节点正确即可 😄)</p><p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言: 简单的文本替换</span></span><br><span class="line">#define SUM(a,b) a+b</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    SUM(<span class="number">2</span>, <span class="number">2</span>);     <span class="comment">// 2 * 2</span></span><br><span class="line">    <span class="number">5</span> * SUM(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 5 * 2 + 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    sum!(<span class="number">2</span>,<span class="number">2</span>);     <span class="comment">// 2 + 2</span></span><br><span class="line">    <span class="number">5</span> * sum!(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 5 * (2 + 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pi-pei-zhu-yi-dian" id="匹配注意点">匹配注意点</h2><p>在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制<br>即下面要讲的东西, 有时间的也可以去看看 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a></p><h3 id="pi-pei-wu-qu" id="匹配误区">匹配误区</h3><p>来看看下面一段代码:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class="line">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    aa!(a);   <span class="comment">// Yes</span></span><br><span class="line">    aa!(a+);  <span class="comment">// No</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配<br>但是实际上会报这么一个错误:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">expected expression, found end of <span class="keyword">macro</span> arguments</span><br><span class="line"><span class="comment">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure><p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p><p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p><p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p><h3 id="qi-yi-xian-zhi" id="歧义限制">歧义限制</h3><p>由于一些歧义, 为了向后兼容性与不破坏代码<br>当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Rust-Reference: 限制</a><br>这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br><s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)</s><br><s>(因为我也没有全部搞懂)</s></p><p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p><p>那么, 今天就到这了, 谢谢您的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;正式系统的关于 macro 的 声明与使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Macro" scheme="https://jedsek.xyz/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>rust-dm-p2: 从println开始</title>
    <link href="https://jedsek.xyz/posts/rust-decl-macro/p2"/>
    <id>https://jedsek.xyz/posts/rust-decl-macro/p2</id>
    <published>2021-09-19T14:50:27.000Z</published>
    <updated>2021-09-19T14:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p></blockquote><span id="more"></span><p>同系列传送门:</p><ul class="lvl-0"><li class="lvl-2"><p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p></li><li class="lvl-2"><p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p></li></ul><h1 id="kai-pian">开篇</h1><p>大家应该都用过一个宏<br>它就是<code>println!</code>:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Rush B!!!!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    <span class="built_in">println!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>为什么后面要跟个感叹号?<br>为什么括号里面的参数可以不一样?</p><p>亲爱的TRPl在教你写 <a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F">Hello World!</a> 的时候<br>告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>注: macro 的读音: [ˈmækroʊ]</p><p>可是macro到底是啥?<br><s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p><hr><h1 id="cha-kan-ding-yi">查看定义</h1><p>让我们按住Ctrl,鼠标左键点击println!<br>(以 VSCode 为例)</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可能会看到, 在 println! 的上面</span></span><br><span class="line"><span class="comment">// 有着类似下面的玩意:  </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// #[macro_export]</span></span><br><span class="line"><span class="comment">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class="line"><span class="comment">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class="line"><span class="comment">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure><p>你悲催地发现根本看不懂这一大堆鬼画符…<br>但看不懂根本没关系,后面几节过后,你肯定懂了<br>现在只需明白的,是大致结构:</p><ol><li class="lvl-3"><p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏<br>(<code>macro_rules!</code>当作特定语法即可)</p></li><li class="lvl-3"><p>之后用花括号包起来,里面是该宏的具体定义</p></li></ol><p>问题来了,关键是<code>println</code>的具体定义<br>花括号内,到底在讲述着啥?</p><p>请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&quot;1&quot;</span>.repeat(<span class="number">10</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;2&quot;</span>.repeat(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// macro</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>macro有点像是match,能根据不同参数,展开不同的代码<br>在macro最外层的花括号中,有许多匹配分支</p><p>match表达式,称呼每个匹配分支为<code>arm</code><br>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割<br>最后一个arm可省略逗号</p><p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)<br>必须使用花括号包裹,使用分号分隔彼此<br>最后一个rule可省略分号</p><p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义部分</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    <span class="comment">// 空参时, 只输出换行符</span></span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参时, 输出参数, 并换行</span></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用部分</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"><span class="built_in">println!</span>();</span><br></pre></td></tr></table></figure><hr><h1 id="zong-jie">总结</h1><ol><li class="lvl-3"><p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p></li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>然后创建两个匹配分支:<br>(匹配空参 =&gt; 不做任何事)<br>(匹配123 =&gt; 打印123)</p></li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>调用时, 要做到: 宏名+感叹号+传参:<br>(传入的参数,若与任何rule都不匹配,则报错)</p></li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    xxx!();      <span class="comment">// Nothing</span></span><br><span class="line">    xxx!(<span class="number">123</span>);   <span class="comment">// println!(&quot;123&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>咱们下期见</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Macro" scheme="https://jedsek.xyz/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>rust-dm-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-decl-macro/p1"/>
    <id>https://jedsek.xyz/posts/rust-decl-macro/p1</id>
    <published>2021-09-19T13:51:27.000Z</published>
    <updated>2021-09-19T13:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p></blockquote><span id="more"></span><p>同系列传送门:</p><ul class="lvl-0"><li class="lvl-2"><p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p></li><li class="lvl-2"><p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p></li></ul><h1 id="xi-lie-shuo-ming">系列说明</h1><p>此系列,我们将学习Rust中的 <code>声明宏</code><br>请注意, 是声明宏, 过程宏日后再说</p><hr><h1 id="can-kao-zi-liao">参考资料</h1><ol><li class="lvl-3"><p>书籍</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zjp-cn.github.io/tlborm/">宏小册</a></p></li><li class="lvl-2"><p><a href="https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html">RustPrimer</a></p></li><li class="lvl-2"><p><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">TRPL</a></p></li></ul><ol start="2"><li class="lvl-3"><p>文章</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zhuanlan.zhihu.com/p/353421021">【译】Rust宏: 教程与示例 (一)</a></p></li><li class="lvl-2"><p><a href="https://zhuanlan.zhihu.com/p/356427780">【译】Rust宏: 教程与示例 (二)</a></p></li></ul><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后, 谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Macro" scheme="https://jedsek.xyz/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>rust-async-p4: 状态的保存与变换</title>
    <link href="https://jedsek.xyz/posts/rust-async/p4"/>
    <id>https://jedsek.xyz/posts/rust-async/p4</id>
    <published>2021-09-12T06:50:14.000Z</published>
    <updated>2021-09-12T06:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>浅显的原理第一篇: 状态的保存/变换</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p><h1 id="kai-pian">开篇</h1><p><strong>注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看</strong><br>为了更好地理解<code>Rust异步</code>背后的原理,我们先来了解下一些概念<br>当然,不用太深入,只是小补充而已:</p><ul class="lvl-0"><li class="lvl-2"><p><code>抢占式/协作式多任务</code></p></li><li class="lvl-2"><p><code>状态机</code></p></li><li class="lvl-2"><p><code>自引用结构体</code></p></li></ul><p>现在,让我们开始吧!</p><hr><h1 id="liang-chong-duo-ren-wu">两种多任务</h1><h2 id="jie-shao" id="介绍">介绍</h2><p><code>抢占式多任务</code>与<code>协作式多任务</code>,都属于<code>多任务</code></p><ul class="lvl-0"><li class="lvl-2"><p>抢占式多任务:<br>操作系统决定CPU的运行权<br>比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会<br>各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种<code>任务们同时运行</code>的感觉<br>这是强迫/抢占的</p></li><li class="lvl-2"><p>协作式多任务:<br>任务们本身进行协调,决定CPU的运行权<br>比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending<br>自己放弃继续执行,并通知运行时执行其他Task<br>这是自愿/协作的,Task们<code>自愿放弃CPU的执行权</code><br>(上文中的<code>任务</code>与<code>Task</code>请区分一下,前者比后者广泛,后者在这用于Rust的举例)</p></li></ul><h2 id="zhuang-tai-de-hui-fu-bao-cun" id="状态的恢复-保存">状态的恢复/保存</h2><p>既然任务们能互相切换执行,那么,当再次轮到某任务执行时<br>该任务,应当从先前暂停的地方开始,继续执行<br>因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是<code>状态保存</code></p><p>对于<code>抢占式</code>与<code>协作式</code>,处理<code>状态保存</code>的思路是不一样的:</p><ul class="lvl-0"><li class="lvl-2"><p>抢占式:<br>因为是强迫切换执行的,任务会在任意某个时刻被中断<br>任务此时运行到了哪里?我们不知道啊!<br>那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)</p></li></ul><p>反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间<br>但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大</p><ul class="lvl-0"><li class="lvl-2"><p>协作式:<br>因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的<br>这种放弃执行权的操作,我们称为<code>yield</code></p></li></ul><p>比如在Rust中,<code>xxx.await</code>会执行一个Future  <br>意味着当程序执行到这里时,可能会<code>yield</code>(poll返回Poll::Pending,自愿放弃执行权)</p><p><code>xxx.await</code>就是一个<code>stop/yield point</code>,代表执行到此处时,可能会发生暂停并yield<br>瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>因此,我们可以准确分配Future执行所需要的最大空间</p><p>其实,每个<code>.await(也就是yield point)</code>,就代表着<code>一种状态</code>(之后会讲)</p><p>协作式的好处在于:<br>能自己掌握所有<code>yield point</code>,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理<br>毕竟机器定义的分配策略, 总是没有比不过我们特意设计的<br>在任务暂停并转让执行权前,准确保存<code>下次继续所需要的状态</code>,内存/性能优势很大<br>但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行</p><hr><h1 id="zhuang-tai-ji-de-gai-nian">状态机的概念</h1><p>在Rust中的异步,我们之前也说过,属于<code>协作式多任务</code><br>而其<code>状态保存</code>的实现,就是利用<code>状态机(state machine)</code>来实现</p><p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>,是一种数学模型</p><ol><li class="lvl-3"><p>状态(state):<br>比如有一扇门,它的状态就处于以下两种之一: Open or Closed</p></li><li class="lvl-3"><p>事件(event):<br>某事件发生后,会触发相应动作,可能改变状态<br>比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p></li><li class="lvl-3"><p>动作 (action):<br>事件发生后,会触发动作</p></li><li class="lvl-3"><p>变换 (transition):<br><code>State_X=&gt;State_Y</code>就叫<code>变换</code>,比如门的状态从<code>Open=&gt;Closed</code></p></li></ol><p>稍微了解下<code>状态机</code>的概念即可</p><p>那么现在,就要看具体代码了</p><p>如果你想亲自运行一下,先确保你的<code>Cargo.toml</code>中的依赖如下:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123;version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>, <span class="string">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>如下代码,读取一个文件的行数<br>你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>(通过target目录下的可执行文件,加上参数后运行,也可以哦)</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    env::args,</span><br><span class="line">    process,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> async_std::&#123;</span><br><span class="line">    prelude::*,</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;<span class="keyword">self</span>,BufReader&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;              <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> path = args().nth(<span class="number">1</span>).unwrap_or_else(||&#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">let</span> file = File::open(path).<span class="keyword">await</span>?;          <span class="comment">// Yield point</span></span><br><span class="line">    <span class="keyword">let</span> lines = BufReader::new(file).lines();</span><br><span class="line">    <span class="keyword">let</span> count = lines.count().<span class="keyword">await</span>;             <span class="comment">// Yield point</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;                                                <span class="comment">// Done</span></span><br></pre></td></tr></table></figure><p>mian()产生一个新实例,异步运行<code>open(path)</code>与<code>count()</code>  <br>对于编译器,每一个<code>.await</code>其实都代表一种状态</p><p>Future实例,实际上是个状态机<br>在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p><ol><li class="lvl-3"><p>Start: 此Future刚开始执行</p></li><li class="lvl-3"><p>Yield1: 第一个 yield point</p></li><li class="lvl-3"><p>Yield2: 第二个 yield point</p></li><li class="lvl-3"><p>Done: 此Future执行完毕</p></li></ol><p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>执行器调用当前Future的poll推动进度时,若在<code>某一阶段</code>返回了<code>Poll::Pending</code>,则放弃执行权<br>当再次调用当前Future的poll推动进度时,则从上次暂停的状态<code>恢复(resume)</code>,继续执行</p><p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机<br>每一个状态都会存储一些数据, 便于进入下一个状态</p><p><strong>Note 1</strong>:<br>Start状态,会存储传入函数的参数(如果有参数)</p><p><strong>Note 2</strong>:<br>Done状态下,若进行resume,则可能得到panic!<br>因为恢复已结束的计算是不可能, 也不应该的</p><p><strong>Note 3</strong>:<br>怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br><code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存,因为从暂停中恢复后还需要使用<br>其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象<br>所以不需要特殊的持久化操作</p><hr><h1 id="zi-yin-yong-jie-gou-ti">自引用结构体</h1><h2 id="bao-cun-yin-yong" id="保存引用">保存引用</h2><p>当每个状态存储数据时,可能会导致发生<code>自引用</code>,比如:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>() -&gt; <span class="built_in">i32</span> &#123;                            <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> element = &amp;arr[<span class="number">2</span>];</span><br><span class="line">    write_file(<span class="string">&quot;foo.txt&quot;</span>, element.to_string()).<span class="keyword">await</span>;  <span class="comment">// Yield1</span></span><br><span class="line">    *element                                           <span class="comment">// Done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有三个状态: <code>Start</code>,<code>Yield1</code>,<code>Done</code><br>而在<code>Yield1</code>这个状态,存储的数据如下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Yield1State</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">i32</span>; <span class="number">3</span>],</span><br><span class="line">    element: *<span class="keyword">const</span> <span class="built_in">i32</span>, <span class="comment">// 数组最后一个元素的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态的实例</span></span><br><span class="line">Yield1State &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    element: &amp;arr[<span class="number">2</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等等,你可能会对上面的代码有疑惑:<br>不是说,状态只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>上面的代码,只有element这个引用需要被保存吧?</p><p>这是因为,它是<code>引用</code>嘛!<br>没了<code>引用</code>背后的实际数据,那它还有啥用,不就是<code>悬垂引用</code>了吗?</p><p>因此我们还得保存,<code>该引用</code>指向的背后数据: <code>arr</code><br>并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中</p><p>像这种 <code>结构体内部的指针,指向结构体本身</code><br>就叫 <code>自引用结构</code></p><p>比如上面代码: 同一结构体下,成员element指向了成员arr</p><h2 id="nei-cun-yi-dong-wen-ti" id="内存移动问题">内存移动问题</h2><p>如上所述, 这可能导致悬垂引用的产生:<br>若该struct实例的<code>内存地址发生改变</code><br>(比如使用<code>std::mem</code>,让struct实例的内存地址,发生移动)</p><p>以上面的那段代码为例,如下:</p><ul class="lvl-0"><li class="lvl-2"><p>arr:<br>内存地址会跟着结构体实例而改变<br>但是, <code>值仍然是 [1,2,3]</code></p></li><li class="lvl-2"><p>element:<br>内存地址会跟着结构体实例而改变<br>但是,值仍然是<code>先前arr的地址</code><br><code>注意,是先前的 ! 而不是后来arr的新地址</code></p></li></ul><p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)</p><p>官方提出了<code>std::pin::Pin(trait)</code><br>来解决自引用结构体方面的悬垂指针/引用问题</p><p>其实你听名字也很好理解:<br><code>Pin(中文意思是钉子)</code>的作用是,防止内存地址发生改变(给爷钉死吧!)</p><p>但是它又是怎么pin住的呢?<br>下一节再慢慢讲吧</p><p>那又是一个值得探讨的话题了<br>欲知后事如何, 且听下回分解</p><p><s>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;浅显的原理第一篇: 状态的保存/变换&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Async" scheme="https://jedsek.xyz/tags/Async/"/>
    
  </entry>
  
  <entry>
    <title>rust-async-p3: Future</title>
    <link href="https://jedsek.xyz/posts/rust-async/p3"/>
    <id>https://jedsek.xyz/posts/rust-async/p3</id>
    <published>2021-09-12T05:56:48.000Z</published>
    <updated>2021-09-12T05:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Rust 中的 Future/async/.await 说明</p></blockquote><span id="more"></span>  <p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p><h1 id="kai-pian">开篇</h1><p>大家好! 我们上一节已经知晓异步的基础概念<br>现在,来看看Rust中的异步语法吧</p><p>在本节,我们会知晓以下三个概念的大致含义:<br>(暂时不涉及背后原理,原理之后专门出好几节来讲)</p><ul class="lvl-0"><li class="lvl-2"><p>Future (trait)</p></li><li class="lvl-2"><p>async (keyword)</p></li><li class="lvl-2"><p>.await (keyword)</p></li></ul><p>开始旅途吧</p><hr><h1 id="future">Future</h1><h2 id="gai-nian" id="概念">概念</h2><p><code>Future</code>,一个标准/核心库中的trait<br>其完整路径为<code>std/core::future::Future</code></p><p>此节我只会讲它的大致含义,原理则放到后面几节专门来讲 <s>(原理太难, 一节根本不够)</s></p><p>在Rust中,一个实现了Future(trait)的类型<br>该类型的实例(有时候直接被简称为 <code>一个Future实例</code>)便代表 <code>一次异步计算</code><br>可以将其交给<code>Runtime(运行时)</code>,从而异步执行</p><p><code>异步执行</code>, 也就是指:<br>当其他异步任务阻塞时,当前异步任务有机会执行<br>或当前异步任务阻塞时,其他异步任务有机会执行<br>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p><p><strong>注意两个名词的区别:</strong></p><ul class="lvl-0"><li class="lvl-2"><p><code>异步 计算</code></p></li><li class="lvl-2"><p><code>异步 任务</code></p></li></ul><p>两者有着区别,举个例子你就明白了:</p><p>假设有这么个父计算, 由两个子计算组成:</p><ol><li class="lvl-3"><p>Open: 先异步打开一个文件(async open)</p></li><li class="lvl-3"><p>Read: 再异步读取该文件(async read)</p></li></ol><p>我们可以看出,一次计算, 是可以由多个子计算组成的<br>同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期<br>因为<code>子计算们可能存在依赖关系</code> (在这里的例子中也确实存在)</p><p>因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算<br>(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p><p><code>当前Task</code>阻塞时,接管执行权的,不能是当前Task中的<code>其他子计算</code><br>只能是<code>其他Task中的子计算</code></p><p>来点总结吧:</p><ul class="lvl-0"><li class="lvl-2"><p>Task是一个顶层Future实例 (即一次顶层异步计算)</p></li><li class="lvl-2"><p>一个Future可以由多个Future组成,即一个Future里可以执行多个Future</p></li><li class="lvl-2"><p>Task_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算</p></li><li class="lvl-2"><p>Task可以只是一次单独计算</p></li></ul><p><code>一个Future (一次异步计算)</code><br>可理解为,是组成<code>一个Task (一个异步任务)</code>的最小单位</p><p>了解到了那么一点点后,现在来正式看看呗 ?</p><h2 id="ding-yi" id="定义">定义</h2><p>让我们来看看它的定义:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面简单了解一下:</p><ul class="lvl-0"><li class="lvl-2"><p>Future:<br>代表一次异步计算</p></li><li class="lvl-2"><p>Output:<br>代表该Future,异步执行完毕后,产出的值的类型</p></li><li class="lvl-2"><p>poll:<br>所有执行操作都会放在该函数中<br>Runtime 会不断调用<code>poll函数</code>来推进<code>该异步计算</code>的完成<br>每次poll的返回值是一个枚举变体,代表是否完成</p></li><li class="lvl-2"><p>Poll<T>:<br>枚举类型,作为poll函数的返回值类型,其变体有:<br><code>Poll::Pending</code>:<br>指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)<br><code>Poll::Ready(T)</code>:<br>指明该计算执行完毕,并产出一个类型为T的值</p></li></ul><p>若只是普通使用者,并不需了解<code>Future的定义</code>背后之原理<br>但若不了解它,又如何为某类型实现 Future 呢?</p><p>别急,Rust为我们提供了关键字<code>async</code>,接着往下看吧</p><hr><h1 id="async">Async</h1><p><code>async</code>: 一个关键字<br>用来创建<code>一个匿名结构体的实例, 该结构体实现了Future</code><br>即,它用来创建一个 <code>Future实例</code></p><p>来个例子,看看async的好处:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HelloStr</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> HelloStr &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">String</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, _cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>);</span><br><span class="line">        Poll::Ready(<span class="built_in">str</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以观察到,使用 async 进行了符合直觉的简化<br>这两种函数,实际上是等价的</p><p>看看它们两的返回值,如下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello_str_1() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr <span class="comment">// Future&lt;Output = String&gt; 的实例</span></span><br><span class="line">&#125;</span><br><span class="line">hello_str_2() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure><p>注意,异步函数的调用,只是返回一个 Future实例<br><strong>但并没有开始执行, 它是惰性的</strong><br><strong>只有调用Future的poll方法, 才能推动它的执行</strong><br><strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong></p><p>这样的好处就在于:<br>将一个异步计算看作一个变量,方便了传参等工作</p><p>比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可</p><p>async的作用就是创建一个Future实例:</p><ul class="lvl-0"><li class="lvl-2"><p><code>async fn</code>: 异步函数, 要求返回一个 Future实例</p></li><li class="lvl-2"><p><code>async block</code>: 异步代码块, 创建一个 Future实例</p></li><li class="lvl-2"><p><code>async closure</code>: 异步闭包, (目前是不稳定特性) 创建一个 Future实例</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1_i32</span>;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `async block` 也可以使用move  </span></span><br><span class="line"><span class="comment">// 获得其中使用的变量的所有权  </span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    &amp;s </span><br><span class="line">&#125;</span><br><span class="line">s; <span class="comment">// Error: use of moved value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure><p>创建一个Future实例, 想必大家已经了解一二<br>但是如何执行一个Future实例?</p><p>请接着往下看</p><hr><h1 id="zhi-xing">执行</h1><h2 id="bei-jing-jie-shao" id="背景介绍">背景介绍</h2><p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序</p><p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future)</p><p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>在嵌入式环境下, 也能够轻松运行异步程序</p><p>在正式开始之前请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123; version = <span class="string">&quot;1.9&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>我们指定了版本, 并且启用了 <code>attributes</code> 这个特性</p><h2 id="runtime-zhi-xing" id="Runtime执行">Runtime执行</h2><p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>并且使用 <code>async-std</code> 这个异步运行时环境来执行它:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello wrold!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们在本节开始不久,就提到过的<code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>async_std::task,该模块,为我们提供了大量api,来执行/操控 这些 <code>Task</code></p><p>比如这里出现的<code>task::block_on</code>:<br>传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程<br>该任务执行完毕后产出的值,会作为<code>block_on</code>的返回值</p><p>我们执行了一个Task,并且这个Task是单个的Future<br>但若我们想执行由多个子Future所组成的Task,又该怎么办?</p><p><code>.await</code> 关键字出场了!</p><hr><h1 id="await">Await</h1><p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>在某个Future实例的后面,增加<code>.await</code>,那么<code>该Future实例</code>则会执行<br>但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)<br>真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future</p><p>来看看它的使用:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">world</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    hello().<span class="keyword">await</span>;</span><br><span class="line">    world().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.await</code>是一个标记点,可以理解为是一个<code>yield point</code><br>Runtime执行到<code>xxx.await</code>时,先会执行一次<code>xxx</code></p><p>一开始,会调用一次poll函数,推动执行进度<br>通过它的返回值,<code>Poll&lt;T&gt;枚举的变体</code>,即<code>Pending</code>或<code>Ready(T)</code><br>来决定:</p><ol><li class="lvl-3"><p>让其他Task接管执行权(yield)</p></li><li class="lvl-3"><p>该Future执行完毕,继续执行当前Task</p></li></ol><p>若为<code>Ready</code>: 则选 <code>2</code>,继续往下执行(一个Task可能是由多个Future所组成)<br>若为<code>Pending</code>: 则选 <code>1</code>,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)</p><p>稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:</p><p><code>.await</code>会指明<code>执行某个Future</code> 这一逻辑<br>当<code>xxx.await</code>所在的Task交给Runtime执行,并执行到<code>xxx.await</code> 时<br><code>xxx</code> 这个Future实例会执行</p><p>若它阻塞(这意味着该Future所在的Task也阻塞)<br>所以调度程序安排其他Task,在该空档期执行<br>若不阻塞,就继续往下执行(可能还有碰见<code>.await</code>哟), 直到该Task结束</p><hr><h1 id="bu-chong">补充</h1><ul class="lvl-0"><li class="lvl-2"><p><code>#[async_std::main]</code><br>这玩意无比常见,是个属性宏,要加在main函数头上<br>使得main前面能被async所修饰<br>程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    hello_world().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    async_std::task::block_on( <span class="keyword">async</span> &#123;</span><br><span class="line">        hello_world().<span class="keyword">await</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>async_std::task::spawn</code><br>因为这玩意也很常见,所以就讲一讲:<br>向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例它实现了Future,与标准库中的<code>JoinHandle</code>无比相似<br>不过那个运行Thread,而这个运行Task,<code>join</code>相应地变成<code>.await</code><br>想让该handle代表的Task运行完毕,应该在该handle前放上<code>.await</code>,如下:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> handle = task::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> two:<span class="built_in">i32</span> = handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Rust 中的 Future/async/.await 说明&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Async" scheme="https://jedsek.xyz/tags/Async/"/>
    
  </entry>
  
  <entry>
    <title>rust-async-p2: 异步简介</title>
    <link href="https://jedsek.xyz/posts/rust-async/p2"/>
    <id>https://jedsek.xyz/posts/rust-async/p2</id>
    <published>2021-09-12T04:04:09.000Z</published>
    <updated>2021-09-12T04:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来简单介绍一下异步吧</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p><h1 id="kai-pian">开篇</h1><p><strong>异步编程</strong> (Asynchronous programming)<br>是一种<strong>并发编程模型</strong></p><p>特点是通过少量<code>OS_thread(系统线程)</code><br>即可运行大量<code>并发任务</code><br>在某些场景下,可以疯狂压榨cpu的性能<br><s>(好吧,有点废话…)</s></p><hr><h1 id="mo-xing-dui-bi">模型对比</h1><p>为何选择异步,它的优势有哪些?</p><p>对于这个问题,我们将对比<strong>异步</strong>与其他<strong>并发模型</strong><br>以此来告诉大家,为什么选择异步:</p><p>1.<code>OS Thread (系统线程)</code><br>由操作系统提供线程,进行并发,如std::thread<br>Good_1:<br>简单易使用,建模能力强,足够传统<br>Good_2:<br>操作系统就是运行时,与C语言交互方便<br>Bad_1:<br>数据同步困难,易发生数据竞争<br>Bad_2:<br>小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低</p><p>2.<code>Green Thread (绿色线程)</code><br>它几乎与系统线程一样,不过<code>Runtime(运行时,jvm/.net听说过吗?)</code>从操作系统变为了程序本身<br>绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程<br>Good:<br>这意味着,程序本身对绿色线程有绝对的管理权<br>所以内存分配等方面的粒度更细,根据任务大小调度内存<br>因此堆栈大小,能够随时间推移而增长<br>并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务<br>Bad_1:<br>它是程序本身实现模拟出来的线程,Runtime较巨大<br>运行时会一直存在,即使你不用该特性,导致拖累全局程序性能<br>并且难以与C库交互<br>这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象<br>它无法在语言层面被Rust支持<br>Bad_2:<br>绿色线程在不同平台上,其实现可能不同<br>对多平台的支持/维护/改进得靠实现者保证</p><p><code>OS Thread</code>与<code>Green Thread</code>与Rust关系比较大:<br>一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的</p><hr><h1 id="yi-bu">异步</h1><p>我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !<br><s>(没把你憋坏吧伙计?)</s></p><p>我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一<br>假设我们正在单线程下,读取文件,并进行一个计算:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件, 获取数据 </span></span><br><span class="line"><span class="keyword">let</span> data = read(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行一个计算</span></span><br><span class="line">compute()</span><br></pre></td></tr></table></figure><p>以上面代码为例子,我们会读取 <code>file</code> 获取 <code>data</code><br>期间,我们的程序,做不了任何其他事情<br>只有等待<code>IO操作(Input/Output, 输入/输出)</code>完毕,我们才能进行接下来的 <code>compute</code></p><p><code>读取文件</code>,属于<code>IO操作</code><br>众所周知,IO操作很耗时,等待它完成的时间可能会很长</p><p>有没有什么办法加快速度?<br>没错,系统线程yyds:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class="line"><span class="keyword">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class="line"><span class="keyword">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class="line"><span class="keyword">let</span> data = handle_a.join().unwrap();</span><br><span class="line">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure><p>因为两个任务<code>read</code>与<code>compute</code>是独立的,无依赖性<br>所以我们<code>spawn</code>了两个线程<br>第一个: 用于读取文件,获取数据第二个: 用于在读取文件的同时,执行着 <code>compute</code><br>虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销<br>而异步,就是只依靠单线程,也能够完成上面的操作</p><p>单线程中的异步(伪)代码如下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件, 获取数据 </span></span><br><span class="line"><span class="keyword">let</span> data = read_async(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行一个计算</span></span><br><span class="line">compute_async()</span><br></pre></td></tr></table></figure><p>你会注意到:<br><code>read</code> -&gt; <code>read_async</code><br><code>compute</code> -&gt; <code>compute_async</code></p><p>我用伪代码表示,这两个操作变成了异步操作<br>你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念<br>如下:</p><ul class="lvl-0"><li class="lvl-2"><p><code>read</code>:<br>它会阻塞调用线程,等待该操作完毕后<br>才继续往下执行<code>compute</code></p></li></ul><p>阻塞期间是几乎不需要cpu参与运行的<br>程序此时傻乎乎地等待阻塞结束<br>无疑是对性能的浪费,对cpu的不尊重</p><ul class="lvl-0"><li class="lvl-2"><p><code>read_async</code>:<br>它处于阻塞时,会运行<code>compute_async</code><br>线程由<code>read_async</code>接管变为由<code>compute_async</code>接管<br>当阻塞时间结束,则程序继续变为运行<code>read_async</code></p></li></ul><p><code>read_async</code>阻塞时,程序是不会傻傻等待的:</p><p>若检测到它处于阻塞,无法取得进展<br>则会运行其他异步任务,由其他异步任务接管线程</p><p>总而言之,异步操作,其实就是:<br>若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>使得cpu一直处于运算,性能被极限压榨</p><p>异步操作,就像是可以随意<code>start/stop</code>一般<br>调度程序能够对它们进行调度,决定当前要运算哪个操作<br>确保不会因为阻塞而傻傻等待</p><p>只需单线程,就可以做到同时运行多个 <code>Task(异步任务)</code><br>异步当然也不排斥多线程:<br>一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?</p><hr><h1 id="wei-sheng">尾声</h1><p>Q:<br>阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>A:<br>现代电脑发展出了一些分担IO操作压力的高科技<br>所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>只需要最后接收数据时, 出个场就行了</p><p>所以我们的程序不需要在等待输入输出时就那样等着<br>给它们找事情, 让它们闲不下来吧!</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来简单介绍一下异步吧&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Async" scheme="https://jedsek.xyz/tags/Async/"/>
    
  </entry>
  
  <entry>
    <title>rust-async-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-async/p1"/>
    <id>https://jedsek.xyz/posts/rust-async/p1</id>
    <published>2021-09-12T03:43:19.000Z</published>
    <updated>2021-09-12T03:43:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Rust 的 异步(async) 系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p><h1 id="xi-lie-shuo-ming">系列说明</h1><p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>当然也会介绍异步方面的相关概念咯</p><hr><h1 id="zi-liao-lai-yuan">资料来源</h1><ol><li class="lvl-3"><p>书籍</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://rust-lang.github.io/async-book/**">async-book</a></p></li><li class="lvl-2"><p><a href="https://book.async.rs/overview/async-std">async_std/tutorials</a></p></li><li class="lvl-2"><p><a href="https://tokio.rs/tokio/tutorial">tokio/tutorials</a></p></li><li class="lvl-2"><p><a href="https://cfsamson.github.io/books-futures-explained/">Futures Explained in 200 Lines of Rust</a></p></li></ul><ol start="2"><li class="lvl-3"><p>博客</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://without.boats/blog/">Withoutboats’s blogs</a></p></li></ul><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后,谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Rust 的 异步(async) 系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Async" scheme="https://jedsek.xyz/tags/Async/"/>
    
  </entry>
  
</feed>
