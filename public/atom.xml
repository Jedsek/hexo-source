<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jedsek&#39;s blog</title>
  
  <subtitle>与其浊富 | 宁比清贫</subtitle>
  <link href="https://jedsek.xyz/atom.xml" rel="self"/>
  
  <link href="https://jedsek.xyz/"/>
  <updated>2022-12-17T09:29:14.000Z</updated>
  <id>https://jedsek.xyz/</id>
  
  <author>
    <name>Jedsek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>p2-环境搭建</title>
    <link href="https://jedsek.xyz/posts/scala3-basic/p2"/>
    <id>https://jedsek.xyz/posts/scala3-basic/p2</id>
    <published>2022-12-17T09:29:14.000Z</published>
    <updated>2022-12-17T09:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将介绍如何搭建 scala3 的环境</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/scala3-basic">scala3-basic</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将介绍如何搭建 scala3 的环境&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Scala3" scheme="https://jedsek.xyz/tags/Scala3/"/>
    
  </entry>
  
  <entry>
    <title>scala3-basic-p1~&gt; 系列说明</title>
    <link href="https://jedsek.xyz/posts/scala3-basic/p1"/>
    <id>https://jedsek.xyz/posts/scala3-basic/p1</id>
    <published>2022-12-17T07:13:04.000Z</published>
    <updated>2022-12-17T07:13:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 scala3 的学习系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/scala3-basic">scala3-basic</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 scala3 的学习系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Scala3" scheme="https://jedsek.xyz/tags/Scala3/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p7~&gt; GObject: 信号</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p7"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p7</id>
    <published>2022-12-10T15:45:10.000Z</published>
    <updated>2022-12-10T15:45:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将学习 GObject 的 signal(信号)</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将学习 GObject 的 signal(信号)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p6~&gt; GObject: 属性</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p6"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p6</id>
    <published>2022-12-10T15:39:26.000Z</published>
    <updated>2022-12-10T15:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将学习 GObject 的 property(属性), 探索其强大且灵活的动态运行时</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p><h1 id="shuo-ming">说明</h1><p>属性(Property), 让我们能够访问 GObject 的状态(state)</p><p>glib 虽然以面向过程的 C 为核心, 但却具有面向对象的思想, 属性自然是其中重要的一环<br>通过库为我们提供的运行时, 我们得到了一个灵活的, 动态的运行时, 直接使用就好</p><p>得益于此, 我们可以在程序的运行过程中, 动态地修改其属性, 比如:</p><ul class="lvl-0"><li class="lvl-2"><p>动态注册某个新的属性</p></li><li class="lvl-2"><p>进行属性间的自动绑定</p></li><li class="lvl-2"><p>属性变更时将执行操作</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将学习 GObject 的 property(属性), 探索其强大且灵活的动态运行时&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>Hyprland 平铺式</title>
    <link href="https://jedsek.xyz/posts/desktop-beautify/hyprland"/>
    <id>https://jedsek.xyz/posts/desktop-beautify/hyprland</id>
    <published>2022-12-10T09:46:21.000Z</published>
    <updated>2022-12-10T09:46:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://jedsek.xyz/tags/Linux/"/>
    
    <category term="Waylnad" scheme="https://jedsek.xyz/tags/Waylnad/"/>
    
    <category term="Desktop" scheme="https://jedsek.xyz/tags/Desktop/"/>
    
    <category term="Hyprland" scheme="https://jedsek.xyz/tags/Hyprland/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p5~&gt; 进制的转换与应用</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p5"/>
    <id>https://jedsek.xyz/posts/high-school-it/p5</id>
    <published>2022-11-23T15:51:02.000Z</published>
    <updated>2022-11-23T15:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于任意进制间的互相转换与应用</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于任意进制间的互相转换与应用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p5~&gt; GObject: 通用类型</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p5"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p5</id>
    <published>2022-11-20T05:51:26.000Z</published>
    <updated>2022-11-20T05:51:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p><h1 id="shuo-ming">说明</h1><p>之前说过, gnome体系依赖于 glib, 以C语言为核心的实现, 通过 Gobject-Introspection 为大量语言提供绑定<br>这是一套以C为核心, 支持多语言互相交互的运行时系统, 自然要有套完整且够通用的数据类型</p><p>在为Rust提供的绑定中, 有两套这样的数据类型, 分别是:</p><ul class="lvl-0"><li class="lvl-2"><p><code>glib::Value</code>: 作用于 rust 与 glib 之间数据类型的互相转换</p></li><li class="lvl-2"><p><code>glib::Variant</code>: 作用于数据类型的序列化/反序列化, 以使应用与外部世界(比如某个进程)交互, 或存储数据到本地磁盘</p></li></ul><p>之后学习属性与信号时, 我们将会用到 <code>glib::Value</code>, 即 <code>GValue</code>, 让 rust 中的数据类型 能与 glib 的库函数互相交互<br>之后学习偏好持久化/设置保存时, 我们将会用到 <code>glib::Variant</code>, 即 <code>GVariant</code>, 进行数据的序列化与反序列化</p><p>搞清楚以上的说明之后, 接下来的难度便是一马平川, 只需稍微看几眼有个印象, 到时候多查查文档就 ok 了<br>接下来的代码直接抄官方书籍了, 不过加了大量解释, 希望有助于你理解它们</p><hr><h1 id="value">Value</h1><p>你可以简单地将 <code>glib::Value</code> 理解为一个 Wrapper 类型, 如果用 rust 中的 enum 来表示, 它可以是这样的:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Value</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">bool</span>(<span class="built_in">bool</span>),</span><br><span class="line">    <span class="built_in">i8</span>(<span class="built_in">i8</span>),</span><br><span class="line">    <span class="built_in">i32</span>(<span class="built_in">i32</span>),</span><br><span class="line">    <span class="built_in">u32</span>(<span class="built_in">u32</span>),</span><br><span class="line">    <span class="built_in">i64</span>(<span class="built_in">i64</span>),</span><br><span class="line">    <span class="built_in">u64</span>(<span class="built_in">u64</span>),</span><br><span class="line">    <span class="built_in">f32</span>(<span class="built_in">f32</span>),</span><br><span class="line">    <span class="built_in">f64</span>(<span class="built_in">f64</span>),</span><br><span class="line">    <span class="comment">// boxed-types</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;),</span><br><span class="line">    Object(<span class="built_in">Option</span>&lt;<span class="keyword">dyn</span> IsA&lt;glib::Object&gt;&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会观察到 <code>boxed-types(装箱类型)</code> 这几个字, 它包装一个 rust 中的 <code>Option&lt;T&gt;</code> 类型<br>即, boxed-types, 可接受包装 <code>Option&lt;T&gt;::None</code>, 以此来表示可空这个概念</p><p>此时, 装箱所得的结果, 是个代表着C语言中 <code>null</code> 概念的东西, 而其他的如数字/布尔类型的 GValue, 则不允许包装 <code>None</code></p><p>听着云里雾里的? 那就直接看代码吧, 下面是一些例子, 或许能帮助你更好地理解:</p><figure class="highlight rust"><figcaption><span>non-boxed-types example:</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store `i32` as `Value`</span></span><br><span class="line">    <span class="keyword">let</span> integer_value = <span class="number">10</span>.to_value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `i32` from `Value`</span></span><br><span class="line">    <span class="keyword">let</span> integer = integer_value</span><br><span class="line">        .get::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `i32`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(integer, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><figcaption><span>boxed-types example:</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store `Option&lt;String&gt;` as `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string_some_value = <span class="string">&quot;Hello!&quot;</span>.to_value();</span><br><span class="line">    <span class="keyword">let</span> string_none_value = None::&lt;<span class="built_in">String</span>&gt;.to_value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `String` from `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string_some = string_some_value</span><br><span class="line">        .get::&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string_none = string_none_value</span><br><span class="line">        .get::&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(string_some, <span class="literal">Some</span>(<span class="string">&quot;Hello!&quot;</span>.to_string()));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(string_none, <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你希望区分可以表示空的Value, 只需将 <code>get::&lt;String&gt;</code> 换成 <code>get::&lt;Option&lt;String&gt;&gt;</code> 即可, 函数会自动帮你进行转换</p><figure class="highlight rust"><figcaption><span>directly use `get::&lt;String&gt;` instead of `get::&lt;Option&lt;String&gt;&gt;` if you are sure it is not none:</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store string as `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string_value = <span class="string">&quot;Hello!&quot;</span>.to_value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `String` from `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string = string_value</span><br><span class="line">        .get::&lt;<span class="built_in">String</span>&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `String`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(string, <span class="string">&quot;Hello!&quot;</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将在之后学习 信号(signal) 与 属性(property) 时, 使用到 <code>glib::Value</code></p><hr><h1 id="variant">Variant</h1><p>数据要发送到某个进程或网络, 或想将数据存储在磁盘上时, 就可以使用 <code>glib::Variant</code><br>你可以将 <code>glib::Variant</code> 想象为 json 文本, 那是一种非常通用的文件格式</p><p>根据文档所述:<br>glib 中的 Variant, 被设计为与 dbus 体系有着基本相同的格式, 能够方便与 dbus 集成<br>Variant 在处理序列化形式的数据方面进行了大量优化, 可在很短的常量时间内, 执行几乎所有的反序列化操作，且占用非常小的内存<br>序列化的 Variant 数据也可以通过网络发送</p><p>因此你希望更深入学习, 可以查找 dbus 的相关资料, 这不在接下来的文章范围内</p><p>与使用 <code>glib::Value</code> 的经验非常相似, 我们只需要将 <code>to_value()</code> 替换为 <code>to_variant()</code>:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store `i32` as `Variant`</span></span><br><span class="line">    <span class="keyword">let</span> integer_variant = <span class="number">10</span>.to_variant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `i32` from `Variant`</span></span><br><span class="line">    <span class="keyword">let</span> integer = integer_variant</span><br><span class="line">        .get::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The variant needs to be of type `i32`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(integer, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多例子, 以下代码将实现 <code>Vec&lt;T&gt;</code> 与 <code>glib::Variant</code> 间的互相转化:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> variant = <span class="built_in">vec!</span>[<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;there!&quot;</span>].to_variant();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(variant.n_children(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vec = &amp;variant</span><br><span class="line">        .get::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The variant needs to be of type `String`.&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec[<span class="number">0</span>], <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将在使用 <code>gio::Settings</code> 保存设置, 或使用 <code>gio::Action</code> 激活操作时，用到 <code>glib::Variant</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p4~&gt; python基础语法-part2</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p4"/>
    <id>https://jedsek.xyz/posts/high-school-it/p4</id>
    <published>2022-11-10T14:59:39.000Z</published>
    <updated>2022-11-10T14:59:39.000Z</updated>
    
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p5~&gt; 与GUI集成</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p5"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p5</id>
    <published>2022-10-22T14:44:16.000Z</published>
    <updated>2022-10-22T14:44:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GStreamer" scheme="https://jedsek.xyz/tags/GStreamer/"/>
    
    <category term="Video" scheme="https://jedsek.xyz/tags/Video/"/>
    
    <category term="Audio" scheme="https://jedsek.xyz/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p4~&gt; 时间管理</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p4"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p4</id>
    <published>2022-10-22T14:44:02.000Z</published>
    <updated>2022-10-22T14:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习 gstreamer 中的时间管理, 执行快进/后退等操作</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习 gstreamer 中的时间管理, 执行快进/后退等操作&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GStreamer" scheme="https://jedsek.xyz/tags/GStreamer/"/>
    
    <category term="Video" scheme="https://jedsek.xyz/tags/Video/"/>
    
    <category term="Audio" scheme="https://jedsek.xyz/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p3~&gt; 管道的动态构建</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p3"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p3</id>
    <published>2022-10-22T14:43:55.000Z</published>
    <updated>2022-10-22T14:43:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习如何在 gstreamer 中动态地构建管道</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习如何在 gstreamer 中动态地构建管道&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GStreamer" scheme="https://jedsek.xyz/tags/GStreamer/"/>
    
    <category term="Video" scheme="https://jedsek.xyz/tags/Video/"/>
    
    <category term="Audio" scheme="https://jedsek.xyz/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p2~&gt; 管道的基础概念</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p2"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p2</id>
    <published>2022-10-22T14:43:36.000Z</published>
    <updated>2022-10-22T14:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过一个入门级例子, 讲述 gstreamer 中管道的基础概念</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过一个入门级例子, 讲述 gstreamer 中管道的基础概念&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GStreamer" scheme="https://jedsek.xyz/tags/GStreamer/"/>
    
    <category term="Video" scheme="https://jedsek.xyz/tags/Video/"/>
    
    <category term="Audio" scheme="https://jedsek.xyz/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p1~&gt; 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p1"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p1</id>
    <published>2022-10-22T14:42:00.000Z</published>
    <updated>2022-10-22T14:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 gstreamer 的系列, 学习如何处理音视频</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 gstreamer 的系列, 学习如何处理音视频&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GStreamer" scheme="https://jedsek.xyz/tags/GStreamer/"/>
    
    <category term="Video" scheme="https://jedsek.xyz/tags/Video/"/>
    
    <category term="Audio" scheme="https://jedsek.xyz/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p4~&gt; GObject: 子类化</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p4"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p4</id>
    <published>2022-10-09T14:52:26.000Z</published>
    <updated>2022-10-09T14:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p><h1 id="mu-lu-jie-gou">目录结构</h1><p>gtk 基于 glib, 而 glib 最让人印象深刻的地方, 又是其 <code>Gobject System</code><br>众所周知, C 是一套面向过程的语言, 但基于 C 的 glib库, 却通过高超的思想, 提供了面向对象的支持</p><p>在这样一个面向对象, 依赖继承的体系中, 我们可以通过子类化(Subclassing)来创建新的自定义的 GObject<br>让我们保持这样子的目录结构:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">src</span></span><br><span class="line">├── custom_button</span><br><span class="line">│   ├── imp<span class="selector-class">.rs</span></span><br><span class="line">│   └── mod<span class="selector-class">.rs</span></span><br><span class="line">└── <span class="selector-tag">main</span>.rs</span><br></pre></td></tr></table></figure><p>在 glib 中, 我们将通过创建两个结构体来创建一个子类<br>我们将会创建一个新的 GObject, 通过继承成为 <code>gtk::Button</code> 的子类, 以此添加一些自定义的功能</p><hr><h1 id="zi-lei-hua">子类化</h1><p>如上面的目录结构所示, 我们定义了一个叫 <code>custom_button</code> 的模块, 在 <code>mod.rs</code> 中将 <code>CustomButton</code> 暴露给外部<br>其实这就是 C 语言中实现子类化的模板, 我们将遵循这个规则, 通过定义两个 struct 来描述子类:</p><ul class="lvl-0"><li class="lvl-2"><p><code>imp.rs</code> 被用来存储自定义的状态, 存储继承自父类待 override 的虚函数</p></li><li class="lvl-2"><p><code>custom_button::imp</code> 是私有模块, <code>custom_button::imp::CustomButton</code> 也是私有的</p></li><li class="lvl-2"><p><code>custom_button::imp::CustomButton</code> 将被暴露给外界的 <code>custom_button::CustomButton</code> 使用, 作为其养料</p></li></ul><p>简单来说, 我们正在利用模块, 对子类化的 GObject 的功能进行分门别类, 让其定义更加清晰罢了</p><p>下面是具体代码, 直接抄书:</p><figure class="highlight rust"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::glib;</span><br><span class="line"><span class="keyword">use</span> gtk::subclass::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object holding the state</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomButton</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The central trait for subclassing a GObject</span></span><br><span class="line"><span class="meta">#[glib::object_subclass]</span></span><br><span class="line"><span class="keyword">impl</span> ObjectSubclass <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="keyword">const</span> NAME: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Type</span></span> = super::CustomButton;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ParentType</span></span> = gtk::Button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all GObjects</span></span><br><span class="line"><span class="keyword">impl</span> ObjectImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all widgets</span></span><br><span class="line"><span class="keyword">impl</span> WidgetImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all buttons</span></span><br><span class="line"><span class="keyword">impl</span> ButtonImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br></pre></td></tr></table></figure><p>先前也说了, 模块 <code>imp.rs</code> 的作用便是描述一个子类, 负责新添加的状态与待覆写的虚函数<br>对于某个子类 GObject 的描述, 在 <code>ObjectSubclass</code> 中:</p><ul class="lvl-0"><li class="lvl-2"><p><code>NAME</code>: 该 GObject 的名字, 为避免命名冲突, 应使用 crate-name 与 object-name 组成 (UpperCamelCase)</p></li><li class="lvl-2"><p><code>Type</code>: 指之后将被创建的, 实际的 GObject</p></li><li class="lvl-2"><p><code>ParentType</code>: 我们继承的那个父类 GObject</p></li></ul><p>你可能会疑惑, 这个 <code>Name</code> 与 <code>Type</code> 是什么鬼, 就不能直接用 <code>Type (我们在Rust中实际创建的类型)</code> 作为 <code>NAME</code> 吗?</p><p>别忘了, gtk 是一套跨语言的通用 GUI 框架, 拥有几十种语言的绑定, 设计必然不能拘泥在一种语言上, 即使对 C 也不例外<br>不同语言自有不同命名规范, 必然得先统一风格, 比如之后会学习的 <code>.ui</code> 为后缀的 xml 文件, 可以用来描述界面, 这可是不管哪个语言都通用的啊<br>因此 <code>NAME</code> 是用来描述其名字, 而 <code>Type/ParentType</code> 则是特定于语言的某一个类型 (此处是Rust中的 <code>CustomButton</code>/<code>gtk::Button</code>)</p><p>再提一嘴, 之后将学习的以 <code>.ui</code> 为后缀的 xml 文件, 可以创建 GtkBuilder template class(模板类), 像下面这样去描述界面:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">class</span>=<span class="string">&quot;GtkAppWindow&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;GtkApplicationWindow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span>My GTK App<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 此处使用 `CustomButton` 指定 widget 的类型 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;CustomButton&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button_1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span>&gt;</span>Press me!<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-top&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-bottom&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-start&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-end&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可能还会在之后对 gtk 框架的一些地方感到疑惑, 因此请记住: gtk 是一套通用的 gui 框架, 不止是为一种语言服务的</p><p>接下来是将暴露给外界的 <code>CustomButton</code>:</p><figure class="highlight rust"><figcaption><span>src/custom_button/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> glib::Object;</span><br><span class="line"><span class="keyword">use</span> gtk::glib;</span><br><span class="line"></span><br><span class="line">glib::wrapper! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomButton</span></span>(ObjectSubclass&lt;imp::CustomButton&gt;)</span><br><span class="line">        @extends gtk::Button, gtk::Widget,</span><br><span class="line">        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CustomButton &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">with_label</span></span>(label: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Object::new(&amp;[(<span class="string">&quot;label&quot;</span>, &amp;label)])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>glib::wrapper!</code> 顾名思义, 能帮我们将 <code>imp::CustomButton</code> 进行包装, 自动生成相关实现, 避免大量样例代码, 我们只需指明其继承情况即可:</p><ul class="lvl-0"><li class="lvl-2"><p><code>@extends</code>: 指明所有父类 GObject</p></li><li class="lvl-2"><p><code>@implements</code>: 指明所有实现的 Interface (在 Rust 中是 Trait)</p></li><li class="lvl-2"><p><code>imp::CustomButton</code>: 经过宏成为了被暴露的 <code>CustomButton</code> 的 inner 成员</p></li><li class="lvl-2"><p><code>with_label</code>: 添加了自己的将被暴露的新方法, 设置了 GObject 的 property (<code>Object::new</code> 的返回值是泛型, 此处会自动推导为 <code>Self</code>)</p></li></ul><p>我们可以通过 <a href="https://docs.gtk.org/gtk4/class.Button.html#hierarchy">docs/gtk/hierarchy</a> 来查看某个 GObject 的继承链情况</p><p>现在, <code>CustomButton</code> 实际上已经与 <code>gtk::Button</code> 一样了, 因此我们可以直接用其替换 <code>Button</code>:</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> custom_button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> custom_button::CustomButton;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> button = CustomButton::with_label(<span class="string">&quot;Press me!&quot;</span>);</span><br><span class="line">    button.set_margin_top(<span class="number">12</span>);</span><br><span class="line">    button.set_margin_bottom(<span class="number">12</span>);</span><br><span class="line">    button.set_margin_start(<span class="number">12</span>);</span><br><span class="line">    button.set_margin_end(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> window = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My GTK App&quot;</span>)</span><br><span class="line">        .child(&amp;button)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    window.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>mold -run cargo run</code>, 你会见识一模一样的效果 😃</p><hr><h1 id="zi-ding-yi">自定义</h1><p>没错, 这还不够, 如果费劲心思搞出来的子类只是和父类一般, 那就没必要搞了, 很简单的道理不是吗?<br>令人兴奋的是, 我们还可以保存状态, 覆写虚函数!</p><p>下面是例子, 直接抄书, 我们将只覆写其中两个虚函数:</p><figure class="highlight rust"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gtk::glib;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::subclass::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object holding the state</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomButton</span></span> &#123;</span><br><span class="line">    number: Cell&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The central trait for subclassing a GObject</span></span><br><span class="line"><span class="meta">#[glib::object_subclass]</span></span><br><span class="line"><span class="keyword">impl</span> ObjectSubclass <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="keyword">const</span> NAME: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Type</span></span> = super::CustomButton;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ParentType</span></span> = gtk::Button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all GObjects</span></span><br><span class="line"><span class="keyword">impl</span> ObjectImpl <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">constructed</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.parent_constructed();</span><br><span class="line">        <span class="keyword">self</span>.obj().set_label(&amp;<span class="keyword">self</span>.number.get().to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all widgets</span></span><br><span class="line"><span class="keyword">impl</span> WidgetImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all buttons</span></span><br><span class="line"><span class="keyword">impl</span> ButtonImpl <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clicked</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number.set(<span class="keyword">self</span>.number.get() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.obj().set_label(&amp;<span class="keyword">self</span>.number.get().to_string())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为 <code>imp::CustomButton</code> 添加了一个状态, 也就是其成员 <code>number</code>, 随后覆写了两个虚函数<br>(覆写构造函数时, 还得记得调用一下父类的构造函数, 完成整个构造链)</p><p>在被覆写的函数中, 我们都调用了 <code>self.obj()</code>, 你可以观察一下其签名:</p><figure class="highlight rust"><figcaption><span>glib::subclass::types::obj</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">obj</span></span>(&amp;<span class="keyword">self</span>) -&gt; crate::BorrowedObject&lt;Self::Type&gt;</span><br></pre></td></tr></table></figure><p>还记得 <code>Self::Type</code> 是什么吗? 没错, 就是被暴露的那个 <code>CustomButton</code>, 而非 <code>imp::CustomButton</code>, 它才是被使用的真正实例(instance)<br>此处的 <code>obj()</code> 方法, 其别名就是 <code>instance()</code>, 得到的是在 <code>main.rs</code> 中被创建的那个真正实例的引用</p><p>顺便再复习一下, 防止有人看见这里而感疑惑: 为什么是 <code>clicked(&amp;self)</code> 而非 <code>clicked(&amp;mut self)</code>, 这样不应该更方便吗?<br>这是因为每个 GObject 都是引用计数的, 所以能绕过编译器的检查(全是不可变借用), 之前提到过了</p><p>经过覆写虚函数, <code>CustomButton</code> 终于出现了有别于父类 <code>Button</code> 的新特性:</p><ul class="lvl-0"><li class="lvl-2"><p>被构造时: 初始化 label 为自己存储的状态数字</p></li><li class="lvl-2"><p>被点击时: 会让存储的状态数字+1, 随后更新 label</p></li></ul><p>现在调用 <code>mold -run cargo run</code>, 你将得到一个按钮, 按钮的 label 初始时为 0, 被点击后不断+1</p><hr><h1 id="shi-yong-qing-kuang">使用情况</h1><p>什么情况下适合使用 <code>glib::wrapper</code> 来模拟继承呢 (Rust 语言层面上不支持继承, 因此叫模拟)</p><ul class="lvl-0"><li class="lvl-2"><p>使用一个 widget, 其添加了自定义状态与覆写虚函数</p></li><li class="lvl-2"><p>将 Rust 对象传递给要求参数是 GObject 的函数 (因为 gtk 不只是 Rust 的GUI框架, 还是其他许多语言的 GUI 框架)</p></li><li class="lvl-2"><p>为某个对象添加 property 或 signal, 继承 glib 体系下的强大力量 (下面几节会讲)</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p3~&gt; python基础语法-part1</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p3"/>
    <id>https://jedsek.xyz/posts/high-school-it/p3</id>
    <published>2022-09-12T03:45:45.000Z</published>
    <updated>2022-09-12T03:45:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正式的对python语法的学习, 包含常见库函数的使用</p></blockquote><span id="more"></span><p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href="/posts/high-school-it/p2">p2: 基础科普与环境搭建</a><br><strong>感谢:</strong><br>本文的切片部分来源于 <a href="https://zhuanlan.zhihu.com/p/79541418">python切片完全指南(语法篇)</a>, 已经过原作者准许</p><h1 id="bian-liang-yu-fu-zhi">变量与赋值</h1><p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p><p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p><p>有两个概念:</p><ul class="lvl-0"><li class="lvl-2"><p>声明变量:  创建变量 (声明一个变量出现了)</p></li><li class="lvl-2"><p>赋值: 把一个值装到箱子(变量)里</p></li></ul><p>比如, 一个很简单的例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p><p>变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同</p><p>你也可以这样:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure><p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>第二行表示, 把a里面的数值取出来, 传给了b</p><p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">d = e = f = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a,b,c = d,e,f</span><br></pre></td></tr></table></figure><p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p><p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure><p>你可能会疑惑:<br>当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>该想法对应的代码是这样的:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = b</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure><p>但在交换数值的代码中, 你应该这样理解:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">_t1 = b</span><br><span class="line">_t2 = a</span><br><span class="line">a = _t1</span><br><span class="line">b = _t2</span><br></pre></td></tr></table></figure><p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了<br>现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p><p>另外 选择题会出现这样的常见选项:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.  a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">B.  a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">C.  a = <span class="number">1</span>; b = <span class="number">2</span>; c = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已</p><hr><h1 id="bian-liang-ming-ming-gui-fan">变量命名规范</h1><p>python中, 变量的命名必须符合规范, 不然直接报错<br>在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p><p>命名规范如下:</p><ul class="lvl-0"><li class="lvl-2"><p>变量名由字母, 数字, 下划线组成</p></li><li class="lvl-2"><p>不能由数字开头</p></li><li class="lvl-2"><p>中间不能有空格分割</p></li><li class="lvl-2"><p>不能与python中的关键字重名</p></li></ul><p>以下都是合法的变量名</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">abada</span><br><span class="line">asd111231</span><br><span class="line">ad190123kkad</span><br><span class="line">asd_asd1_asd2</span><br><span class="line">_123daa</span><br><span class="line">_as11</span><br></pre></td></tr></table></figure><p>以下是不合法的变量名:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span></span></span><br><span class="line"><span class="function"><span class="title">not</span></span></span><br><span class="line"><span class="function"><span class="title">in</span></span></span><br><span class="line"><span class="function"><span class="title">lambda</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1123</span></span><br><span class="line"><span class="function">123<span class="title">adad</span></span></span><br><span class="line"><span class="function"><span class="title">sad</span>;;-``</span></span><br><span class="line"><span class="function">``?/</span></span><br><span class="line"><span class="function">&#x27;,</span></span><br></pre></td></tr></table></figure><p><strong>关键字:</strong><br>关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p><p>你怎么知道哪些是关键字呢? 慢慢看吧, 像 <code>def/import/for/if/break</code> 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字</p><hr><h1 id="zhu-shi">注释</h1><h2 id="zuo-yong" id="作用">作用</h2><p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  此时 a 的值为 <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure><p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p><p>再举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"><span class="built_in">max</span> = -<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = a</span><br><span class="line"><span class="keyword">elif</span> b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">max</span> = c</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p><h2 id="dan-duo-xing-zhu-shi" id="单-多行注释">单/多行注释</h2><p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 12345</span></span><br><span class="line"><span class="comment"># 上山打老虎</span></span><br><span class="line"><span class="comment"># 老虎打不着</span></span><br><span class="line"><span class="comment"># 打到小松鼠</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">12345</span></span><br><span class="line"><span class="string">上山打老虎</span></span><br><span class="line"><span class="string">老虎打不着</span></span><br><span class="line"><span class="string">打到小松鼠</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p><hr><h1 id="ji-ben-shu-ju-lei-xing">基本数据类型</h1><p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p><p>为了模拟现实, py将数据进行了抽象与分类:</p><ul class="lvl-0"><li class="lvl-2"><p>int: 对应整数</p></li><li class="lvl-2"><p>float: 对应实数</p></li><li class="lvl-2"><p>string: 对应文字</p></li><li class="lvl-2"><p>bool: 对应真与假</p></li></ul><p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p><p>举些例子:</p><ul class="lvl-0"><li class="lvl-2"><p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p></li><li class="lvl-2"><p>我的年龄是16岁: 用int来表示 16 这个数字</p></li><li class="lvl-2"><p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p></li></ul><p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>你可以这样抽象:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student &#123;</span><br><span class="line">  age:  <span class="built_in">int</span>,</span><br><span class="line">  height: <span class="built_in">float</span>,</span><br><span class="line">  name: string,</span><br><span class="line">  fat_or_not: <span class="built_in">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p><hr><h1 id="yun-suan-fu-yu-you-xian-ji">运算符与优先级</h1><p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>在以下的图表中, 优先级1是最高, 数字越大优先级越低</p><h2 id="suan-zhu-yun-suan-fu" id="算术运算符">算术运算符</h2><p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>优先级</th></tr></thead><tbody><tr><td>**</td><td>x的y次方</td><td>x**y</td><td>1</td></tr><tr><td>*</td><td>x乘以y</td><td>x*y</td><td>2</td></tr><tr><td>/</td><td>x除以y, 产生实数值</td><td>x/y</td><td>2</td></tr><tr><td>//</td><td>x除以y, 产生整数值</td><td>x//y</td><td>2</td></tr><tr><td>%</td><td>x除以y, 取余数</td><td>x%y</td><td>2</td></tr><tr><td>+</td><td>x加y</td><td>x+y</td><td>3</td></tr><tr><td>-</td><td>x减y</td><td>x-y</td><td>3</td></tr></tbody></table><p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p><p>算术运算符, 可以与赋值运算符相互结合:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span>  <span class="comment"># 是上面的等价物</span></span><br></pre></td></tr></table></figure><p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p><h2 id="guan-xi-yun-suan-fu" id="关系运算符">关系运算符</h2><p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&gt;</td><td>x 大于 y</td><td>x &gt; y</td></tr><tr><td>&lt;</td><td>x 小于 y</td><td>x &lt; y</td></tr><tr><td>&gt;=</td><td>x 大于等于 y</td><td>x &gt;= y</td></tr><tr><td>&lt;=</td><td>x 小于等于 y</td><td>x &lt;= y</td></tr><tr><td>==</td><td>x 等于 y</td><td>x == y</td></tr><tr><td>!=</td><td>x 不等于 y</td><td>x != y</td></tr></tbody></table><p><strong>注:</strong><br>本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p><hr><h1 id="ji-ben-shu-ju-jie-gou">基本数据结构</h1><p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p><p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p><p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>当然, 我们此处仅学习基本数据结构</p><h2 id="lie-biao" id="列表">列表</h2><p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p><h3 id="dan-suo-yin" id="单索引">单索引</h3><p>我们可以通过单个索引, 访问对应的单个元素</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有着 3 个元素的列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]  <span class="comment"># 300</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]  <span class="comment"># 400</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>]  <span class="comment"># 500</span></span><br></pre></td></tr></table></figure><p><strong>扩展: 为何 index 从 0 开始?</strong><br>因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p><p>你可以这样理解:<br>一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p><p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>如何访问第 1 个格子? 第一个格子向右跳 0 格<br>如何访问第 2 个格子? 第二个格子向右跳 1 格<br>如何访问第 3 个格子? 第三个格子向右跳 2 格</p><p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p><p>如果你非要把下标从 1 开始, 那就得这样:<br>list[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p><p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br><s>(好吧, 原因其实真的只是因为习俗)</s></p><p>而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 😃</p><p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p><p>举个例子, 已知 <code>a = [10, 20, 30, 40, 50]</code> 让我们将其与图表进行对立:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>元素</td><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td></tr><tr><td>正索引</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>负索引</td><td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td></tr></tbody></table><p>显而易见的, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p><h3 id="suo-yin-yue-jie" id="索引越界">索引越界</h3><p>于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:</p><figure class="highlight python"><figcaption><span>demo.py</span></figcaption><table><tr><td class="code"><pre><span class="line">a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">a[<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>当我们在命令行中执行 <code>python demo.py</code> (见 <a href="/posts/high-school-it/p2#huan-jing-da-jian">p2: 基础科普#环境搭建</a> ) 或直接使用图形化工具, 点击运行按钮</p><p>脑子想一想都知道肯定编译不过, 我们将得到以下报错:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;/home/jedsek/a.py&quot;</span>, <span class="built_in">line</span> <span class="number">2</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">a</span>[<span class="number">5</span>]</span><br><span class="line">    ~^^^</span><br><span class="line">IndexError: <span class="keyword">list</span> <span class="built_in">index</span> out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure><p>看不懂的直接像做玩英语完形一样当作 “哔(屏蔽词)” 跳过就好, index 是 “索引/下标的意思”, 这条报错表示, 下标越界了!<br>因为 a 是个长度为 5 的列表, 所以只能用 <code>n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)</code> 来当下标, 即 0 到 4, 因此 5 是非法的<br>负索引也是一样的道理, 不能越界哟~~</p><h3 id="qie-pian" id="切片">切片</h3><p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>]  <span class="comment"># 定义列表</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">4</span>]  <span class="comment"># [201, 202, 203, 204]</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># [201, 202]</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">1</span>]  <span class="comment"># [201]</span></span><br></pre></td></tr></table></figure><p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p><p>图表依然会较为直观:</p><p><code>numbers = [201, 202, 203, 204]</code></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>切片</td><td>对应索引</td><td>取出的子列表</td></tr><tr><td>0:4</td><td>[0, 1, 2, 3]</td><td>[201, 202, 203, 204]</td></tr><tr><td>0:2</td><td>[0, 1]</td><td>[201, 202]</td></tr><tr><td>0:1</td><td>[0]</td><td>[201]</td></tr><tr><td>-3:-1</td><td>[-3, -2]</td><td>[202, 203]</td></tr></tbody></table><p>默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 <code>numbers[0:4:1]</code> 就相当于 <code>numbers[0:4]</code><br>而 <code>numbers[0:4:2]</code> 则相当于从 <code>[0, 1, 2, 3]</code> 中的第一个元素 <code>0</code> 开始, 作为下标取 numbers 的元素, 然后走两步到 <code>2</code>, 依次类推<br>步长不能设置为 0, 不然会报错</p><p>有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 <code>[]</code><br>举个例子: <code>numbers[3:2]</code> 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分</p><h3 id="sheng-lue-yu-mo-ren-zhi" id="省略与默认值">省略与默认值</h3><p>关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 😃</p><p>已知 <code>a = [10, 20, 30, 40, 50]</code>, 你可以使用 <code>a[start:stop:step]</code> 来表示 a 的切片, 其中 start/stop/step 都是可以省略的<br>当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 <code>a[start:stop]</code>/<code>a[start:stop:]</code> 的形式时, 步长会使用默认值1</p><p>而对于 <code>start/stop</code> 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取<br>举些例子, 已知 <code>a = [10, 20, 30, 40, 50, 60, 70]</code>:</p><ul class="lvl-0"><li class="lvl-2"><p><code>a[2:5:1]</code> 中, <code>2:4</code> 对应的下标是 <code>[2, 3, 4]</code>, 索引对应的元素是 <code>[30, 40, 50]</code>, 因为步长为1, 所以结果直接就是 <code>[30, 40, 50]</code></p></li><li class="lvl-2"><p><code>a[2::1]</code> 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 <code>[30, 40, 50, 60, 70]</code></p></li><li class="lvl-2"><p><code>a[:2:1]</code> 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 <code>[10, 20]</code></p></li><li class="lvl-2"><p><code>a[2::-1]</code> 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 <code>[30, 20, 10]</code></p></li><li class="lvl-2"><p><code>a[:2:-1]</code> 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 <code>[70, 60, 50, 40]</code></p></li></ul><p>什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:</p><ul class="lvl-0"><li class="lvl-2"><p><code>start</code> 代表列表中某个元素的下标, 这个元素是切片的起头</p></li><li class="lvl-2"><p><code>stop</code> 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)</p></li><li class="lvl-2"><p><code>step</code> 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取</p></li></ul><p>要开始了哦, 超级直观的方法:</p><p>以 <code>a[2:5:1]</code> 为例:</p><ul class="lvl-0"><li class="lvl-2"><p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p></li><li class="lvl-2"><p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p></li><li class="lvl-2"><p>因为 <code>stop</code> 是 <code>5</code>, 所以箭头的终点是 <code>50</code> (箭头从 60 逆方向缩一格): [10, 20, <s>30, 40, 50</s>&gt;, 60, 70]</p></li></ul><p>以 <code>a[2::1]</code> 为例:</p><ul class="lvl-0"><li class="lvl-2"><p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p></li><li class="lvl-2"><p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p></li><li class="lvl-2"><p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p></li></ul><p>以 <code>a[:2:1]</code> 为例:</p><ul class="lvl-0"><li class="lvl-2"><p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p></li><li class="lvl-2"><p>因为 <code>start</code> 被省略, 所以箭头的起点在左边的无限远处, 不用动: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p></li><li class="lvl-2"><p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>20</code> (箭头从 30 逆方向缩一格): <s>[10, 20</s>&gt;, 30, 40, 50, 60, 70]</p></li></ul><p>以 <code>a[2::-1]</code> 为例:</p><ul class="lvl-0"><li class="lvl-2"><p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p></li><li class="lvl-2"><p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p></li><li class="lvl-2"><p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p></li></ul><p>以 <code>a[:2:-1]</code> 为例:</p><ul class="lvl-0"><li class="lvl-2"><p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p></li><li class="lvl-2"><p>因为 <code>start</code> 被省略, 所以箭头的起点在右边的无限远处, 不用动: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p></li><li class="lvl-2"><p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>40</code> (箭头从 30 逆方向缩一格): [10, 20, 30, &lt;<s>40, 50, 60, 70]</s></p></li></ul><p>对于负索引也是一样的道理, 先确定好 <code>start</code> 与 <code>stop</code> 的位置, 然后根据步长画对应方向的箭头<br>照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行<br>最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可</p><hr><h2 id="zi-dian" id="字典">字典</h2><p>python 中的字典, 实际上就是一些键值对组成的集合<br>键值对, 指的就是根据某个键值, 获取其对应的另外一个值</p><p>举个例子:</p><ul class="lvl-0"><li class="lvl-2"><p>名字: “小明”</p></li><li class="lvl-2"><p>年龄(year): 16</p></li><li class="lvl-2"><p>身高(cm): 178</p></li></ul><p>名字 -&gt; “小明”, 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了</p><p>在 python 中, 你可以用一对花括号来定义字典:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;Shadd&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;Lasd&#x27;</span>: <span class="number">111</span>, <span class="string">&#x27;PPqwea&#x27;</span>: <span class="number">899</span>&#125;</span><br></pre></td></tr></table></figure><p>冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  <code>a['Shadd']</code> 将得到 <code>10</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;正式的对python语法的学习, 包含常见库函数的使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p2~&gt; 基础科普</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p2"/>
    <id>https://jedsek.xyz/posts/high-school-it/p2</id>
    <published>2022-09-11T12:51:16.000Z</published>
    <updated>2022-09-11T12:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p></blockquote><span id="more"></span><p><strong>注意:</strong><br>本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p><h1 id="bian-yi-yu-jie-shi">编译与解释</h1><p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>c/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p><p>反正记住一点:<br>机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 <code>.exe</code> 结尾的文件<br>我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p><p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p><p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p><p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p><p><strong>代码:</strong><br>代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p><p><strong>文件后缀:</strong><br>文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p><p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>windows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p><p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p><p>如何显示文件后缀?<br>按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p><hr><h1 id="python-de-te-dian">Python的特点</h1><ul class="lvl-0"><li class="lvl-2"><p>是一门 <ins>高级语言</ins></p></li><li class="lvl-2"><p>是一门 <ins>面向对象</ins> 的语言</p></li><li class="lvl-2"><p>是一门 <ins>解释型</ins> 语言</p></li><li class="lvl-2"><p>语法简单, 拥有丰富强大的库, 适合快速开发</p></li></ul><p><strong>高级语言</strong><br>计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p><ul class="lvl-0"><li class="lvl-2"><p>机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</p></li><li class="lvl-2"><p>汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</p></li><li class="lvl-2"><p>高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</p></li></ul><p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p><p><strong>面向对象</strong><br>假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>(非严谨版, 勿喷, 只是快速了解而已)</p><p><strong>库:</strong><br>当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p><hr><h1 id="huan-jing-da-jian">环境搭建</h1><p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br><s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p><p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href="https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe">安装程序</a><br>至于出现安装界面后点哪里, 你就记住两个地方:</p><ul class="lvl-0"><li class="lvl-2"><p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p></li><li class="lvl-2"><p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p></li></ul><p>如何检验自己是否安装成功?<br>请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p><p>请输入以下命令, 检验python是否安装成功:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span>  --<span class="keyword">version</span></span><br></pre></td></tr></table></figure><p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>它应该会输出类似下面的文字:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Python</span> <span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p><div class="tips"><p><strong>命令与路径</strong><br>这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>粗体闪烁的光标前的提示符, 表示你当前处于的路径</p><p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>比如, 敲下 “C:\asdiasdadows\asdadtem32\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p><p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\asdad\xxx.exe” 该怎么办呢?<br>这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p><p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p><p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>因此, 出现了这个黑框框 😃</p><p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p></div><hr><h1 id="idle-de-bei-hou-yuan-li">idle的背后原理</h1><p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p><p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p><p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p><p>整个过程如下:</p><ul class="lvl-0"><li class="lvl-2"><p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href="http://xxx.py">xxx.py</a>”</p></li><li class="lvl-2"><p>在 cmd 中输入: <code>python xxx.py</code></p></li></ul><hr><h1 id="hello-world">Hello world!</h1><p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p><div class="tips"><p><strong>注意:</strong><br>这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p></div><p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>随后打开cmd/终端, 你的当前路径应该是 “C:\Users\用户名”<br>我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br><span class="line">python first_app.txt</span><br></pre></td></tr></table></figure><p>这将会打印:</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p><p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p><p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p><p>但还是有个问题<br>那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p><p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p><p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p><p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>windows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p><p>python是可以调用外部命令的!</p><p>你可以在 first_app.py 中, 这样改进你的代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br><code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p><p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p1~&gt; 数据与信息</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p1"/>
    <id>https://jedsek.xyz/posts/high-school-it/p1</id>
    <published>2022-09-10T13:05:57.000Z</published>
    <updated>2022-09-10T13:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p></blockquote><span id="more"></span><p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p><h1 id="shu-ju-de-ding-yi">数据的定义</h1><p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p><ul class="lvl-0"><li class="lvl-2"><p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p></li><li class="lvl-2"><p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p></li></ul><p>上面的两种情况中:</p><ul class="lvl-0"><li class="lvl-2"><p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p></li><li class="lvl-2"><p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p></li></ul><p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p><hr><h1 id="xin-xi-de-ding-yi">信息的定义</h1><p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p><p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p><ul class="lvl-0"><li class="lvl-2"><p>这是一台电脑笔记本</p></li><li class="lvl-2"><p>这是一台屏幕大小为15.6英寸的电脑笔记本</p></li><li class="lvl-2"><p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p></li><li class="lvl-2"><p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p></li></ul><p>你会看到, 信息越多, 越能消除随机不确定性</p><hr><h1 id="xin-xi-de-te-zheng">信息的特征</h1><p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p><p>下面是信息的5个特征, 教科书上搬的:</p><ul class="lvl-0"><li class="lvl-2"><p>载体依附性<br>信息不能独立存在, 它是虚的, 必须有载体<br>比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p></li><li class="lvl-2"><p>不损耗性信息在传播的过程中, 是不会发生损耗的</p></li><li class="lvl-2"><p>时效性<br>信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p></li><li class="lvl-2"><p>共享性<br>信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p></li><li class="lvl-2"><p>可加工处理性/真伪性<br>信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>在比如 <code>盲人摸象/管中窥豹</code>, 都体现了真伪性</p></li><li class="lvl-2"><p>价值性<br>比如天气预报让你出门避免被雨淋湿, 这就是价值<br>对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p></li></ul><hr><h1 id="zhi-shi-de-ding-yi">知识的定义</h1><p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的<br>指的是人们已经掌握的能力</p><p>这部分很简单, 简单概述即可, 但请注意不要与下面的 <code>智慧的定义搞错了</code></p><hr><h1 id="zhi-hui-de-ding-yi">智慧的定义</h1><p>一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力</p><hr><h1 id="zong-jie">总结</h1><p>以下是一个很好的, 对三者进行了区分的例子:</p><ul class="lvl-0"><li class="lvl-2"><p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p></li><li class="lvl-2"><p>信息: 人们知道圆周率就是3.1415926</p></li><li class="lvl-2"><p>知识: 人们知道如何求解圆的面积来解决现实问题</p></li><li class="lvl-2"><p>智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术</p></li></ul><p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>clap-rs 简介</title>
    <link href="https://jedsek.xyz/posts/rust-clap/intro"/>
    <id>https://jedsek.xyz/posts/rust-clap/intro</id>
    <published>2022-08-16T12:03:34.000Z</published>
    <updated>2022-08-16T12:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p></blockquote><span id="more"></span><p>前置知识: Rust基础<br>完整代码: <a href="https://github.com/Jedsek/rust-wc">github/jedsek/rust-wc</a></p><p><strong>注意</strong><br>本项目基于当前最新版本的 clap, 也就是 version 4<br>本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p><p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>官方教程: <a href="https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html">derive tutorial</a><br>官方资料: <a href="https://docs.rs/clap/latest/clap/_derive/index.html">derive reference</a></p><h1 id="cheng-pin-zhan-shi">成品展示</h1><p>你可以通过如下命令, 从 <a href="https://crates.io">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install rust-wc</span><br></pre></td></tr></table></figure><p>以下是使用 <a href="https://asciinema.org/">asciinema</a> 录制的展示:</p><script id="asciicast-534647" src="https://asciinema.org/a/534647.js" async></script><hr><h1 id="ji-chu-gai-nian">基础概念</h1><p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p><p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p><p><strong>注意:</strong><br>cli 可以代表抽象的界面, 也可以指代具体的某个程序<br>后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p><p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p><ul class="lvl-0"><li class="lvl-2"><p><code>参数(Arguments)</code>:<br>传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p></li><li class="lvl-2"><p><code>选项(Options)</code>:<br>通常以单/双横杠开头, 不同的options表示不同的行为<br>比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p></li><li class="lvl-2"><p><code>子命令(Subcommands)</code>:<br>一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p></li><li class="lvl-2"><p><code>双横杠(--)</code>:<br>在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p></li><li class="lvl-2"><p><code>短/长帮助(short/long help)</code>:<br>有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p></li></ul><hr><h1 id="chu-shi-pei-zhi">初始配置</h1><p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>请自行创建好目录:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">./rust-wc</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">   ├── wc_result.rs   <span class="meta"># 计算并存储结果</span></span><br><span class="line">   ├── <span class="keyword">cli</span>.rs         <span class="meta"># 命令行的定义</span></span><br><span class="line">   ├── files.rs       <span class="meta"># 读取文件</span></span><br><span class="line">   ├── lib.rs         <span class="meta"># 声明模块, 类型别名</span></span><br><span class="line">   └── main.rs</span><br></pre></td></tr></table></figure><p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p><figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust-wc&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class="line"><span class="section">[[bin]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rwc&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/main.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定依赖</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clap</span> = &#123;version = <span class="string">&quot;4.0.8&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>]&#125;      <span class="comment"># 解析参数</span></span><br><span class="line"><span class="attr">unicode-width</span> = <span class="string">&quot;0.1.10&quot;</span>                               <span class="comment"># 计算 Unicode 字符宽度</span></span><br><span class="line"><span class="attr">indicatif</span> = <span class="string">&quot;0.17.1&quot;</span>                                   <span class="comment"># 进度条</span></span><br><span class="line"><span class="attr">prettytable-rs</span> = <span class="string">&quot;0.9.0&quot;</span>                               <span class="comment"># 打印表格</span></span><br><span class="line"><span class="attr">rayon</span> = <span class="string">&quot;1.5.3&quot;</span>                                        <span class="comment"># 并行化</span></span><br></pre></td></tr></table></figure><p>以下是 <a href="http://lib.rs">lib.rs</a> 的内容:</p><figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cli;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> files;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> wc_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Counts</span></span> = <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure><hr><h1 id="ming-ling-ding-yi">命令定义</h1><p><strong>注意:</strong><br>clap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p><p>让我们来想象下这个命令:</p><ul class="lvl-0"><li class="lvl-2"><p>必须接受一个参数</p></li><li class="lvl-2"><p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p></li><li class="lvl-2"><p>根据启用的 flag 来决定计算并打印哪些东西</p></li></ul><p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p><figure class="highlight rust"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span>  <span class="comment">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    author, version, about,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest_line&quot;</span>]</span>)),</span><br><span class="line">    subcommand_negates_reqs = <span class="literal">true</span>,</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the byte counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the character counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> chars: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the word counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> words: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the line counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> lines: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the maximum line width (Unicode)</span></span><br><span class="line">    <span class="meta">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[command(subcommand)]</span></span><br><span class="line">    <span class="keyword">pub</span> sub_commands: <span class="built_in">Option</span>&lt;SubCommands&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Subcommand)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubCommands</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Enabled all available options</span></span><br><span class="line">    All &#123;</span><br><span class="line">        <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">        <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">        paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_path</span></span>(filename: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PathBuf, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = PathBuf::from(filename);</span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cli &#123;</span><br><span class="line">    <span class="comment">// 开启所有的 options</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">enable_all_options</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.bytes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.chars = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.words = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.lines = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.longest_line = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_enabled_options</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> enabled_options = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.bytes.then(|| enabled_options.push(<span class="string">&quot;Bytes&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.chars.then(|| enabled_options.push(<span class="string">&quot;Chars&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.words.then(|| enabled_options.push(<span class="string">&quot;Words&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.lines.then(|| enabled_options.push(<span class="string">&quot;Lines&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.longest_line.then(|| enabled_options.push(<span class="string">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class="line"></span><br><span class="line">        enabled_options</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p><p>clap 以及为我们做好了一切 😃</p><p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> rust_wc::&#123;cli::Cli, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cli = Cli::parse();</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wen-dang-zhu-shi-yu-bang-zhu" id="文档注释与帮助">文档注释与帮助</h2><p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo run -- -h</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">A GNU/wc clone written in rust, which <span class="keyword">is</span> super faster when reading <span class="keyword">a</span> large of big <span class="keyword">files</span></span><br><span class="line"></span><br><span class="line">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class="built_in">line</span>&gt; <span class="symbol">&lt;PATH&gt;</span>...</span><br><span class="line">       rwc [PATH]... <span class="symbol">&lt;COMMAND&gt;</span></span><br><span class="line"></span><br><span class="line">Command<span class="variable">s:</span></span><br><span class="line">  <span class="keyword">all</span>   Enabled <span class="keyword">all</span> available <span class="keyword">options</span></span><br><span class="line">  <span class="keyword">help</span>  <span class="keyword">Print</span> this message <span class="built_in">or</span> the <span class="keyword">help</span> of the given subcommand(s)</span><br><span class="line"></span><br><span class="line">Argument<span class="variable">s:</span></span><br><span class="line">  <span class="symbol">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class="line"></span><br><span class="line">Option<span class="variable">s:</span></span><br><span class="line">  -<span class="keyword">b</span>, --bytes         <span class="keyword">Print</span> the byte counts</span><br><span class="line">  -<span class="keyword">c</span>, --chars         <span class="keyword">Print</span> the character counts</span><br><span class="line">  -<span class="keyword">w</span>, --words         <span class="keyword">Print</span> the word counts</span><br><span class="line">  -<span class="keyword">l</span>, --lines         <span class="keyword">Print</span> the <span class="built_in">line</span> counts</span><br><span class="line">  -L, --longest-<span class="built_in">line</span>  <span class="keyword">Print</span> the maximum <span class="built_in">line</span> width (Unicode)</span><br><span class="line">  -h, --<span class="keyword">help</span>          <span class="keyword">Print</span> <span class="keyword">help</span> information</span><br><span class="line">  -V, --<span class="keyword">version</span>       <span class="keyword">Print</span> <span class="keyword">version</span> information</span><br></pre></td></tr></table></figure><p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p><p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    about = <span class="meta-string">&quot;...&quot;</span>,</span></span><br><span class="line"><span class="meta">// ......</span></span><br><span class="line"><span class="meta">// ......</span></span><br></pre></td></tr></table></figure><p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>你可以查看 <a href="https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p><p>你可以像这样将 builder形式 的代码转化为 derive形式:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::new(<span class="string">&quot;myprog&quot;</span>)</span><br><span class="line">    .help_template(<span class="string">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    help_template = <span class="meta-string">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class="line"><span class="meta">// ......</span></span><br><span class="line"><span class="meta">// ......</span></span><br></pre></td></tr></table></figure><p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p><h2 id="xuan-xiang-yu-can-shu-de-sheng-cheng" id="选项与参数的生成">选项与参数的生成</h2><p>clap 能非常方便地以声明的方式, 定义选项/参数</p><h3 id="xuan-xiang" id="选项">选项</h3><p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print the byte counts</span></span><br><span class="line"><span class="meta">#[arg(short, long)]</span></span><br><span class="line"><span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br></pre></td></tr></table></figure><p>它由三部分组成:</p><ul class="lvl-0"><li class="lvl-2"><p>文档注释: help 中对该命令的解释</p></li><li class="lvl-2"><p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p></li><li class="lvl-2"><p>类型为bool: 传入时默认的行为是将其设置为 true</p></li></ul><p>如 help 中所示, 会生成如下内容:</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Options</span>:</span><br><span class="line">  -b, --bytes         <span class="keyword">Print</span> the <span class="keyword">byte</span> counts</span><br></pre></td></tr></table></figure><p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p><p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print the maximum line width (Unicode)</span></span><br><span class="line"><span class="meta">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class="line"><span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br></pre></td></tr></table></figure><h3 id="can-shu" id="参数">参数</h3><p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p><p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The path(s) you should provide</span></span><br><span class="line"><span class="meta">#[arg(value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line"><span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure><p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -b</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The following required arguments were not provided:</span><br><span class="line">  &lt;PATH&gt;...</span><br><span class="line"></span><br><span class="line">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class="line"></span><br><span class="line">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure><p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p><p>因此, 我们来学学如何使用自定义的参数解析器吧</p><h2 id="zi-ding-yi-can-shu-jie-xi-qi" id="自定义参数解析器">自定义参数解析器</h2><p>有些疑问或许会萦绕在你的心头:</p><ul class="lvl-0"><li class="lvl-2"><p>clap 是怎么进行解析的?</p></li><li class="lvl-2"><p>clap 能否将传入的参数, 解析为自定义的类型呢?</p></li><li class="lvl-2"><p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p></li></ul><p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_path</span></span>(filename: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PathBuf, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = PathBuf::from(filename);</span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>该错误会在用户传入非法路径时, 作为报错信息出现:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class="line"></span><br><span class="line">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure><p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>得益于此, 你可以为任何类型定义对应的 parser</p><h2 id="can-shu-guan-xi" id="参数关系">参数关系</h2><p>有时候, 我们可能会面临这样或那样的问题:</p><ul class="lvl-0"><li class="lvl-2"><p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p></li><li class="lvl-2"><p>一个或多个指定的 option(s) 必须被启用</p></li><li class="lvl-2"><p>多个指定的 options 可以同时被启用</p></li></ul><p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p><p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p><p>以我们的 <code>rwc</code> 举个例子:</p><ul class="lvl-0"><li class="lvl-2"><p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p></li><li class="lvl-2"><p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p></li></ul><p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    author, version, about,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest_line&quot;</span>]</span>)),</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p><h2 id="zi-ming-ling" id="子命令">子命令</h2><p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="meta">#[command(subcommand)]</span></span><br><span class="line">    <span class="keyword">pub</span> sub_commands: <span class="built_in">Option</span>&lt;SubCommands&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Subcommand)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubCommands</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Enabled all available options</span></span><br><span class="line">    All &#123;</span><br><span class="line">        <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">        <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">        paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p><p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href="https://github.com/clap-rs/clap/issues/1546">相关issue</a></p><p><strong>注意:</strong><br>这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>但本文还是定义了 subcommand 以便读者了解, 起演示作用</p><hr><h1 id="luo-ji-shi-xian">逻辑实现</h1><p>根据:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">├── wc_result.rs   <span class="meta"># 计算并存储结果</span></span><br><span class="line">├── <span class="keyword">cli</span>.rs         <span class="meta"># 命令行的定义</span></span><br><span class="line">├── files.rs       <span class="meta"># 读取文件</span></span><br></pre></td></tr></table></figure><p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p><figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cli;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> files;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> wc_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Counts</span></span> = <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure><p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p><div class="tabs" id="逻辑实现代码"><ul class="nav-tabs"><li class="tab active"><a href="#逻辑实现代码-1">读取文件</a></li><li class="tab"><a href="#逻辑实现代码-2">进行计算</a></li></ul><div class="tab-content"><div class="tab-pane active" id="逻辑实现代码-1"><figure class="highlight rust"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明依赖</span></span><br><span class="line"><span class="comment">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class="line"><span class="keyword">use</span> crate::&#123;PathWithContent, <span class="built_in">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;BufReader, Read&#125;,</span><br><span class="line">    path::PathBuf,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class="line"><span class="comment">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class="line"><span class="keyword">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> BUFFER_SIZR: <span class="built_in">usize</span> = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class="line"><span class="comment">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class="line"><span class="comment">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PathExt</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">without_dotted_prefix</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_dotted_prefix</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PathExt <span class="keyword">for</span> PathBuf &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">without_dotted_prefix</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.is_relative() &amp;&amp; !<span class="keyword">self</span>.starts_with(<span class="string">&quot;../&quot;</span>) &amp;&amp; !<span class="keyword">self</span>.starts_with(<span class="string">&quot;./&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_dotted_prefix</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = PathBuf::from_iter([OsStr::new(<span class="string">&quot;./&quot;</span>), <span class="keyword">self</span>.as_os_str()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_files</span></span>(paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;) -&gt; <span class="built_in">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class="line">    <span class="keyword">let</span> result = paths</span><br><span class="line">        .into_par_iter()</span><br><span class="line">        .filter(|path| path.is_file() || path.as_os_str() == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">        .map(|<span class="keyword">mut</span> path| &#123;</span><br><span class="line">            <span class="keyword">let</span> should_read_from_input = path.as_os_str() == <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> path.without_dotted_prefix() &#123;</span><br><span class="line">                path.add_dotted_prefix();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> should_read_from_input &#123;</span><br><span class="line">                <span class="keyword">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">                path = PathBuf::from(<span class="built_in">format!</span>(<span class="string">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class="line">                eprintln!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            (path, content)</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line">    <span class="literal">Ok</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// helper 函数, 针对单个路径</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class="built_in">bool</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> should_read_from_input &#123;</span><br><span class="line">        read_from_stdin()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bars = MultiProgress::new();</span><br><span class="line">        <span class="keyword">let</span> style =</span><br><span class="line">            ProgressStyle::with_template(<span class="string">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class="line">                .progress_chars(<span class="string">&quot;&gt;-&quot;</span>);</span><br><span class="line">        read_file_with_progress(path, style, bars)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对应路径的文件</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file = File::open(path)?;</span><br><span class="line">    <span class="keyword">let</span> size = file.metadata()?.len();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bar = ProgressBar::new(size).with_message(<span class="built_in">format!</span> &#123;<span class="string">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class="line">    <span class="keyword">let</span> bar = bars.add(bar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bufreader = BufReader::new(file);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0</span>; BUFFER_SIZR];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(n) = bufreader.read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bar.inc(n <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">        content += &amp;<span class="built_in">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class="line">    &#125;</span><br><span class="line">    bar.finish_with_message(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_from_stdin</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">vec!</span>[];</span><br><span class="line">    std::io::stdin().read_to_end(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="built_in">String</span>::from_utf8(content)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="逻辑实现代码-2"><figure class="highlight rust"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明依赖</span></span><br><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class="line">    files::read_files,</span><br><span class="line">    Counts, <span class="built_in">Result</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class="built_in">str</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放被启用的 options, 与键值对</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">WcResult</span></span> &#123;</span><br><span class="line">    enabled_options: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;,</span><br><span class="line">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化函数</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(<span class="keyword">mut</span> cli: Cli) -&gt; <span class="built_in">Result</span>&lt;WcResult&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please waiting...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子命令进行相应操作</span></span><br><span class="line">    <span class="keyword">match</span> cli.sub_commands &#123;</span><br><span class="line">        <span class="literal">Some</span>(SubCommands::All &#123; <span class="keyword">ref</span> paths &#125;) =&gt; &#123;</span><br><span class="line">            cli.paths = paths.clone();</span><br><span class="line">            cli.enable_all_options();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; cli.enable_all_options(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行计算</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> wc_result = WcResult &#123;</span><br><span class="line">        enabled_options: cli.get_enabled_options(),</span><br><span class="line">        paths_with_counts: &#123;</span><br><span class="line">            <span class="keyword">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class="line">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(wc_result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> WcResult &#123;</span><br><span class="line">    <span class="comment">// 将保存的信息转化为美化后的表格</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">to_pretty_table</span></span>(<span class="keyword">self</span>) -&gt; Table &#123;</span><br><span class="line">        <span class="keyword">let</span> titles = &#123;</span><br><span class="line">            <span class="keyword">let</span> enabled_options = <span class="keyword">self</span>.enabled_options;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class="line">            titles.insert_cell(<span class="number">0</span>, cell!(Fybi -&gt; <span class="string">&quot;Path&quot;</span>));</span><br><span class="line">            titles</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> table = Table::new();</span><br><span class="line">        table.set_titles(titles);</span><br><span class="line">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (path, counts) <span class="keyword">in</span> <span class="keyword">self</span>.paths_with_counts &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class="line">            <span class="keyword">let</span> path_cell = <span class="keyword">if</span> path.starts_with(<span class="string">&quot;Input&quot;</span>) &#123;</span><br><span class="line">                cell!(Fbb -&gt; path.display())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cell!(Fmb -&gt; path.display())</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            row.insert_cell(<span class="number">0</span>, path_cell);</span><br><span class="line">            table.add_row(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        table</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_counts</span></span>(cli: &amp;Cli, content: <span class="built_in">String</span>) -&gt; Counts &#123;</span><br><span class="line">    <span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt;&gt; = <span class="built_in">vec!</span>[<span class="literal">None</span>; <span class="number">5</span>];</span><br><span class="line">    v.into_par_iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .map(|(idx, _)| <span class="keyword">match</span> idx &#123;</span><br><span class="line">            <span class="number">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class="line">            <span class="number">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class="line">            <span class="number">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class="line">            <span class="number">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class="line">            <span class="number">4</span> =&gt; cli</span><br><span class="line">                .longest_line</span><br><span class="line">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class="number">0</span>)),</span><br><span class="line">            _ =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .flatten()</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>然后就是 main 函数:</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cli = Cli::parse();</span><br><span class="line">    <span class="keyword">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class="line">    pretty_table.printstd();</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就酱, 结束啦! 希望本文能帮到你 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Clap" scheme="https://jedsek.xyz/tags/Clap/"/>
    
    <category term="CLI" scheme="https://jedsek.xyz/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>GNOME 入坑指南</title>
    <link href="https://jedsek.xyz/posts/desktop-beautify/gnome"/>
    <id>https://jedsek.xyz/posts/desktop-beautify/gnome</id>
    <published>2022-07-20T03:22:42.000Z</published>
    <updated>2022-07-20T03:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p></blockquote><span id="more"></span><p><strong>注意:</strong><br>本篇文章的配置皆在注重简洁, 高效, 美观<br>想要平铺式, 炫酷效果, 更多功能的, 请自行配置, 或查看我的另外一篇博客: <a href="/posts/desktop-beautify/hyprland">Hyprland 平铺式</a><br>请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>目前, 该篇文章的GNOME 版本为: <strong>42</strong></p><h1 id="cheng-pin-zhan-shi">成品展示</h1><p>2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前…<br>我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!</p><p><img data-src="/images/gnome/overview.png" alt="按下Super后的Overview"></p><hr><h1 id="dconf-amp-amp-gsettings">dconf &amp;&amp; gsettings</h1><ul class="lvl-0"><li class="lvl-2"><p><code>dconf</code>:<br>是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p></li><li class="lvl-2"><p><code>gsettings</code>:<br>是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p></li></ul><p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p><p>接下来的大部分配置, 都会使用 <code>gsettings</code></p><hr><h1 id="hong-mo-ban">触摸板</h1><p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p><h2 id="pei-zhi" id="配置">配置</h2><p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p><p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p><p>你可以在终端输入如下命令进行调整:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class="literal">true</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>分别对应:</p><ul class="lvl-0"><li class="lvl-2"><p>轻击模拟鼠标点击, 默认为false</p></li><li class="lvl-2"><p>调整触摸板速度, 默认为0</p></li><li class="lvl-2"><p>打字时禁用触摸板, 默认为true</p></li></ul><h2 id="shou-shi" id="手势">手势</h2><ul class="lvl-0"><li class="lvl-2"><p>单指: 移动鼠标</p></li><li class="lvl-2"><p>双指上下: 翻页</p></li><li class="lvl-2"><p>三指左右: 切换Workspace</p></li><li class="lvl-2"><p>三指上: 打开Overview (不常用, 按Super更快)</p></li><li class="lvl-2"><p>三指下: 显示任务栏 (当你隐藏任务栏时)</p></li></ul><hr><h1 id="an-zhuang-kuo-zhan">安装扩展</h1><p>GNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之<br>我将先介绍如何安装/使用它们, 因为后面需要用到扩展</p><p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p><h2 id="cong-ming-ling-xing" id="从命令行">从命令行</h2><p><strong>提示</strong><br>请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有…<br>下载成功后, 切记要 logout, 然后再登进来</p><p>每个GNOME扩展都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载扩展</p><p>你可以在 <a href="https://extensions.gnome.org/">Extensions-GNOME</a> 这个网站上, 浏览并下载扩展<br>请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 <code>exts_list</code></p><p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p><div class="tabs" id="install-extensions"><ul class="nav-tabs"><li class="tab active"><a href="#install-extensions-1">Bash</a></li><li class="tab"><a href="#install-extensions-2">Fish</a></li></ul><div class="tab-content"><div class="tab-pane active" id="install-extensions-1"><figure class="highlight bash"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">declare</span> -a UUID_LIST</span><br><span class="line">EXTS_DIR=<span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions</span><br><span class="line">EXTS_LIST=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"><span class="function"><span class="title">str_join</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span> | sed <span class="string">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">mkdir -p <span class="variable">$EXTS_DIR</span></span><br><span class="line">chmod -R 755 <span class="variable">$HOME</span>/.<span class="built_in">local</span>/</span><br><span class="line"><span class="keyword">for</span> EXT <span class="keyword">in</span> <span class="variable">$EXTS_LIST</span>/*.zip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  UUID=$(unzip -p <span class="variable">$EXT</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span>)</span><br><span class="line">  mkdir -p <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  unzip -q -o <span class="variable">$EXT</span> -d <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  UUID_LIST+=<span class="string">&quot;\&quot;<span class="variable">$UUID</span>\&quot;&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">UUID_LIST=[$(str_join <span class="variable">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="install-extensions-2"><figure class="highlight bash"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> exts_list <span class="variable">$argv</span>[1]</span><br><span class="line"><span class="built_in">set</span> exts_dir <span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions/</span><br><span class="line"><span class="built_in">set</span> uuid_list</span><br><span class="line">mkdir -p <span class="variable">$exts_dir</span></span><br><span class="line"><span class="keyword">for</span> ext <span class="keyword">in</span> exts_list/*.zip</span><br><span class="line">  <span class="built_in">set</span> uuid ( unzip -p <span class="variable">$ext</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span> )</span><br><span class="line">  mkdir -p <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  unzip -q -o <span class="variable">$ext</span> -d <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  <span class="built_in">set</span> -a uuid_list \<span class="string">&#x27;$uuid\&#x27;</span></span><br><span class="line">end</span><br><span class="line"><span class="built_in">set</span> uuid_list [( string join <span class="string">&quot;,&quot;</span> <span class="variable">$uuid_list</span> )]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div><p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p><p><strong>注意: 先logout, 再登进来</strong></p><p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dbus-send --<span class="built_in">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \</span><br><span class="line">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class="string">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="cong-liu-lan-qi" id="从浏览器">从浏览器</h2><p>该方法其实也蛮方便的, 但不适合快速部署<br>你需要安装两个玩意, 才能直接从 <a href="https://extensions.gnome.org/">Extension-GNOME</a> 上直接下载</p><ul class="lvl-0"><li class="lvl-2"><p><code>chrome-gnome-shell</code>:<br>本地软件, 你可以通过包管理器, 直接搜这个名字</p></li><li class="lvl-2"><p><code>GNOME Shell integration</code>:<br>浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>Edge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p></li></ul><p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href="https://extensions.gnome.org/">网站</a> 上 直接安装到本地</p><hr><h1 id="cha-kan-pei-zhi-kuo-zhan">查看/配置扩展</h1><p>通过 <code>gnome-extensions</code> 这个命令, 我们可以查看/配置当前扩展</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帮助, `Command` 为可选项</span></span><br><span class="line">gnome-extensions <span class="built_in">help</span> [Command]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展列表</span></span><br><span class="line">gnome-extensions list --user    <span class="comment"># 查看用户级扩展</span></span><br><span class="line">gnome-extensions list --system  <span class="comment"># 查看系统级扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展的信息</span></span><br><span class="line">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用某个扩展</span></span><br><span class="line">gnome-extensions <span class="built_in">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line">gnome-extensions <span class="built_in">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置某个扩展 (打开 GUI 界面)</span></span><br><span class="line">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure><p>或者通过 <code>gsettings</code> 来配置某个扩展, 但不推荐, 因为麻烦:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看某个扩展的所有选项</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class="line"><span class="comment"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class="line"><span class="comment"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure><p>你也可以参考或<a href="#jia-zai-pei-zhi"><strong>直接加载</strong></a> <code>dconf.settings</code> 文件<br><strong>注意:</strong> 如何你选择直接加载我的配置, 请注意 <code>picture-uri</code> 符合自己实际</p><hr><h1 id="tui-jian-de-kuo-zhan">推荐的扩展</h1><p>以下是我目前正在使用且推荐的扩展</p><p><strong>注意:</strong><br>如果你是通过我的博客 jedsek.xyz 观看的话, 我默认隐藏了这些图片<br>你可以展开任意一张图片后, 点击图片, 在 fancybox 种通过方向键切换图片 😃</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/16/auto-move-windows/">auto-move-windows</a>:<br>通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/905/refresh-wifi-connections/">refresh-wifi-connections</a><br>当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/refresh-wifi-connections.png" alt="refresh-wifi-connections"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1446/transparent-window-moving/">transparent-window-moving</a><br>在对窗口进行移动/调整大小时, 使窗口变得透明</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/transparent-window-moving.png" alt="transparent-window-moving"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3843/just-perfection/">just-perfection</a><br>我最喜欢的一个扩展, 用于对界面进行大量自定义与精简<br>比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="just-perfection"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3139/eye-extended/">eye-extended</a><br>很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场<br>在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/eye-extended.png" alt="eye-extended"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1113/nothing-to-say/">nothing-to-say</a><br>用于切断/恢复声音的输入, 对我来说蛮有用的:<br>当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/nothing-to-say.png" alt="nothing-to-say"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/5090/space-bar/">space-bar</a><br>模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 <code>Activities</code> 替换为 <code>Workspaces</code>, 有些类似的扩展, 但这个最好</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/space-bar.png" alt="space-bar"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4696/static-background-in-overview/">static-background-in-overview</a><br>在按下 <code>Super</code> 进入 <code>Overview</code> 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="static-background-in-overview"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4788/workspace-switcher-manager/">workspace-switcher-manager</a><br>美化通过键盘(我配成了 <code>Super + 1..9</code>), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/workspace-switcher-manager.png" alt="workspace-switcher-manager"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/">disable-workspace-switch-animation-for-GNOME40+</a><br>消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1319/gsconnect/">gsconnect</a><br>GNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href="/downloads/gnome/kdeconnect.apk">kdeconnect</a></p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gsconnect.png" alt="gsconnect"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3193/blur-my-shell/">blur-my-shell</a><br>用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="blur-my-shell"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3488/big-avatar/">big-avatar</a><br>让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/big-avatar.png" alt="big-avatar"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4530/cpudots/">cpudots</a><br>监视你当前的CPU频率, 以百分数的形式呈现在顶栏</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="cpudots"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4817/colorful-battery-indicator/">colorful-battery-indicator</a><br>让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="colorful-battery-indicator"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/">gnome40-ui-improvements</a><br>按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区的内容</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome40-ui-improvements.png" alt="gnome40-ui-improvements"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/">gnome-fuzzy-app-search</a><br>出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该扩展修改</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome-fuzzy-app-search.png" alt="gnome-fuzzy-app-search"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4691/pip-on-top/">pip-on-top</a><br>当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4792/frequency-boost-switch/">frequency-boost-switch</a><br>在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/frequency-boost-switch.png" alt="frequency-boost-switch"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1702/overview-navigation/">overview-navigation</a><br>当按下 <code>Super</code> 进入 <code>Overview</code> 后, 可以按下 <code>空格键</code>, 窗口上会出现字母<br>输入小写字母就切换到对应窗口, 按下 <code>Shift</code> 会使字母颜色变红, 此时输入字母会关闭对应窗口</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="overview-navigation"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3759/cleaner-overview/">cleaner-overview</a><br>进入 <code>Overview</code> 时, 将窗口排列整齐, 简单实用</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="cleaner-overview"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/19/user-themes/">user-theme</a><br>从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3414/user-stylesheet-font/">user-syle-sheet</a><br>读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者<br><strong>无图片</strong></p></li></ul><hr><h1 id="mei-hua">美化</h1><p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>还有很多扩展有帮助, 上面 <a href="#tui-jian-de-kuo-zhan">推荐的扩展</a> 里有提到, 比如那个更改css的, 这里不说了</p><ul class="lvl-0"><li class="lvl-2"><p>启动暗模式:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface color-scheme <span class="string">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri-dark <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或将图片命名为.face, 放到家目录</span></span><br><span class="line"><span class="comment"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href="https://www.gnome-look.org/">gnome-look</a> 挑选主题</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 Nordic 为例子</span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface gtk-theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你也可以使用 `user-theme` 这个扩展进行设置:  </span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class="line">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface font-name <span class="string">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell favorite-apps <span class="string">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 扩展<br>此扩展得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href="#jin-yong-kuai-jie-jian">禁用快捷键</a></p><ul class="lvl-0"><li class="lvl-2"><p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: <code>space-bar</code> 或 <code>workspace-bar</code>)</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences workspace-names <span class="string">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href="#cheng-pin-zhan-shi">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p></li></ul><hr><h1 id="kuai-jie-jian">快捷键</h1><p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p><p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p><p><strong>注意:</strong><br>快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突</p><h2 id="cha-zhao-kuai-jie-jian" id="查找快捷键">查找快捷键</h2><p>首先, 我们得明白如何查找对应的快捷键</p><p>下面的命令会列出极大部分的快捷键:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings list-recursively | grep -E <span class="string">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure><p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>如果实在找不到, 一点点看过去也行 😃</p><h2 id="jin-yong-kuai-jie-jian" id="禁用快捷键">禁用快捷键</h2><p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>想要禁用该快捷键, 将对应的数组设置为空就行了</p><p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default: Super+&quot;1..9&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    gsettings <span class="built_in">set</span> org.gnome.shell.keybindings switch-to-application-<span class="variable">$i</span> <span class="string">&quot;[]&quot;</span>  </span><br><span class="line"><span class="keyword">done</span>    </span><br></pre></td></tr></table></figure><p>禁用快捷键还可以让你避免冲突, 比如:<br>某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p><p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class="string">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class="comment">#Default: Sup+L</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class="string">&quot;[]&quot;</span> <span class="comment"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure><h2 id="xiu-gai-kuai-jie-jian" id="修改快捷键">修改快捷键</h2><p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href="#tian-jia-kuai-jie-jian">添加快捷键</a> 不是一个概念<br>单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p><ul class="lvl-0"><li class="lvl-2"><p>Vim 式的案件, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class="line"></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class="string">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class="comment"># 放左边</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class="comment"># 最大化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class="comment"># 最小化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class="string">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class="comment"># 放右边</span></span><br></pre></td></tr></table></figure><p>对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管…</p><ul class="lvl-0"><li class="lvl-2"><p>move, resize, kill 一个窗口:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Move</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class="string">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class="string">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings close        <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class="comment">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Toggle max</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class="string">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class="comment">#Default: Alt+F10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max/Min</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings maximize          <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings minimize          <span class="string">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class="comment">#Default: Super+H</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle fullscreen</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class="string">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show desktop</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class="string">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class="variable">$i</span> <span class="string">&quot;[&#x27;&lt;Super&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class="variable">$i</span>   <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class="string">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class="string">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class="comment">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure><h2 id="tian-jia-kuai-jie-jian" id="添加快捷键">添加快捷键</h2><p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p><p>废话不多说, 你按下面照猫画虎, 就阔以了:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gp0=<span class="string">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line">gp1=<span class="string">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\</span></span><br><span class="line"><span class="string">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Keys</span></span><br><span class="line"><span class="comment"># 注意!!!!!!!</span></span><br><span class="line"><span class="comment"># 不要在最后添加逗号</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class="string">&quot;[     \</span></span><br><span class="line"><span class="string">    &#x27;<span class="variable">$gp0</span>/custom0/&#x27;, &#x27;<span class="variable">$gp0</span>/custom1/&#x27;, &#x27;<span class="variable">$gp0</span>/custom2/&#x27;, &#x27;<span class="variable">$gp0</span>/custom3/&#x27;               \</span></span><br><span class="line"><span class="string">]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Terminal</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ name     <span class="string">&#x27;Terminal&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ <span class="built_in">command</span>  <span class="string">&#x27;alacritty&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ binding  <span class="string">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Files</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ name     <span class="string">&#x27;Files&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ <span class="built_in">command</span>  <span class="string">&#x27;nautilus&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ binding  <span class="string">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Browser</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ name     <span class="string">&#x27;Browser&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ <span class="built_in">command</span>  <span class="string">&#x27;microsoft-edge-beta&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ binding  <span class="string">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Fcitx5 Reload</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ name     <span class="string">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ <span class="built_in">command</span>  <span class="string">&#x27;fcitx5 -r&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ binding  <span class="string">&#x27;&lt;Alt&gt;space&#x27;</span></span><br></pre></td></tr></table></figure><p>我相信你不会将时间浪费在掉在坑里面了<br>上面的一切已经非常非常全了</p><hr><h1 id="jia-zai-pei-zhi">加载配置</h1><p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p><h2 id="dui-yu-fei-nixos" id="对于非Nixos">对于非Nixos</h2><p>对于普通的Linux发行版, 直接按下面的方式</p><ul class="lvl-0"><li class="lvl-2"><p>导出当前的dconf数据到某个文件:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>加载/导入某个dconf文件到当前系统:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure><p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p><h2 id="dui-yu-nixos" id="对于Nixos">对于Nixos</h2><p>如果你使用 Nixos, 请先确保已经安装了 <a href="https://github.com/nix-community/home-manager">HomeManager</a><br>HomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p><p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br><span class="line">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure><p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">nixpkgs/</span><br><span class="line">├── gnome</span><br><span class="line">│   ├── <span class="selector-class">.background</span></span><br><span class="line">│   ├── <span class="selector-class">.face</span></span><br><span class="line">│   └── dconf<span class="selector-class">.nix</span></span><br><span class="line">└── home.nix</span><br></pre></td></tr></table></figure><p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">imports</span> = [</span><br><span class="line">  ./gnome/dconf.nix</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p><ul class="lvl-0"><li class="lvl-2"><p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class="line"><span class="keyword">let</span> <span class="attr">picture</span> = ../.background.png; <span class="keyword">in</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">picture-uri</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">  <span class="attr">picture-uri-dark</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">home.file.<span class="string">&quot;.face&quot;</span>.<span class="attr">source</span> = ./.face;</span><br></pre></td></tr></table></figure><p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://jedsek.xyz/tags/Linux/"/>
    
    <category term="GNOME" scheme="https://jedsek.xyz/tags/GNOME/"/>
    
    <category term="Waylnad" scheme="https://jedsek.xyz/tags/Waylnad/"/>
    
    <category term="Desktop" scheme="https://jedsek.xyz/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p5~&gt; 类型与类型类</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p5"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p5</id>
    <published>2022-07-18T08:24:44.000Z</published>
    <updated>2022-07-18T08:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="kai-pian">开篇</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Haskell 中的类型(Type), 与类型类(Typeclass)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
</feed>
