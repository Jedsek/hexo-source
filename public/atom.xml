<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jedsek&#39;s blog</title>
  
  <subtitle>与其浊富 | 宁比清贫</subtitle>
  <link href="https://jedsek.xyz/atom.xml" rel="self"/>
  
  <link href="https://jedsek.xyz/"/>
  <updated>2022-10-22T14:44:16.000Z</updated>
  <id>https://jedsek.xyz/</id>
  
  <author>
    <name>Jedsek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rust-gstreamer-p6: Basic-与GUI集成</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p6"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p6</id>
    <published>2022-10-22T14:44:16.000Z</published>
    <updated>2022-10-22T14:44:16.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p5: Basic-时间管理</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p5"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p5</id>
    <published>2022-10-22T14:44:02.000Z</published>
    <updated>2022-10-22T14:44:02.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p4: Basic-管道的动态构建</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p4"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p4</id>
    <published>2022-10-22T14:43:55.000Z</published>
    <updated>2022-10-22T14:43:55.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p3: Basic-管道的手动构建</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p3"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p3</id>
    <published>2022-10-22T14:43:45.000Z</published>
    <updated>2022-10-22T14:43:45.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p2: Basic-管道的自动构建</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p2"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p2</id>
    <published>2022-10-22T14:43:36.000Z</published>
    <updated>2022-10-22T14:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个入门级例子</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个入门级例子&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>rust-gstreamer-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-gstreamer/p1"/>
    <id>https://jedsek.xyz/posts/rust-gstreamer/p1</id>
    <published>2022-10-22T14:42:00.000Z</published>
    <updated>2022-10-22T14:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习使用 gstreamer 来处理音视频</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习使用 gstreamer 来处理音视频&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GStreamer" scheme="https://jedsek.xyz/tags/GStreamer/"/>
    
    <category term="Video" scheme="https://jedsek.xyz/tags/Video/"/>
    
    <category term="Audio" scheme="https://jedsek.xyz/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p4: 进制转换</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p4"/>
    <id>https://jedsek.xyz/posts/high-school-it/p4</id>
    <published>2022-10-13T15:51:02.000Z</published>
    <updated>2022-10-13T15:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于任意进制间的互相转换与应用</p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于任意进制间的互相转换与应用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p3: python基础语法</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p3"/>
    <id>https://jedsek.xyz/posts/high-school-it/p3</id>
    <published>2022-09-12T03:45:45.000Z</published>
    <updated>2022-09-12T03:45:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正式的对python语法的学习, 包含常见库函数的使用</p></blockquote><span id="more"></span><div class="tips"><p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href="/posts/high-school-it/p2">p2: 基础科普与环境搭建</a></p></div><h1 id="bian-liang-yu-fu-zhi">变量与赋值</h1><p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p><p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p><p>有两个概念:</p><ul class="lvl-0"><li class="lvl-2"><p>声明变量:  创建变量 (声明一个变量出现了)</p></li><li class="lvl-2"><p>赋值: 把一个值装到箱子(变量)里</p></li></ul><p>比如, 一个很简单的例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p><p>你也可以这样:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure><p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>第二行表示, 把a里面的数值取出来, 传给了b</p><p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">d = e = f = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a,b,c = d,e,f</span><br></pre></td></tr></table></figure><p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p><p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure><p>你可能会疑惑:<br>当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>该想法对应的代码是这样的:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = b</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure><p>但在交换数值的代码中, 你应该这样理解:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">_t1 = b</span><br><span class="line">_t2 = a</span><br><span class="line">a = _t1</span><br><span class="line">b = _t2</span><br></pre></td></tr></table></figure><p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了</p><p>现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p><hr><h1 id="zhu-shi">注释</h1><h2 id="zuo-yong" id="作用">作用</h2><p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  此时 a 的值为 <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure><p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p><p>再举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"><span class="built_in">max</span> = -<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = a</span><br><span class="line"><span class="keyword">elif</span> b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">max</span> = c</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p><h2 id="dan-duo-xing-zhu-shi" id="单-多行注释">单/多行注释</h2><p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 12345</span></span><br><span class="line"><span class="comment"># 上山打老虎</span></span><br><span class="line"><span class="comment"># 老虎打不着</span></span><br><span class="line"><span class="comment"># 打到小松鼠</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">12345</span></span><br><span class="line"><span class="string">上山打老虎</span></span><br><span class="line"><span class="string">老虎打不着</span></span><br><span class="line"><span class="string">打到小松鼠</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p><hr><h1 id="ji-ben-shu-ju-lei-xing">基本数据类型</h1><p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p><p>为了模拟现实, py将数据进行了抽象与分类:</p><ul class="lvl-0"><li class="lvl-2"><p>int: 对应整数</p></li><li class="lvl-2"><p>float: 对应实数</p></li><li class="lvl-2"><p>string: 对应文字</p></li><li class="lvl-2"><p>bool: 对应真与假</p></li></ul><p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p><p>举些例子:</p><ul class="lvl-0"><li class="lvl-2"><p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p></li><li class="lvl-2"><p>我的年龄是16岁: 用int来表示 16 这个数字</p></li><li class="lvl-2"><p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p></li></ul><p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>你可以这样抽象:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student &#123;</span><br><span class="line">  age:  <span class="built_in">int</span>,</span><br><span class="line">  height: <span class="built_in">float</span>,</span><br><span class="line">  name: string,</span><br><span class="line">  fat_or_not: <span class="built_in">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p><hr><h1 id="bian-liang-ming-ming-gui-fan">变量命名规范</h1><p>python中, 变量的命名必须符合规范, 不然直接报错<br>在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p><p>命名规范如下:</p><ul class="lvl-0"><li class="lvl-2"><p>变量名由字母, 数字, 下划线组成</p></li><li class="lvl-2"><p>数字不能在第一位</p></li><li class="lvl-2"><p>不能与python中的关键字重名</p></li></ul><p>以下都是合法的变量名</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">abada</span><br><span class="line">asd111231</span><br><span class="line">ad190123kkad</span><br><span class="line">asd_asd1_asd2</span><br><span class="line">_123daa</span><br><span class="line">_as11</span><br></pre></td></tr></table></figure><p>以下是不合法的变量名:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span></span></span><br><span class="line"><span class="function"><span class="title">not</span></span></span><br><span class="line"><span class="function"><span class="title">in</span></span></span><br><span class="line"><span class="function"><span class="title">lambda</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1123</span></span><br><span class="line"><span class="function">123<span class="title">adad</span></span></span><br><span class="line"><span class="function"><span class="title">sad</span>;;-``</span></span><br><span class="line"><span class="function">``?/</span></span><br><span class="line"><span class="function">&#x27;,</span></span><br></pre></td></tr></table></figure><div class="tips"><p><strong>关键字:</strong><br>关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p></div><p>如何判断一个变量名是不是关键字?<br>呃…多认识下就知道了… 反正也不可能考没学过的关键字 😃</p><hr><h1 id="yun-suan-fu-yu-you-xian-ji">运算符与优先级</h1><p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>在以下的图表中, 优先级1是最高, 数字越大优先级越低</p><h2 id="suan-zhu-yun-suan-fu" id="算术运算符">算术运算符</h2><p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>优先级</th></tr></thead><tbody><tr><td>**</td><td>x的y次方</td><td>x**y</td><td>1</td></tr><tr><td>*</td><td>x乘以y</td><td>x*y</td><td>2</td></tr><tr><td>/</td><td>x除以y, 产生实数值</td><td>x/y</td><td>2</td></tr><tr><td>//</td><td>x除以y, 产生整数值</td><td>x//y</td><td>2</td></tr><tr><td>%</td><td>x除以y, 取余数</td><td>x%y</td><td>2</td></tr><tr><td>+</td><td>x加y</td><td>x+y</td><td>3</td></tr><tr><td>-</td><td>x减y</td><td>x-y</td><td>3</td></tr></tbody></table><p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p><p>算术运算符, 可以与赋值运算符相互结合:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span>  <span class="comment"># 是上面的等价物</span></span><br></pre></td></tr></table></figure><p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p><h2 id="guan-xi-yun-suan-fu" id="关系运算符">关系运算符</h2><p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&gt;</td><td>x 大于 y</td><td>x &gt; y</td></tr><tr><td>&lt;</td><td>x 小于 y</td><td>x &lt; y</td></tr><tr><td>&gt;=</td><td>x 大于等于 y</td><td>x &gt;= y</td></tr><tr><td>&lt;=</td><td>x 小于等于 y</td><td>x &lt;= y</td></tr><tr><td>==</td><td>x 等于 y</td><td>x == y</td></tr><tr><td>!=</td><td>x 不等于 y</td><td>x != y</td></tr></tbody></table><p><strong>注:</strong><br>本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p><hr><h1 id="ji-ben-shu-ju-jie-gou">基本数据结构</h1><p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p><p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p><p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>当然, 我们此处仅学习基本数据结构</p><h2 id="lie-biao" id="列表">列表</h2><p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p><h3 id="dan-suo-yin" id="单索引">单索引</h3><p>我们可以通过单个索引, 访问对应的单个元素</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有着 3 个元素的列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]  <span class="comment"># 300</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]  <span class="comment"># 400</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>]  <span class="comment"># 500</span></span><br></pre></td></tr></table></figure><p>list 可以通过 index 来访问元素, 那么如果 index 过大呢, 比如下面这样:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有着 3 个元素的列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line"><span class="built_in">list</span>[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>脑子想一想都知道一定会报错:</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">  list[<span class="number">3</span>]</span><br><span class="line">  ~~~~^^^</span><br><span class="line">IndexError: list <span class="built_in">index</span> <span class="keyword">out</span> of <span class="built_in">range</span></span><br></pre></td></tr></table></figure><p>果不其然, 解释器告诉我们了报错信息, 提示 “列表的索引越界了”<br>如果一个列表的长度length = n, 那么 index 自然要 &lt;= n-1 (从0开始哦~~)</p><div class="tips"><p><strong>扩展: 为何 index 从 0 开始?</strong><br>因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p><p>你可以这样理解:<br>一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p><p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>如何访问第 1 个格子? 第一个格子向右跳 0 格<br>如何访问第 2 个格子? 第二个格子向右跳 1 格<br>如何访问第 3 个格子? 第三个格子向右跳 2 格</p><p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p><p>如果你非要把下标从 1 开始, 那就得这样:<br>list[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p><p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br><s>(好吧, 原因其实真的只是因为习俗)</s></p><p>而且在设计算法, 并且需要考虑下标的边界问题时, 下标从0开始会很方便</p></div><p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p><p>此时, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p><h3 id="qie-pian" id="切片">切片</h3><p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p><p>举个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>]  <span class="comment"># 定义列表</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">4</span>]  <span class="comment"># [201, 202, 203, 204]</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># [201, 202]</span></span><br></pre></td></tr></table></figure><p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>如 <code>0:4</code> 代表 [0, 1, 2, 3], 再如 <code>0:2</code>, 代表 [0, 1]<br>我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p><hr><h2 id="zi-dian" id="字典">字典</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;正式的对python语法的学习, 包含常见库函数的使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p2: 基础科普</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p2"/>
    <id>https://jedsek.xyz/posts/high-school-it/p2</id>
    <published>2022-09-11T12:51:16.000Z</published>
    <updated>2022-09-11T12:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p></blockquote><span id="more"></span><div class="tips"><p><strong>注意:</strong><br>本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p></div><h1 id="bian-yi-yu-jie-shi">编译与解释</h1><p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>c/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p><p>反正记住一点:<br>机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 也就是.exe结尾的文件<br>我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p><p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p><p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p><p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p><div class="tips"><p><strong>代码:</strong><br>代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p></div><div class="tips"><p><strong>文件后缀:</strong><br>文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p><p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>windows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p><p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p><p>如何显示文件后缀?<br>按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p></div><hr><h1 id="python-de-te-dian">Python的特点</h1><ul class="lvl-0"><li class="lvl-2"><p>是一门 <ins>高级语言</ins></p></li><li class="lvl-2"><p>是一门 <ins>面向对象</ins> 的语言</p></li><li class="lvl-2"><p>是一门 <ins>解释型</ins> 语言</p></li><li class="lvl-2"><p>语法简单, 拥有丰富强大的库, 适合快速开发</p></li></ul><div class="tips"><p><strong>高级语言</strong><br>计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p><ul class="lvl-1"><li class="lvl-2">机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</li><li class="lvl-2">汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</li><li class="lvl-2">高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</li></ul><p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p></div><div class="tips"><p><strong>面向对象</strong><br>假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>(非严谨版, 勿喷, 只是快速了解而已)</p></div><div class="tips"><p><strong>库:</strong><br>当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p></div><hr><h1 id="huan-jing-da-jian">环境搭建</h1><p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br><s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p><p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href="https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe">安装程序</a><br>至于出现安装界面后点哪里, 你就记住两个地方:</p><ul class="lvl-0"><li class="lvl-2"><p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p></li><li class="lvl-2"><p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p></li></ul><p>如何检验自己是否安装成功?<br>请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p><p>请输入以下命令, 检验python是否安装成功:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span>  --<span class="keyword">version</span></span><br></pre></td></tr></table></figure><p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>它应该会输出类似下面的文字:</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Python</span> <span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p><div class="tips"><p><strong>命令与路径</strong><br>这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>粗体闪烁的光标前的提示符, 表示你当前处于的路径</p><p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>比如, 敲下 “C:\asdiasdadows\asdadtem32\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p><p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\asdad\xxx.exe” 该怎么办呢?<br>这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p><p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p><p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>因此, 出现了这个黑框框 😃</p><p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p></div><hr><h1 id="idle-de-bei-hou-yuan-li">idle的背后原理</h1><p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p><p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p><p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p><p>整个过程如下:</p><ul class="lvl-0"><li class="lvl-2"><p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href="http://xxx.py">xxx.py</a>”</p></li><li class="lvl-2"><p>在 cmd 中输入: <code>python xxx.py</code></p></li></ul><hr><h1 id="hello-world">Hello world!</h1><p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p><div class="tips"><p><strong>注意:</strong><br>这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p></div><p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>随后打开cmd/终端, 你的当前路径应该是 “C:\Users\用户名”<br>我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br><span class="line">python first_app.txt</span><br></pre></td></tr></table></figure><p>这将会打印:</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p><p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p><p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p><p>但还是有个问题<br>那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p><p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p><p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p><p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>windows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p><p>python是可以调用外部命令的!</p><p>你可以在 first_app.py 中, 这样改进你的代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br><code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p><p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>high-school-it-p1: 数据与信息</title>
    <link href="https://jedsek.xyz/posts/high-school-it/p1"/>
    <id>https://jedsek.xyz/posts/high-school-it/p1</id>
    <published>2022-09-10T13:05:57.000Z</published>
    <updated>2022-09-10T13:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p></blockquote><span id="more"></span><p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p><h1 id="shu-ju-de-ding-yi">数据的定义</h1><p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p><ul class="lvl-0"><li class="lvl-2"><p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p></li><li class="lvl-2"><p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p></li></ul><p>上面的两种情况中:</p><ul class="lvl-0"><li class="lvl-2"><p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p></li><li class="lvl-2"><p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p></li></ul><p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p><hr><h1 id="xin-xi-de-ding-yi">信息的定义</h1><p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p><p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p><ul class="lvl-0"><li class="lvl-2"><p>这是一台电脑笔记本</p></li><li class="lvl-2"><p>这是一台屏幕大小为15.6英寸的电脑笔记本</p></li><li class="lvl-2"><p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p></li><li class="lvl-2"><p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p></li></ul><p>你会看到, 信息越多, 越能消除随机不确定性</p><hr><h1 id="xin-xi-de-te-zheng">信息的特征</h1><p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p><p>下面是信息的5个特征, 教科书上搬的:</p><ul class="lvl-0"><li class="lvl-2"><p>载体依附性<br>信息不能独立存在, 它是虚的, 必须有载体<br>比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p></li><li class="lvl-2"><p>时效性<br>信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p></li><li class="lvl-2"><p>共享性<br>信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p></li><li class="lvl-2"><p>可加工处理性/真伪性<br>信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>因此, 不要轻易跟随网上的人云亦云!</p></li><li class="lvl-2"><p>价值性<br>比如天气预报让你出门避免被雨淋湿, 这就是价值<br>对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p></li></ul><hr><h1 id="zhi-shi-de-ding-yi">知识的定义</h1><p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的</p><p>这部分很简单, 简单概述即可</p><hr><h1 id="zong-jie">总结</h1><p>以下是一个很好的, 对三者进行了区分的例子:</p><ul class="lvl-0"><li class="lvl-2"><p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p></li><li class="lvl-2"><p>信息: 人们想到了圆周率就是3.1415926</p></li><li class="lvl-2"><p>知识: 人们能够运用圆周率, 知道如何求解圆的面积</p></li></ul><p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="高中信息技术" scheme="https://jedsek.xyz/tags/%E9%AB%98%E4%B8%AD%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>clap-rs 简介</title>
    <link href="https://jedsek.xyz/posts/rust-clap/intro"/>
    <id>https://jedsek.xyz/posts/rust-clap/intro</id>
    <published>2022-08-16T12:03:34.000Z</published>
    <updated>2022-08-16T12:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习命令行的常识, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p></blockquote><span id="more"></span><p>前置知识: Rust基础<br>完整代码: <a href="https://github.com/Jedsek/rust-wc">github/jedsek/rust-wc</a></p><div class="tips"><p><strong>注意</strong><br>本项目基于当前最新版本的 clap, 也就是 version 4<br>本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p><p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>官方教程: <a href="https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html">derive tutorial</a><br>官方资料: <a href="https://docs.rs/clap/latest/clap/_derive/index.html">derive reference</a></p></div><h1 id="cheng-pin-zhan-shi">成品展示</h1><p>你可以通过如下命令, 从 <a href="https://crates.io">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install rust-wc</span><br></pre></td></tr></table></figure><p>以下是使用 <a href="https://asciinema.org/">asciinema</a> 录制的展示:</p><script id="asciicast-534647" src="https://asciinema.org/a/534647.js" async></script><hr><h1 id="ji-chu-gai-nian">基础概念</h1><p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p><p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p><div class="tips"><p><strong>注意:</strong><br>cli 可以代表抽象的界面, 也可以指代具体的某个程序<br>后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p></div><p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p><ul class="lvl-0"><li class="lvl-2"><p><code>参数(Arguments)</code>:<br>传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p></li><li class="lvl-2"><p><code>选项(Options)</code>:<br>通常以单/双横杠开头, 不同的options表示不同的行为<br>比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p></li><li class="lvl-2"><p><code>子命令(Subcommands)</code>:<br>一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p></li><li class="lvl-2"><p><code>双横杠(--)</code>:<br>在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p></li><li class="lvl-2"><p><code>短/长帮助(short/long help)</code>:<br>有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p></li></ul><hr><h1 id="chu-shi-pei-zhi">初始配置</h1><p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>请自行创建好目录:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">./rust-wc</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">   ├── wc_result.rs   <span class="meta"># 计算并存储结果</span></span><br><span class="line">   ├── <span class="keyword">cli</span>.rs         <span class="meta"># 命令行的定义</span></span><br><span class="line">   ├── files.rs       <span class="meta"># 读取文件</span></span><br><span class="line">   ├── lib.rs         <span class="meta"># 声明模块, 类型别名</span></span><br><span class="line">   └── main.rs</span><br></pre></td></tr></table></figure><p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p><figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust-wc&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class="line"><span class="section">[[bin]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rwc&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/main.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定依赖</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clap</span> = &#123;version = <span class="string">&quot;4.0.8&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>]&#125;      <span class="comment"># 解析参数</span></span><br><span class="line"><span class="attr">unicode-width</span> = <span class="string">&quot;0.1.10&quot;</span>                               <span class="comment"># 计算 Unicode 字符宽度</span></span><br><span class="line"><span class="attr">indicatif</span> = <span class="string">&quot;0.17.1&quot;</span>                                   <span class="comment"># 进度条</span></span><br><span class="line"><span class="attr">prettytable-rs</span> = <span class="string">&quot;0.9.0&quot;</span>                               <span class="comment"># 打印表格</span></span><br><span class="line"><span class="attr">rayon</span> = <span class="string">&quot;1.5.3&quot;</span>                                        <span class="comment"># 并行化</span></span><br></pre></td></tr></table></figure><p>以下是 <a href="http://lib.rs">lib.rs</a> 的内容:</p><figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cli;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> files;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> wc_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Counts</span></span> = <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure><hr><h1 id="ming-ling-ding-yi">命令定义</h1><div class="tips"><p><strong>注意:</strong><br>clap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p></div><p>让我们来想象下这个命令:</p><ul class="lvl-0"><li class="lvl-2"><p>必须接受一个参数</p></li><li class="lvl-2"><p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p></li><li class="lvl-2"><p>根据启用的 flag 来决定计算并打印哪些东西</p></li></ul><p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p><figure class="highlight rust"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span>  <span class="comment">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    author, version, about,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest_line&quot;</span>]</span>)),</span><br><span class="line">    subcommand_negates_reqs = <span class="literal">true</span>,</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the byte counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the character counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> chars: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the word counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> words: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the line counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> lines: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the maximum line width (Unicode)</span></span><br><span class="line">    <span class="meta">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[command(subcommand)]</span></span><br><span class="line">    <span class="keyword">pub</span> sub_commands: <span class="built_in">Option</span>&lt;SubCommands&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Subcommand)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubCommands</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Enabled all available options</span></span><br><span class="line">    All &#123;</span><br><span class="line">        <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">        <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">        paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_path</span></span>(filename: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PathBuf, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = PathBuf::from(filename);</span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cli &#123;</span><br><span class="line">    <span class="comment">// 开启所有的 options</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">enable_all_options</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.bytes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.chars = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.words = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.lines = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.longest_line = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_enabled_options</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> enabled_options = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.bytes.then(|| enabled_options.push(<span class="string">&quot;Bytes&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.chars.then(|| enabled_options.push(<span class="string">&quot;Chars&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.words.then(|| enabled_options.push(<span class="string">&quot;Words&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.lines.then(|| enabled_options.push(<span class="string">&quot;Lines&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.longest_line.then(|| enabled_options.push(<span class="string">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class="line"></span><br><span class="line">        enabled_options</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p><p>clap 以及为我们做好了一切 😃</p><p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> rust_wc::&#123;cli::Cli, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cli = Cli::parse();</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wen-dang-zhu-shi-yu-bang-zhu" id="文档注释与帮助">文档注释与帮助</h2><p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo run -- -h</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">A GNU/wc clone written in rust, which <span class="keyword">is</span> super faster when reading <span class="keyword">a</span> large of big <span class="keyword">files</span></span><br><span class="line"></span><br><span class="line">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class="built_in">line</span>&gt; <span class="symbol">&lt;PATH&gt;</span>...</span><br><span class="line">       rwc [PATH]... <span class="symbol">&lt;COMMAND&gt;</span></span><br><span class="line"></span><br><span class="line">Command<span class="variable">s:</span></span><br><span class="line">  <span class="keyword">all</span>   Enabled <span class="keyword">all</span> available <span class="keyword">options</span></span><br><span class="line">  <span class="keyword">help</span>  <span class="keyword">Print</span> this message <span class="built_in">or</span> the <span class="keyword">help</span> of the given subcommand(s)</span><br><span class="line"></span><br><span class="line">Argument<span class="variable">s:</span></span><br><span class="line">  <span class="symbol">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class="line"></span><br><span class="line">Option<span class="variable">s:</span></span><br><span class="line">  -<span class="keyword">b</span>, --bytes         <span class="keyword">Print</span> the byte counts</span><br><span class="line">  -<span class="keyword">c</span>, --chars         <span class="keyword">Print</span> the character counts</span><br><span class="line">  -<span class="keyword">w</span>, --words         <span class="keyword">Print</span> the word counts</span><br><span class="line">  -<span class="keyword">l</span>, --lines         <span class="keyword">Print</span> the <span class="built_in">line</span> counts</span><br><span class="line">  -L, --longest-<span class="built_in">line</span>  <span class="keyword">Print</span> the maximum <span class="built_in">line</span> width (Unicode)</span><br><span class="line">  -h, --<span class="keyword">help</span>          <span class="keyword">Print</span> <span class="keyword">help</span> information</span><br><span class="line">  -V, --<span class="keyword">version</span>       <span class="keyword">Print</span> <span class="keyword">version</span> information</span><br></pre></td></tr></table></figure><p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p><p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    about = <span class="meta-string">&quot;...&quot;</span>,</span></span><br><span class="line"><span class="meta">// ......</span></span><br><span class="line"><span class="meta">// ......</span></span><br></pre></td></tr></table></figure><p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>你可以查看 <a href="https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p><p>你可以像这样将 builder形式 的代码转化为 derive形式:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::new(<span class="string">&quot;myprog&quot;</span>)</span><br><span class="line">    .help_template(<span class="string">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    help_template = <span class="meta-string">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class="line"><span class="meta">// ......</span></span><br><span class="line"><span class="meta">// ......</span></span><br></pre></td></tr></table></figure><p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p><h2 id="xuan-xiang-yu-can-shu-de-sheng-cheng" id="选项与参数的生成">选项与参数的生成</h2><p>clap 能非常方便地以声明的方式, 定义选项/参数</p><h3 id="xuan-xiang" id="选项">选项</h3><p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print the byte counts</span></span><br><span class="line"><span class="meta">#[arg(short, long)]</span></span><br><span class="line"><span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br></pre></td></tr></table></figure><p>它由三部分组成:</p><ul class="lvl-0"><li class="lvl-2"><p>文档注释: help 中对该命令的解释</p></li><li class="lvl-2"><p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p></li><li class="lvl-2"><p>类型为bool: 传入时默认的行为是将其设置为 true</p></li></ul><p>如 help 中所示, 会生成如下内容:</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Options</span>:</span><br><span class="line">  -b, --bytes         <span class="keyword">Print</span> the <span class="keyword">byte</span> counts</span><br></pre></td></tr></table></figure><p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p><p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print the maximum line width (Unicode)</span></span><br><span class="line"><span class="meta">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class="line"><span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br></pre></td></tr></table></figure><h3 id="can-shu" id="参数">参数</h3><p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p><p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The path(s) you should provide</span></span><br><span class="line"><span class="meta">#[arg(value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line"><span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure><p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -b</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The following required arguments were not provided:</span><br><span class="line">  &lt;PATH&gt;...</span><br><span class="line"></span><br><span class="line">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class="line"></span><br><span class="line">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure><p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p><p>因此, 我们来学学如何使用自定义的参数解析器吧</p><h2 id="zi-ding-yi-can-shu-jie-xi-qi" id="自定义参数解析器">自定义参数解析器</h2><p>有些疑问或许会萦绕在你的心头:</p><ul class="lvl-0"><li class="lvl-2"><p>clap 是怎么进行解析的?</p></li><li class="lvl-2"><p>clap 能否将传入的参数, 解析为自定义的类型呢?</p></li><li class="lvl-2"><p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p></li></ul><p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_path</span></span>(filename: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PathBuf, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = PathBuf::from(filename);</span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>该错误会在用户传入非法路径时, 作为报错信息出现:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class="line"></span><br><span class="line">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure><p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>得益于此, 你可以为任何类型定义对应的 parser</p><h2 id="can-shu-guan-xi" id="参数关系">参数关系</h2><p>有时候, 我们可能会面临这样或那样的问题:</p><ul class="lvl-0"><li class="lvl-2"><p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p></li><li class="lvl-2"><p>一个或多个指定的 option(s) 必须被启用</p></li><li class="lvl-2"><p>多个指定的 options 可以同时被启用</p></li></ul><p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p><p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p><p>以我们的 <code>rwc</code> 举个例子:</p><ul class="lvl-0"><li class="lvl-2"><p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p></li><li class="lvl-2"><p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p></li></ul><p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    author, version, about,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest_line&quot;</span>]</span>)),</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p><h2 id="zi-ming-ling" id="子命令">子命令</h2><p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="meta">#[command(subcommand)]</span></span><br><span class="line">    <span class="keyword">pub</span> sub_commands: <span class="built_in">Option</span>&lt;SubCommands&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Subcommand)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubCommands</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Enabled all available options</span></span><br><span class="line">    All &#123;</span><br><span class="line">        <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">        <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">        paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p><p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href="https://github.com/clap-rs/clap/issues/1546">相关issue</a></p><div class="tips"><p><strong>注意:</strong><br>这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>但本文还是定义了 subcommand 以便读者了解, 起演示作用</p></div><hr><h1 id="luo-ji-shi-xian">逻辑实现</h1><p>根据:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">├── wc_result.rs   <span class="meta"># 计算并存储结果</span></span><br><span class="line">├── <span class="keyword">cli</span>.rs         <span class="meta"># 命令行的定义</span></span><br><span class="line">├── files.rs       <span class="meta"># 读取文件</span></span><br></pre></td></tr></table></figure><p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p><figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cli;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> files;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> wc_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Counts</span></span> = <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure><p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p><div class="tabs" id="逻辑实现代码"><ul class="nav-tabs"><li class="tab active"><a href="#逻辑实现代码-1">读取文件</a></li><li class="tab"><a href="#逻辑实现代码-2">进行计算</a></li></ul><div class="tab-content"><div class="tab-pane active" id="逻辑实现代码-1"><figure class="highlight rust"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明依赖</span></span><br><span class="line"><span class="comment">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class="line"><span class="keyword">use</span> crate::&#123;PathWithContent, <span class="built_in">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;BufReader, Read&#125;,</span><br><span class="line">    path::PathBuf,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class="line"><span class="comment">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class="line"><span class="keyword">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> BUFFER_SIZR: <span class="built_in">usize</span> = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class="line"><span class="comment">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class="line"><span class="comment">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PathExt</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">without_dotted_prefix</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_dotted_prefix</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PathExt <span class="keyword">for</span> PathBuf &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">without_dotted_prefix</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.is_relative() &amp;&amp; !<span class="keyword">self</span>.starts_with(<span class="string">&quot;../&quot;</span>) &amp;&amp; !<span class="keyword">self</span>.starts_with(<span class="string">&quot;./&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_dotted_prefix</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = PathBuf::from_iter([OsStr::new(<span class="string">&quot;./&quot;</span>), <span class="keyword">self</span>.as_os_str()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_files</span></span>(paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;) -&gt; <span class="built_in">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class="line">    <span class="keyword">let</span> result = paths</span><br><span class="line">        .into_par_iter()</span><br><span class="line">        .filter(|path| path.is_file() || path.as_os_str() == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">        .map(|<span class="keyword">mut</span> path| &#123;</span><br><span class="line">            <span class="keyword">let</span> should_read_from_input = path.as_os_str() == <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> path.without_dotted_prefix() &#123;</span><br><span class="line">                path.add_dotted_prefix();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> should_read_from_input &#123;</span><br><span class="line">                <span class="keyword">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">                path = PathBuf::from(<span class="built_in">format!</span>(<span class="string">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class="line">                eprintln!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            (path, content)</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line">    <span class="literal">Ok</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// helper 函数, 针对单个路径</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class="built_in">bool</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> should_read_from_input &#123;</span><br><span class="line">        read_from_stdin()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bars = MultiProgress::new();</span><br><span class="line">        <span class="keyword">let</span> style =</span><br><span class="line">            ProgressStyle::with_template(<span class="string">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class="line">                .progress_chars(<span class="string">&quot;&gt;-&quot;</span>);</span><br><span class="line">        read_file_with_progress(path, style, bars)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对应路径的文件</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file = File::open(path)?;</span><br><span class="line">    <span class="keyword">let</span> size = file.metadata()?.len();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bar = ProgressBar::new(size).with_message(<span class="built_in">format!</span> &#123;<span class="string">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class="line">    <span class="keyword">let</span> bar = bars.add(bar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bufreader = BufReader::new(file);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0</span>; BUFFER_SIZR];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(n) = bufreader.read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bar.inc(n <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">        content += &amp;<span class="built_in">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class="line">    &#125;</span><br><span class="line">    bar.finish_with_message(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_from_stdin</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">vec!</span>[];</span><br><span class="line">    std::io::stdin().read_to_end(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="built_in">String</span>::from_utf8(content)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="逻辑实现代码-2"><figure class="highlight rust"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明依赖</span></span><br><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class="line">    files::read_files,</span><br><span class="line">    Counts, <span class="built_in">Result</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class="built_in">str</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放被启用的 options, 与键值对</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">WcResult</span></span> &#123;</span><br><span class="line">    enabled_options: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;,</span><br><span class="line">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化函数</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(<span class="keyword">mut</span> cli: Cli) -&gt; <span class="built_in">Result</span>&lt;WcResult&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please waiting...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子命令进行相应操作</span></span><br><span class="line">    <span class="keyword">match</span> cli.sub_commands &#123;</span><br><span class="line">        <span class="literal">Some</span>(SubCommands::All &#123; <span class="keyword">ref</span> paths &#125;) =&gt; &#123;</span><br><span class="line">            cli.paths = paths.clone();</span><br><span class="line">            cli.enable_all_options();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; cli.enable_all_options(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行计算</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> wc_result = WcResult &#123;</span><br><span class="line">        enabled_options: cli.get_enabled_options(),</span><br><span class="line">        paths_with_counts: &#123;</span><br><span class="line">            <span class="keyword">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class="line">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(wc_result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> WcResult &#123;</span><br><span class="line">    <span class="comment">// 将保存的信息转化为美化后的表格</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">to_pretty_table</span></span>(<span class="keyword">self</span>) -&gt; Table &#123;</span><br><span class="line">        <span class="keyword">let</span> titles = &#123;</span><br><span class="line">            <span class="keyword">let</span> enabled_options = <span class="keyword">self</span>.enabled_options;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class="line">            titles.insert_cell(<span class="number">0</span>, cell!(Fybi -&gt; <span class="string">&quot;Path&quot;</span>));</span><br><span class="line">            titles</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> table = Table::new();</span><br><span class="line">        table.set_titles(titles);</span><br><span class="line">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (path, counts) <span class="keyword">in</span> <span class="keyword">self</span>.paths_with_counts &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class="line">            <span class="keyword">let</span> path_cell = <span class="keyword">if</span> path.starts_with(<span class="string">&quot;Input&quot;</span>) &#123;</span><br><span class="line">                cell!(Fbb -&gt; path.display())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cell!(Fmb -&gt; path.display())</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            row.insert_cell(<span class="number">0</span>, path_cell);</span><br><span class="line">            table.add_row(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        table</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_counts</span></span>(cli: &amp;Cli, content: <span class="built_in">String</span>) -&gt; Counts &#123;</span><br><span class="line">    <span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt;&gt; = <span class="built_in">vec!</span>[<span class="literal">None</span>; <span class="number">5</span>];</span><br><span class="line">    v.into_par_iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .map(|(idx, _)| <span class="keyword">match</span> idx &#123;</span><br><span class="line">            <span class="number">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class="line">            <span class="number">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class="line">            <span class="number">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class="line">            <span class="number">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class="line">            <span class="number">4</span> =&gt; cli</span><br><span class="line">                .longest_line</span><br><span class="line">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class="number">0</span>)),</span><br><span class="line">            _ =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .flatten()</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>然后就是 main 函数:</p><figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cli = Cli::parse();</span><br><span class="line">    <span class="keyword">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class="line">    pretty_table.printstd();</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就酱, 结束啦! 希望本文能帮到你 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习命令行的常识, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="Clap" scheme="https://jedsek.xyz/tags/Clap/"/>
    
    <category term="CLI" scheme="https://jedsek.xyz/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p4: GObject-子类化</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p4"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p4</id>
    <published>2022-08-09T14:52:26.000Z</published>
    <updated>2022-08-09T14:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a><br>GNOME入坑指南: <a href="/posts/gnome/guide">gnome-guide</a></p><h1 id=""></h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
  <entry>
    <title>GNOME 入坑指南</title>
    <link href="https://jedsek.xyz/posts/gnome/guide"/>
    <id>https://jedsek.xyz/posts/gnome/guide</id>
    <published>2022-07-20T03:22:42.000Z</published>
    <updated>2022-07-20T03:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p></blockquote><span id="more"></span><div class="tips"><p><strong>注意:</strong><br>本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式, 炫酷效果, 更多功能的, 请自行配置<br>请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>目前, 该篇文章的GNOME 版本为: <strong>42</strong></p></div><h1 id="cheng-pin-zhan-shi">成品展示</h1><p>2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前…<br>我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!</p><p><img data-src="/images/gnome/overview.png" alt="按下Super后的Overview"></p><hr><h1 id="dconf-amp-amp-gsettings">dconf &amp;&amp; gsettings</h1><ul class="lvl-0"><li class="lvl-2"><p><code>dconf</code>:<br>是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p></li><li class="lvl-2"><p><code>gsettings</code>:<br>是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p></li></ul><p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p><p>接下来的大部分配置, 都会使用 <code>gsettings</code></p><hr><h1 id="hong-mo-ban">触摸板</h1><p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p><h2 id="pei-zhi" id="配置">配置</h2><p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p><p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p><p>你可以在终端输入如下命令进行调整:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class="literal">true</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>分别对应:</p><ul class="lvl-0"><li class="lvl-2"><p>轻击模拟鼠标点击, 默认为false</p></li><li class="lvl-2"><p>调整触摸板速度, 默认为0</p></li><li class="lvl-2"><p>打字时禁用触摸板, 默认为true</p></li></ul><h2 id="shou-shi" id="手势">手势</h2><ul class="lvl-0"><li class="lvl-2"><p>单指: 移动鼠标</p></li><li class="lvl-2"><p>双指上下: 翻页</p></li><li class="lvl-2"><p>三指左右: 切换Workspace</p></li><li class="lvl-2"><p>三指上: 打开Overview (不常用, 按Super更快)</p></li><li class="lvl-2"><p>三指下: 显示任务栏 (当你隐藏任务栏时)</p></li></ul><hr><h1 id="an-zhuang-kuo-zhan">安装扩展</h1><p>GNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之<br>我将先介绍如何安装/使用它们, 因为后面需要用到扩展</p><p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p><h2 id="cong-ming-ling-xing" id="从命令行">从命令行</h2><div class="tips"><p><strong>提示</strong><br>请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有…<br>下载成功后, 切记要 logout, 然后再登进来</p></div><p>每个GNOME扩展都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载扩展</p><p>你可以在 <a href="https://extensions.gnome.org/">Extensions-GNOME</a> 这个网站上, 浏览并下载扩展<br>请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 <code>exts_list</code></p><p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p><div class="tabs" id="install-extensions"><ul class="nav-tabs"><li class="tab active"><a href="#install-extensions-1">Bash</a></li><li class="tab"><a href="#install-extensions-2">Fish</a></li></ul><div class="tab-content"><div class="tab-pane active" id="install-extensions-1"><figure class="highlight bash"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">declare</span> -a UUID_LIST</span><br><span class="line">EXTS_DIR=<span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions</span><br><span class="line">EXTS_LIST=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"><span class="function"><span class="title">str_join</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span> | sed <span class="string">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">mkdir -p <span class="variable">$EXTS_DIR</span></span><br><span class="line">chmod -R 755 <span class="variable">$HOME</span>/.<span class="built_in">local</span>/</span><br><span class="line"><span class="keyword">for</span> EXT <span class="keyword">in</span> <span class="variable">$EXTS_LIST</span>/*.zip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  UUID=$(unzip -p <span class="variable">$EXT</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span>)</span><br><span class="line">  mkdir -p <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  unzip -q -o <span class="variable">$EXT</span> -d <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  UUID_LIST+=<span class="string">&quot;\&quot;<span class="variable">$UUID</span>\&quot;&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">UUID_LIST=[$(str_join <span class="variable">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="install-extensions-2"><figure class="highlight bash"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> exts_list <span class="variable">$argv</span>[1]</span><br><span class="line"><span class="built_in">set</span> exts_dir <span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions/</span><br><span class="line"><span class="built_in">set</span> uuid_list</span><br><span class="line">mkdir -p <span class="variable">$exts_dir</span></span><br><span class="line"><span class="keyword">for</span> ext <span class="keyword">in</span> exts_list/*.zip</span><br><span class="line">  <span class="built_in">set</span> uuid ( unzip -p <span class="variable">$ext</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span> )</span><br><span class="line">  mkdir -p <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  unzip -q -o <span class="variable">$ext</span> -d <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  <span class="built_in">set</span> -a uuid_list \<span class="string">&#x27;$uuid\&#x27;</span></span><br><span class="line">end</span><br><span class="line"><span class="built_in">set</span> uuid_list [( string join <span class="string">&quot;,&quot;</span> <span class="variable">$uuid_list</span> )]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div><p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p><p><strong>注意: 先logout, 再登进来</strong></p><p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dbus-send --<span class="built_in">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \</span><br><span class="line">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class="string">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="cong-liu-lan-qi" id="从浏览器">从浏览器</h2><p>该方法其实也蛮方便的, 但不适合快速部署<br>你需要安装两个玩意, 才能直接从 <a href="https://extensions.gnome.org/">Extension-GNOME</a> 上直接下载</p><ul class="lvl-0"><li class="lvl-2"><p><code>chrome-gnome-shell</code>:<br>本地软件, 你可以通过包管理器, 直接搜这个名字</p></li><li class="lvl-2"><p><code>GNOME Shell integration</code>:<br>浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>Edge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p></li></ul><p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href="https://extensions.gnome.org/">网站</a> 上 直接安装到本地</p><hr><h1 id="cha-kan-pei-zhi-kuo-zhan">查看/配置扩展</h1><p>通过 <code>gnome-extensions</code> 这个命令, 我们可以查看/配置当前扩展</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帮助, `Command` 为可选项</span></span><br><span class="line">gnome-extensions <span class="built_in">help</span> [Command]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展列表</span></span><br><span class="line">gnome-extensions list --user    <span class="comment"># 查看用户级扩展</span></span><br><span class="line">gnome-extensions list --system  <span class="comment"># 查看系统级扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展的信息</span></span><br><span class="line">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用某个扩展</span></span><br><span class="line">gnome-extensions <span class="built_in">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line">gnome-extensions <span class="built_in">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置某个扩展 (打开 GUI 界面)</span></span><br><span class="line">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure><p>或者通过 <code>gsettings</code> 来配置某个扩展, 但不推荐, 因为麻烦:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看某个扩展的所有选项</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class="line"><span class="comment"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class="line"><span class="comment"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure><p>你也可以参考或<a href="#jia-zai-pei-zhi"><strong>直接加载</strong></a>我博客下的 <a href="/downloads/gnome/dconf.settings"><strong>dconf.settings</strong></a><br><strong>注意:</strong> 如何你选择直接加载我的配置, 请注意 <code>picture-uri</code> 符合自己实际</p><hr><h1 id="tui-jian-de-kuo-zhan">推荐的扩展</h1><p>以下是我目前正在使用, 推荐的扩展</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/16/auto-move-windows/">auto-move-windows</a>:<br>通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/905/refresh-wifi-connections/">refresh-wifi-connections</a><br>当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/refresh-wifi-connections.png" alt="refresh-wifi-connections"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1446/transparent-window-moving/">transparent-window-moving</a><br>在对窗口进行移动/调整大小时, 使窗口变得透明</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/transparent-window-moving.png" alt="transparent-window-moving"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3843/just-perfection/">just-perfection</a><br>我最喜欢的一个扩展, 用于对界面进行大量自定义与精简<br>比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="just-perfection"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3139/eye-extended/">eye-extended</a><br>很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场<br>在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/eye-extended.png" alt="eye-extended"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1113/nothing-to-say/">nothing-to-say</a><br>用于切断/恢复声音的输入, 对我来说蛮有用的:<br>当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/nothing-to-say.png" alt="nothing-to-say"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/5090/space-bar/">space-bar</a><br>模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 <code>Activities</code> 替换为 <code>Workspaces</code>, 有些类似的扩展, 但这个最好</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/space-bar.png" alt="space-bar"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4696/static-background-in-overview/">static-background-in-overview</a><br>在按下 <code>Super</code> 进入 <code>Overview</code> 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="static-background-in-overview"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4788/workspace-switcher-manager/">workspace-switcher-manager</a><br>美化通过键盘(我配成了 <code>Super + 1..9</code>), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/workspace-switcher-manager.png" alt="workspace-switcher-manager"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/">disable-workspace-switch-animation-for-GNOME40+</a><br>消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1319/gsconnect/">gsconnect</a><br>GNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href="/downloads/gnome/kdeconnect.apk">kdeconnect</a></p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gsconnect.png" alt="gsconnect"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3193/blur-my-shell/">blur-my-shell</a><br>用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="blur-my-shell"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3488/big-avatar/">big-avatar</a><br>让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/big-avatar.png" alt="big-avatar"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4530/cpudots/">cpudots</a><br>监视你当前的CPU频率, 以百分数的形式呈现在顶栏</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="cpudots"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4817/colorful-battery-indicator/">colorful-battery-indicator</a><br>让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="colorful-battery-indicator"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/">gnome40-ui-improvements</a><br>按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区的内容</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome40-ui-improvements.png" alt="gnome40-ui-improvements"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/">gnome-fuzzy-app-search</a><br>出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该扩展修改</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome-fuzzy-app-search.png" alt="gnome-fuzzy-app-search"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4691/pip-on-top/">pip-on-top</a><br>当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/4792/frequency-boost-switch/">frequency-boost-switch</a><br>在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/frequency-boost-switch.png" alt="frequency-boost-switch"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/1702/overview-navigation/">overview-navigation</a><br>当按下 <code>Super</code> 进入 <code>Overview</code> 后, 可以按下 <code>空格键</code>, 窗口上会出现字母<br>输入小写字母就切换到对应窗口, 按下 <code>Shift</code> 会使字母颜色变红, 此时输入字母会关闭对应窗口</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="overview-navigation"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3759/cleaner-overview/">cleaner-overview</a><br>进入 <code>Overview</code> 时, 将窗口排列整齐, 简单实用</p></li></ul><details><summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="cleaner-overview"></p></details><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/19/user-themes/">user-theme</a><br>从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br><strong>无图片</strong></p></li></ul><br><ul class="lvl-0"><li class="lvl-2"><p><a href="https://extensions.gnome.org/extension/3414/user-stylesheet-font/">user-syle-sheet</a><br>读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者<br><strong>无图片</strong></p></li></ul><hr><h1 id="mei-hua">美化</h1><p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>还有很多扩展有帮助, 上面 <a href="#tui-jian-de-kuo-zhan">推荐的扩展</a> 里有提到, 比如那个更改css的, 这里不说了</p><ul class="lvl-0"><li class="lvl-2"><p>启动暗模式:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface color-scheme <span class="string">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri-dark <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或将图片命名为.face, 放到家目录</span></span><br><span class="line"><span class="comment"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href="https://www.gnome-look.org/">gnome-look</a> 挑选主题</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 Nordic 为例子</span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface gtk-theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你也可以使用 `user-theme` 这个扩展进行设置:  </span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class="line">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface font-name <span class="string">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell favorite-apps <span class="string">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure><div class="tips"><p><strong>注意:</strong><br>以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 扩展<br>此扩展得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href="#jin-yong-kuai-jie-jian">禁用快捷键</a></p></div><ul class="lvl-0"><li class="lvl-2"><p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: <code>space-bar</code> 或 <code>workspace-bar</code>)</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences workspace-names <span class="string">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href="#cheng-pin-zhan-shi">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p></li></ul><hr><h1 id="kuai-jie-jian">快捷键</h1><p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p><p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p><div class="tips"><p><strong>注意:</strong><br>快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突</p></div><h2 id="cha-zhao-kuai-jie-jian" id="查找快捷键">查找快捷键</h2><p>首先, 我们得明白如何查找对应的快捷键</p><p>下面的命令会列出极大部分的快捷键:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings list-recursively | grep -E <span class="string">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure><p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>如果实在找不到, 一点点看过去也行 😃</p><h2 id="jin-yong-kuai-jie-jian" id="禁用快捷键">禁用快捷键</h2><p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>想要禁用该快捷键, 将对应的数组设置为空就行了</p><p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default: Super+&quot;1..9&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    gsettings <span class="built_in">set</span> org.gnome.shell.keybindings switch-to-application-<span class="variable">$i</span> <span class="string">&quot;[]&quot;</span>  </span><br><span class="line"><span class="keyword">done</span>    </span><br></pre></td></tr></table></figure><p>禁用快捷键还可以让你避免冲突, 比如:<br>某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p><p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class="string">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class="comment">#Default: Sup+L</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class="string">&quot;[]&quot;</span> <span class="comment"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure><h2 id="xiu-gai-kuai-jie-jian" id="修改快捷键">修改快捷键</h2><p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href="#tian-jia-kuai-jie-jian">添加快捷键</a> 不是一个概念<br>单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p><ul class="lvl-0"><li class="lvl-2"><p>Vim 式的案件, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class="line"></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class="string">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class="comment"># 放左边</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class="comment"># 最大化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class="comment"># 最小化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class="string">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class="comment"># 放右边</span></span><br></pre></td></tr></table></figure><p>对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管…</p><ul class="lvl-0"><li class="lvl-2"><p>move, resize, kill 一个窗口:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Move</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class="string">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class="string">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings close        <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class="comment">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Toggle max</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class="string">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class="comment">#Default: Alt+F10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max/Min</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings maximize          <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings minimize          <span class="string">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class="comment">#Default: Super+H</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle fullscreen</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class="string">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show desktop</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class="string">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class="variable">$i</span> <span class="string">&quot;[&#x27;&lt;Super&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class="variable">$i</span>   <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class="string">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class="string">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class="comment">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure><h2 id="tian-jia-kuai-jie-jian" id="添加快捷键">添加快捷键</h2><p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p><p>废话不多说, 你按下面照猫画虎, 就阔以了:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gp0=<span class="string">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line">gp1=<span class="string">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\</span></span><br><span class="line"><span class="string">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Keys</span></span><br><span class="line"><span class="comment"># 注意!!!!!!!</span></span><br><span class="line"><span class="comment"># 不要在最后添加逗号</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class="string">&quot;[     \</span></span><br><span class="line"><span class="string">    &#x27;<span class="variable">$gp0</span>/custom0/&#x27;, &#x27;<span class="variable">$gp0</span>/custom1/&#x27;, &#x27;<span class="variable">$gp0</span>/custom2/&#x27;, &#x27;<span class="variable">$gp0</span>/custom3/&#x27;               \</span></span><br><span class="line"><span class="string">]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Terminal</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ name     <span class="string">&#x27;Terminal&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ <span class="built_in">command</span>  <span class="string">&#x27;alacritty&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ binding  <span class="string">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Files</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ name     <span class="string">&#x27;Files&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ <span class="built_in">command</span>  <span class="string">&#x27;nautilus&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ binding  <span class="string">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Browser</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ name     <span class="string">&#x27;Browser&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ <span class="built_in">command</span>  <span class="string">&#x27;microsoft-edge-beta&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ binding  <span class="string">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Fcitx5 Reload</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ name     <span class="string">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ <span class="built_in">command</span>  <span class="string">&#x27;fcitx5 -r&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ binding  <span class="string">&#x27;&lt;Alt&gt;space&#x27;</span></span><br></pre></td></tr></table></figure><p>我相信你不会将时间浪费在掉在坑里面了<br>上面的一切已经非常非常全了</p><hr><h1 id="jia-zai-pei-zhi">加载配置</h1><p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p><p>你也可以参考或直接加载我博客下的 <a href="/downloads/gnome/dconf.settings"><strong>dconf.settings</strong></a></p><h2 id="dui-yu-fei-nixos" id="对于非Nixos">对于非Nixos</h2><p>对于普通的Linux发行版, 直接按下面的方式</p><ul class="lvl-0"><li class="lvl-2"><p>导出当前的dconf数据到某个文件:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>加载/导入某个dconf文件到当前系统:</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure><p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p><h2 id="dui-yu-nixos" id="对于Nixos">对于Nixos</h2><p>如果你使用 Nixos, 请先确保已经安装了 <a href="https://github.com/nix-community/home-manager">HomeManager</a><br>HomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p><p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br><span class="line">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure><p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">nixpkgs/</span><br><span class="line">├── gnome</span><br><span class="line">│   ├── <span class="selector-class">.background</span></span><br><span class="line">│   ├── <span class="selector-class">.face</span></span><br><span class="line">│   └── dconf<span class="selector-class">.nix</span></span><br><span class="line">└── home.nix</span><br></pre></td></tr></table></figure><p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">imports</span> = [</span><br><span class="line">  ./gnome/dconf.nix</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p><ul class="lvl-0"><li class="lvl-2"><p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class="line"><span class="keyword">let</span> <span class="attr">picture</span> = ../.background.png; <span class="keyword">in</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">picture-uri</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">  <span class="attr">picture-uri-dark</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">home.file.<span class="string">&quot;.face&quot;</span>.<span class="attr">source</span> = ./.face;</span><br></pre></td></tr></table></figure><p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="GNOME" scheme="https://jedsek.xyz/tags/GNOME/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p5: 类型与类型类</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p5"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p5</id>
    <published>2022-07-18T08:24:44.000Z</published>
    <updated>2022-07-18T08:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="kai-pian">开篇</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Haskell 中的类型(Type), 与类型类(Typeclass)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p4: 基础语法</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p4"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p4</id>
    <published>2022-07-12T13:46:05.000Z</published>
    <updated>2022-07-12T13:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Haskell 的数字, Bool, List, If语句</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p><h1 id="shu-zi">数字</h1><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span> + <span class="number">8</span>) * <span class="number">9</span> - <span class="number">10</span>   <span class="comment">-- 80</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>              <span class="comment">-- 2.5</span></span><br><span class="line"><span class="number">5</span> ^ <span class="number">2</span>              <span class="comment">-- 25</span></span><br><span class="line"><span class="number">5</span> ^  (<span class="number">2.0</span>)         <span class="comment">-- error</span></span><br><span class="line"><span class="number">5</span> ** (<span class="number">2.0</span>)         <span class="comment">-- 25.0 </span></span><br></pre></td></tr></table></figure><p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>以上的运算符号, 实际上都是函数</p><p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p><code>=&gt;</code> 后面的表示参数与返回值的类型<br><code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p><p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>以上的东西, 实际上类似于:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="params">(+)</span>&lt;<span class="title">a</span>: <span class="title">Num</span>&gt; <span class="params">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure><p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>Num 这个类型类了, 便起到一个约束的作用</p><p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p><hr><h1 id="bool">Bool</h1><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">True</span> &amp;&amp; <span class="type">False</span>      <span class="comment">-- False</span></span><br><span class="line"><span class="type">True</span> || <span class="type">False</span>      <span class="comment">-- True</span></span><br><span class="line"><span class="title">not</span> <span class="type">True</span>           <span class="comment">-- False</span></span><br></pre></td></tr></table></figure><p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">0</span>             <span class="comment">-- False</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> == <span class="number">1</span> + <span class="number">4</span>     <span class="comment">-- True</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span> /= <span class="string">&quot;AB&quot;</span>      <span class="comment">-- True</span></span><br></pre></td></tr></table></figure><p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>可以键入 <code>:t (==)</code> 查看其类型:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>表示接受的两个参数, 其类型相同, 都是a<br>并且a类型必须具有相等性, 返回值是Bool类型</p><p>注意:<br>由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>原因与先前的加法函数同理</p><p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>甚至连 If语句, 我们都可以自己写个函数来代替</p><p>If语句在 Haskell 中仅仅是个语法糖而已<br>在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>感兴趣的话, 可以自己去看下: <a href="https://wiki.haskell.org/If-then-else">传送门</a></p><hr><h1 id="list">List</h1><p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>就像是其他语言的数组一样, 但却更加强大</p><h2 id="sheng-lue-you-duan" id="省略右端">省略右端</h2><p>像下面, 就创建了一个有十个元素的List:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>a 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p><p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>你可以查看它的类型:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure><p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>比如:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]      <span class="comment">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p><p>回到刚才, 你可以一个个地输入元素, 创建List<br>不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.100</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.1000</span>]</span><br></pre></td></tr></table></figure><p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p><p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p><p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p><p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p><p>事实上, 这是 Haskell 中为数不多的隐式行为<br>任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p><p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">a</span> = <span class="number">100</span>::<span class="type">Integer</span>      <span class="comment">-- 100</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>                 <span class="comment">-- 101</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>::<span class="type">Int</span>            <span class="comment">-- error</span></span><br></pre></td></tr></table></figure><p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>根据 <a href="#shu-zi">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p><p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p><h2 id="she-zhi-bu-chang" id="设置步长">设置步长</h2><p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>同时, 取决于元素的类型, 会产生无限或有界的List</p><p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>如果你想调整步长的话, 可以像下面这样:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3.</span>.]          <span class="comment">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">10.</span>.]         <span class="comment">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure><p>你还可以设置小数的步长, 比如:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>..]     <span class="comment">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure><p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p><h2 id="lie-biao-tui-dao" id="列表推导">列表推导</h2><p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x | x &lt;- [<span class="number">1.</span>.], mod x <span class="number">2</span> == <span class="number">0</span>]  <span class="comment">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure><p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p><p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p></li><li class="lvl-2"><p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p></li><li class="lvl-2"><p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p></li></ul><p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x + y | x &lt;- [<span class="number">1.</span><span class="number">.3</span>], y &lt;- [<span class="number">1.</span><span class="number">.3</span>]]                   <span class="comment">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class="line">[x | x &lt;- [<span class="number">1.</span><span class="number">.100</span>], x `mod` <span class="number">2</span> == <span class="number">0</span>, x `mod` <span class="number">3</span> == <span class="number">0</span>]  <span class="comment">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure><p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p><ul class="lvl-0"><li class="lvl-2"><p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">100</span>]</span><br><span class="line">  <span class="keyword">if</span> x `<span class="keyword">mod</span>` <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x `<span class="keyword">mod</span>` <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure><p>因此, 你可以对比下下面两种式子:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x * y | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], y &lt;- [<span class="number">1.</span>.x]  ]</span><br><span class="line">[ x * y | x &lt;- [<span class="number">1.</span>.y],  y &lt;- [<span class="number">1.</span><span class="number">.10</span>] ]</span><br></pre></td></tr></table></figure><p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p><p>好了, 关于List, 暂时先到这吧<br>其实后面还有很多关于List的, 毕竟它太重要了</p><hr><h1 id="if-yu-ju">If语句</h1><p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p><p>毕竟 Haskell 比较特殊, 为了函数的 <a href="/posts/haskell-basic/p3/#chun-han-shu">纯度</a> , 特意搞了一堆东西<br>再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p><p>开始吧!</p><h2 id="dan-if" id="单if">单if</h2><p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p><p>BMI, Body Mass Index (身体质量指数)<br>它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p><p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p><div class="tips"><p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p><ol><li class="lvl-3">在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</li><li class="lvl-3">输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></li></ol></div><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>  bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p><p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">    <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>也蛮美观的, 但我更喜欢压行 😃</p><h2 id="duo-if" id="多If">多If</h2><p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p><p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &gt; <span class="number">25</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt;= <span class="number">18.5</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Healthy!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>哇, 看着好美, 好熟悉!<br>所以你为什么说没有多重If呢?</p><p>别急, 格式化之后:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">        <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt; <span class="number">18.5</span></span><br><span class="line">            <span class="keyword">then</span> putStrLn <span class="string">&quot;12&quot;</span></span><br><span class="line">            <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure><p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p><p>这节就到这, 看辉夜3的最后一集去了~~</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Haskell 的数字, Bool, List, If语句&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p3: 函数式介绍</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p3"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p3</id>
    <published>2022-06-26T08:16:10.000Z</published>
    <updated>2022-06-26T08:16:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>何为函数式编程(FP, 即Functional Programming) ?</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>那么, 开始吧!</p><h1 id="bian-cheng-fan-shi">编程范式</h1><h2 id="gai-lan" id="概览">概览</h2><p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p><p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>在世界上, 有许多编程范式, 最主要的有:</p><table><thead><tr><th>简称</th><th>中文名</th><th>英文名</th></tr></thead><tbody><tr><td>FP</td><td>函数式编程</td><td>Functional Programming</td></tr><tr><td>OOP</td><td>面向对象编程</td><td>Object-Oriented Programming</td></tr><tr><td>POP</td><td>面向过程编程</td><td>Procedure-Oriented Programming</td></tr><tr><td>LP</td><td>逻辑式编程</td><td>Logic Programming</td></tr><tr><td>DP</td><td>声明式编程</td><td>Declarative Programming</td></tr><tr><td>IP</td><td>命令式编程</td><td>Imperative Programming</td></tr></tbody></table><p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p><p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>下面是一些编程范式的例子:</p><div class="tips"><p><strong>提示</strong><br>如果你已经了解过以下范式, 直接跳到 <a href="#zong-jie"><strong>总结</strong></a> 吧</p></div><ul class="lvl-0"><li class="lvl-2"><p>面向过程:<br>优点:<br>解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>缺点:<br>代码复用能力差, 扩展性差, 繁琐</p></li><li class="lvl-2"><p>面向对象:<br>优点:<br>将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>缺点:<br>不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p></li><li class="lvl-2"><p>逻辑式:<br>优点:<br>通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>缺点:<br>玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p></li><li class="lvl-2"><p>函数式:<br>优点:<br>通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>缺点:<br>学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p></li><li class="lvl-2"><p>命令式:<br>有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p></li><li class="lvl-2"><p>声明式:<br>指你编程依靠描述, 而非面向过程地去思考<br>这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>特点是一旦脱离相关领域, 语法就不再便利</p></li></ul><h2 id="zong-jie" id="总结">总结</h2><p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p><p>比如:</p><ul class="lvl-0"><li class="lvl-2"><p>面向过程/面向对象 &amp;&amp; 命令式</p></li><li class="lvl-2"><p>函数式/逻辑式 &amp;&amp; 声明式</p></li><li class="lvl-2"><p>混合一种, 两种, 甚至各种范式</p></li></ul><p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p><p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>接下来, 我们就要专注于本节的主角, 函数式</p><p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>让我们开始对函数式的正式介绍吧!</p><hr><h1 id="gao-jie-han-shu">高阶函数</h1><p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p><p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br><s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p><p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p><hr><h1 id="bu-ke-bian-shu-ju">不可变数据</h1><p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p><p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p><p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p><p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>但不可变的数据能够有效降低并发的难度</p><p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p><hr><h1 id="fu-zuo-yong">副作用</h1><p>副作用(Side Effects), 指与外界发生的交互</p><p>假设有这么一个函数:<br>它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p><p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p><p>副作用包括, 但不限于:</p><ul class="lvl-0"><li class="lvl-2"><p>发送网络请求</p></li><li class="lvl-2"><p>访问系统状态</p></li><li class="lvl-2"><p>操作数据库</p></li><li class="lvl-2"><p>操作DOM</p></li><li class="lvl-2"><p>IO操作</p></li><li class="lvl-2"><p>修改函数外部的变量</p></li><li class="lvl-2"><p>使用具有副作用的函数 (传播性)</p></li></ul><p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>那么这将无法保证相同输入, 能得到相同输出</p><p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>绝对的没有副作用, 意味着这个程序绝对的没用</p><hr><h1 id="yin-yong-tou-ming">引用透明</h1><p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p><p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>以下是数学中的 RT, 简单来讲, 就是等式推导:</p><p>f(x) = (x+1)<sup>2</sup><br>f(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p><p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p><p>总而言之, 就是替换, 替换, 还是替换<br>即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p><p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>若有这么个函数:</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">double_x</span>(x: <span class="type">Int</span>): <span class="type">Int</span> &#123;</span><br><span class="line">    println(x);</span><br><span class="line">    return x+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p><p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>这通常是一些 BUG 的来源</p><p>RT, 即引用透明, 注定与副作用互斥</p><hr><h1 id="chun-han-shu">纯函数</h1><p>纯函数(Pure Functions), 表示引用透明的函数</p><p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p><p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p><p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p><p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p><hr><h1 id="qi-ta">其他</h1><p>以上是对函数式的小小概括<br>还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p><p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p><ul class="lvl-0"><li class="lvl-2"><p>埃氏筛求素数:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">primes</span> = filterPrime [<span class="number">2.</span>.]</span><br><span class="line">  <span class="keyword">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>斐波那契数列:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fibs</span> = <span class="number">0</span> : <span class="number">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>快速排列:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">qsort</span> [] = []</span><br><span class="line"><span class="title">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class="line">  <span class="keyword">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>辗转相除法求最大公约数:</p></li></ul><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">gcd&#x27;</span> x y</span><br><span class="line">  | y == <span class="number">0</span> = x</span><br><span class="line">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure><p>感谢你的观看, 咋们下期见!!<br>先让我鸽几天 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;何为函数式编程(FP, 即Functional Programming) ?&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p2: 环境搭建</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p2"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p2</id>
    <published>2022-06-25T13:57:14.000Z</published>
    <updated>2022-06-25T13:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先, 我们得搭建好 Haskell 的环境</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="bian-yi-qi-amp-amp-bao-guan-li">编译器 &amp;&amp; 包管理</h1><p>本文假设你使用的是Linux系统</p><p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p><ul class="lvl-0"><li class="lvl-2"><p><code>ghc</code>: Haskell 的编译器</p></li><li class="lvl-2"><p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p></li><li class="lvl-2"><p><code>cabal</code>: Hsakell的包管理器</p></li></ul><p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p><p>请确保都能正确显示版本:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ghc -V</span><br><span class="line">ghci -V</span><br><span class="line">cabal -V</span><br></pre></td></tr></table></figure><p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p><hr><h1 id="dai-ma-bian-ji">代码编辑</h1><p>推荐的代码编辑器:</p><ul class="lvl-0"><li class="lvl-2"><p>Helix (强推)</p></li><li class="lvl-2"><p>Nvim/Vim</p></li><li class="lvl-2"><p>Emacs</p></li><li class="lvl-2"><p>Vscode</p></li></ul><p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p><p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf copr <span class="built_in">enable</span> -y petersen/haskell-language-server</span><br><span class="line">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure><p>如果你使用的是 <a href="https://helix-editor.com/">Helix</a>, LSP将会直接启用<br>当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p><hr><h1 id="huan-yuan">换源</h1><p>Haskell的包都放在 <a href="https://hackage.haskell.org/">hackage</a>, 下载依赖时, 速度可能极慢<br>这时, 我们应该进行将其换成镜像源</p><p>若你使用cabal, 可以按照下面的做:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cabal user-config init</span><br><span class="line">sed -i <span class="string">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/hackage.haskell.org\//http:\/\/mirrors.ustc.edu.cn\/hackage\//g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class="line">cabal update</span><br></pre></td></tr></table></figure><p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p><p>至此, 环境准备工作已全部完成<br>下一节, 我们将正式开始学习 Haskell</p><hr><h1 id="geng-gai-ghci-ti-shi-fu">更改ghci提示符</h1><p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p><p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p><p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class="line">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure><p>第一行更改提示符<br>第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;首先, 我们得搭建好 Haskell 的环境&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>haskell-basic-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/haskell-basic/p1"/>
    <id>https://jedsek.xyz/posts/haskell-basic/p1</id>
    <published>2022-06-25T13:22:14.000Z</published>
    <updated>2022-06-25T13:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Haskell 的学习系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p><h1 id="xi-lie-shuo-ming">系列说明</h1><p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br><s>(毕竟是Haskell)</s></p><hr><h1 id="can-kao-zi-liao">参考资料</h1><ol><li class="lvl-3"><p>书籍</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good! (趣学指南)</a></p></li><li class="lvl-2"><p><a href="https://www.haskell.org/tutorial/">A Gentle Introduction to Haskell, Version 98</a></p></li></ul><ol start="2"><li class="lvl-3"><p>论坛</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://discourse.haskell.org/">Haskell Discourse</a></p></li></ul><ol start="3"><li class="lvl-3"><p>博客</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97">Lambda Calculus (Lambda演算)</a></p></li><li class="lvl-2"><p><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors In Pictures (图解函子)</a></p></li></ul><ol start="4"><li class="lvl-3"><p>Wiki</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://wiki.haskell.org/">Haskell Wiki</a></p></li></ul><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后,谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Haskell 的学习系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://jedsek.xyz/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>rust-tui-p1: 系列说明</title>
    <link href="https://jedsek.xyz/posts/rust-tui/p1"/>
    <id>https://jedsek.xyz/posts/rust-tui/p1</id>
    <published>2022-06-19T04:59:50.000Z</published>
    <updated>2022-06-19T04:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎大家来到 Rust 的 TUI 系列</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-tui">rust-tui</a></p><h1 id="xi-lie-shuo-ming">系列说明</h1><p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>当然, 还会介绍Rust中的两个crate: <code>tui</code> &amp;&amp; <code>crossterm</code></p><hr><h1 id="can-kao-zi-liao">参考资料</h1><ol><li class="lvl-3"><p>博客:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/">Playing with tui-rs</a></p></li><li class="lvl-2"><p><a href="https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/">Building a command-line interface in Rust</a></p></li></ul><ol start="2"><li class="lvl-3"><p>文档:</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><a href="https://docs.rs/tui/latest/tui/">tui-rs</a></p></li><li class="lvl-2"><p><a href="https://docs.rs/crossterm/latest/crossterm/">crossterm</a></p></li></ul><hr><h1 id="huan-ying-sao-rao">欢迎骚扰</h1><p>发现错误的话, 请及时跟我联系<br>你可以通过博客侧边栏上的联系方式找到我~~</p><p>最后, 谢谢你的观看 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;欢迎大家来到 Rust 的 TUI 系列&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="TUI" scheme="https://jedsek.xyz/tags/TUI/"/>
    
  </entry>
  
  <entry>
    <title>rust-gtk4-p3: GObject-内存管理</title>
    <link href="https://jedsek.xyz/posts/rust-gtk4/p3"/>
    <id>https://jedsek.xyz/posts/rust-gtk4/p3</id>
    <published>2022-03-30T04:01:22.000Z</published>
    <updated>2022-03-30T04:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p></blockquote><span id="more"></span><p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a><br>GNOME入坑指南: <a href="/posts/gnome/guide">gnome-guide</a></p><h1 id="widget">Widget</h1><p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p><p><a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p><p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>例如 <code>Button</code>, 其继承树如下:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">GObject</span><br><span class="line">└── Widget</span><br><span class="line">    └── <span class="selector-tag">Button</span></span><br></pre></td></tr></table></figure><p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p><p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p><ul class="lvl-0"><li class="lvl-2"><p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p></li><li class="lvl-2"><p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p></li><li class="lvl-2"><p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p></li></ul><hr><h1 id="cuo-wu-shi-xian">错误实现</h1><p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p><p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>下面是代码, 已经讲过的概念不再重复:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="comment">// 创建两个按钮, 设置Label</span></span><br><span class="line">    <span class="keyword">let</span> btn_inc = Button::builder()</span><br><span class="line">        .label(<span class="string">&quot;Increase&quot;</span>)</span><br><span class="line">        .margin_top(<span class="number">12</span>)</span><br><span class="line">        .margin_bottom(<span class="number">20</span>)</span><br><span class="line">        .margin_start(<span class="number">12</span>)</span><br><span class="line">        .margin_end(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">let</span> btn_dec = Button::builder()</span><br><span class="line">        .label(<span class="string">&quot;Decrease&quot;</span>)</span><br><span class="line">        .margin_top(<span class="number">12</span>)</span><br><span class="line">        .margin_bottom(<span class="number">20</span>)</span><br><span class="line">        .margin_start(<span class="number">12</span>)</span><br><span class="line">        .margin_end(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Clicked` 事件发生后的处理函数</span></span><br><span class="line">    <span class="comment">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">0</span>;</span><br><span class="line">    btn_inc.connect_clicked(|_| &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    btn_dec.connect_clicked(|_| &#123;</span><br><span class="line">        num -= <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class="line">    <span class="comment">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class="line">    <span class="keyword">let</span> gtk_box = gtk::<span class="built_in">Box</span>::builder()</span><br><span class="line">        .orientation(Orientation::Vertical)</span><br><span class="line">        .build();</span><br><span class="line">    gtk_box.append(&amp;btn_inc);</span><br><span class="line">    gtk_box.append(&amp;btn_dec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class="line">    <span class="comment">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">        .child(&amp;gtk_box)</span><br><span class="line">        .build();</span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p><p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p><p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p><p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>有没有什么办法, 让这两个闭包都能拥有num的所有权?</p><p>请看下面的正确实现, 通过引用计数的方式 😃</p><hr><h1 id="yin-yong-ji-shu">引用计数</h1><p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p><p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p><div class="tips"><p><strong>提示</strong><br>对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p></div><p>下面是代码, 请务必记得use一下:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> num_clone = num.clone();</span><br><span class="line"></span><br><span class="line">btn_inc.connect_clicked(|_| &#123;</span><br><span class="line">    num_clone.set(num_clone.get() + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn_dec.connect_clicked(|_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p><p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p><ul class="lvl-0"><li class="lvl-2"><p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p></li><li class="lvl-2"><p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p></li><li class="lvl-2"><p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p></li></ul><p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p><p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p><p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p><hr><h1 id="clone">clone!</h1><p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href="https://docs.rs/glib/latest/glib/macro.clone.html">glib::clone</a><br>请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> glib::clone;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;   <span class="comment">// 这里</span></span><br><span class="line"><span class="keyword">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class="comment">// 这里</span></span><br></pre></td></tr></table></figure><p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p><p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p><ul class="lvl-0"><li class="lvl-2"><p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p></li><li class="lvl-2"><p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p></li></ul><div class="tips"><p><strong>注意:</strong><br><code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>详情请见文档: <a href="https://docs.rs/glib/latest/glib/macro.clone.html">glib::clone</a></p></div><p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>循环引用导致内存泄漏!</p><hr><h1 id="xun-huan-yin-yong">循环引用</h1><p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br><s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p><p>贴一份刚刚的代码:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>这就是 <code>循环引用</code></p><p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p><p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p><p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>答案是不会, 原因是以下两段代码</p><ul class="lvl-0"><li class="lvl-2"><p>第一段:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gtk_box = gtk::<span class="built_in">Box</span>::builder()</span><br><span class="line">    .orientation(Orientation::Vertical)</span><br><span class="line">    .build();</span><br><span class="line">gtk_box.append(&amp;btn_inc);</span><br><span class="line">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>第二段:</p></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .child(&amp;gtk_box)</span><br><span class="line">    .build();</span><br><span class="line">win.present();</span><br></pre></td></tr></table></figure><p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p><p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br><code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br><code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>win活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p><p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p><p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="https://jedsek.xyz/tags/Rust/"/>
    
    <category term="GUI" scheme="https://jedsek.xyz/tags/GUI/"/>
    
  </entry>
  
</feed>
