<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hyprland 平铺式</title>
    <url>/posts/desktop-beautify/hyprland.html</url>
    <content><![CDATA[<blockquote>
<p>Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户</p>
</blockquote>
<span id="more"></span>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Hyprland</tag>
        <tag>Waylnad</tag>
        <tag>Desktop</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p1~&gt; 数据与信息</title>
    <url>/posts/high-school-it/p1.html</url>
    <content><![CDATA[<blockquote>
<p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p>
</blockquote>
<span id="more"></span>
<p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>
当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p>
<h1 id="shu-ju-de-ding-yi">数据的定义</h1>
<p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>
传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>
数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p>
</li>
<li class="lvl-2">
<p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p>
</li>
</ul>
<p>上面的两种情况中:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p>
</li>
<li class="lvl-2">
<p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p>
</li>
</ul>
<p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p>
<hr>
<h1 id="xin-xi-de-ding-yi">信息的定义</h1>
<p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>
其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p>
<p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>
比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是一台电脑笔记本</p>
</li>
<li class="lvl-2">
<p>这是一台屏幕大小为15.6英寸的电脑笔记本</p>
</li>
<li class="lvl-2">
<p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p>
</li>
<li class="lvl-2">
<p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p>
</li>
</ul>
<p>你会看到, 信息越多, 越能消除随机不确定性</p>
<hr>
<h1 id="xin-xi-de-te-zheng">信息的特征</h1>
<p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>
但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p>
<p>下面是信息的5个特征, 教科书上搬的:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>载体依附性<br>
信息不能独立存在, 它是虚的, 必须有载体<br>
比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p>
</li>
<li class="lvl-2">
<p>不损耗性信息在传播的过程中, 是不会发生损耗的</p>
</li>
<li class="lvl-2">
<p>时效性<br>
信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>
比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p>
</li>
<li class="lvl-2">
<p>共享性<br>
信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>
毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p>
</li>
<li class="lvl-2">
<p>可加工处理性/真伪性<br>
信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>
在比如 <code>盲人摸象/管中窥豹</code>, 都体现了真伪性</p>
</li>
<li class="lvl-2">
<p>价值性<br>
比如天气预报让你出门避免被雨淋湿, 这就是价值<br>
对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p>
</li>
</ul>
<hr>
<h1 id="zhi-shi-de-ding-yi">知识的定义</h1>
<p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的<br>
指的是人们已经掌握的能力</p>
<p>这部分很简单, 简单概述即可, 但请注意不要与下面的 <code>智慧的定义搞错了</code></p>
<hr>
<h1 id="zhi-hui-de-ding-yi">智慧的定义</h1>
<p>一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力</p>
<hr>
<h1 id="zong-jie">总结</h1>
<p>以下是一个很好的, 对三者进行了区分的例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p>
</li>
<li class="lvl-2">
<p>信息: 人们知道圆周率就是3.1415926</p>
</li>
<li class="lvl-2">
<p>知识: 人们知道如何求解圆的面积来解决现实问题</p>
</li>
<li class="lvl-2">
<p>智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术</p>
</li>
</ul>
<p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>
您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>GNOME 入坑指南</title>
    <url>/posts/desktop-beautify/gnome.html</url>
    <content><![CDATA[<blockquote>
<p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p>
</blockquote>
<span id="more"></span>
<p><strong>注意:</strong><br>
本篇文章的配置皆在注重简洁, 高效, 美观<br>
想要平铺式, 炫酷效果, 更多功能的, 请自行配置, 或查看我的另外一篇博客: <a href="/posts/desktop-beautify/hyprland">Hyprland 平铺式</a><br>
请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>
目前, 该篇文章的GNOME 版本为: <strong>42</strong></p>
<h1 id="cheng-pin-zhan-shi">成品展示</h1>
<p>2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前…<br>
我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!</p>
<p><img data-src="/images/gnome/overview.png" alt="按下Super后的Overview"></p>
<hr>
<h1 id="dconf-amp-amp-gsettings">dconf &amp;&amp; gsettings</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>dconf</code>:<br>
是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p>
</li>
<li class="lvl-2">
<p><code>gsettings</code>:<br>
是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p>
</li>
</ul>
<p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>
答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p>
<p>接下来的大部分配置, 都会使用 <code>gsettings</code></p>
<hr>
<h1 id="hong-mo-ban">触摸板</h1>
<p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p>
<h2 id="pei-zhi" id="配置">配置</h2>
<p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>
这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p>
<p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>
而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>
还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p>
<p>你可以在终端输入如下命令进行调整:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class="literal">true</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>分别对应:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>轻击模拟鼠标点击, 默认为false</p>
</li>
<li class="lvl-2">
<p>调整触摸板速度, 默认为0</p>
</li>
<li class="lvl-2">
<p>打字时禁用触摸板, 默认为true</p>
</li>
</ul>
<h2 id="shou-shi" id="手势">手势</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>单指: 移动鼠标</p>
</li>
<li class="lvl-2">
<p>双指上下: 翻页</p>
</li>
<li class="lvl-2">
<p>三指左右: 切换Workspace</p>
</li>
<li class="lvl-2">
<p>三指上: 打开Overview (不常用, 按Super更快)</p>
</li>
<li class="lvl-2">
<p>三指下: 显示任务栏 (当你隐藏任务栏时)</p>
</li>
</ul>
<hr>
<h1 id="an-zhuang-kuo-zhan">安装扩展</h1>
<p>GNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之<br>
我将先介绍如何安装/使用它们, 因为后面需要用到扩展</p>
<p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>
我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p>
<h2 id="cong-ming-ling-xing" id="从命令行">从命令行</h2>
<p><strong>提示</strong><br>
请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有…<br>
下载成功后, 切记要 logout, 然后再登进来</p>
<p>每个GNOME扩展都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载扩展</p>
<p>你可以在 <a href="https://extensions.gnome.org/">Extensions-GNOME</a> 这个网站上, 浏览并下载扩展<br>
请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 <code>exts_list</code></p>
<p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p>
<div class="tabs" id="install-extensions"><ul class="nav-tabs"><li class="tab active"><a href="#install-extensions-1">Bash</a></li><li class="tab"><a href="#install-extensions-2">Fish</a></li></ul><div class="tab-content"><div class="tab-pane active" id="install-extensions-1"><figure class="highlight bash"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">declare</span> -a UUID_LIST</span><br><span class="line">EXTS_DIR=<span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions</span><br><span class="line">EXTS_LIST=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"><span class="function"><span class="title">str_join</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span> | sed <span class="string">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">mkdir -p <span class="variable">$EXTS_DIR</span></span><br><span class="line">chmod -R 755 <span class="variable">$HOME</span>/.<span class="built_in">local</span>/</span><br><span class="line"><span class="keyword">for</span> EXT <span class="keyword">in</span> <span class="variable">$EXTS_LIST</span>/*.zip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  UUID=$(unzip -p <span class="variable">$EXT</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span>)</span><br><span class="line">  mkdir -p <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  unzip -q -o <span class="variable">$EXT</span> -d <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  UUID_LIST+=<span class="string">&quot;\&quot;<span class="variable">$UUID</span>\&quot;&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">UUID_LIST=[$(str_join <span class="variable">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="install-extensions-2"><figure class="highlight bash"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> exts_list <span class="variable">$argv</span>[1]</span><br><span class="line"><span class="built_in">set</span> exts_dir <span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions/</span><br><span class="line"><span class="built_in">set</span> uuid_list</span><br><span class="line">mkdir -p <span class="variable">$exts_dir</span></span><br><span class="line"><span class="keyword">for</span> ext <span class="keyword">in</span> exts_list/*.zip</span><br><span class="line">  <span class="built_in">set</span> uuid ( unzip -p <span class="variable">$ext</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span> )</span><br><span class="line">  mkdir -p <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  unzip -q -o <span class="variable">$ext</span> -d <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  <span class="built_in">set</span> -a uuid_list \<span class="string">&#x27;$uuid\&#x27;</span></span><br><span class="line">end</span><br><span class="line"><span class="built_in">set</span> uuid_list [( string join <span class="string">&quot;,&quot;</span> <span class="variable">$uuid_list</span> )]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p>
<p><strong>注意: 先logout, 再登进来</strong></p>
<p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dbus-send --<span class="built_in">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \</span><br><span class="line">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class="string">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="cong-liu-lan-qi" id="从浏览器">从浏览器</h2>
<p>该方法其实也蛮方便的, 但不适合快速部署<br>
你需要安装两个玩意, 才能直接从 <a href="https://extensions.gnome.org/">Extension-GNOME</a> 上直接下载</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>chrome-gnome-shell</code>:<br>
本地软件, 你可以通过包管理器, 直接搜这个名字</p>
</li>
<li class="lvl-2">
<p><code>GNOME Shell integration</code>:<br>
浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>
Edge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p>
</li>
</ul>
<p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href="https://extensions.gnome.org/">网站</a> 上 直接安装到本地</p>
<hr>
<h1 id="cha-kan-pei-zhi-kuo-zhan">查看/配置扩展</h1>
<p>通过 <code>gnome-extensions</code> 这个命令, 我们可以查看/配置当前扩展</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帮助, `Command` 为可选项</span></span><br><span class="line">gnome-extensions <span class="built_in">help</span> [Command]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展列表</span></span><br><span class="line">gnome-extensions list --user    <span class="comment"># 查看用户级扩展</span></span><br><span class="line">gnome-extensions list --system  <span class="comment"># 查看系统级扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展的信息</span></span><br><span class="line">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用某个扩展</span></span><br><span class="line">gnome-extensions <span class="built_in">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line">gnome-extensions <span class="built_in">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置某个扩展 (打开 GUI 界面)</span></span><br><span class="line">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure>
<p>或者通过 <code>gsettings</code> 来配置某个扩展, 但不推荐, 因为麻烦:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看某个扩展的所有选项</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class="line"><span class="comment"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class="line"><span class="comment"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure>
<p>你也可以参考或<a href="#jia-zai-pei-zhi"><strong>直接加载</strong></a> <code>dconf.settings</code> 文件<br>
<strong>注意:</strong> 如何你选择直接加载我的配置, 请注意 <code>picture-uri</code> 符合自己实际</p>
<hr>
<h1 id="tui-jian-de-kuo-zhan">推荐的扩展</h1>
<p>以下是我目前正在使用且推荐的扩展</p>
<p><strong>注意:</strong><br>
如果你是通过我的博客 jedsek.xyz 观看的话, 我默认隐藏了这些图片<br>
你可以展开任意一张图片后, 点击图片, 在 fancybox 种通过方向键切换图片 😃</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/16/auto-move-windows/">auto-move-windows</a>:<br>
通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/905/refresh-wifi-connections/">refresh-wifi-connections</a><br>
当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/refresh-wifi-connections.png" alt="refresh-wifi-connections"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1446/transparent-window-moving/">transparent-window-moving</a><br>
在对窗口进行移动/调整大小时, 使窗口变得透明</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/transparent-window-moving.png" alt="transparent-window-moving"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3843/just-perfection/">just-perfection</a><br>
我最喜欢的一个扩展, 用于对界面进行大量自定义与精简<br>
比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="just-perfection"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3139/eye-extended/">eye-extended</a><br>
很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场<br>
在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/eye-extended.png" alt="eye-extended"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1113/nothing-to-say/">nothing-to-say</a><br>
用于切断/恢复声音的输入, 对我来说蛮有用的:<br>
当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/nothing-to-say.png" alt="nothing-to-say"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/5090/space-bar/">space-bar</a><br>
模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 <code>Activities</code> 替换为 <code>Workspaces</code>, 有些类似的扩展, 但这个最好</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/space-bar.png" alt="space-bar"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4696/static-background-in-overview/">static-background-in-overview</a><br>
在按下 <code>Super</code> 进入 <code>Overview</code> 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="static-background-in-overview"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4788/workspace-switcher-manager/">workspace-switcher-manager</a><br>
美化通过键盘(我配成了 <code>Super + 1..9</code>), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/workspace-switcher-manager.png" alt="workspace-switcher-manager"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/">disable-workspace-switch-animation-for-GNOME40+</a><br>
消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1319/gsconnect/">gsconnect</a><br>
GNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>
手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href="/downloads/gnome/kdeconnect.apk">kdeconnect</a></p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gsconnect.png" alt="gsconnect"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3193/blur-my-shell/">blur-my-shell</a><br>
用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="blur-my-shell"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3488/big-avatar/">big-avatar</a><br>
让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/big-avatar.png" alt="big-avatar"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4530/cpudots/">cpudots</a><br>
监视你当前的CPU频率, 以百分数的形式呈现在顶栏</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="cpudots"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4817/colorful-battery-indicator/">colorful-battery-indicator</a><br>
让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="colorful-battery-indicator"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/">gnome40-ui-improvements</a><br>
按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区的内容</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome40-ui-improvements.png" alt="gnome40-ui-improvements"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/">gnome-fuzzy-app-search</a><br>
出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该扩展修改</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome-fuzzy-app-search.png" alt="gnome-fuzzy-app-search"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4691/pip-on-top/">pip-on-top</a><br>
当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4792/frequency-boost-switch/">frequency-boost-switch</a><br>
在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/frequency-boost-switch.png" alt="frequency-boost-switch"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1702/overview-navigation/">overview-navigation</a><br>
当按下 <code>Super</code> 进入 <code>Overview</code> 后, 可以按下 <code>空格键</code>, 窗口上会出现字母<br>
输入小写字母就切换到对应窗口, 按下 <code>Shift</code> 会使字母颜色变红, 此时输入字母会关闭对应窗口</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="overview-navigation"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3759/cleaner-overview/">cleaner-overview</a><br>
进入 <code>Overview</code> 时, 将窗口排列整齐, 简单实用</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="cleaner-overview"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/19/user-themes/">user-theme</a><br>
从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>
注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3414/user-stylesheet-font/">user-syle-sheet</a><br>
读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者<br>
<strong>无图片</strong></p>
</li>
</ul>
<hr>
<h1 id="mei-hua">美化</h1>
<p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>
还有很多扩展有帮助, 上面 <a href="#tui-jian-de-kuo-zhan">推荐的扩展</a> 里有提到, 比如那个更改css的, 这里不说了</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>启动暗模式:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface color-scheme <span class="string">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri-dark <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或将图片命名为.face, 放到家目录</span></span><br><span class="line"><span class="comment"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href="https://www.gnome-look.org/">gnome-look</a> 挑选主题</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 Nordic 为例子</span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface gtk-theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你也可以使用 `user-theme` 这个扩展进行设置:  </span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class="line">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface font-name <span class="string">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell favorite-apps <span class="string">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>
以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 扩展<br>
此扩展得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>
如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href="#jin-yong-kuai-jie-jian">禁用快捷键</a></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: <code>space-bar</code> 或 <code>workspace-bar</code>)</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences workspace-names <span class="string">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href="#cheng-pin-zhan-shi">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p>
</li>
</ul>
<hr>
<h1 id="kuai-jie-jian">快捷键</h1>
<p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p>
<p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>
当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p>
<p><strong>注意:</strong><br>
快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突</p>
<h2 id="cha-zhao-kuai-jie-jian" id="查找快捷键">查找快捷键</h2>
<p>首先, 我们得明白如何查找对应的快捷键</p>
<p>下面的命令会列出极大部分的快捷键:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings list-recursively | grep -E <span class="string">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure>
<p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>
如果实在找不到, 一点点看过去也行 😃</p>
<h2 id="jin-yong-kuai-jie-jian" id="禁用快捷键">禁用快捷键</h2>
<p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>
想要禁用该快捷键, 将对应的数组设置为空就行了</p>
<p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default: Super+&quot;1..9&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    gsettings <span class="built_in">set</span> org.gnome.shell.keybindings switch-to-application-<span class="variable">$i</span> <span class="string">&quot;[]&quot;</span>  </span><br><span class="line"><span class="keyword">done</span>    </span><br></pre></td></tr></table></figure>
<p>禁用快捷键还可以让你避免冲突, 比如:<br>
某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>
这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p>
<p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class="string">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class="comment">#Default: Sup+L</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class="string">&quot;[]&quot;</span> <span class="comment"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure>
<h2 id="xiu-gai-kuai-jie-jian" id="修改快捷键">修改快捷键</h2>
<p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href="#tian-jia-kuai-jie-jian">添加快捷键</a> 不是一个概念<br>
单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Vim 式的案件, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class="line"></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class="string">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class="comment"># 放左边</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class="comment"># 最大化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class="comment"># 最小化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class="string">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class="comment"># 放右边</span></span><br></pre></td></tr></table></figure>
<p>对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管…</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>move, resize, kill 一个窗口:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Move</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class="string">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class="string">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings close        <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class="comment">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Toggle max</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class="string">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class="comment">#Default: Alt+F10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max/Min</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings maximize          <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings minimize          <span class="string">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class="comment">#Default: Super+H</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle fullscreen</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class="string">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show desktop</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class="string">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class="variable">$i</span> <span class="string">&quot;[&#x27;&lt;Super&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class="variable">$i</span>   <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class="string">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class="string">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class="comment">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure>
<h2 id="tian-jia-kuai-jie-jian" id="添加快捷键">添加快捷键</h2>
<p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>
比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p>
<p>废话不多说, 你按下面照猫画虎, 就阔以了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gp0=<span class="string">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line">gp1=<span class="string">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\</span></span><br><span class="line"><span class="string">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Keys</span></span><br><span class="line"><span class="comment"># 注意!!!!!!!</span></span><br><span class="line"><span class="comment"># 不要在最后添加逗号</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class="string">&quot;[     \</span></span><br><span class="line"><span class="string">    &#x27;<span class="variable">$gp0</span>/custom0/&#x27;, &#x27;<span class="variable">$gp0</span>/custom1/&#x27;, &#x27;<span class="variable">$gp0</span>/custom2/&#x27;, &#x27;<span class="variable">$gp0</span>/custom3/&#x27;               \</span></span><br><span class="line"><span class="string">]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Terminal</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ name     <span class="string">&#x27;Terminal&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ <span class="built_in">command</span>  <span class="string">&#x27;alacritty&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ binding  <span class="string">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Files</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ name     <span class="string">&#x27;Files&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ <span class="built_in">command</span>  <span class="string">&#x27;nautilus&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ binding  <span class="string">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Browser</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ name     <span class="string">&#x27;Browser&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ <span class="built_in">command</span>  <span class="string">&#x27;microsoft-edge-beta&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ binding  <span class="string">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Fcitx5 Reload</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ name     <span class="string">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ <span class="built_in">command</span>  <span class="string">&#x27;fcitx5 -r&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ binding  <span class="string">&#x27;&lt;Alt&gt;space&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我相信你不会将时间浪费在掉在坑里面了<br>
上面的一切已经非常非常全了</p>
<hr>
<h1 id="jia-zai-pei-zhi">加载配置</h1>
<p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>
你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>
这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p>
<h2 id="dui-yu-fei-nixos" id="对于非Nixos">对于非Nixos</h2>
<p>对于普通的Linux发行版, 直接按下面的方式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>导出当前的dconf数据到某个文件:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>加载/导入某个dconf文件到当前系统:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure>
<p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>
同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p>
<h2 id="dui-yu-nixos" id="对于Nixos">对于Nixos</h2>
<p>如果你使用 Nixos, 请先确保已经安装了 <a href="https://github.com/nix-community/home-manager">HomeManager</a><br>
HomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p>
<p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>
请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>
随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br><span class="line">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure>
<p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">nixpkgs/</span><br><span class="line">├── gnome</span><br><span class="line">│   ├── <span class="selector-class">.background</span></span><br><span class="line">│   ├── <span class="selector-class">.face</span></span><br><span class="line">│   └── dconf<span class="selector-class">.nix</span></span><br><span class="line">└── home.nix</span><br></pre></td></tr></table></figure>
<p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">imports</span> = [</span><br><span class="line">  ./gnome/dconf.nix</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>
这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p>
</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class="line"><span class="keyword">let</span> <span class="attr">picture</span> = ../.background.png; <span class="keyword">in</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">picture-uri</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">  <span class="attr">picture-uri-dark</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p>
</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">home.file.<span class="string">&quot;.face&quot;</span>.<span class="attr">source</span> = ./.face;</span><br></pre></td></tr></table></figure>
<p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Waylnad</tag>
        <tag>Desktop</tag>
        <tag>GNOME</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p4~&gt; python基础语法-part2</title>
    <url>/posts/high-school-it/p4.html</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p5~&gt; 进制的转换与应用</title>
    <url>/posts/high-school-it/p5.html</url>
    <content><![CDATA[<blockquote>
<p>关于任意进制间的互相转换与应用</p>
</blockquote>
<span id="more"></span>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p2~&gt; 基础科普</title>
    <url>/posts/high-school-it/p2.html</url>
    <content><![CDATA[<blockquote>
<p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p>
</blockquote>
<span id="more"></span>
<p><strong>注意:</strong><br>
本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p>
<h1 id="bian-yi-yu-jie-shi">编译与解释</h1>
<p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>
c/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p>
<p>反正记住一点:<br>
机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 <code>.exe</code> 结尾的文件<br>
我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p>
<p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>
我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p>
<p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>
新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p>
<p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>
因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p>
<p><strong>代码:</strong><br>
代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>
它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>
编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p>
<p><strong>文件后缀:</strong><br>
文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>
后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p>
<p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>
windows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p>
<p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>
一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p>
<p>如何显示文件后缀?<br>
按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>
在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>
此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p>
<hr>
<h1 id="python-de-te-dian">Python的特点</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>是一门 <ins>高级语言</ins></p>
</li>
<li class="lvl-2">
<p>是一门 <ins>面向对象</ins> 的语言</p>
</li>
<li class="lvl-2">
<p>是一门 <ins>解释型</ins> 语言</p>
</li>
<li class="lvl-2">
<p>语法简单, 拥有丰富强大的库, 适合快速开发</p>
</li>
</ul>
<p><strong>高级语言</strong><br>
计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</p>
</li>
<li class="lvl-2">
<p>汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</p>
</li>
<li class="lvl-2">
<p>高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</p>
</li>
</ul>
<p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>
自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p>
<p><strong>面向对象</strong><br>
假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>
那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>
(非严谨版, 勿喷, 只是快速了解而已)</p>
<p><strong>库:</strong><br>
当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>
比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p>
<hr>
<h1 id="huan-jing-da-jian">环境搭建</h1>
<p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br>
<s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p>
<p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href="https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe">安装程序</a><br>
至于出现安装界面后点哪里, 你就记住两个地方:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p>
</li>
<li class="lvl-2">
<p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p>
</li>
</ul>
<p>如何检验自己是否安装成功?<br>
请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>
随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p>
<p>请输入以下命令, 检验python是否安装成功:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span>  --<span class="keyword">version</span></span><br></pre></td></tr></table></figure>
<p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>
我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>
它应该会输出类似下面的文字:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Python</span> <span class="number">3</span>.<span class="number">9</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p>
<div class="tips">
<p><strong>命令与路径</strong><br>
这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>
粗体闪烁的光标前的提示符, 表示你当前处于的路径</p>
<p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>
事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>
比如, 敲下 “C:\asdiasdadows\asdadtem32\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>
你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p>
<p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\asdad\xxx.exe” 该怎么办呢?<br>
这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p>
<p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>
就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p>
<p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>
因此, 出现了这个黑框框 😃</p>
<p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>
真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>
你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p>
</div>
<hr>
<h1 id="idle-de-bei-hou-yuan-li">idle的背后原理</h1>
<p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p>
<p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>
实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p>
<p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>
执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p>
<p>整个过程如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href="http://xxx.py">xxx.py</a>”</p>
</li>
<li class="lvl-2">
<p>在 cmd 中输入: <code>python xxx.py</code></p>
</li>
</ul>
<hr>
<h1 id="hello-world">Hello world!</h1>
<p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>
这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p>
<div class="tips">
<p><strong>注意:</strong><br>
这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>
你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p>
</div>
<p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>随后打开cmd/终端, 你的当前路径应该是 “C:\Users\用户名”<br>
我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br><span class="line">python first_app.txt</span><br></pre></td></tr></table></figure>
<p>这将会打印:</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>
当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p>
<p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>
(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p>
<p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>
当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>
这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p>
<p>但还是有个问题<br>
那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>
执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p>
<p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>
实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p>
<p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>
但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p>
<p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>
windows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>
你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p>
<p>python是可以调用外部命令的!</p>
<p>你可以在 first_app.py 中, 这样改进你的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br>
<code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p>
<p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p3~&gt; python基础语法-part1</title>
    <url>/posts/high-school-it/p3.html</url>
    <content><![CDATA[<blockquote>
<p>正式的对python语法的学习, 包含常见库函数的使用</p>
</blockquote>
<span id="more"></span>
<p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href="/posts/high-school-it/p2">p2: 基础科普与环境搭建</a><br>
<strong>感谢:</strong><br>
本文的切片部分来源于 <a href="https://zhuanlan.zhihu.com/p/79541418">python切片完全指南(语法篇)</a>, 已经过原作者准许</p>
<h1 id="bian-liang-yu-fu-zhi">变量与赋值</h1>
<p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>
需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p>
<p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>
你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p>
<p>有两个概念:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声明变量:  创建变量 (声明一个变量出现了)</p>
</li>
<li class="lvl-2">
<p>赋值: 把一个值装到箱子(变量)里</p>
</li>
</ul>
<p>比如, 一个很简单的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>
右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p>
<p>变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同</p>
<p>你也可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>
<p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>
第二行表示, 把a里面的数值取出来, 传给了b</p>
<p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">d = e = f = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a,b,c = d,e,f</span><br></pre></td></tr></table></figure>
<p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p>
<p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure>
<p>你可能会疑惑:<br>
当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>
该想法对应的代码是这样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = b</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>
<p>但在交换数值的代码中, 你应该这样理解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">_t1 = b</span><br><span class="line">_t2 = a</span><br><span class="line">a = _t1</span><br><span class="line">b = _t2</span><br></pre></td></tr></table></figure>
<p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>
只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了<br>
现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p>
<p>另外 选择题会出现这样的常见选项:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.  a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">B.  a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">C.  a = <span class="number">1</span>; b = <span class="number">2</span>; c = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已</p>
<hr>
<h1 id="bian-liang-ming-ming-gui-fan">变量命名规范</h1>
<p>python中, 变量的命名必须符合规范, 不然直接报错<br>
在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p>
<p>命名规范如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>变量名由字母, 数字, 下划线组成</p>
</li>
<li class="lvl-2">
<p>不能由数字开头</p>
</li>
<li class="lvl-2">
<p>中间不能有空格分割</p>
</li>
<li class="lvl-2">
<p>不能与python中的关键字重名</p>
</li>
</ul>
<p>以下都是合法的变量名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">abada</span><br><span class="line">asd111231</span><br><span class="line">ad190123kkad</span><br><span class="line">asd_asd1_asd2</span><br><span class="line">_123daa</span><br><span class="line">_as11</span><br></pre></td></tr></table></figure>
<p>以下是不合法的变量名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span></span></span><br><span class="line"><span class="function"><span class="title">not</span></span></span><br><span class="line"><span class="function"><span class="title">in</span></span></span><br><span class="line"><span class="function"><span class="title">lambda</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1123</span></span><br><span class="line"><span class="function">123<span class="title">adad</span></span></span><br><span class="line"><span class="function"><span class="title">sad</span>;;-``</span></span><br><span class="line"><span class="function">``?/</span></span><br><span class="line"><span class="function">&#x27;,</span></span><br></pre></td></tr></table></figure>
<p><strong>关键字:</strong><br>
关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>
这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>
比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p>
<p>你怎么知道哪些是关键字呢? 慢慢看吧, 像 <code>def/import/for/if/break</code> 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字</p>
<hr>
<h1 id="zhu-shi">注释</h1>
<h2 id="zuo-yong" id="作用">作用</h2>
<p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>
注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p>
<p>举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  此时 a 的值为 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure>
<p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>
后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p>
<p>再举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"><span class="built_in">max</span> = -<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = a</span><br><span class="line"><span class="keyword">elif</span> b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">max</span> = c</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure>
<p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p>
<h2 id="dan-duo-xing-zhu-shi" id="单-多行注释">单/多行注释</h2>
<p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 12345</span></span><br><span class="line"><span class="comment"># 上山打老虎</span></span><br><span class="line"><span class="comment"># 老虎打不着</span></span><br><span class="line"><span class="comment"># 打到小松鼠</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">12345</span></span><br><span class="line"><span class="string">上山打老虎</span></span><br><span class="line"><span class="string">老虎打不着</span></span><br><span class="line"><span class="string">打到小松鼠</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>
如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p>
<hr>
<h1 id="ji-ben-shu-ju-lei-xing">基本数据类型</h1>
<p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>
如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p>
<p>为了模拟现实, py将数据进行了抽象与分类:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>int: 对应整数</p>
</li>
<li class="lvl-2">
<p>float: 对应实数</p>
</li>
<li class="lvl-2">
<p>string: 对应文字</p>
</li>
<li class="lvl-2">
<p>bool: 对应真与假</p>
</li>
</ul>
<p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p>
<p>举些例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p>
</li>
<li class="lvl-2">
<p>我的年龄是16岁: 用int来表示 16 这个数字</p>
</li>
<li class="lvl-2">
<p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p>
</li>
</ul>
<p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>
你可以这样抽象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student &#123;</span><br><span class="line">  age:  <span class="built_in">int</span>,</span><br><span class="line">  height: <span class="built_in">float</span>,</span><br><span class="line">  name: string,</span><br><span class="line">  fat_or_not: <span class="built_in">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p>
<hr>
<h1 id="yun-suan-fu-yu-you-xian-ji">运算符与优先级</h1>
<p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>
这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>
在以下的图表中, 优先级1是最高, 数字越大优先级越低</p>
<h2 id="suan-zhu-yun-suan-fu" id="算术运算符">算术运算符</h2>
<p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>x的y次方</td>
<td>x**y</td>
<td>1</td>
</tr>
<tr>
<td>*</td>
<td>x乘以y</td>
<td>x*y</td>
<td>2</td>
</tr>
<tr>
<td>/</td>
<td>x除以y, 产生实数值</td>
<td>x/y</td>
<td>2</td>
</tr>
<tr>
<td>//</td>
<td>x除以y, 产生整数值</td>
<td>x//y</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>x除以y, 取余数</td>
<td>x%y</td>
<td>2</td>
</tr>
<tr>
<td>+</td>
<td>x加y</td>
<td>x+y</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>x减y</td>
<td>x-y</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p>
<p>算术运算符, 可以与赋值运算符相互结合:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span>  <span class="comment"># 是上面的等价物</span></span><br></pre></td></tr></table></figure>
<p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>
这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p>
<h2 id="guan-xi-yun-suan-fu" id="关系运算符">关系运算符</h2>
<p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>
(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>x 大于 y</td>
<td>x &gt; y</td>
</tr>
<tr>
<td>&lt;</td>
<td>x 小于 y</td>
<td>x &lt; y</td>
</tr>
<tr>
<td>&gt;=</td>
<td>x 大于等于 y</td>
<td>x &gt;= y</td>
</tr>
<tr>
<td>&lt;=</td>
<td>x 小于等于 y</td>
<td>x &lt;= y</td>
</tr>
<tr>
<td>==</td>
<td>x 等于 y</td>
<td>x == y</td>
</tr>
<tr>
<td>!=</td>
<td>x 不等于 y</td>
<td>x != y</td>
</tr>
</tbody>
</table>
<p><strong>注:</strong><br>
本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p>
<hr>
<h1 id="ji-ben-shu-ju-jie-gou">基本数据结构</h1>
<p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p>
<p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>
在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>
此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p>
<p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>
当然, 我们此处仅学习基本数据结构</p>
<h2 id="lie-biao" id="列表">列表</h2>
<p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p>
<h3 id="dan-suo-yin" id="单索引">单索引</h3>
<p>我们可以通过单个索引, 访问对应的单个元素</p>
<p>举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有着 3 个元素的列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]  <span class="comment"># 300</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]  <span class="comment"># 400</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>]  <span class="comment"># 500</span></span><br></pre></td></tr></table></figure>
<p><strong>扩展: 为何 index 从 0 开始?</strong><br>
因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>
实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>
用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p>
<p>你可以这样理解:<br>
一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>
你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p>
<p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>
如何访问第 1 个格子? 第一个格子向右跳 0 格<br>
如何访问第 2 个格子? 第二个格子向右跳 1 格<br>
如何访问第 3 个格子? 第三个格子向右跳 2 格</p>
<p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>
要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p>
<p>如果你非要把下标从 1 开始, 那就得这样:<br>
list[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>
于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>
同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>
同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p>
<p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>
现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br>
<s>(好吧, 原因其实真的只是因为习俗)</s></p>
<p>而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 😃</p>
<p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>
比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p>
<p>举个例子, 已知 <code>a = [10, 20, 30, 40, 50]</code> 让我们将其与图表进行对立:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>10</td>
<td>20</td>
<td>30</td>
<td>40</td>
<td>50</td>
</tr>
<tr>
<td>正索引</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>负索引</td>
<td>-5</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>显而易见的, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p>
<h3 id="suo-yin-yue-jie" id="索引越界">索引越界</h3>
<p>于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:</p>
<figure class="highlight python"><figcaption><span>demo.py</span></figcaption><table><tr><td class="code"><pre><span class="line">a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">a[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>当我们在命令行中执行 <code>python demo.py</code> (见 <a href="/posts/high-school-it/p2#huan-jing-da-jian">p2: 基础科普#环境搭建</a> ) 或直接使用图形化工具, 点击运行按钮</p>
<p>脑子想一想都知道肯定编译不过, 我们将得到以下报错:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;/home/jedsek/a.py&quot;</span>, <span class="built_in">line</span> <span class="number">2</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">a</span>[<span class="number">5</span>]</span><br><span class="line">    ~^^^</span><br><span class="line">IndexError: <span class="keyword">list</span> <span class="built_in">index</span> out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>
<p>看不懂的直接像做玩英语完形一样当作 “哔(屏蔽词)” 跳过就好, index 是 “索引/下标的意思”, 这条报错表示, 下标越界了!<br>
因为 a 是个长度为 5 的列表, 所以只能用 <code>n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)</code> 来当下标, 即 0 到 4, 因此 5 是非法的<br>
负索引也是一样的道理, 不能越界哟~~</p>
<h3 id="qie-pian" id="切片">切片</h3>
<p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p>
<p>举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>]  <span class="comment"># 定义列表</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">4</span>]  <span class="comment"># [201, 202, 203, 204]</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># [201, 202]</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">1</span>]  <span class="comment"># [201]</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>
我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p>
<p>图表依然会较为直观:</p>
<p><code>numbers = [201, 202, 203, 204]</code></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>切片</td>
<td>对应索引</td>
<td>取出的子列表</td>
</tr>
<tr>
<td>0:4</td>
<td>[0, 1, 2, 3]</td>
<td>[201, 202, 203, 204]</td>
</tr>
<tr>
<td>0:2</td>
<td>[0, 1]</td>
<td>[201, 202]</td>
</tr>
<tr>
<td>0:1</td>
<td>[0]</td>
<td>[201]</td>
</tr>
<tr>
<td>-3:-1</td>
<td>[-3, -2]</td>
<td>[202, 203]</td>
</tr>
</tbody>
</table>
<p>默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 <code>numbers[0:4:1]</code> 就相当于 <code>numbers[0:4]</code><br>
而 <code>numbers[0:4:2]</code> 则相当于从 <code>[0, 1, 2, 3]</code> 中的第一个元素 <code>0</code> 开始, 作为下标取 numbers 的元素, 然后走两步到 <code>2</code>, 依次类推<br>
步长不能设置为 0, 不然会报错</p>
<p>有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 <code>[]</code><br>
举个例子: <code>numbers[3:2]</code> 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分</p>
<h3 id="sheng-lue-yu-mo-ren-zhi" id="省略与默认值">省略与默认值</h3>
<p>关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 😃</p>
<p>已知 <code>a = [10, 20, 30, 40, 50]</code>, 你可以使用 <code>a[start:stop:step]</code> 来表示 a 的切片, 其中 start/stop/step 都是可以省略的<br>
当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 <code>a[start:stop]</code>/<code>a[start:stop:]</code> 的形式时, 步长会使用默认值1</p>
<p>而对于 <code>start/stop</code> 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取<br>
举些例子, 已知 <code>a = [10, 20, 30, 40, 50, 60, 70]</code>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>a[2:5:1]</code> 中, <code>2:4</code> 对应的下标是 <code>[2, 3, 4]</code>, 索引对应的元素是 <code>[30, 40, 50]</code>, 因为步长为1, 所以结果直接就是 <code>[30, 40, 50]</code></p>
</li>
<li class="lvl-2">
<p><code>a[2::1]</code> 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 <code>[30, 40, 50, 60, 70]</code></p>
</li>
<li class="lvl-2">
<p><code>a[:2:1]</code> 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 <code>[10, 20]</code></p>
</li>
<li class="lvl-2">
<p><code>a[2::-1]</code> 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 <code>[30, 20, 10]</code></p>
</li>
<li class="lvl-2">
<p><code>a[:2:-1]</code> 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 <code>[70, 60, 50, 40]</code></p>
</li>
</ul>
<p>什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>start</code> 代表列表中某个元素的下标, 这个元素是切片的起头</p>
</li>
<li class="lvl-2">
<p><code>stop</code> 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)</p>
</li>
<li class="lvl-2">
<p><code>step</code> 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取</p>
</li>
</ul>
<p>要开始了哦, 超级直观的方法:</p>
<p>以 <code>a[2:5:1]</code> 为例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>
</li>
<li class="lvl-2">
<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>
</li>
<li class="lvl-2">
<p>因为 <code>stop</code> 是 <code>5</code>, 所以箭头的终点是 <code>50</code> (箭头从 60 逆方向缩一格): [10, 20, <s>30, 40, 50</s>&gt;, 60, 70]</p>
</li>
</ul>
<p>以 <code>a[2::1]</code> 为例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>
</li>
<li class="lvl-2">
<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>
</li>
<li class="lvl-2">
<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>
</li>
</ul>
<p>以 <code>a[:2:1]</code> 为例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>
</li>
<li class="lvl-2">
<p>因为 <code>start</code> 被省略, 所以箭头的起点在左边的无限远处, 不用动: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>
</li>
<li class="lvl-2">
<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>20</code> (箭头从 30 逆方向缩一格): <s>[10, 20</s>&gt;, 30, 40, 50, 60, 70]</p>
</li>
</ul>
<p>以 <code>a[2::-1]</code> 为例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>
</li>
<li class="lvl-2">
<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>
</li>
<li class="lvl-2">
<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>
</li>
</ul>
<p>以 <code>a[:2:-1]</code> 为例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>
</li>
<li class="lvl-2">
<p>因为 <code>start</code> 被省略, 所以箭头的起点在右边的无限远处, 不用动: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>
</li>
<li class="lvl-2">
<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>40</code> (箭头从 30 逆方向缩一格): [10, 20, 30, &lt;<s>40, 50, 60, 70]</s></p>
</li>
</ul>
<p>对于负索引也是一样的道理, 先确定好 <code>start</code> 与 <code>stop</code> 的位置, 然后根据步长画对应方向的箭头<br>
照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行<br>
最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可</p>
<hr>
<h2 id="zi-dian" id="字典">字典</h2>
<p>python 中的字典, 实际上就是一些键值对组成的集合<br>
键值对, 指的就是根据某个键值, 获取其对应的另外一个值</p>
<p>举个例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>名字: “小明”</p>
</li>
<li class="lvl-2">
<p>年龄(year): 16</p>
</li>
<li class="lvl-2">
<p>身高(cm): 178</p>
</li>
</ul>
<p>名字 -&gt; “小明”, 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了</p>
<p>在 python 中, 你可以用一对花括号来定义字典:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;Shadd&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;Lasd&#x27;</span>: <span class="number">111</span>, <span class="string">&#x27;PPqwea&#x27;</span>: <span class="number">899</span>&#125;</span><br></pre></td></tr></table></figure>
<p>冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  <code>a['Shadd']</code> 将得到 <code>10</code></p>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>clap-rs 简介</title>
    <url>/posts/rust-clap/intro.html</url>
    <content><![CDATA[<blockquote>
<p>了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p>
</blockquote>
<span id="more"></span>
<p>前置知识: Rust基础<br>
完整代码: <a href="https://github.com/Jedsek/rust-wc">github/jedsek/rust-wc</a></p>
<p><strong>注意</strong><br>
本项目基于当前最新版本的 clap, 也就是 version 4<br>
本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p>
<p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>
官方教程: <a href="https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html">derive tutorial</a><br>
官方资料: <a href="https://docs.rs/clap/latest/clap/_derive/index.html">derive reference</a></p>
<h1 id="cheng-pin-zhan-shi">成品展示</h1>
<p>你可以通过如下命令, 从 <a href="https://crates.io">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install rust-wc</span><br></pre></td></tr></table></figure>
<p>以下是使用 <a href="https://asciinema.org/">asciinema</a> 录制的展示:</p>
<script id="asciicast-534647" src="https://asciinema.org/a/534647.js" async></script>
<hr>
<h1 id="ji-chu-gai-nian">基础概念</h1>
<p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>
如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p>
<p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>
我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p>
<p><strong>注意:</strong><br>
cli 可以代表抽象的界面, 也可以指代具体的某个程序<br>
后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p>
<p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>参数(Arguments)</code>:<br>
传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p>
</li>
<li class="lvl-2">
<p><code>选项(Options)</code>:<br>
通常以单/双横杠开头, 不同的options表示不同的行为<br>
比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>
单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p>
</li>
<li class="lvl-2">
<p><code>子命令(Subcommands)</code>:<br>
一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>
比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p>
</li>
<li class="lvl-2">
<p><code>双横杠(--)</code>:<br>
在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>
举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>
如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>
在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>
此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p>
</li>
<li class="lvl-2">
<p><code>短/长帮助(short/long help)</code>:<br>
有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p>
</li>
</ul>
<hr>
<h1 id="chu-shi-pei-zhi">初始配置</h1>
<p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>
请自行创建好目录:</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">./rust-wc</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">   ├── wc_result.rs   <span class="meta"># 计算并存储结果</span></span><br><span class="line">   ├── <span class="keyword">cli</span>.rs         <span class="meta"># 命令行的定义</span></span><br><span class="line">   ├── files.rs       <span class="meta"># 读取文件</span></span><br><span class="line">   ├── lib.rs         <span class="meta"># 声明模块, 类型别名</span></span><br><span class="line">   └── main.rs</span><br></pre></td></tr></table></figure>
<p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p>
<figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust-wc&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class="line"><span class="section">[[bin]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rwc&quot;</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/main.rs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定依赖</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clap</span> = &#123;version = <span class="string">&quot;4.0.8&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>]&#125;      <span class="comment"># 解析参数</span></span><br><span class="line"><span class="attr">unicode-width</span> = <span class="string">&quot;0.1.10&quot;</span>                               <span class="comment"># 计算 Unicode 字符宽度</span></span><br><span class="line"><span class="attr">indicatif</span> = <span class="string">&quot;0.17.1&quot;</span>                                   <span class="comment"># 进度条</span></span><br><span class="line"><span class="attr">prettytable-rs</span> = <span class="string">&quot;0.9.0&quot;</span>                               <span class="comment"># 打印表格</span></span><br><span class="line"><span class="attr">rayon</span> = <span class="string">&quot;1.5.3&quot;</span>                                        <span class="comment"># 并行化</span></span><br></pre></td></tr></table></figure>
<p>以下是 <a href="http://lib.rs">lib.rs</a> 的内容:</p>
<figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cli;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> files;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> wc_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Counts</span></span> = <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="ming-ling-ding-yi">命令定义</h1>
<p><strong>注意:</strong><br>
clap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>
因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>
这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p>
<p>让我们来想象下这个命令:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须接受一个参数</p>
</li>
<li class="lvl-2">
<p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p>
</li>
<li class="lvl-2">
<p>根据启用的 flag 来决定计算并打印哪些东西</p>
</li>
</ul>
<p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p>
<figure class="highlight rust"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span>  <span class="comment">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    author, version, about,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest_line&quot;</span>]</span>)),</span><br><span class="line">    subcommand_negates_reqs = <span class="literal">true</span>,</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the byte counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the character counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> chars: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the word counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> words: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the line counts</span></span><br><span class="line">    <span class="meta">#[arg(short, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> lines: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the maximum line width (Unicode)</span></span><br><span class="line">    <span class="meta">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class="line">    <span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[command(subcommand)]</span></span><br><span class="line">    <span class="keyword">pub</span> sub_commands: <span class="built_in">Option</span>&lt;SubCommands&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Subcommand)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubCommands</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Enabled all available options</span></span><br><span class="line">    All &#123;</span><br><span class="line">        <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">        <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">        paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_path</span></span>(filename: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PathBuf, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = PathBuf::from(filename);</span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Cli &#123;</span><br><span class="line">    <span class="comment">// 开启所有的 options</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">enable_all_options</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.bytes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.chars = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.words = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.lines = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">self</span>.longest_line = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_enabled_options</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> enabled_options = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.bytes.then(|| enabled_options.push(<span class="string">&quot;Bytes&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.chars.then(|| enabled_options.push(<span class="string">&quot;Chars&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.words.then(|| enabled_options.push(<span class="string">&quot;Words&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.lines.then(|| enabled_options.push(<span class="string">&quot;Lines&quot;</span>));</span><br><span class="line">        <span class="keyword">self</span>.longest_line.then(|| enabled_options.push(<span class="string">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class="line"></span><br><span class="line">        enabled_options</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>
得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>
也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p>
<p>clap 以及为我们做好了一切 😃</p>
<p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> rust_wc::&#123;cli::Cli, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cli = Cli::parse();</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wen-dang-zhu-shi-yu-bang-zhu" id="文档注释与帮助">文档注释与帮助</h2>
<p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo run -- -h</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">A GNU/wc clone written in rust, which <span class="keyword">is</span> super faster when reading <span class="keyword">a</span> large of big <span class="keyword">files</span></span><br><span class="line"></span><br><span class="line">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class="built_in">line</span>&gt; <span class="symbol">&lt;PATH&gt;</span>...</span><br><span class="line">       rwc [PATH]... <span class="symbol">&lt;COMMAND&gt;</span></span><br><span class="line"></span><br><span class="line">Command<span class="variable">s:</span></span><br><span class="line">  <span class="keyword">all</span>   Enabled <span class="keyword">all</span> available <span class="keyword">options</span></span><br><span class="line">  <span class="keyword">help</span>  <span class="keyword">Print</span> this message <span class="built_in">or</span> the <span class="keyword">help</span> of the given subcommand(s)</span><br><span class="line"></span><br><span class="line">Argument<span class="variable">s:</span></span><br><span class="line">  <span class="symbol">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class="line"></span><br><span class="line">Option<span class="variable">s:</span></span><br><span class="line">  -<span class="keyword">b</span>, --bytes         <span class="keyword">Print</span> the byte counts</span><br><span class="line">  -<span class="keyword">c</span>, --chars         <span class="keyword">Print</span> the character counts</span><br><span class="line">  -<span class="keyword">w</span>, --words         <span class="keyword">Print</span> the word counts</span><br><span class="line">  -<span class="keyword">l</span>, --lines         <span class="keyword">Print</span> the <span class="built_in">line</span> counts</span><br><span class="line">  -L, --longest-<span class="built_in">line</span>  <span class="keyword">Print</span> the maximum <span class="built_in">line</span> width (Unicode)</span><br><span class="line">  -h, --<span class="keyword">help</span>          <span class="keyword">Print</span> <span class="keyword">help</span> information</span><br><span class="line">  -V, --<span class="keyword">version</span>       <span class="keyword">Print</span> <span class="keyword">version</span> information</span><br></pre></td></tr></table></figure>
<p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>
没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p>
<p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    about = <span class="meta-string">&quot;...&quot;</span>,</span></span><br><span class="line"><span class="meta">// ......</span></span><br><span class="line"><span class="meta">// ......</span></span><br></pre></td></tr></table></figure>
<p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>
你可以查看 <a href="https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p>
<p>你可以像这样将 builder形式 的代码转化为 derive形式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Command::new(<span class="string">&quot;myprog&quot;</span>)</span><br><span class="line">    .help_template(<span class="string">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    help_template = <span class="meta-string">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class="line"><span class="meta">// ......</span></span><br><span class="line"><span class="meta">// ......</span></span><br></pre></td></tr></table></figure>
<p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p>
<h2 id="xuan-xiang-yu-can-shu-de-sheng-cheng" id="选项与参数的生成">选项与参数的生成</h2>
<p>clap 能非常方便地以声明的方式, 定义选项/参数</p>
<h3 id="xuan-xiang" id="选项">选项</h3>
<p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print the byte counts</span></span><br><span class="line"><span class="meta">#[arg(short, long)]</span></span><br><span class="line"><span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br></pre></td></tr></table></figure>
<p>它由三部分组成:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文档注释: help 中对该命令的解释</p>
</li>
<li class="lvl-2">
<p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p>
</li>
<li class="lvl-2">
<p>类型为bool: 传入时默认的行为是将其设置为 true</p>
</li>
</ul>
<p>如 help 中所示, 会生成如下内容:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Options</span>:</span><br><span class="line">  -b, --bytes         <span class="keyword">Print</span> the <span class="keyword">byte</span> counts</span><br></pre></td></tr></table></figure>
<p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>
你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p>
<p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Print the maximum line width (Unicode)</span></span><br><span class="line"><span class="meta">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class="line"><span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br></pre></td></tr></table></figure>
<h3 id="can-shu" id="参数">参数</h3>
<p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p>
<p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>
为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The path(s) you should provide</span></span><br><span class="line"><span class="meta">#[arg(value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line"><span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure>
<p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -b</span><br></pre></td></tr></table></figure>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>The following required arguments were not provided:</span><br><span class="line">  &lt;PATH&gt;...</span><br><span class="line"></span><br><span class="line">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class="line"></span><br><span class="line">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>
<p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>
没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>
但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p>
<p>因此, 我们来学学如何使用自定义的参数解析器吧</p>
<h2 id="zi-ding-yi-can-shu-jie-xi-qi" id="自定义参数解析器">自定义参数解析器</h2>
<p>有些疑问或许会萦绕在你的心头:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>clap 是怎么进行解析的?</p>
</li>
<li class="lvl-2">
<p>clap 能否将传入的参数, 解析为自定义的类型呢?</p>
</li>
<li class="lvl-2">
<p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p>
</li>
</ul>
<p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>
比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">check_path</span></span>(filename: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;PathBuf, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> path = PathBuf::from(filename);</span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">Err</span>(<span class="built_in">format!</span>(<span class="string">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>
该错误会在用户传入非法路径时, 作为报错信息出现:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class="line"></span><br><span class="line">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>
<p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>
得益于此, 你可以为任何类型定义对应的 parser</p>
<h2 id="can-shu-guan-xi" id="参数关系">参数关系</h2>
<p>有时候, 我们可能会面临这样或那样的问题:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p>
</li>
<li class="lvl-2">
<p>一个或多个指定的 option(s) 必须被启用</p>
</li>
<li class="lvl-2">
<p>多个指定的 options 可以同时被启用</p>
</li>
</ul>
<p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>
它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>
因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p>
<p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p>
<p>以我们的 <code>rwc</code> 举个例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p>
</li>
<li class="lvl-2">
<p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p>
</li>
</ul>
<p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>
我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    author, version, about,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest_line&quot;</span>]</span>)),</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
<p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p>
<h2 id="zi-ming-ling" id="子命令">子命令</h2>
<p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="meta">#[command(subcommand)]</span></span><br><span class="line">    <span class="keyword">pub</span> sub_commands: <span class="built_in">Option</span>&lt;SubCommands&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Subcommand)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">SubCommands</span></span> &#123;</span><br><span class="line">    <span class="comment">/// Enabled all available options</span></span><br><span class="line">    All &#123;</span><br><span class="line">        <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">        <span class="meta">#[arg(value_parser = check_path, value_name = <span class="meta-string">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class="line">        paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>
当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p>
<p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href="https://github.com/clap-rs/clap/issues/1546">相关issue</a></p>
<p><strong>注意:</strong><br>
这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>
但本文还是定义了 subcommand 以便读者了解, 起演示作用</p>
<hr>
<h1 id="luo-ji-shi-xian">逻辑实现</h1>
<p>根据:</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">├── wc_result.rs   <span class="meta"># 计算并存储结果</span></span><br><span class="line">├── <span class="keyword">cli</span>.rs         <span class="meta"># 命令行的定义</span></span><br><span class="line">├── files.rs       <span class="meta"># 读取文件</span></span><br></pre></td></tr></table></figure>
<p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>
为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p>
<figure class="highlight rust"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> cli;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> files;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> wc_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Counts</span></span> = <span class="built_in">Vec</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p>
<div class="tabs" id="逻辑实现代码"><ul class="nav-tabs"><li class="tab active"><a href="#逻辑实现代码-1">读取文件</a></li><li class="tab"><a href="#逻辑实现代码-2">进行计算</a></li></ul><div class="tab-content"><div class="tab-pane active" id="逻辑实现代码-1"><figure class="highlight rust"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明依赖</span></span><br><span class="line"><span class="comment">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class="line"><span class="keyword">use</span> crate::&#123;PathWithContent, <span class="built_in">Result</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;BufReader, Read&#125;,</span><br><span class="line">    path::PathBuf,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class="line"><span class="comment">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class="line"><span class="keyword">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> BUFFER_SIZR: <span class="built_in">usize</span> = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class="line"><span class="comment">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class="line"><span class="comment">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PathExt</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">without_dotted_prefix</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_dotted_prefix</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> PathExt <span class="keyword">for</span> PathBuf &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">without_dotted_prefix</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.is_relative() &amp;&amp; !<span class="keyword">self</span>.starts_with(<span class="string">&quot;../&quot;</span>) &amp;&amp; !<span class="keyword">self</span>.starts_with(<span class="string">&quot;./&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_dotted_prefix</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = PathBuf::from_iter([OsStr::new(<span class="string">&quot;./&quot;</span>), <span class="keyword">self</span>.as_os_str()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">read_files</span></span>(paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;) -&gt; <span class="built_in">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class="line">    <span class="keyword">let</span> result = paths</span><br><span class="line">        .into_par_iter()</span><br><span class="line">        .filter(|path| path.is_file() || path.as_os_str() == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">        .map(|<span class="keyword">mut</span> path| &#123;</span><br><span class="line">            <span class="keyword">let</span> should_read_from_input = path.as_os_str() == <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> path.without_dotted_prefix() &#123;</span><br><span class="line">                path.add_dotted_prefix();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> should_read_from_input &#123;</span><br><span class="line">                <span class="keyword">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">                path = PathBuf::from(<span class="built_in">format!</span>(<span class="string">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class="line">                eprintln!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            (path, content)</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line">    <span class="literal">Ok</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// helper 函数, 针对单个路径</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class="built_in">bool</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> should_read_from_input &#123;</span><br><span class="line">        read_from_stdin()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bars = MultiProgress::new();</span><br><span class="line">        <span class="keyword">let</span> style =</span><br><span class="line">            ProgressStyle::with_template(<span class="string">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class="line">                .progress_chars(<span class="string">&quot;&gt;-&quot;</span>);</span><br><span class="line">        read_file_with_progress(path, style, bars)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对应路径的文件</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> file = File::open(path)?;</span><br><span class="line">    <span class="keyword">let</span> size = file.metadata()?.len();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bar = ProgressBar::new(size).with_message(<span class="built_in">format!</span> &#123;<span class="string">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class="line">    <span class="keyword">let</span> bar = bars.add(bar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bufreader = BufReader::new(file);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0</span>; BUFFER_SIZR];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Ok</span>(n) = bufreader.read(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bar.inc(n <span class="keyword">as</span> <span class="built_in">u64</span>);</span><br><span class="line">        content += &amp;<span class="built_in">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class="line">    &#125;</span><br><span class="line">    bar.finish_with_message(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_from_stdin</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> content = <span class="built_in">vec!</span>[];</span><br><span class="line">    std::io::stdin().read_to_end(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="built_in">String</span>::from_utf8(content)?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="逻辑实现代码-2"><figure class="highlight rust"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明依赖</span></span><br><span class="line"><span class="keyword">use</span> crate::&#123;</span><br><span class="line">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class="line">    files::read_files,</span><br><span class="line">    Counts, <span class="built_in">Result</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class="line"><span class="keyword">use</span> rayon::prelude::*;</span><br><span class="line"><span class="keyword">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class="built_in">str</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放被启用的 options, 与键值对</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">WcResult</span></span> &#123;</span><br><span class="line">    enabled_options: <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>&gt;,</span><br><span class="line">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化函数</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get</span></span>(<span class="keyword">mut</span> cli: Cli) -&gt; <span class="built_in">Result</span>&lt;WcResult&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please waiting...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子命令进行相应操作</span></span><br><span class="line">    <span class="keyword">match</span> cli.sub_commands &#123;</span><br><span class="line">        <span class="literal">Some</span>(SubCommands::All &#123; <span class="keyword">ref</span> paths &#125;) =&gt; &#123;</span><br><span class="line">            cli.paths = paths.clone();</span><br><span class="line">            cli.enable_all_options();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; cli.enable_all_options(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行计算</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Calculating...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> wc_result = WcResult &#123;</span><br><span class="line">        enabled_options: cli.get_enabled_options(),</span><br><span class="line">        paths_with_counts: &#123;</span><br><span class="line">            <span class="keyword">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class="line">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(wc_result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> WcResult &#123;</span><br><span class="line">    <span class="comment">// 将保存的信息转化为美化后的表格</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">to_pretty_table</span></span>(<span class="keyword">self</span>) -&gt; Table &#123;</span><br><span class="line">        <span class="keyword">let</span> titles = &#123;</span><br><span class="line">            <span class="keyword">let</span> enabled_options = <span class="keyword">self</span>.enabled_options;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class="line">            titles.insert_cell(<span class="number">0</span>, cell!(Fybi -&gt; <span class="string">&quot;Path&quot;</span>));</span><br><span class="line">            titles</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> table = Table::new();</span><br><span class="line">        table.set_titles(titles);</span><br><span class="line">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (path, counts) <span class="keyword">in</span> <span class="keyword">self</span>.paths_with_counts &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class="line">            <span class="keyword">let</span> path_cell = <span class="keyword">if</span> path.starts_with(<span class="string">&quot;Input&quot;</span>) &#123;</span><br><span class="line">                cell!(Fbb -&gt; path.display())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cell!(Fmb -&gt; path.display())</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            row.insert_cell(<span class="number">0</span>, path_cell);</span><br><span class="line">            table.add_row(row);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        table</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_counts</span></span>(cli: &amp;Cli, content: <span class="built_in">String</span>) -&gt; Counts &#123;</span><br><span class="line">    <span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt;&gt; = <span class="built_in">vec!</span>[<span class="literal">None</span>; <span class="number">5</span>];</span><br><span class="line">    v.into_par_iter()</span><br><span class="line">        .enumerate()</span><br><span class="line">        .map(|(idx, _)| <span class="keyword">match</span> idx &#123;</span><br><span class="line">            <span class="number">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class="line">            <span class="number">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class="line">            <span class="number">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class="line">            <span class="number">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class="line">            <span class="number">4</span> =&gt; cli</span><br><span class="line">                .longest_line</span><br><span class="line">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class="number">0</span>)),</span><br><span class="line">            _ =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .flatten()</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>然后就是 main 函数:</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> clap::Parser;</span><br><span class="line"><span class="keyword">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class="built_in">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cli = Cli::parse();</span><br><span class="line">    <span class="keyword">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class="line">    pretty_table.printstd();</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就酱, 结束啦! 希望本文能帮到你 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Clap</tag>
        <tag>CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p1~&gt; 系列说明</title>
    <url>/posts/rust-async/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 异步(async) 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>
当然也会介绍异步方面的相关概念咯</p>
<hr>
<h1 id="zi-liao-lai-yuan">资料来源</h1>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://rust-lang.github.io/async-book/**">async-book</a></p>
</li>
<li class="lvl-2">
<p><a href="https://book.async.rs/overview/async-std">async_std/tutorials</a></p>
</li>
<li class="lvl-2">
<p><a href="https://tokio.rs/tokio/tutorial">tokio/tutorials</a></p>
</li>
<li class="lvl-2">
<p><a href="https://cfsamson.github.io/books-futures-explained/">Futures Explained in 200 Lines of Rust</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>博客</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://without.boats/blog/">Withoutboats’s blogs</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后,谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p2~&gt; 异步简介</title>
    <url>/posts/rust-async/p2.html</url>
    <content><![CDATA[<blockquote>
<p>来简单介绍一下异步吧</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="kai-pian">开篇</h1>
<p><strong>异步编程 (Asynchronous programming)</strong>, 是一种<strong>并发编程模型</strong><br>
特点是通过少量<code>OS_thread(系统线程)</code>, 即可运行大量<code>并发任务</code>, 在某些场景下,可以疯狂压榨cpu的性能</p>
<hr>
<h1 id="mo-xing-dui-bi">模型对比</h1>
<p>为何选择异步,它的优势有哪些? 让我们对比下 <strong>异步</strong> 与其他 <strong>并发模型</strong>:</p>
<p>1.<code>系统线程 (OS Thread)</code><br>
由操作系统提供线程,进行并发,如 <code>std::thread</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单易使用, 建模能力强, 足够传统</p>
</li>
<li class="lvl-2">
<p>操作系统就是运行时, 与C语言交互方便</p>
</li>
<li class="lvl-2">
<p>数据同步困难, 易发生数据竞争</p>
</li>
<li class="lvl-2">
<p>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>
</li>
</ul>
<p>2.<code>绿色线程 (Green Thread)</code><br>
它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身, 由程序本身进行模拟<br>
Rust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长</p>
</li>
<li class="lvl-2">
<p>创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务</p>
</li>
<li class="lvl-2">
<p>由程序本身实现模拟出来, Runtime 较大</p>
</li>
<li class="lvl-2">
<p>如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互</p>
</li>
<li class="lvl-2">
<p>绿色线程在不同平台上,其实现可能不同</p>
</li>
<li class="lvl-2">
<p>对多平台的支持/维护/改进得靠实现者保证</p>
</li>
</ul>
<hr>
<h1 id="yi-bu">异步</h1>
<p>我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"><span class="keyword">let</span> content = read(file);</span><br><span class="line">compute()</span><br></pre></td></tr></table></figure>
<p>读取 <code>file</code>, 获取 <code>content</code>, 在此期间, 我们做不了任何其他事, 得等待<code>IO操作(Input/Output, 输入/输出)</code> 完毕, 才能进行接下来的 <code>compute</code><br>
<code>读取文件</code>, 属于<code>IO操作</code>, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"><span class="comment">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class="line"><span class="keyword">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class="line"><span class="keyword">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class="line"><span class="comment">// 使用 join 阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class="line"><span class="keyword">let</span> content = handle_a.join().unwrap();</span><br><span class="line">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>
<p>两个任务 <code>read</code> 与 <code>compute</code> 是独立无依赖的, 所以我们<code>spawn</code>了两个线程</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个用于读取文件,获取数据</p>
</li>
<li class="lvl-2">
<p>第二个用于执行 <code>compute</code></p>
</li>
</ul>
<p>速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作<br>
单线程中的异步(伪)代码如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"><span class="keyword">let</span> content = read_async(file);</span><br><span class="line">compute_async()</span><br></pre></td></tr></table></figure>
<p>你会注意到:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>read</code> -&gt; <code>read_async</code></p>
</li>
<li class="lvl-2">
<p><code>compute</code> -&gt; <code>compute_async</code></p>
</li>
</ul>
<p>伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>read</code>:<br>
它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 <code>compute</code><br>
阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重</p>
</li>
<li class="lvl-2">
<p><code>read_async</code>:<br>
它处于阻塞时,会运行 <code>compute_async</code>, 线程由 <code>read_async</code> 接管, 变为由 <code>compute_async</code> 接管<br>
当阻塞时间结束,则程序继续变为运行<code>read_async</code></p>
</li>
</ul>
<p>瞧, <code>read_async</code> 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程<br>
总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨<br>
异步操作, 就像是可以随意 <code>start/stop</code> 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待</p>
<p>即使是单线程, 也能做到同时运行多个 <code>Task(异步任务)</code>, 而异步结合多线程也是可以的, 只要存在耗时的IO操作<br>
如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步</p>
<hr>
<h1 id="wei-sheng">尾声</h1>
<p>Q:<br>
阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>
A:<br>
现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了<br>
所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p3~&gt; Future</title>
    <url>/posts/rust-async/p3.html</url>
    <content><![CDATA[<blockquote>
<p>Rust 中的 Future/async/.await 说明</p>
</blockquote>
<span id="more"></span>  
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="kai-pian">开篇</h1>
<p>大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧</p>
<p>本节, 我们将学习以下三个概念的大致含义:<br>
(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Future (trait)</p>
</li>
<li class="lvl-2">
<p>async (keyword)</p>
</li>
<li class="lvl-2">
<p>.await (keyword)</p>
</li>
</ul>
<hr>
<h1 id="future">Future</h1>
<h2 id="gai-nian" id="概念">概念</h2>
<p><code>Future</code>,一个标准/核心库中的trait: <code>std/core::future::Future</code></p>
<p>在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 <code>一次异步计算</code>, 可将其交给 <code>Runtime(运行时)</code> 来异步执行</p>
<p><code>异步执行</code>, 也就是指:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>其他异步任务阻塞时,当前异步任务有机会执行</p>
</li>
<li class="lvl-2">
<p>当前异步任务阻塞时,其他异步任务有机会执行</p>
</li>
</ul>
<p>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>
<p><strong>注意两个名词的区别:</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>异步 计算</code></p>
</li>
<li class="lvl-2">
<p><code>异步 任务</code></p>
</li>
</ul>
<p>两者有着区别,举个例子你就明白了:</p>
<p>假设有这么个父计算, 由两个子计算组成:</p>
<ol>
<li class="lvl-3">
<p>Open: 先异步打开一个文件(async open)</p>
</li>
<li class="lvl-3">
<p>Read: 再异步读取该文件(async read)</p>
</li>
</ol>
<p>我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>
因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算<br>
(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p>
<p>当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算</p>
<p>总结:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Task 是一个顶层 Future 实例 (即一次顶层异步计算)</p>
</li>
<li class="lvl-2">
<p>一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future</p>
</li>
<li class="lvl-2">
<p>Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算</p>
</li>
<li class="lvl-2">
<p>Task 可以只是一次单独计算</p>
</li>
</ul>
<p>一个 Future, 可理解为是组成一个 Task 的最小单位</p>
<h2 id="ding-yi" id="定义">定义</h2>
<p>让我们来看看它的定义:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简单了解一下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Future:<br>
代表一次异步计算</p>
</li>
<li class="lvl-2">
<p>Output: 代表 Future 执行完毕后, 产出的值的类型</p>
</li>
<li class="lvl-2">
<p>poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成</p>
</li>
<li class="lvl-2">
<p>Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:<br>
<code>Poll::Pending</code>: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br>
<code>Poll::Ready(T)</code>: 指明该计算执行完毕, 并产出一个类型为 T 的值</p>
</li>
</ul>
<hr>
<h1 id="async">Async</h1>
<p>Rust 为我们提供了关键字 async, 方便人们为某次计算实现 Future<br>
你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊<br>
async, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例</p>
<p>来个例子,看看 async 的好处:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HelloStr</span></span>;</span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> HelloStr &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">String</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, _cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>);</span><br><span class="line">        Poll::Ready(<span class="built_in">str</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的<br>
看看它们两的返回值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello_str_1() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr <span class="comment">// Future&lt;Output = String&gt; 的实例</span></span><br><span class="line">&#125;</span><br><span class="line">hello_str_2() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>
<p>注意, 异步函数的调用, 只是返回一个 Future实例<br>
但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户</p>
<p>这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作<br>
比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可<br>
如果一旦创建 Future 实例就立刻执行, 就没有这么方便了</p>
<p>async 的作用就是创建一个 Future 实例, 以下是不同的语法糖:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>async fn</code>: 异步函数, 要求返回一个 Future 实例</p>
</li>
<li class="lvl-2">
<p><code>async block</code>: 异步代码块, 创建一个 Future 实例</p>
</li>
<li class="lvl-2">
<p><code>async closure</code>: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1_i32</span>;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `async block` 也可以使用move  </span></span><br><span class="line"><span class="comment">// 获得其中使用的变量的所有权  </span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    &amp;s </span><br><span class="line">&#125;</span><br><span class="line">s; <span class="comment">// Error: use of moved value</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>
<p>创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?<br>
请接着往下看</p>
<hr>
<h1 id="zhi-xing">执行</h1>
<h2 id="bei-jing-jie-shao" id="背景介绍">背景介绍</h2>
<p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>
仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境</p>
<p>异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序<br>
因此它是可选的, 你可以凭借 <code>cartes.io</code> 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序</p>
<p>在开始下面的章节前, 请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码<br>
以 <code>async-std</code> 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123; version = <span class="string">&quot;1.9&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>
<h2 id="runtime" id="Runtime">Runtime</h2>
<p>我们先来创建一个打印 “hello world” 的 Future吧:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello wrold!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?<br>
<code>async_std::task</code> 提供了大量 API, 用来执行/操控这些 Task</p>
<p>如这里出现的<code>task::block_on</code>, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程<br>
该任务执行完毕后产出的值,会作为 <code>block_on</code> 的返回值</p>
<p>我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?<br>
<code>.await</code> 关键字出场了!</p>
<hr>
<h1 id="await">Await</h1>
<p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部, 在某个 Future 变量后面添加 <code>.await</code> 后, 该 Future 就会执行<br>
但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>
真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future</p>
<p>来看看它的使用:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">world</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    hello().<span class="keyword">await</span>;</span><br><span class="line">    world().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.await</code> 是一个标记点, 可理解为是一个 <code>yield point</code>, Runtime 执行到 <code>xxx.await</code> 时,先会执行一次 <code>xxx</code></p>
<p>一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 <code>Poll::Pending</code> 或 <code>Poll::Ready(T)</code><br>
来决定做以下两件事中的哪一件:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>让其他 Task 接管执行权(yield)</p>
</li>
<li class="lvl-2">
<p>继续执行当前 Task</p>
</li>
</ul>
<p>若为<code>Pending</code>: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)<br>
若为<code>Ready</code>: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)</p>
<p>可能有点难理解, 来个简单粗暴理解版:</p>
<p><code>.await</code> 指明 <code>执行某个Future</code> 这一逻辑<br>
当 <code>xxx.await</code> 所在的 Task 交给 Runtime 并并执行到 <code>xxx.await</code> 时, <code>xxx</code> 这个 Future实例 会执行</p>
<p>若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行<br>
若不阻塞, 就继续往下执行(可能还会碰见 <code>.await</code> 哟), 直到该 Task 结束</p>
<hr>
<h1 id="bu-chong">补充</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>#[async_std::main]</code><br>
这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰<br>
程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    hello_world().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    async_std::task::block_on( <span class="keyword">async</span> &#123;</span><br><span class="line">        hello_world().<span class="keyword">await</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>async_std::task::spawn</code><br>
因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 <code>async_std::task::JoinHandle</code> 类型的实例<br>
它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似, 不过 <code>join</code> 相应地改变为了 <code>.await</code><br>
想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 <code>.await</code> 进行修饰哦:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> handle = task::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> two:<span class="built_in">i32</span> = handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-decl-macro-p1~&gt; 系列说明</title>
    <url>/posts/rust-decl-macro/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>此系列,我们将学习Rust中的 <code>声明宏</code><br>
请注意, 是声明宏, 过程宏日后再说</p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://zjp-cn.github.io/tlborm/">宏小册</a></p>
</li>
<li class="lvl-2">
<p><a href="https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html">RustPrimer</a></p>
</li>
<li class="lvl-2">
<p><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">TRPL</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>文章</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://zhuanlan.zhihu.com/p/353421021">【译】Rust宏: 教程与示例 (一)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://zhuanlan.zhihu.com/p/356427780">【译】Rust宏: 教程与示例 (二)</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后, 谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p4~&gt; 状态的保存与变换</title>
    <url>/posts/rust-async/p4.html</url>
    <content><![CDATA[<blockquote>
<p>浅显的原理第一篇: 状态的保存/变换</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="kai-pian">开篇</h1>
<p><strong>注</strong>: 参考了 &lt;&lt;Writing an OS in Rust&gt;&gt; 中的 async 篇,可以自己搜索下看看<br>
为了更好地理解 <code>Rust异步</code>背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>多任务: 抢占式与协作式</p>
</li>
<li class="lvl-2">
<p>状态机</p>
</li>
<li class="lvl-2">
<p>自引用结构体</p>
</li>
</ul>
<p>现在,让我们开始吧!</p>
<hr>
<h1 id="liang-chong-duo-ren-wu">两种多任务</h1>
<h2 id="jie-shao" id="介绍">介绍</h2>
<p>抢占式 与 协作式, 是 多任务 的不同分类</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抢占式多任务:<br>
操作系统决定CPU的运行权<br>
比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会<br>
各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉<br>
这是强迫/抢占的</p>
</li>
<li class="lvl-2">
<p>协作式多任务:<br>
任务们本身进行协调, 决定CPU的运行权<br>
比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending<br>
自己放弃继续执行, 并通知运行时执行其他Task<br>
这是自愿/协作的, Task 们自愿放弃CPU的执行权</p>
</li>
</ul>
<h2 id="zhuang-tai-de-hui-fu-bao-cun" id="状态的恢复-保存">状态的恢复/保存</h2>
<p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>
该任务,应当从先前暂停的地方开始, 继续执行<br>
因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存</p>
<p>对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抢占式:<br>
因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>
任务此时运行到了哪里?我们不知道啊!<br>
那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)</p>
</li>
</ul>
<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>
但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>协作式:<br>
因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>
这种放弃执行权的操作, 我们称为<code>yield</code></p>
</li>
</ul>
<p>比如在Rust中, <code>xxx.await</code>会执行一个Future  	<br>
意味着当程序执行到这里时, 可能会<code>yield</code>(poll返回Poll::Pending, 自愿放弃执行权)</p>
<p><code>xxx.await</code>就是一个<code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>
瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>
因此, 我们可以准确分配Future执行所需要的最大空间</p>
<p>其实, 每个<code>.await(也就是yield point)</code>, 就代表着<code>一种状态</code>(之后会讲)</p>
<p>协作式的好处在于:<br>
能自己掌握所有<code>yield point</code>, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理<br>
毕竟机器定义的分配策略,  总是没有比不过我们特意设计的<br>
在任务暂停并转让执行权前, 准确保存<code>下次继续所需要的状态</code>, 内存/性能优势很大<br>
但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行</p>
<hr>
<h1 id="zhuang-tai-ji-de-gai-nian">状态机的概念</h1>
<p>在Rust中的异步, 我们之前也说过, 属于<code>协作式多任务</code><br>
而其<code>状态保存</code>的实现, 就是利用<code>状态机(state machine)</code>来实现</p>
<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>, 是一种数学模型</p>
<ol>
<li class="lvl-3">
<p>状态(state):<br>
比如有一扇门, 它的状态就处于以下两种之一: Open or Closed</p>
</li>
<li class="lvl-3">
<p>事件(event):<br>
某事件发生后, 会触发相应动作, 可能改变状态<br>
比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p>
</li>
<li class="lvl-3">
<p>动作 (action):<br>
事件发生后, 会触发动作</p>
</li>
<li class="lvl-3">
<p>变换 (transition):<br>
<code>State_X=&gt;State_Y</code>就叫<code>变换</code>, 比如门的状态从<code>Open=&gt;Closed</code></p>
</li>
</ol>
<p>稍微了解下<code>状态机</code>的概念即可</p>
<p>那么现在, 就要看具体代码了</p>
<p>如果你想亲自运行一下, 先确保你的<code>Cargo.toml</code>中的依赖如下:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123;version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>, <span class="string">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>如下代码, 读取一个文件的行数<br>
你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>
(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    env::args,</span><br><span class="line">    process,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> async_std::&#123;</span><br><span class="line">    prelude::*,</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;<span class="keyword">self</span>,BufReader&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;              <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> path = args().nth(<span class="number">1</span>).unwrap_or_else(||&#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">let</span> file = File::open(path).<span class="keyword">await</span>?;          <span class="comment">// Yield point</span></span><br><span class="line">    <span class="keyword">let</span> lines = BufReader::new(file).lines();</span><br><span class="line">    <span class="keyword">let</span> count = lines.count().<span class="keyword">await</span>;             <span class="comment">// Yield point</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;                                                <span class="comment">// Done</span></span><br></pre></td></tr></table></figure>
<p>mian()产生一个新实例, 异步运行<code>open(path)</code>与<code>count()</code>  	<br>
对于编译器, 每一个<code>.await</code>其实都代表一种状态</p>
<p>Future实例, 实际上是个状态机<br>
在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p>
<ol>
<li class="lvl-3">
<p>Start: 此Future刚开始执行</p>
</li>
<li class="lvl-3">
<p>Yield1: 第一个 yield point</p>
</li>
<li class="lvl-3">
<p>Yield2: 第二个 yield point</p>
</li>
<li class="lvl-3">
<p>Done: 此Future执行完毕</p>
</li>
</ol>
<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>
执行器调用当前Future的poll推动进度时, 若在<code>某一阶段</code>返回了<code>Poll::Pending</code>, 则放弃执行权<br>
当再次调用当前Future的poll推动进度时, 则从上次暂停的状态<code>恢复(resume)</code>, 继续执行</p>
<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态</p>
<p><strong>Note 1</strong>:<br>
Start状态, 会存储传入函数的参数(如果有参数)</p>
<p><strong>Note 2</strong>:<br>
Done状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的</p>
<p><strong>Note 3</strong>:<br>
怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br>
<code>某个yield point之前定义,  且point之后还需要使用的变量</code><br>
如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存, 因为从暂停中恢复后还需要使用<br>
其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>
所以不需要特殊的持久化操作</p>
<hr>
<h1 id="zi-yin-yong-jie-gou-ti">自引用结构体</h1>
<h2 id="bao-cun-yin-yong" id="保存引用">保存引用</h2>
<p>当每个状态存储数据时,  可能会导致发生<code>自引用</code>, 比如:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>() -&gt; <span class="built_in">i32</span> &#123;                            <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> element = &amp;arr[<span class="number">2</span>];</span><br><span class="line">    write_file(<span class="string">&quot;foo.txt&quot;</span>, element.to_string()).<span class="keyword">await</span>;  <span class="comment">// Yield1</span></span><br><span class="line">    *element                                           <span class="comment">// Done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code>, 而在<code>Yield1</code>这个状态下, 存储的数据如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Yield1State</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">i32</span>; <span class="number">3</span>], </span><br><span class="line">    element: *<span class="keyword">const</span> <span class="built_in">i32</span>, <span class="comment">// 数组最后一个元素的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态的实例</span></span><br><span class="line">Yield1State &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    element: &amp;arr[<span class="number">2</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等, 你可能会对上面的代码有疑惑:<br>
不是说, 状态只需要保存 <code>在yield point之前定义,  并且该point之后还需要使用的变量</code> 吗<br>
上面的代码, 只有element这个引用需要被保存吧?</p>
<p>这是因为, 它是<code>引用</code>嘛! 没了<code>引用</code>背后的实际数据, 那它还有啥用, 不就是<code>悬垂引用</code>了吗?<br>
因此我们还得保存, <code>该引用</code>指向的背后数据: <code>arr</code>, 并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中<br>
像这种 <code>结构体内部的指针, 指向结构体本身</code>, 就叫 <code>自引用结构</code></p>
<p>比如上面代码: 同一结构体下, 成员element指向了成员arr</p>
<h2 id="nei-cun-yi-dong-wen-ti" id="内存移动问题">内存移动问题</h2>
<p>如上所述,  这可能导致悬垂引用的产生, 若该struct实例的<code>内存地址发生改变</code>, 如使用 <code>std::mem</code>, 让struct实例的内存地址发生移动<br>
以上面的那段代码为例, 如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>arr:<br>
内存地址会跟着结构体实例而改变, 但是,  <code>值仍然是 [1, 2, 3]</code></p>
</li>
<li class="lvl-2">
<p>element:<br>
内存地址会跟着结构体实例而改变, 但是, 值仍然是<code>先前arr的地址</code>, <code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>
</li>
</ul>
<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)<br>
官方提出了<code>std::pin::Pin(trait)</code> 来解决自引用结构体方面的悬垂指针/引用问题</p>
<p>其实你听名字也很好理解, <code>Pin(中文意思是钉子)</code>的作用是, 防止内存地址发生改变(给爷钉死吧!)<br>
但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了</p>
<p>欲知后事如何,  且听下回分解<br>
<s>(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-decl-macro-p2~&gt; 从println开始</title>
    <url>/posts/rust-decl-macro/p2.html</url>
    <content><![CDATA[<blockquote>
<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2"><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></li>
<li class="lvl-2"><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></li>
</ul>
<h1 id="kai-pian">开篇</h1>
<p>大家应该都用过一个宏, 它就是 <code>println!</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Rush B!!!!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    <span class="built_in">println!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?</p>
<p>亲爱的 TRPl 在教你写 <a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F">Hello World!</a> 时告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>
可 macro 到底是啥? <s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p>
<hr>
<h1 id="cha-kan-ding-yi">查看定义</h1>
<p>让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能会看到, 在 println! 的上面</span></span><br><span class="line"><span class="comment">// 有着类似下面的玩意:  </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// #[macro_export]</span></span><br><span class="line"><span class="comment">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class="line"><span class="comment">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class="line"><span class="comment">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>
<p>你悲催地发现, 根本看不懂这堆鬼画符… 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏 (<code>macro_rules!</code>当作特定语法即可)</p>
</li>
<li class="lvl-2">
<p>之后用花括号包起来,里面是该宏的具体定义</p>
</li>
</ul>
<p>问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?<br>
请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&quot;1&quot;</span>.repeat(<span class="number">10</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;2&quot;</span>.repeat(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// macro</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>macro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:</p>
<p>match:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>match表达式,称呼每个匹配分支为<code>arm</code></p>
</li>
<li class="lvl-2">
<p>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割</p>
</li>
<li class="lvl-2">
<p>最后一个arm可省略逗号</p>
</li>
</ul>
<p>macro:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)</p>
</li>
<li class="lvl-2">
<p>必须使用花括号包裹,使用分号分隔彼此</p>
</li>
<li class="lvl-2">
<p>最后一个rule可省略分号</p>
</li>
</ul>
<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>
现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义部分</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    <span class="comment">// 空参时, 只输出换行符</span></span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="comment">// 有参时, 输出参数, 并换行</span></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用部分</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"><span class="built_in">println!</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="zong-jie">总结</h1>
<ol>
<li class="lvl-3">
<p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>然后创建两个匹配分支:<br>
(匹配空参 =&gt; 不做任何事)<br>
(匹配123 =&gt; 打印123)</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>调用时, 要做到: 宏名+感叹号+传参:<br>
(传入的参数,若与任何rule都不匹配,则报错)</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    xxx!();      <span class="comment">// Nothing</span></span><br><span class="line">    xxx!(<span class="number">123</span>);   <span class="comment">// println!(&quot;123&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>
咱们下期见</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-decl-macro-p5~&gt; 卫生性</title>
    <url>/posts/rust-decl-macro/p5.html</url>
    <content><![CDATA[<blockquote>
<p>本节将介绍宏的 卫生性(hygienic)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="kai-pian">开篇</h1>
<p>什么是 卫生性(Hygienic) 呢?<br>
简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>
如果你是第一次接触此概念, 我不信你不会懵逼<br>
不过实际上, 这个概念理解起来不算困难</p>
<p>让我们先来讨论一个问题, 请看下面的代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> create_var &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    create_var!();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-decl-macro-p3~&gt; 声明与使用</title>
    <url>/posts/rust-decl-macro/p3.html</url>
    <content><![CDATA[<blockquote>
<p>关于 macro 的 正式说明</p>
</blockquote>
<span id="more"></span>  
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2"><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></li>
<li class="lvl-2"><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></li>
</ul>
<h1 id="kuang-jia-jian-li">框架建立</h1>
<p>前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p>
</li>
<li class="lvl-2">
<p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p>
</li>
<li class="lvl-2">
<p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p>
</li>
</ul>
<p>现在稍微深入一点:<br>
一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber), 它由三个重要的部分组成:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>matcher (匹配器)</code>: 用来匹配传入的参数</p>
</li>
<li class="lvl-2">
<p><code>metavariable/literal (元变量/字面量)</code>: 绑定传入的代码片段,出现于 <code>matcher</code></p>
</li>
<li class="lvl-2">
<p><code>transcriber (转录器)</code>: 用来在宏匹配成功后,进行代码替换</p>
</li>
</ul>
<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>
因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    (<span class="comment">/* 空参匹配 */</span>) =&gt; (<span class="comment">/* `换行` 的代码 */</span>);</span><br><span class="line">    (<span class="comment">/* 有参匹配 */</span>) =&gt; (<span class="comment">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code>, 从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配, 匹配时括号具有多样性<br>
下面是具体阐述:</p>
<p>匹配规则:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>匹配到: 就替换为<code>transcriber</code>里面的代码</p>
</li>
<li class="lvl-2">
<p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p>
</li>
</ul>
<p>括号多样性:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p>
</li>
<li class="lvl-2">
<p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p>
</li>
<li class="lvl-2">
<p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>
</li>
</ul>
<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>
在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p>
<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p>
<hr>
<h1 id="liang-chong-hong-can-shu">两种宏参数</h1>
<p>是时候引入一些新的东西了, 顺便加深下你的印象</p>
<h2 id="yuan-bian-liang" id="元变量">元变量</h2>
<p>元变量, 即Metavariable, 让我们来看个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class="line">        $a + $b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    my_macro!(<span class="number">1</span>);</span><br><span class="line">    my_macro!(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    1;</span></span><br><span class="line"><span class="comment">    1 + 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>
比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p>
<p><code>$</code> 这个前缀是干嘛的?<br>
这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>
至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~</p>
<p>先看看 <code>expr</code> 类型, 其全称为 <code>expression(表达式)</code><br>
第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>
这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>
(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)<br>
简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>
macro就像个code generator: 一段用来生成code的code<br>
注意:<br>
macro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点<br>
在本节下面会更详细地讲讲</p>
<h2 id="yuan-zi-mian-liang" id="元字面量">元字面量</h2>
<p>元字面量, 即Metaliteral<br>
为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">($a: expr) =&gt; &#123;$a&#125;;                     <span class="comment">// the first rule</span></span><br><span class="line">  |             |  </span><br><span class="line">  |         	|</span><br><span class="line">( <span class="number">1</span>      )      <span class="number">1</span>                       <span class="comment">// pass &amp;&amp; expand </span></span><br><span class="line">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class="comment">// the second rule</span></span><br><span class="line">  |      |  |              |    |</span><br><span class="line">  |      |  |              |    |</span><br><span class="line">( <span class="number">1</span>      ,  <span class="number">2</span>      ) =&gt;    <span class="number">1</span> +  <span class="number">2</span>      <span class="comment">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>
<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>
你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p>
<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>
这种固定的参数, 如同token中的字面量一样<br>
我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>
(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p>
<p>假若 rule 中的参数没有 $前缀 进行区分:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> fuck &#123;</span><br><span class="line">    (a:expr) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    fuck!(<span class="number">1</span>);       <span class="comment">// No</span></span><br><span class="line">    fuck!(a:expr);  <span class="comment">// Yes ~~(Oh~)~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>), 传入固定形式的 “a:expr” 时才可发生匹配<br>
因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰</p>
<h2 id="li-zi" id="例子">例子</h2>
<p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>
它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>
如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map![</span><br><span class="line">        <span class="string">&quot;吉良吉影&quot;</span> =&gt; <span class="number">33</span>,</span><br><span class="line">        <span class="string">&quot;空条承太郎&quot;</span> =&gt; <span class="number">41</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来写一个这样的宏吧!<br>
不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>
来看看两种宏参数在宏中, 发挥着怎样的作用:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Metavariable</code>:<br>
将捕获的传入的代码片段绑定到自身, 并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p>
</li>
<li class="lvl-2">
<p><code>Metaliteral </code>:<br>
限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>
(这里只有一个rule, 空匹配的懒得放里面了)</p>
</li>
</ul>
<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>
考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>
之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>
(博客的话, 我周六放学回来慢慢更吧…)<br>
<s>(潜台词是随时会鸽子)</s></p>
<hr>
<h1 id="ben-zhi">本质</h1>
<p>macro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p>
<p>假若由你来设计一个Rust编译器:</p>
<p>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>
若我们将每遍扫描并做点事情的过程, 称为<code>pass</code>, pass一次就生成了, 对于很大的源码来说, 这不现实吧<br>
那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗</p>
<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p>
<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASTNode</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>), </span><br><span class="line">    BinaryExpr &#123;</span><br><span class="line">        op: Op,</span><br><span class="line">        lhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">        rhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Op</span></span> &#123;</span><br><span class="line">    Plus, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你只需明白AST是对源码封装的一层抽象产物就可以了</p>
<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了<br>
那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p>
<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛<br>
<code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码</p>
<p>Q: 生成AST需要点啥? 或者说, 它由什么组成?<br>
A: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p>
<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架<br>
这个庞然大物便是 AST 了</p>
<hr>
<h1 id="hui-dao-macro">回到Macro</h1>
<h2 id="token-lei-xing-biao" id="Token类型表">Token类型表</h2>
<p>生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型</p>
<p>macro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?<br>
只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p>
<p>所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>对应</th>
</tr>
</thead>
<tbody>
<tr>
<td>ident</td>
<td>标识符, 如函数名, 变量名, 关键字</td>
</tr>
<tr>
<td>expr</td>
<td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td>
</tr>
<tr>
<td>literal</td>
<td>literal expression, 即字面量表达式, 是expr的子集</td>
</tr>
<tr>
<td>pat</td>
<td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td>
</tr>
<tr>
<td>path</td>
<td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td>
</tr>
<tr>
<td>ty</td>
<td>type, 如 i32, u32, String, Option<T>等</td>
</tr>
<tr>
<td>tt</td>
<td>token tree, 之后我会单独再讲解下它的</td>
</tr>
<tr>
<td>meta</td>
<td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td>
</tr>
<tr>
<td>vis</td>
<td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td>
</tr>
<tr>
<td>lifetime</td>
<td>生命周期</td>
</tr>
<tr>
<td>item</td>
<td>条目/项, 例如函数定义</td>
</tr>
<tr>
<td>block</td>
<td>代码块</td>
</tr>
<tr>
<td>stmt</td>
<td>statemen, 语句</td>
</tr>
</tbody>
</table>
<h2 id="tt" id="TT">TT</h2>
<p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>
从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p>
<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>
作为 Token Tree 的根节点, 先让我们来点例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a:tt) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>($a));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Single Token</span></span><br><span class="line">    aa!(<span class="number">123</span>);          <span class="comment">// Yes: 123</span></span><br><span class="line">    aa!(FuckYou);      <span class="comment">// Yes: FuckYou</span></span><br><span class="line">    <span class="comment">// aa!(Fuck You);     // No</span></span><br><span class="line">    <span class="comment">// aa!(123 + 11);     // No</span></span><br><span class="line">    <span class="comment">// (), [], &#123;&#125;</span></span><br><span class="line">    aa!([<span class="number">123</span>]);        <span class="comment">// Yes: [123]</span></span><br><span class="line">    aa!(&#123;<span class="number">123</span> + <span class="number">123</span>&#125;);  <span class="comment">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>
请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的眼中:</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + (<span class="number">3</span> + <span class="number">4</span>)</span><br><span class="line"><span class="comment">// tt的眼中:</span></span><br><span class="line">&lt;&lt;<span class="number">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class="number">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">                   &lt;&lt;<span class="number">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class="number">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码的Token Tree共有5个:</p>
<ol>
<li class="lvl-3">
<p>&lt;&lt;1&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;+&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;2&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;+&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;(3 + 4)&gt;&gt;</p>
</li>
</ol>
<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>
对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p>
<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p>
<h2 id="ast-jie-dian" id="AST节点">AST节点</h2>
<p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>
比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们通过使用 macro , 站在了更抽象的视角上<br>
操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)<br>
这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p>
<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a> 上面的代码了:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class="line">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> match_tokens &#123;</span><br><span class="line">    ($a:tt + $b:tt) =&gt; &#123;<span class="string">&quot;got an addition&quot;</span>&#125;;</span><br><span class="line">    (($i:ident)) =&gt; &#123;<span class="string">&quot;got an identifier&quot;</span>&#125;;</span><br><span class="line">    ($($other:tt)*) =&gt; &#123;<span class="string">&quot;got something else&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;\n&quot;</span>,</span><br><span class="line">        match_tokens!((caravan)),</span><br><span class="line">        match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;&quot;</span>,</span><br><span class="line">        capture_then_match_tokens!((caravan)),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果会是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">got an identifier</span><br><span class="line">got an addition</span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!</p>
<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>
但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br>
<code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p>
<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p>
<p>总结:<br>
宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>
这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 😄)</p>
<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>
最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言: 简单的文本替换</span></span><br><span class="line">#define SUM(a,b) a+b</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    SUM(<span class="number">2</span>, <span class="number">2</span>);     <span class="comment">// 2 * 2</span></span><br><span class="line">    <span class="number">5</span> * SUM(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 5 * 2 + 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    sum!(<span class="number">2</span>,<span class="number">2</span>);     <span class="comment">// 2 + 2</span></span><br><span class="line">    <span class="number">5</span> * sum!(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 5 * (2 + 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pi-pei-zhu-yi-dian" id="匹配注意点">匹配注意点</h2>
<p>在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a></p>
<h3 id="pi-pei-wu-qu" id="匹配误区">匹配误区</h3>
<p>来看看下面一段代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class="line">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    aa!(a);   <span class="comment">// Yes</span></span><br><span class="line">    aa!(a+);  <span class="comment">// No</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">expected expression, found end of <span class="keyword">macro</span> arguments</span><br><span class="line"><span class="comment">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>
<p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p>
<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>
而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p>
<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p>
<h3 id="qi-yi-xian-zhi" id="歧义限制">歧义限制</h3>
<p>由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Rust-Reference: 限制</a><br>
这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br>
<s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)</s></p>
<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-decl-macro-p4~&gt; 重复</title>
    <url>/posts/rust-decl-macro/p4.html</url>
    <content><![CDATA[<blockquote>
<p>宏中非常重要的语法: 重复(repetition)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2"><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></li>
<li class="lvl-2"><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></li>
</ul>
<h1 id="jie-shao">介绍</h1>
<p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p>
<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p>
</li>
<li class="lvl-2">
<p>Transcriber: 将一段指定的模式, 重复地展开</p>
</li>
</ul>
<p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p>
<p>假设你要设计一个宏, 进行求和(参数个数不确定):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="built_in">assert_eq!</span>( <span class="number">0</span>,  sum!() );</span><br><span class="line"><span class="built_in">assert_eq!</span>( <span class="number">15</span>, sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) );</span><br></pre></td></tr></table></figure>
<p>让我们来看看, 如何使用重复吧</p>
<h1 id="yu-fa">语法</h1>
<p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($($a:expr),*) =&gt; &#123;</span><br><span class="line">        <span class="number">0</span> $(+ $a)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    sum!();          <span class="comment">// 0</span></span><br><span class="line">    sum!(<span class="number">5</span>);         <span class="comment">// 5</span></span><br><span class="line">    sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伪代码表示:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$( Pattern )   Sep    RepOp</span><br><span class="line">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>
<p>它可以被分为三个部分:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模式(Pattern):<br>
被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p>
</li>
<li class="lvl-2">
<p>分隔符(Separator):<br>
用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p>
</li>
<li class="lvl-2">
<p>重复符号(Repetition Operator):<br>
对模式匹配次数, 进行说明限制, 不符合就编译报错</p>
</li>
</ul>
<p>以 <code>sum!</code> 为例子, 它在第二个rule中用到了重复:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>In Matcher:<br>
模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>
分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>
次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p>
</li>
<li class="lvl-2">
<p>In Transcriber:<br>
模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>
分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>
次数:	 同 Matcher</p>
</li>
</ul>
<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p>
<p>RepOp 有三种可选项, 有点像正则:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>
记忆法-&gt; 该符号看上去像是一个点, 联想为0</p>
</li>
<li class="lvl-2">
<p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>
记忆法-&gt; 联想为正数, 那就&gt;=1</p>
</li>
<li class="lvl-2">
<p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>
记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p>
</li>
</ul>
<p>有一些注意点:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p>
</li>
<li class="lvl-2">
<p>Sep 是有限制的, <a href="/posts/rust-decl-macro/p3#qi-yi-xian-zhi">p3#歧义限制</a> 提到过, 详情可见 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">rust-reference</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gstreamer-p1~&gt; 系列说明</title>
    <url>/posts/rust-gstreamer/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 gstreamer 的系列, 学习如何处理音视频</p>
</blockquote>
<span id="more"></span>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GStreamer</tag>
        <tag>Video</tag>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gstreamer-p2~&gt; 管道的基础概念</title>
    <url>/posts/rust-gstreamer/p2.html</url>
    <content><![CDATA[<blockquote>
<p>通过一个入门级例子, 讲述 gstreamer 中管道的基础概念</p>
</blockquote>
<span id="more"></span>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GStreamer</tag>
        <tag>Video</tag>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gstreamer-p3~&gt; 管道的动态构建</title>
    <url>/posts/rust-gstreamer/p3.html</url>
    <content><![CDATA[<blockquote>
<p>学习如何在 gstreamer 中动态地构建管道</p>
</blockquote>
<span id="more"></span>]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GStreamer</tag>
        <tag>Video</tag>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gstreamer-p4~&gt; 时间管理</title>
    <url>/posts/rust-gstreamer/p4.html</url>
    <content><![CDATA[<blockquote>
<p>学习 gstreamer 中的时间管理, 执行快进/后退等操作</p>
</blockquote>
<span id="more"></span>]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GStreamer</tag>
        <tag>Video</tag>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gstreamer-p5~&gt; 与GUI集成</title>
    <url>/posts/rust-gstreamer/p5.html</url>
    <content><![CDATA[<blockquote>
<p>通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器</p>
</blockquote>
<span id="more"></span>]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GStreamer</tag>
        <tag>Video</tag>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-tui-p1~&gt; 系列说明</title>
    <url>/posts/rust-tui/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 TUI 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-tui">rust-tui</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>
当然, 还会介绍Rust中的两个crate: <code>tui</code> &amp;&amp; <code>crossterm</code></p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ol>
<li class="lvl-3">
<p>博客:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/">Playing with tui-rs</a></p>
</li>
<li class="lvl-2">
<p><a href="https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/">Building a command-line interface in Rust</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>文档:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://docs.rs/tui/latest/tui/">tui-rs</a></p>
</li>
<li class="lvl-2">
<p><a href="https://docs.rs/crossterm/latest/crossterm/">crossterm</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话, 请及时跟我联系<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后, 谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>TUI</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p1~&gt; 系列说明</title>
    <url>/posts/haskell-basic/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Haskell 的学习系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>
这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br>
<s>(毕竟是Haskell)</s></p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good! (趣学指南)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.haskell.org/tutorial/">A Gentle Introduction to Haskell, Version 98</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>论坛</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://discourse.haskell.org/">Haskell Discourse</a></p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p>博客</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97">Lambda Calculus (Lambda演算)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors In Pictures (图解函子)</a></p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p>Wiki</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://wiki.haskell.org/">Haskell Wiki</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后,谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p2~&gt; 环境搭建</title>
    <url>/posts/haskell-basic/p2.html</url>
    <content><![CDATA[<blockquote>
<p>本节将介绍如何搭建 Haskell 的环境</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<h1 id="bian-yi-qi-amp-amp-bao-guan-li">编译器 &amp;&amp; 包管理</h1>
<p>本文假设你使用的是Linux系统</p>
<p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>
随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ghc</code>: Haskell 的编译器</p>
</li>
<li class="lvl-2">
<p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p>
</li>
<li class="lvl-2">
<p><code>cabal</code>: Hsakell的包管理器</p>
</li>
</ul>
<p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p>
<p>请确保都能正确显示版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ghc -V</span><br><span class="line">ghci -V</span><br><span class="line">cabal -V</span><br></pre></td></tr></table></figure>
<p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p>
<hr>
<h1 id="dai-ma-bian-ji">代码编辑</h1>
<p>推荐的代码编辑器:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Helix (强推)</p>
</li>
<li class="lvl-2">
<p>Nvim/Vim</p>
</li>
<li class="lvl-2">
<p>Emacs</p>
</li>
<li class="lvl-2">
<p>Vscode</p>
</li>
</ul>
<p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>
如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p>
<p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf copr <span class="built_in">enable</span> -y petersen/haskell-language-server</span><br><span class="line">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure>
<p>如果你使用的是 <a href="https://helix-editor.com/">Helix</a>, LSP将会直接启用<br>
当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p>
<hr>
<h1 id="huan-yuan">换源</h1>
<p>Haskell的包都放在 <a href="https://hackage.haskell.org/">hackage</a>, 下载依赖时, 速度可能极慢<br>
这时, 我们应该进行将其换成镜像源</p>
<p>若你使用cabal, 可以按照下面的做:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cabal user-config init</span><br><span class="line">sed -i <span class="string">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/hackage.haskell.org\//http:\/\/mirrors.ustc.edu.cn\/hackage\//g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class="line">cabal update</span><br></pre></td></tr></table></figure>
<p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p>
<p>至此, 环境准备工作已全部完成<br>
下一节, 我们将正式开始学习 Haskell</p>
<hr>
<h1 id="geng-gai-ghci-ti-shi-fu">更改ghci提示符</h1>
<p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>
但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p>
<p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p>
<p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class="line">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure>
<p>第一行更改提示符<br>
第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p3~&gt; 函数式介绍</title>
    <url>/posts/haskell-basic/p3.html</url>
    <content><![CDATA[<blockquote>
<p>何为函数式编程(FP, 即Functional Programming) ?</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>
那么, 开始吧!</p>
<h1 id="bian-cheng-fan-shi">编程范式</h1>
<h2 id="gai-lan" id="概览">概览</h2>
<p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p>
<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>
在世界上, 有许多编程范式, 最主要的有:</p>
<table>
<thead>
<tr>
<th>简称</th>
<th>中文名</th>
<th>英文名</th>
</tr>
</thead>
<tbody>
<tr>
<td>FP</td>
<td>函数式编程</td>
<td>Functional Programming</td>
</tr>
<tr>
<td>OOP</td>
<td>面向对象编程</td>
<td>Object-Oriented Programming</td>
</tr>
<tr>
<td>POP</td>
<td>面向过程编程</td>
<td>Procedure-Oriented Programming</td>
</tr>
<tr>
<td>LP</td>
<td>逻辑式编程</td>
<td>Logic Programming</td>
</tr>
<tr>
<td>DP</td>
<td>声明式编程</td>
<td>Declarative Programming</td>
</tr>
<tr>
<td>IP</td>
<td>命令式编程</td>
<td>Imperative Programming</td>
</tr>
</tbody>
</table>
<p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>
记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p>
<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>
下面是一些编程范式的例子:</p>
<p><strong>提示</strong><br>
如果你已经了解过以下范式, 直接跳到 <a href="#zong-jie"><strong>总结</strong></a> 吧</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程:<br>
优点:<br>
解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>
缺点:<br>
代码复用能力差, 扩展性差, 繁琐</p>
</li>
<li class="lvl-2">
<p>面向对象:<br>
优点:<br>
将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>
缺点:<br>
不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p>
</li>
<li class="lvl-2">
<p>逻辑式:<br>
优点:<br>
通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>
缺点:<br>
玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p>
</li>
<li class="lvl-2">
<p>函数式:<br>
优点:<br>
通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>
缺点:<br>
学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p>
</li>
<li class="lvl-2">
<p>命令式:<br>
有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>
我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>
毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>
现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p>
</li>
<li class="lvl-2">
<p>声明式:<br>
指你编程依靠描述, 而非面向过程地去思考<br>
这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>
DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>
特点是一旦脱离相关领域, 语法就不再便利</p>
</li>
</ul>
<h2 id="zong-jie" id="总结">总结</h2>
<p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>
编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p>
<p>比如:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程/面向对象 &amp;&amp; 命令式</p>
</li>
<li class="lvl-2">
<p>函数式/逻辑式 &amp;&amp; 声明式</p>
</li>
<li class="lvl-2">
<p>混合一种, 两种, 甚至各种范式</p>
</li>
</ul>
<p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>
比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>
再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p>
<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>
接下来, 我们就要专注于本节的主角, 函数式</p>
<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>
让我们开始对函数式的正式介绍吧!</p>
<hr>
<h1 id="gao-jie-han-shu">高阶函数</h1>
<p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p>
<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>
函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>
比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br>
<s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p>
<p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p>
<hr>
<h1 id="bu-ke-bian-shu-ju">不可变数据</h1>
<p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p>
<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>
被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p>
<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>
但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p>
<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>
但不可变的数据能够有效降低并发的难度</p>
<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>
比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p>
<hr>
<h1 id="fu-zuo-yong">副作用</h1>
<p>副作用(Side Effects), 指与外界发生的交互</p>
<p>假设有这么一个函数:<br>
它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>
可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p>
<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>
这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p>
<p>副作用包括, 但不限于:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>发送网络请求</p>
</li>
<li class="lvl-2">
<p>访问系统状态</p>
</li>
<li class="lvl-2">
<p>操作数据库</p>
</li>
<li class="lvl-2">
<p>操作DOM</p>
</li>
<li class="lvl-2">
<p>IO操作</p>
</li>
<li class="lvl-2">
<p>修改函数外部的变量</p>
</li>
<li class="lvl-2">
<p>使用具有副作用的函数 (传播性)</p>
</li>
</ul>
<p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>
比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>
那么这将无法保证相同输入, 能得到相同输出</p>
<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>
绝对的没有副作用, 意味着这个程序绝对的没用</p>
<hr>
<h1 id="yin-yong-tou-ming">引用透明</h1>
<p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p>
<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>
以下是数学中的 RT, 简单来讲, 就是等式推导:</p>
<p>f(x) = (x+1)<sup>2</sup><br>
f(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p>
<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>
某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>
计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p>
<p>总而言之, 就是替换, 替换, 还是替换<br>
即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p>
<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>
若有这么个函数:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">double_x</span>(x: <span class="type">Int</span>): <span class="type">Int</span> &#123;</span><br><span class="line">    println(x);</span><br><span class="line">    return x+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>
此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>
假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p>
<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>
使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>
你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>
这通常是一些 BUG 的来源</p>
<p>RT, 即引用透明, 注定与副作用互斥</p>
<hr>
<h1 id="chun-han-shu">纯函数</h1>
<p>纯函数(Pure Functions), 表示引用透明的函数</p>
<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>
相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p>
<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>
简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p>
<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>
有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>
这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p>
<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p>
<hr>
<h1 id="qi-ta">其他</h1>
<p>以上是对函数式的小小概括<br>
还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p>
<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>埃氏筛求素数:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">primes</span> = filterPrime [<span class="number">2.</span>.]</span><br><span class="line">  <span class="keyword">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>斐波那契数列:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fibs</span> = <span class="number">0</span> : <span class="number">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>快速排列:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">qsort</span> [] = []</span><br><span class="line"><span class="title">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class="line">  <span class="keyword">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>辗转相除法求最大公约数:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">gcd&#x27;</span> x y</span><br><span class="line">  | y == <span class="number">0</span> = x</span><br><span class="line">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure>
<p>感谢你的观看, 咋们下期见!!<br>
先让我鸽几天 😃</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p4~&gt; 基础语法</title>
    <url>/posts/haskell-basic/p4.html</url>
    <content><![CDATA[<blockquote>
<p>关于 Haskell 的数字, Bool, List, If语句</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>
你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p>
<h1 id="shu-zi">数字</h1>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span> + <span class="number">8</span>) * <span class="number">9</span> - <span class="number">10</span>   <span class="comment">-- 80</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>              <span class="comment">-- 2.5</span></span><br><span class="line"><span class="number">5</span> ^ <span class="number">2</span>              <span class="comment">-- 25</span></span><br><span class="line"><span class="number">5</span> ^  (<span class="number">2.0</span>)         <span class="comment">-- error</span></span><br><span class="line"><span class="number">5</span> ** (<span class="number">2.0</span>)         <span class="comment">-- 25.0 </span></span><br></pre></td></tr></table></figure>
<p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>
但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>
以上的运算符号, 实际上都是函数</p>
<p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p><code>=&gt;</code> 后面的表示参数与返回值的类型<br>
<code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p>
<p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>
以上的东西, 实际上类似于:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="params">(+)</span>&lt;<span class="title">a</span>: <span class="title">Num</span>&gt; <span class="params">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>
Num 这个类型类了, 便起到一个约束的作用</p>
<p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>
因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p>
<hr>
<h1 id="bool">Bool</h1>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">True</span> &amp;&amp; <span class="type">False</span>      <span class="comment">-- False</span></span><br><span class="line"><span class="type">True</span> || <span class="type">False</span>      <span class="comment">-- True</span></span><br><span class="line"><span class="title">not</span> <span class="type">True</span>           <span class="comment">-- False</span></span><br></pre></td></tr></table></figure>
<p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>
(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">0</span>             <span class="comment">-- False</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> == <span class="number">1</span> + <span class="number">4</span>     <span class="comment">-- True</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span> /= <span class="string">&quot;AB&quot;</span>      <span class="comment">-- True</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>
这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>
可以键入 <code>:t (==)</code> 查看其类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>表示接受的两个参数, 其类型相同, 都是a<br>
并且a类型必须具有相等性, 返回值是Bool类型</p>
<p>注意:<br>
由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>
原因与先前的加法函数同理</p>
<p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>
甚至连 If语句, 我们都可以自己写个函数来代替</p>
<p>If语句在 Haskell 中仅仅是个语法糖而已<br>
在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>
感兴趣的话, 可以自己去看下: <a href="https://wiki.haskell.org/If-then-else">传送门</a></p>
<hr>
<h1 id="list">List</h1>
<p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>
就像是其他语言的数组一样, 但却更加强大</p>
<h2 id="sheng-lue-you-duan" id="省略右端">省略右端</h2>
<p>像下面, 就创建了一个有十个元素的List:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>
a 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p>
<p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>
你可以查看它的类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>
<p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>
比如:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]      <span class="comment">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p>
<p>回到刚才, 你可以一个个地输入元素, 创建List<br>
不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.100</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.1000</span>]</span><br></pre></td></tr></table></figure>
<p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>
当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>
从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p>
<p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>
你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p>
<p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>
当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>
不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p>
<p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p>
<p>事实上, 这是 Haskell 中为数不多的隐式行为<br>
任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p>
<p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">a</span> = <span class="number">100</span>::<span class="type">Integer</span>      <span class="comment">-- 100</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>                 <span class="comment">-- 101</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>::<span class="type">Int</span>            <span class="comment">-- error</span></span><br></pre></td></tr></table></figure>
<p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>
对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>
根据 <a href="#shu-zi">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p>
<p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p>
<h2 id="she-zhi-bu-chang" id="设置步长">设置步长</h2>
<p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>
同时, 取决于元素的类型, 会产生无限或有界的List</p>
<p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>
如果你想调整步长的话, 可以像下面这样:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3.</span>.]          <span class="comment">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">10.</span>.]         <span class="comment">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure>
<p>你还可以设置小数的步长, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>..]     <span class="comment">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure>
<p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p>
<h2 id="lie-biao-tui-dao" id="列表推导">列表推导</h2>
<p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>
听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x | x &lt;- [<span class="number">1.</span>.], mod x <span class="number">2</span> == <span class="number">0</span>]  <span class="comment">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure>
<p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>
希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p>
<p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p>
</li>
<li class="lvl-2">
<p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p>
</li>
<li class="lvl-2">
<p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p>
</li>
</ul>
<p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x + y | x &lt;- [<span class="number">1.</span><span class="number">.3</span>], y &lt;- [<span class="number">1.</span><span class="number">.3</span>]]                   <span class="comment">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class="line">[x | x &lt;- [<span class="number">1.</span><span class="number">.100</span>], x `mod` <span class="number">2</span> == <span class="number">0</span>, x `mod` <span class="number">3</span> == <span class="number">0</span>]  <span class="comment">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure>
<p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>
随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">100</span>]</span><br><span class="line">  <span class="keyword">if</span> x `<span class="keyword">mod</span>` <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x `<span class="keyword">mod</span>` <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure>
<p>因此, 你可以对比下下面两种式子:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x * y | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], y &lt;- [<span class="number">1.</span>.x]  ]</span><br><span class="line">[ x * y | x &lt;- [<span class="number">1.</span>.y],  y &lt;- [<span class="number">1.</span><span class="number">.10</span>] ]</span><br></pre></td></tr></table></figure>
<p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p>
<p>好了, 关于List, 暂时先到这吧<br>
其实后面还有很多关于List的, 毕竟它太重要了</p>
<hr>
<h1 id="if-yu-ju">If语句</h1>
<p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>
顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p>
<p>毕竟 Haskell 比较特殊, 为了函数的 <a href="/posts/haskell-basic/p3/#chun-han-shu">纯度</a> , 特意搞了一堆东西<br>
再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p>
<p>开始吧!</p>
<h2 id="dan-if" id="单if">单if</h2>
<p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p>
<p>BMI, Body Mass Index (身体质量指数)<br>
它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p>
<p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p>
<p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</p>
</li>
<li class="lvl-2">
<p>输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>  bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>
程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p>
<p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">    <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>也蛮美观的, 但我更喜欢压行 😃</p>
<h2 id="duo-if" id="多If">多If</h2>
<p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p>
<p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>
而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &gt; <span class="number">25</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt;= <span class="number">18.5</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Healthy!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>哇, 看着好美, 好熟悉!<br>
所以你为什么说没有多重If呢?</p>
<p>别急, 格式化之后:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">        <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt; <span class="number">18.5</span></span><br><span class="line">            <span class="keyword">then</span> putStrLn <span class="string">&quot;12&quot;</span></span><br><span class="line">            <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>
而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>
就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p>
<p>这节就到这, 看辉夜3的最后一集去了~~</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p5~&gt; 类型与类型类</title>
    <url>/posts/haskell-basic/p5.html</url>
    <content><![CDATA[<blockquote>
<p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<h1 id="kai-pian">开篇</h1>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>scala3-basic-p1~&gt; 系列说明</title>
    <url>/posts/scala3-basic/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 scala3 的学习系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/scala3-basic">scala3-basic</a></p>
]]></content>
      <tags>
        <tag>Scala3</tag>
      </tags>
  </entry>
  <entry>
    <title>p2-环境搭建</title>
    <url>/posts/scala3-basic/p2.html</url>
    <content><![CDATA[<blockquote>
<p>本节将介绍如何搭建 scala3 的环境</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/scala3-basic">scala3-basic</a></p>
]]></content>
      <tags>
        <tag>Scala3</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p1~&gt; 系列说明</title>
    <url>/posts/rust-gtk4/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p><a href="https://www.gtk.org/">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序</p>
<p>Rust语言自是其中之一, 具有相关的绑定库: <a href="https://gtk-rs.org/">gtk-rs</a> (gtk官方网页所指定)<br>
同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了</p>
<p>不定期更新, 毕竟我只有周末才能碰到电脑<br>
<s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<p>资料正在持续更新ing. . .</p>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://gtk-rs.org/gtk4-rs/stable/latest/book/">GUI development with Rust and GTK 4</a> (官方书籍)</p>
</li>
<li class="lvl-2">
<p><a href="https://toshiocp.github.io/Gtk4-tutorial/">Gtk4 Tutorial</a> (由社区编写的gtk4教学书籍)</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>博客/文档</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html">Rust Vs GUI</a></p>
</li>
<li class="lvl-2">
<p><a href="https://gi.readthedocs.io/en/latest/#gobject-introspection">GObject Introspection</a></p>
</li>
<li class="lvl-2">
<p><a href="https://developer.gnome.org/documentation/tutorials.html">GNOME Developer Doc/Tutorials</a></p>
</li>
</ul>
<hr>
<h1 id="huan-jing-pei-zhi">环境配置</h1>
<p>首先请参照 <a href="https://www.gtk.org/docs/installations/">GTK官方页面</a> , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Fedora, 及其衍生:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install gtk4-devel gcc libadwaita-devel</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Debian, 及其衍生:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libgtk-4-dev build-essential libadwaita-1-dev</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Arch, 及其衍生:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gtk4 base-devel libadwaita</span><br></pre></td></tr></table></figure>
<p>Windows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 <s>(无视即可)</s><br>
比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可</p>
<p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后, 谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p3~&gt; GObject: 内存管理</title>
    <url>/posts/rust-gtk4/p3.html</url>
    <content><![CDATA[<blockquote>
<p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
<h1 id="widget">Widget</h1>
<p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>
再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p>
<p><a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p>
<p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>
例如 <code>Button</code>, 其继承树如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">GObject</span><br><span class="line">└── Widget</span><br><span class="line">    └── <span class="selector-tag">Button</span></span><br></pre></td></tr></table></figure>
<p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>
举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p>
<p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>
</li>
</ul>
<hr>
<h1 id="cuo-wu-shi-xian">错误实现</h1>
<p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p>
<p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>
下面是代码, 已经讲过的概念不再重复:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="comment">// 创建两个按钮, 设置Label</span></span><br><span class="line">    <span class="keyword">let</span> btn_inc = Button::builder()</span><br><span class="line">        .label(<span class="string">&quot;Increase&quot;</span>)</span><br><span class="line">        .margin_top(<span class="number">12</span>)</span><br><span class="line">        .margin_bottom(<span class="number">20</span>)</span><br><span class="line">        .margin_start(<span class="number">12</span>)</span><br><span class="line">        .margin_end(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">let</span> btn_dec = Button::builder()</span><br><span class="line">        .label(<span class="string">&quot;Decrease&quot;</span>)</span><br><span class="line">        .margin_top(<span class="number">12</span>)</span><br><span class="line">        .margin_bottom(<span class="number">20</span>)</span><br><span class="line">        .margin_start(<span class="number">12</span>)</span><br><span class="line">        .margin_end(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Clicked` 事件发生后的处理函数</span></span><br><span class="line">    <span class="comment">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">0</span>;</span><br><span class="line">    btn_inc.connect_clicked(|_| &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    btn_dec.connect_clicked(|_| &#123;</span><br><span class="line">        num -= <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class="line">    <span class="comment">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class="line">    <span class="keyword">let</span> gtk_box = gtk::<span class="built_in">Box</span>::builder()</span><br><span class="line">        .orientation(Orientation::Vertical)</span><br><span class="line">        .build();</span><br><span class="line">    gtk_box.append(&amp;btn_inc);</span><br><span class="line">    gtk_box.append(&amp;btn_dec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class="line">    <span class="comment">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">        .child(&amp;gtk_box)</span><br><span class="line">        .build();</span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>
如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p>
<p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>
因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p>
<p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>
这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p>
<p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>
有没有什么办法, 让这两个闭包都能拥有num的所有权?</p>
<p>请看下面的正确实现, 通过引用计数的方式 😃</p>
<hr>
<h1 id="yin-yong-ji-shu">引用计数</h1>
<p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>
那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p>
<p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>
于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p>
<p><strong>提示</strong><br>
对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>
因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p>
<p>下面是代码, 请务必记得use一下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> num_clone = num.clone();</span><br><span class="line"></span><br><span class="line">btn_inc.connect_clicked(|_| &#123;</span><br><span class="line">    num_clone.set(num_clone.get() + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn_dec.connect_clicked(|_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>
其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p>
<p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>
</li>
</ul>
<p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>
要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p>
<p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>
因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p>
<p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>
所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p>
<hr>
<h1 id="clone">clone!</h1>
<p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href="https://docs.rs/glib/latest/glib/macro.clone.html">glib::clone</a><br>
请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> glib::clone;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;   <span class="comment">// 这里</span></span><br><span class="line"><span class="keyword">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class="comment">// 这里</span></span><br></pre></td></tr></table></figure>
<p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>
若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>
若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p>
<p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>
而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p>
</li>
<li class="lvl-2">
<p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>
我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p>
</li>
</ul>
<p><strong>注意:</strong><br>
<code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>
详情请见文档: <a href="https://docs.rs/glib/latest/glib/macro.clone.html">glib::clone</a></p>
<p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>
循环引用导致内存泄漏!</p>
<hr>
<h1 id="xun-huan-yin-yong">循环引用</h1>
<p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br>
<s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p>
<p>贴一份刚刚的代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>
两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>
这就是 <code>循环引用</code></p>
<p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p>
<p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>
在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p>
<p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>
答案是不会, 原因是以下两段代码</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一段:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gtk_box = gtk::<span class="built_in">Box</span>::builder()</span><br><span class="line">    .orientation(Orientation::Vertical)</span><br><span class="line">    .build();</span><br><span class="line">gtk_box.append(&amp;btn_inc);</span><br><span class="line">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>第二段:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .child(&amp;gtk_box)</span><br><span class="line">    .build();</span><br><span class="line">win.present();</span><br></pre></td></tr></table></figure>
<p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>
第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p>
<p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br>
<code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br>
<code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>
win活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p>
<p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>
尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p>
<p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p4~&gt; GObject: 子类化</title>
    <url>/posts/rust-gtk4/p4.html</url>
    <content><![CDATA[<blockquote>
<p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
<h1 id="mu-lu-jie-gou">目录结构</h1>
<p>gtk 基于 glib, 而 glib 最让人印象深刻的地方, 又是其 <code>Gobject System</code><br>
众所周知, C 是一套面向过程的语言, 但基于 C 的 glib库, 却通过高超的思想, 提供了面向对象的支持</p>
<p>在这样一个面向对象, 依赖继承的体系中, 我们可以通过子类化(Subclassing)来创建新的自定义的 GObject<br>
让我们保持这样子的目录结构:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="attribute">src</span></span><br><span class="line">├── custom_button</span><br><span class="line">│   ├── imp<span class="selector-class">.rs</span></span><br><span class="line">│   └── mod<span class="selector-class">.rs</span></span><br><span class="line">└── <span class="selector-tag">main</span>.rs</span><br></pre></td></tr></table></figure>
<p>在 glib 中, 我们将通过创建两个结构体来创建一个子类<br>
我们将会创建一个新的 GObject, 通过继承成为 <code>gtk::Button</code> 的子类, 以此添加一些自定义的功能</p>
<hr>
<h1 id="zi-lei-hua">子类化</h1>
<p>如上面的目录结构所示, 我们定义了一个叫 <code>custom_button</code> 的模块, 在 <code>mod.rs</code> 中将 <code>CustomButton</code> 暴露给外部<br>
其实这就是 C 语言中实现子类化的模板, 我们将遵循这个规则, 通过定义两个 struct 来描述子类:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>imp.rs</code> 被用来存储自定义的状态, 存储继承自父类待 override 的虚函数</p>
</li>
<li class="lvl-2">
<p><code>custom_button::imp</code> 是私有模块, <code>custom_button::imp::CustomButton</code> 也是私有的</p>
</li>
<li class="lvl-2">
<p><code>custom_button::imp::CustomButton</code> 将被暴露给外界的 <code>custom_button::CustomButton</code> 使用, 作为其养料</p>
</li>
</ul>
<p>简单来说, 我们正在利用模块, 对子类化的 GObject 的功能进行分门别类, 让其定义更加清晰罢了</p>
<p>下面是具体代码, 直接抄书:</p>
<figure class="highlight rust"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::glib;</span><br><span class="line"><span class="keyword">use</span> gtk::subclass::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object holding the state</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomButton</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The central trait for subclassing a GObject</span></span><br><span class="line"><span class="meta">#[glib::object_subclass]</span></span><br><span class="line"><span class="keyword">impl</span> ObjectSubclass <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="keyword">const</span> NAME: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Type</span></span> = super::CustomButton;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ParentType</span></span> = gtk::Button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all GObjects</span></span><br><span class="line"><span class="keyword">impl</span> ObjectImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all widgets</span></span><br><span class="line"><span class="keyword">impl</span> WidgetImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all buttons</span></span><br><span class="line"><span class="keyword">impl</span> ButtonImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>先前也说了, 模块 <code>imp.rs</code> 的作用便是描述一个子类, 负责新添加的状态与待覆写的虚函数<br>
对于某个子类 GObject 的描述, 在 <code>ObjectSubclass</code> 中:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NAME</code>: 该 GObject 的名字, 为避免命名冲突, 应使用 crate-name 与 object-name 组成 (UpperCamelCase)</p>
</li>
<li class="lvl-2">
<p><code>Type</code>: 指之后将被创建的, 实际的 GObject</p>
</li>
<li class="lvl-2">
<p><code>ParentType</code>: 我们继承的那个父类 GObject</p>
</li>
</ul>
<p>你可能会疑惑, 这个 <code>Name</code> 与 <code>Type</code> 是什么鬼, 就不能直接用 <code>Type (我们在Rust中实际创建的类型)</code> 作为 <code>NAME</code> 吗?</p>
<p>别忘了, gtk 是一套跨语言的通用 GUI 框架, 拥有几十种语言的绑定, 设计必然不能拘泥在一种语言上, 即使对 C 也不例外<br>
不同语言自有不同命名规范, 必然得先统一风格, 比如之后会学习的 <code>.ui</code> 为后缀的 xml 文件, 可以用来描述界面, 这可是不管哪个语言都通用的啊<br>
因此 <code>NAME</code> 是用来描述其名字, 而 <code>Type/ParentType</code> 则是特定于语言的某一个类型 (此处是Rust中的 <code>CustomButton</code>/<code>gtk::Button</code>)</p>
<p>再提一嘴, 之后将学习的以 <code>.ui</code> 为后缀的 xml 文件, 可以创建 GtkBuilder template class(模板类), 像下面这样去描述界面:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">class</span>=<span class="string">&quot;GtkAppWindow&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;GtkApplicationWindow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span>&gt;</span>My GTK App<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 此处使用 `CustomButton` 指定 widget 的类型 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;CustomButton&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button_1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;label&quot;</span>&gt;</span>Press me!<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-top&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-bottom&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-start&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;margin-end&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可能还会在之后对 gtk 框架的一些地方感到疑惑, 因此请记住: gtk 是一套通用的 gui 框架, 不止是为一种语言服务的</p>
<p>接下来是将暴露给外界的 <code>CustomButton</code>:</p>
<figure class="highlight rust"><figcaption><span>src/custom_button/mod.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> glib::Object;</span><br><span class="line"><span class="keyword">use</span> gtk::glib;</span><br><span class="line"></span><br><span class="line">glib::wrapper! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomButton</span></span>(ObjectSubclass&lt;imp::CustomButton&gt;)</span><br><span class="line">        @extends gtk::Button, gtk::Widget,</span><br><span class="line">        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> CustomButton &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">with_label</span></span>(label: &amp;<span class="built_in">str</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Object::new(&amp;[(<span class="string">&quot;label&quot;</span>, &amp;label)])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glib::wrapper!</code> 顾名思义, 能帮我们将 <code>imp::CustomButton</code> 进行包装, 自动生成相关实现, 避免大量样例代码, 我们只需指明其继承情况即可:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>@extends</code>: 指明所有父类 GObject</p>
</li>
<li class="lvl-2">
<p><code>@implements</code>: 指明所有实现的 Interface (在 Rust 中是 Trait)</p>
</li>
<li class="lvl-2">
<p><code>imp::CustomButton</code>: 经过宏成为了被暴露的 <code>CustomButton</code> 的 inner 成员</p>
</li>
<li class="lvl-2">
<p><code>with_label</code>: 添加了自己的将被暴露的新方法, 设置了 GObject 的 property (<code>Object::new</code> 的返回值是泛型, 此处会自动推导为 <code>Self</code>)</p>
</li>
</ul>
<p>我们可以通过 <a href="https://docs.gtk.org/gtk4/class.Button.html#hierarchy">docs/gtk/hierarchy</a> 来查看某个 GObject 的继承链情况</p>
<p>现在, <code>CustomButton</code> 实际上已经与 <code>gtk::Button</code> 一样了, 因此我们可以直接用其替换 <code>Button</code>:</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> custom_button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> custom_button::CustomButton;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> button = CustomButton::with_label(<span class="string">&quot;Press me!&quot;</span>);</span><br><span class="line">    button.set_margin_top(<span class="number">12</span>);</span><br><span class="line">    button.set_margin_bottom(<span class="number">12</span>);</span><br><span class="line">    button.set_margin_start(<span class="number">12</span>);</span><br><span class="line">    button.set_margin_end(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> window = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My GTK App&quot;</span>)</span><br><span class="line">        .child(&amp;button)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    window.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>mold -run cargo run</code>, 你会见识一模一样的效果 😃</p>
<hr>
<h1 id="zi-ding-yi">自定义</h1>
<p>没错, 这还不够, 如果费劲心思搞出来的子类只是和父类一般, 那就没必要搞了, 很简单的道理不是吗?<br>
令人兴奋的是, 我们还可以保存状态, 覆写虚函数!</p>
<p>下面是例子, 直接抄书, 我们将只覆写其中两个虚函数:</p>
<figure class="highlight rust"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> gtk::glib;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::subclass::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object holding the state</span></span><br><span class="line"><span class="meta">#[derive(Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">CustomButton</span></span> &#123;</span><br><span class="line">    number: Cell&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The central trait for subclassing a GObject</span></span><br><span class="line"><span class="meta">#[glib::object_subclass]</span></span><br><span class="line"><span class="keyword">impl</span> ObjectSubclass <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="keyword">const</span> NAME: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Type</span></span> = super::CustomButton;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">ParentType</span></span> = gtk::Button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all GObjects</span></span><br><span class="line"><span class="keyword">impl</span> ObjectImpl <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">constructed</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.parent_constructed();</span><br><span class="line">        <span class="keyword">self</span>.obj().set_label(&amp;<span class="keyword">self</span>.number.get().to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all widgets</span></span><br><span class="line"><span class="keyword">impl</span> WidgetImpl <span class="keyword">for</span> CustomButton &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait shared by all buttons</span></span><br><span class="line"><span class="keyword">impl</span> ButtonImpl <span class="keyword">for</span> CustomButton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clicked</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number.set(<span class="keyword">self</span>.number.get() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.obj().set_label(&amp;<span class="keyword">self</span>.number.get().to_string())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为 <code>imp::CustomButton</code> 添加了一个状态, 也就是其成员 <code>number</code>, 随后覆写了两个虚函数<br>
(覆写构造函数时, 还得记得调用一下父类的构造函数, 完成整个构造链)</p>
<p>在被覆写的函数中, 我们都调用了 <code>self.obj()</code>, 你可以观察一下其签名:</p>
<figure class="highlight rust"><figcaption><span>glib::subclass::types::obj</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">obj</span></span>(&amp;<span class="keyword">self</span>) -&gt; crate::BorrowedObject&lt;Self::Type&gt;</span><br></pre></td></tr></table></figure>
<p>还记得 <code>Self::Type</code> 是什么吗? 没错, 就是被暴露的那个 <code>CustomButton</code>, 而非 <code>imp::CustomButton</code>, 它才是被使用的真正实例(instance)<br>
此处的 <code>obj()</code> 方法, 其别名就是 <code>instance()</code>, 得到的是在 <code>main.rs</code> 中被创建的那个真正实例的引用</p>
<p>顺便再复习一下, 防止有人看见这里而感疑惑: 为什么是 <code>clicked(&amp;self)</code> 而非 <code>clicked(&amp;mut self)</code>, 这样不应该更方便吗?<br>
这是因为每个 GObject 都是引用计数的, 所以能绕过编译器的检查(全是不可变借用), 之前提到过了</p>
<p>经过覆写虚函数, <code>CustomButton</code> 终于出现了有别于父类 <code>Button</code> 的新特性:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>被构造时: 初始化 label 为自己存储的状态数字</p>
</li>
<li class="lvl-2">
<p>被点击时: 会让存储的状态数字+1, 随后更新 label</p>
</li>
</ul>
<p>现在调用 <code>mold -run cargo run</code>, 你将得到一个按钮, 按钮的 label 初始时为 0, 被点击后不断+1</p>
<hr>
<h1 id="shi-yong-qing-kuang">使用情况</h1>
<p>什么情况下适合使用 <code>glib::wrapper</code> 来模拟继承呢 (Rust 语言层面上不支持继承, 因此叫模拟)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用一个 widget, 其添加了自定义状态与覆写虚函数</p>
</li>
<li class="lvl-2">
<p>将 Rust 对象传递给要求参数是 GObject 的函数 (因为 gtk 不只是 Rust 的GUI框架, 还是其他许多语言的 GUI 框架)</p>
</li>
<li class="lvl-2">
<p>为某个对象添加 property 或 signal, 继承 glib 体系下的强大力量 (下面几节会讲)</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p5~&gt; GObject: 通用类型</title>
    <url>/posts/rust-gtk4/p5.html</url>
    <content><![CDATA[<blockquote>
<p>本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
<h1 id="shuo-ming">说明</h1>
<p>之前说过, gnome体系依赖于 glib, 以C语言为核心的实现, 通过 Gobject-Introspection 为大量语言提供绑定<br>
这是一套以C为核心, 支持多语言互相交互的运行时系统, 自然要有套完整且够通用的数据类型</p>
<p>在为Rust提供的绑定中, 有两套这样的数据类型, 分别是:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>glib::Value</code>: 作用于 rust 与 glib 之间数据类型的互相转换</p>
</li>
<li class="lvl-2">
<p><code>glib::Variant</code>: 作用于数据类型的序列化/反序列化, 以使应用与外部世界(比如某个进程)交互, 或存储数据到本地磁盘</p>
</li>
</ul>
<p>之后学习属性与信号时, 我们将会用到 <code>glib::Value</code>, 即 <code>GValue</code>, 让 rust 中的数据类型 能与 glib 的库函数互相交互<br>
之后学习偏好持久化/设置保存时, 我们将会用到 <code>glib::Variant</code>, 即 <code>GVariant</code>, 进行数据的序列化与反序列化</p>
<p>搞清楚以上的说明之后, 接下来的难度便是一马平川, 只需稍微看几眼有个印象, 到时候多查查文档就 ok 了<br>
接下来的代码直接抄官方书籍了, 不过加了大量解释, 希望有助于你理解它们</p>
<hr>
<h1 id="value">Value</h1>
<p>你可以简单地将 <code>glib::Value</code> 理解为一个 Wrapper 类型, 如果用 rust 中的 enum 来表示, 它可以是这样的:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Value</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">bool</span>(<span class="built_in">bool</span>),</span><br><span class="line">    <span class="built_in">i8</span>(<span class="built_in">i8</span>),</span><br><span class="line">    <span class="built_in">i32</span>(<span class="built_in">i32</span>),</span><br><span class="line">    <span class="built_in">u32</span>(<span class="built_in">u32</span>),</span><br><span class="line">    <span class="built_in">i64</span>(<span class="built_in">i64</span>),</span><br><span class="line">    <span class="built_in">u64</span>(<span class="built_in">u64</span>),</span><br><span class="line">    <span class="built_in">f32</span>(<span class="built_in">f32</span>),</span><br><span class="line">    <span class="built_in">f64</span>(<span class="built_in">f64</span>),</span><br><span class="line">    <span class="comment">// boxed-types</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;),</span><br><span class="line">    Object(<span class="built_in">Option</span>&lt;<span class="keyword">dyn</span> IsA&lt;glib::Object&gt;&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会观察到 <code>boxed-types(装箱类型)</code> 这几个字, 它包装一个 rust 中的 <code>Option&lt;T&gt;</code> 类型<br>
即, boxed-types, 可接受包装 <code>Option&lt;T&gt;::None</code>, 以此来表示可空这个概念</p>
<p>此时, 装箱所得的结果, 是个代表着C语言中 <code>null</code> 概念的东西, 而其他的如数字/布尔类型的 GValue, 则不允许包装 <code>None</code></p>
<p>听着云里雾里的? 那就直接看代码吧, 下面是一些例子, 或许能帮助你更好地理解:</p>
<figure class="highlight rust"><figcaption><span>non-boxed-types example:</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store `i32` as `Value`</span></span><br><span class="line">    <span class="keyword">let</span> integer_value = <span class="number">10</span>.to_value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `i32` from `Value`</span></span><br><span class="line">    <span class="keyword">let</span> integer = integer_value</span><br><span class="line">        .get::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `i32`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(integer, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><figcaption><span>boxed-types example:</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store `Option&lt;String&gt;` as `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string_some_value = <span class="string">&quot;Hello!&quot;</span>.to_value();</span><br><span class="line">    <span class="keyword">let</span> string_none_value = None::&lt;<span class="built_in">String</span>&gt;.to_value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `String` from `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string_some = string_some_value</span><br><span class="line">        .get::&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> string_none = string_none_value</span><br><span class="line">        .get::&lt;<span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(string_some, <span class="literal">Some</span>(<span class="string">&quot;Hello!&quot;</span>.to_string()));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(string_none, <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你希望区分可以表示空的Value, 只需将 <code>get::&lt;String&gt;</code> 换成 <code>get::&lt;Option&lt;String&gt;&gt;</code> 即可, 函数会自动帮你进行转换</p>
<figure class="highlight rust"><figcaption><span>directly use `get::&lt;String&gt;` instead of `get::&lt;Option&lt;String&gt;&gt;` if you are sure it is not none:</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store string as `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string_value = <span class="string">&quot;Hello!&quot;</span>.to_value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `String` from `Value`</span></span><br><span class="line">    <span class="keyword">let</span> string = string_value</span><br><span class="line">        .get::&lt;<span class="built_in">String</span>&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The value needs to be of type `String`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(string, <span class="string">&quot;Hello!&quot;</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将在之后学习 信号(signal) 与 属性(property) 时, 使用到 <code>glib::Value</code></p>
<hr>
<h1 id="variant">Variant</h1>
<p>数据要发送到某个进程或网络, 或想将数据存储在磁盘上时, 就可以使用 <code>glib::Variant</code><br>
你可以将 <code>glib::Variant</code> 想象为 json 文本, 那是一种非常通用的文件格式</p>
<p>根据文档所述:<br>
glib 中的 Variant, 被设计为与 dbus 体系有着基本相同的格式, 能够方便与 dbus 集成<br>
Variant 在处理序列化形式的数据方面进行了大量优化, 可在很短的常量时间内, 执行几乎所有的反序列化操作，且占用非常小的内存<br>
序列化的 Variant 数据也可以通过网络发送</p>
<p>因此你希望更深入学习, 可以查找 dbus 的相关资料, 这不在接下来的文章范围内</p>
<p>与使用 <code>glib::Value</code> 的经验非常相似, 我们只需要将 <code>to_value()</code> 替换为 <code>to_variant()</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Store `i32` as `Variant`</span></span><br><span class="line">    <span class="keyword">let</span> integer_variant = <span class="number">10</span>.to_variant();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve `i32` from `Variant`</span></span><br><span class="line">    <span class="keyword">let</span> integer = integer_variant</span><br><span class="line">        .get::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The variant needs to be of type `i32`.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the retrieved value is correct</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(integer, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多例子, 以下代码将实现 <code>Vec&lt;T&gt;</code> 与 <code>glib::Variant</code> 间的互相转化:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> variant = <span class="built_in">vec!</span>[<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;there!&quot;</span>].to_variant();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(variant.n_children(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vec = &amp;variant</span><br><span class="line">        .get::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;()</span><br><span class="line">        .expect(<span class="string">&quot;The variant needs to be of type `String`.&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec[<span class="number">0</span>], <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将在使用 <code>gio::Settings</code> 保存设置, 或使用 <code>gio::Action</code> 激活操作时，用到 <code>glib::Variant</code></p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p6~&gt; GObject: 属性</title>
    <url>/posts/rust-gtk4/p6.html</url>
    <content><![CDATA[<blockquote>
<p>本节将学习 GObject 的 property(属性), 探索其强大且灵活的动态运行时</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
<h1 id="shuo-ming">说明</h1>
<p>属性(Property), 让我们能够访问 GObject 的状态(state)</p>
<p>glib 虽然以面向过程的 C 为核心, 但却具有面向对象的思想, 属性自然是其中重要的一环<br>
通过库为我们提供的运行时, 我们得到了一个灵活的, 动态的运行时, 直接使用就好</p>
<p>得益于此, 我们可以在程序的运行过程中, 动态地修改其属性, 比如:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>动态注册某个新的属性</p>
</li>
<li class="lvl-2">
<p>进行属性间的自动绑定</p>
</li>
<li class="lvl-2">
<p>属性变更时将执行操作</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p2~&gt; 创建窗口</title>
    <url>/posts/rust-gtk4/p2.html</url>
    <content><![CDATA[<blockquote>
<p>让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
<h1 id="bei-jing-liao-jie">背景了解</h1>
<h2 id="gtk" id="GTK">GTK</h2>
<p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写<br>
在gtk3后, 由于GI(<a href="https://gi.readthedocs.io/en/latest/">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定<br>
这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript… <s>(不会真的有人用C语言写Gtk吧?)</s></p>
<p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p>
<h2 id="gtk-rs" id="gtk-rs">gtk-rs</h2>
<p>目前有个项目, 叫做 <a href="https://gtk-rs.org/">gtk-rs</a>, 负责GTK的Rust绑定, 在 <a href="https://crates.io/">crates.io</a> 上搜索 gtk, 所看到的 <a href="https://crates.io/crates/gtk">gtk</a> 与 <a href="https://crates.io/crates/gtk4">gtk4</a>, 就属于gtk-rs</p>
<p>gtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身<br>
所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上</p>
<hr>
<h1 id="xiang-mu-pei-zhi">项目配置</h1>
<p>首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 请输入以下命令:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">cargo add gtk4@0.5.2 --rename gtk</span><br><span class="line">cargo add libadwaita@0.2 --rename adw</span><br></pre></td></tr></table></figure>
<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4/libadwaita, 如 <a href="/posts/rust-gtk4/p1">p1</a> 中所述)<br>
(adw 这个库之后会提的, 现在先忽略掉即可)<br>
下面就是正式的编码环节了</p>
<hr>
<h1 id="jia-su-bian-yi">加速编译</h1>
<p>有个非常快速的名为 <a href="https://github.com/rui314/mold">mold (github.com/rui314/mold)</a> 的链接器, 非常适合加速 gtk 项目的编译, 以便快速调试<br>
直接用你的包管理器下载 <code>mold</code>, 或者根据 github 的指示获取, 随后像下面这样简单的添加前缀即可:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">mold -run cargo run</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="ji-chu-zhi-shi">基础知识</h1>
<p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>
同时还需 <code>use gtk::prelude::*</code>, 原因与 <a href="https://doc.rust-lang.org/std/prelude/index.html">std::prelude</a> 一样</p>
<p>先创建一个应用, 它目前连窗口也没有:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单吧? 但别急着运行, 先看看下面两处:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://developer.gnome.org/documentation/tutorials/application-id.html">application_id</a>:<br>
每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的, 一般使用反域名作为id, 如 “org.gnome.gedit”<br>
<code>app_id</code> 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!</p>
</li>
<li class="lvl-2">
<p><a href="http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>
我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: <code>application_id(id: &amp;str)</code><br>
在gtk4中, 它被高频次地使用, 最后调用的 <code>build</code> 会生成比如窗口, 按钮等部件的实例<br>
当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话</p>
</li>
</ul>
<hr>
<h1 id="xin-hao-liang">信号量</h1>
<p>当你跃跃欲试, <code>mold -run cargo run</code> 之后, 会看到:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GLib-GIO-WARNING : Your application does not implement g_application_activate()</span><br><span class="line">and has no handlers connected to the <span class="string">&#x27;activate&#x27;</span> signal.  </span><br><span class="line">It should <span class="keyword">do</span> one of these.</span><br></pre></td></tr></table></figure>
<p>靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然, 现在还无法执行, 请注意 <code>build_ui</code> 函数中的 <code>todo!()</code>, 我们还没有填充这个函数!<br>
因为我想逐步地讲解一下… 先来讲什么是 signal 吗:</p>
<p>当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度<br>
比如窗口打开, 按钮被点击, 拖动控件…这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了<br>
你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>我们把处理函数, 称之为 <code>handler</code></p>
</li>
<li class="lvl-2">
<p>我们将为 signal 绑定一个 handler 的过程, 称之为 <code>connect</code></p>
</li>
</ul>
<p>Gtk 的理念是: App只关心在特定的时候需要做的事情<br>
<code>事件发送的时间</code> , 即 signal 什么时候发送已经定好了, 至于 <code>事情的内容</code>, 即 handler 的具体实现, 由开发者自己负责</p>
<p>下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>startup:<br>
在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p>
</li>
<li class="lvl-2">
<p>shutdown:<br>
在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p>
</li>
<li class="lvl-2">
<p>activate:<br>
GtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口</p>
</li>
<li class="lvl-2">
<p>open<br>
当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p>
</li>
</ul>
<p>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>
当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口<br>
所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化</p>
<p>这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象</p>
<hr>
<h1 id="chuang-jian-kong-bai-chuang-kou">创建空白窗口</h1>
<p>回到之前的代码, 如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Your <span class="built_in">application</span> <span class="keyword">does</span> <span class="keyword">not</span> implement g_application_activate()</span><br><span class="line"><span class="keyword">and</span> has no handlers connected <span class="keyword">to</span> <span class="keyword">the</span> &#x27;<span class="built_in">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure>
<p>现在你应该明白, 为什么之前会报出这个警告了吧? <code>connect_xxxx</code>, 代表着连接某个 signal , 即实现对应的虚函数/handler</p>
<p><code>connect_activate</code>, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 <code>&amp;Application</code><br>
我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这…啧, 不太聪明?</p>
<p>直接上 <code>build_ui</code> 的代码, 注意 use 那边多了东西:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My App&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它<br>
如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 <code>My App</code></p>
<p>在App启动之后的某时刻, <code>activate</code> 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现<br>
但现在, 我们已经将它覆盖成自己的 <code>build_ui</code> 了, 因此警告不再出现</p>
<hr>
<h1 id="xin-zeng-an-niu">新增按钮</h1>
<p>让我们再创建一个按钮, 提示信息是 <code>Press me!</code>, 在按下之后, 变成显示 <code>Hello World!</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::&#123;prelude::*, Button&#125;;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> btn = Button::builder().label(<span class="string">&quot;Press me!&quot;</span>).build();</span><br><span class="line">    btn.connect_clicked(|btn| btn.set_label(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My App&quot;</span>)</span><br><span class="line">        .child(&amp;btn)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已</p>
<p>之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler<br>
点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理</p>
<p>然后, 我们在使用 <code>Builder Pattern</code> 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中<br>
注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲</p>
<hr>
<h1 id="chang-jian-she-zhi">常见设置</h1>
<p><s>稍微再水一点字数</s></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置间距:<br>
运行先前的代码, 你会发现按钮占满了整个窗口<br>
我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = Button::builder()</span><br><span class="line">    .label(<span class="string">&quot;Press me!&quot;</span>)</span><br><span class="line">    .margin_top(<span class="number">12</span>)</span><br><span class="line">    .margin_bottom(<span class="number">12</span>)</span><br><span class="line">    .margin_start(<span class="number">12</span>)</span><br><span class="line">    .margin_end(<span class="number">12</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>透明设置:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .opacity(<span class="number">0.8</span>)         <span class="comment">// 窗口不透明度, 越低越透明, 越高越不透明</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认高宽:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .default_height(<span class="number">100</span>)</span><br><span class="line">    .default_width(<span class="number">200</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p7~&gt; GObject: 信号</title>
    <url>/posts/rust-gtk4/p7.html</url>
    <content><![CDATA[<blockquote>
<p>本节将学习 GObject 的 signal(信号)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gui">rust-gui</a><br>
GNOME入坑指南: <a href="/posts/desktop-beautify/gnome">gnome</a></p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
</search>
