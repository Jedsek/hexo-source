<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GNOME 入坑指南</title>
    <url>/posts/gnome/guide.html</url>
    <content><![CDATA[<blockquote>
<p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p>
</blockquote>
<span id="more"></span>
<div class="tips">
<p><strong>注意:</strong><br>
本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式, 炫酷效果, 更多功能的, 请自行配置<br>
请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>
目前, 该篇文章的GNOME 版本为: <strong>42</strong></p>
</div>
<h1 id="cheng-pin-zhan-shi">成品展示</h1>
<p>2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前…<br>
我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!</p>
<details open>
<summary><span class="pre-summary">&nbsp;</span><strong>以下是成品展示, 请点击隐藏/展开图像</strong></summary><p><img data-src="/images/gnome/overview.png" alt="按下Super后的Overview"></p>
</details>
<hr>
<h1 id="dconf-amp-amp-gsettings">dconf &amp;&amp; gsettings</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>dconf</code>:<br>
是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p>
</li>
<li class="lvl-2">
<p><code>gsettings</code>:<br>
是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p>
</li>
</ul>
<p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>
答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p>
<p>接下来的大部分配置, 都会使用 <code>gsettings</code></p>
<hr>
<h1 id="hong-mo-ban">触摸板</h1>
<p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p>
<h2 id="pei-zhi" id="配置">配置</h2>
<p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>
这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p>
<p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>
而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>
还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p>
<p>你可以在终端输入如下命令进行调整:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class="literal">true</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>分别对应:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>轻击模拟鼠标点击, 默认为false</p>
</li>
<li class="lvl-2">
<p>调整触摸板速度, 默认为0</p>
</li>
<li class="lvl-2">
<p>打字时禁用触摸板, 默认为true</p>
</li>
</ul>
<h2 id="shou-shi" id="手势">手势</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>单指: 移动鼠标</p>
</li>
<li class="lvl-2">
<p>双指上下: 翻页</p>
</li>
<li class="lvl-2">
<p>三指左右: 切换Workspace</p>
</li>
<li class="lvl-2">
<p>三指上: 打开Overview (不常用, 按Super更快)</p>
</li>
<li class="lvl-2">
<p>三指下: 显示任务栏 (当你隐藏任务栏时)</p>
</li>
</ul>
<hr>
<h1 id="an-zhuang-kuo-zhan">安装扩展</h1>
<p>GNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之<br>
我将先介绍如何安装/使用它们, 因为后面需要用到扩展</p>
<p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>
我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p>
<h2 id="cong-ming-ling-xing" id="从命令行">从命令行</h2>
<div class="tips">
<p><strong>提示</strong><br>
请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有…<br>
下载成功后, 切记要 logout, 然后再登进来</p>
</div>
<p>每个GNOME扩展都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载扩展</p>
<p>你可以在 <a href="https://extensions.gnome.org/">Extensions-GNOME</a> 这个网站上, 浏览并下载扩展<br>
请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 <code>exts_list</code></p>
<p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p>
<div class="tabs" id="install-extensions"><ul class="nav-tabs"><li class="tab active"><a href="#install-extensions-1">Bash</a></li><li class="tab"><a href="#install-extensions-2">Fish</a></li></ul><div class="tab-content"><div class="tab-pane active" id="install-extensions-1"><figure class="highlight bash"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">declare</span> -a UUID_LIST</span><br><span class="line">EXTS_DIR=<span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions</span><br><span class="line">EXTS_LIST=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"><span class="function"><span class="title">str_join</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;$*&quot;</span> | sed <span class="string">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">mkdir -p <span class="variable">$EXTS_DIR</span></span><br><span class="line">chmod -R 755 <span class="variable">$HOME</span>/.<span class="built_in">local</span>/</span><br><span class="line"><span class="keyword">for</span> EXT <span class="keyword">in</span> <span class="variable">$EXTS_LIST</span>/*.zip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  UUID=$(unzip -p <span class="variable">$EXT</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span>)</span><br><span class="line">  mkdir -p <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  unzip -q -o <span class="variable">$EXT</span> -d <span class="variable">$EXTS_DIR</span>/<span class="variable">$UUID</span></span><br><span class="line">  UUID_LIST+=<span class="string">&quot;\&quot;<span class="variable">$UUID</span>\&quot;&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">UUID_LIST=[$(str_join <span class="variable">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="install-extensions-2"><figure class="highlight bash"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> exts_list <span class="variable">$argv</span>[1]</span><br><span class="line"><span class="built_in">set</span> exts_dir <span class="variable">$HOME</span>/.<span class="built_in">local</span>/share/gnome-shell/extensions/</span><br><span class="line"><span class="built_in">set</span> uuid_list</span><br><span class="line">mkdir -p <span class="variable">$exts_dir</span></span><br><span class="line"><span class="keyword">for</span> ext <span class="keyword">in</span> exts_list/*.zip</span><br><span class="line">  <span class="built_in">set</span> uuid ( unzip -p <span class="variable">$ext</span> metadata.json | jq -r <span class="string">&quot;.uuid&quot;</span> )</span><br><span class="line">  mkdir -p <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  unzip -q -o <span class="variable">$ext</span> -d <span class="variable">$ext_dir</span>/<span class="variable">$uuid</span></span><br><span class="line">  <span class="built_in">set</span> -a uuid_list \<span class="string">&#x27;$uuid\&#x27;</span></span><br><span class="line">end</span><br><span class="line"><span class="built_in">set</span> uuid_list [( string join <span class="string">&quot;,&quot;</span> <span class="variable">$uuid_list</span> )]</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell enabled-extensions <span class="variable">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p>
<p><strong>注意: 先logout, 再登进来</strong></p>
<p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dbus-send --<span class="built_in">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \</span><br><span class="line">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class="string">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="cong-liu-lan-qi" id="从浏览器">从浏览器</h2>
<p>该方法其实也蛮方便的, 但不适合快速部署<br>
你需要安装两个玩意, 才能直接从 <a href="https://extensions.gnome.org/">Extension-GNOME</a> 上直接下载</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>chrome-gnome-shell</code>:<br>
本地软件, 你可以通过包管理器, 直接搜这个名字</p>
</li>
<li class="lvl-2">
<p><code>GNOME Shell integration</code>:<br>
浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>
Edge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p>
</li>
</ul>
<p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href="https://extensions.gnome.org/">网站</a> 上 直接安装到本地</p>
<hr>
<h1 id="cha-kan-pei-zhi-kuo-zhan">查看/配置扩展</h1>
<p>通过 <code>gnome-extensions</code> 这个命令, 我们可以查看/配置当前扩展</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帮助, `Command` 为可选项</span></span><br><span class="line">gnome-extensions <span class="built_in">help</span> [Command]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展列表</span></span><br><span class="line">gnome-extensions list --user    <span class="comment"># 查看用户级扩展</span></span><br><span class="line">gnome-extensions list --system  <span class="comment"># 查看系统级扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看扩展的信息</span></span><br><span class="line">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用某个扩展</span></span><br><span class="line">gnome-extensions <span class="built_in">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line">gnome-extensions <span class="built_in">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置某个扩展 (打开 GUI 界面)</span></span><br><span class="line">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure>
<p>或者通过 <code>gsettings</code> 来配置某个扩展, 但不推荐, 因为麻烦:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看某个扩展的所有选项</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class="line">gsettings --schemadir ~/.<span class="built_in">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \</span><br><span class="line">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class="line"><span class="comment"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class="line"><span class="comment"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure>
<p>你也可以参考或<a href="#jia-zai-pei-zhi"><strong>直接加载</strong></a>我博客下的 <a href="/downloads/gnome/dconf.settings"><strong>dconf.settings</strong></a><br>
<strong>注意:</strong> 如何你选择直接加载我的配置, 请注意 <code>picture-uri</code> 符合自己实际</p>
<hr>
<h1 id="tui-jian-de-kuo-zhan">推荐的扩展</h1>
<p>以下是我目前正在使用, 推荐的扩展</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/16/auto-move-windows/">auto-move-windows</a>:<br>
通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/905/refresh-wifi-connections/">refresh-wifi-connections</a><br>
当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/refresh-wifi-connections.png" alt="refresh-wifi-connections"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1446/transparent-window-moving/">transparent-window-moving</a><br>
在对窗口进行移动/调整大小时, 使窗口变得透明</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/transparent-window-moving.png" alt="transparent-window-moving"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3843/just-perfection/">just-perfection</a><br>
我最喜欢的一个扩展, 用于对界面进行大量自定义与精简<br>
比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="just-perfection"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3139/eye-extended/">eye-extended</a><br>
很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场<br>
在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/eye-extended.png" alt="eye-extended"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1113/nothing-to-say/">nothing-to-say</a><br>
用于切断/恢复声音的输入, 对我来说蛮有用的:<br>
当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/nothing-to-say.png" alt="nothing-to-say"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/5090/space-bar/">space-bar</a><br>
模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 <code>Activities</code> 替换为 <code>Workspaces</code>, 有些类似的扩展, 但这个最好</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/space-bar.png" alt="space-bar"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4696/static-background-in-overview/">static-background-in-overview</a><br>
在按下 <code>Super</code> 进入 <code>Overview</code> 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="static-background-in-overview"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4788/workspace-switcher-manager/">workspace-switcher-manager</a><br>
美化通过键盘(我配成了 <code>Super + 1..9</code>), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/workspace-switcher-manager.png" alt="workspace-switcher-manager"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/">disable-workspace-switch-animation-for-GNOME40+</a><br>
消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1319/gsconnect/">gsconnect</a><br>
GNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>
手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href="/downloads/gnome/kdeconnect.apk">kdeconnect</a></p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gsconnect.png" alt="gsconnect"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3193/blur-my-shell/">blur-my-shell</a><br>
用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview.png" alt="blur-my-shell"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3488/big-avatar/">big-avatar</a><br>
让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/big-avatar.png" alt="big-avatar"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4530/cpudots/">cpudots</a><br>
监视你当前的CPU频率, 以百分数的形式呈现在顶栏</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="cpudots"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4817/colorful-battery-indicator/">colorful-battery-indicator</a><br>
让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/right-corner.png" alt="colorful-battery-indicator"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/">gnome40-ui-improvements</a><br>
按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区的内容</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome40-ui-improvements.png" alt="gnome40-ui-improvements"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/">gnome-fuzzy-app-search</a><br>
出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该扩展修改</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/gnome-fuzzy-app-search.png" alt="gnome-fuzzy-app-search"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4691/pip-on-top/">pip-on-top</a><br>
当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/4792/frequency-boost-switch/">frequency-boost-switch</a><br>
在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/frequency-boost-switch.png" alt="frequency-boost-switch"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/1702/overview-navigation/">overview-navigation</a><br>
当按下 <code>Super</code> 进入 <code>Overview</code> 后, 可以按下 <code>空格键</code>, 窗口上会出现字母<br>
输入小写字母就切换到对应窗口, 按下 <code>Shift</code> 会使字母颜色变红, 此时输入字母会关闭对应窗口</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="overview-navigation"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3759/cleaner-overview/">cleaner-overview</a><br>
进入 <code>Overview</code> 时, 将窗口排列整齐, 简单实用</p>
</li>
</ul>
<details>
<summary><span class="pre-summary">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src="/images/gnome/overview-navigation.png" alt="cleaner-overview"></p>
</details>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/19/user-themes/">user-theme</a><br>
从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>
注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br>
<strong>无图片</strong></p>
</li>
</ul>
<br>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://extensions.gnome.org/extension/3414/user-stylesheet-font/">user-syle-sheet</a><br>
读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者<br>
<strong>无图片</strong></p>
</li>
</ul>
<hr>
<h1 id="mei-hua">美化</h1>
<p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>
还有很多扩展有帮助, 上面 <a href="#tui-jian-de-kuo-zhan">推荐的扩展</a> 里有提到, 比如那个更改css的, 这里不说了</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>启动暗模式:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface color-scheme <span class="string">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.background picture-uri-dark <span class="string">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或将图片命名为.face, 放到家目录</span></span><br><span class="line"><span class="comment"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href="https://www.gnome-look.org/">gnome-look</a> 挑选主题</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 Nordic 为例子</span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface gtk-theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences theme <span class="string">&#x27;Nordic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你也可以使用 `user-theme` 这个扩展进行设置:  </span></span><br><span class="line">mkdir ~/.themes/ &amp;&amp; <span class="built_in">cd</span> ~/.themes/</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class="line">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface font-name <span class="string">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.shell favorite-apps <span class="string">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure>
<div class="tips">
<p><strong>注意:</strong><br>
以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 扩展<br>
此扩展得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>
如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href="#jin-yong-kuai-jie-jian">禁用快捷键</a></p>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: <code>space-bar</code> 或 <code>workspace-bar</code>)</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences workspace-names <span class="string">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href="#cheng-pin-zhan-shi">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p>
</li>
</ul>
<hr>
<h1 id="kuai-jie-jian">快捷键</h1>
<p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p>
<p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>
当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p>
<div class="tips">
<p><strong>注意:</strong><br>
快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突</p>
</div>
<h2 id="cha-zhao-kuai-jie-jian" id="查找快捷键">查找快捷键</h2>
<p>首先, 我们得明白如何查找对应的快捷键</p>
<p>下面的命令会列出极大部分的快捷键:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings list-recursively | grep -E <span class="string">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure>
<p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>
如果实在找不到, 一点点看过去也行 😃</p>
<h2 id="jin-yong-kuai-jie-jian" id="禁用快捷键">禁用快捷键</h2>
<p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>
想要禁用该快捷键, 将对应的数组设置为空就行了</p>
<p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default: Super+&quot;1..9&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    gsettings <span class="built_in">set</span> org.gnome.shell.keybindings switch-to-application-<span class="variable">$i</span> <span class="string">&quot;[]&quot;</span>  </span><br><span class="line"><span class="keyword">done</span>    </span><br></pre></td></tr></table></figure>
<p>禁用快捷键还可以让你避免冲突, 比如:<br>
某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>
这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p>
<p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class="string">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class="comment">#Default: Sup+L</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class="string">&quot;[]&quot;</span> <span class="comment"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure>
<h2 id="xiu-gai-kuai-jie-jian" id="修改快捷键">修改快捷键</h2>
<p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href="#tian-jia-kuai-jie-jian">添加快捷键</a> 不是一个概念<br>
单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Vim 式的案件, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class="line"></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class="string">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class="comment"># 放左边</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class="comment"># 最大化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class="comment"># 最小化</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class="string">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class="comment"># 放右边</span></span><br></pre></td></tr></table></figure>
<p>对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管…</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>move, resize, kill 一个窗口:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Move</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class="string">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class="string">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class="comment">#Default: Alt+F8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings close        <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class="comment">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Toggle max</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class="string">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class="comment">#Default: Alt+F10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max/Min</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings maximize          <span class="string">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class="string">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings minimize          <span class="string">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class="comment">#Default: Super+H</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle fullscreen</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class="string">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show desktop</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class="string">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class="comment">#Default: None</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 9)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class="variable">$i</span> <span class="string">&quot;[&#x27;&lt;Super&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line">  gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class="variable">$i</span>   <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class="variable">$i</span>&#x27;]&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class="string">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class="string">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class="string">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class="comment">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure>
<h2 id="tian-jia-kuai-jie-jian" id="添加快捷键">添加快捷键</h2>
<p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>
比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p>
<p>废话不多说, 你按下面照猫画虎, 就阔以了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gp0=<span class="string">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line">gp1=<span class="string">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\</span></span><br><span class="line"><span class="string">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Keys</span></span><br><span class="line"><span class="comment"># 注意!!!!!!!</span></span><br><span class="line"><span class="comment"># 不要在最后添加逗号</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class="string">&quot;[     \</span></span><br><span class="line"><span class="string">    &#x27;<span class="variable">$gp0</span>/custom0/&#x27;, &#x27;<span class="variable">$gp0</span>/custom1/&#x27;, &#x27;<span class="variable">$gp0</span>/custom2/&#x27;, &#x27;<span class="variable">$gp0</span>/custom3/&#x27;               \</span></span><br><span class="line"><span class="string">]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Terminal</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ name     <span class="string">&#x27;Terminal&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ <span class="built_in">command</span>  <span class="string">&#x27;alacritty&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom0/ binding  <span class="string">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Files</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ name     <span class="string">&#x27;Files&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ <span class="built_in">command</span>  <span class="string">&#x27;nautilus&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom1/ binding  <span class="string">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Browser</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ name     <span class="string">&#x27;Browser&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ <span class="built_in">command</span>  <span class="string">&#x27;microsoft-edge-beta&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom2/ binding  <span class="string">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Fcitx5 Reload</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ name     <span class="string">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ <span class="built_in">command</span>  <span class="string">&#x27;fcitx5 -r&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> <span class="variable">$gp1</span>/custom3/ binding  <span class="string">&#x27;&lt;Alt&gt;space&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我相信你不会将时间浪费在掉在坑里面了<br>
上面的一切已经非常非常全了</p>
<hr>
<h1 id="jia-zai-pei-zhi">加载配置</h1>
<p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>
你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>
这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p>
<p>你也可以参考或直接加载我博客下的 <a href="/downloads/gnome/dconf.settings"><strong>dconf.settings</strong></a></p>
<h2 id="dui-yu-fei-nixos" id="对于非Nixos">对于非Nixos</h2>
<p>对于普通的Linux发行版, 直接按下面的方式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>导出当前的dconf数据到某个文件:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>加载/导入某个dconf文件到当前系统:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure>
<p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>
同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p>
<h2 id="dui-yu-nixos" id="对于Nixos">对于Nixos</h2>
<p>如果你使用 Nixos, 请先确保已经安装了 <a href="https://github.com/nix-community/home-manager">HomeManager</a><br>
HomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p>
<p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>
请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>
随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf dump / &gt; dconf.settings</span><br><span class="line">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure>
<p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nixpkgs/</span><br><span class="line">├── gnome</span><br><span class="line">│   ├── .background</span><br><span class="line">│   ├── .face</span><br><span class="line">│   └── dconf.nix</span><br><span class="line">└── home.nix</span><br></pre></td></tr></table></figure>
<p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imports = [</span><br><span class="line">  ./gnome/dconf.nix</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>
这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p>
</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class="line"><span class="keyword">let</span> <span class="attr">picture</span> = ../.background.png; <span class="keyword">in</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">picture-uri</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">  <span class="attr">picture-uri-dark</span> = <span class="string">&quot;file://<span class="subst">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p>
</li>
</ul>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">home.file.<span class="string">&quot;.face&quot;</span>.<span class="attr">source</span> = ./.face;</span><br></pre></td></tr></table></figure>
<p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>
]]></content>
      <tags>
        <tag>GNOME</tag>
      </tags>
  </entry>
  <entry>
    <title>Clap|命令行</title>
    <url>/posts/rust-clap/guide.html</url>
    <content><![CDATA[<blockquote>
<p>用 Rust 中的 Clap, 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出等功能</p>
</blockquote>
<span id="more"></span>
<p>前置知识: Rust基础<br>
完整代码: <a href="https://github.com/Jedsek/rust-wc">github-jedsek/rustwc</a></p>
<h1 id="cheng-pin-zhan-shi">成品展示</h1>
<p><img data-src="/images/clap-rwc.png" alt="彩色的表格输出, 根据参数进行统计"></p>
<hr>
<h1 id="cli">CLI</h1>
<p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>
比如我们在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传进去参数, 它做一些事情 (可能会有相应的输出)</p>
<p>GNU 项目为我们提供了非常多的开源软件, 比如一个叫做 <code>wc</code> 的命令, 可以统计指定文件的字节/字符/行的数量<br>
等一会, 我们就要使用 Rust 语言, 搭配今天的主角: clap, 实现美化版的 <code>wc</code> 命令</p>
<div class="tips">
<p><strong>注意:</strong><br>
cli 可以代表抽象的界面, 也可以指代具体的某个程序<br>
而后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p>
</div>
<hr>
<h1 id="clap">Clap</h1>
<h2 id="kai-pian" id="开篇">开篇</h2>
<p>clap 是个Rust中地位举足轻重的crate, 它十分强大, 能让cli的制作变得很容易<br>
让我们新建一个叫做 <code>rwc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加clap吧:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rwc&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clap</span> = &#123;version = <span class="string">&quot;*&quot;</span>, features = [<span class="string">&quot;derive&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>在 Clap-rs 的第三个大版本, clap 融合了另外一个很强大的库: structopt, 成为实至名归的第一<br>
因此以后请直接用 clap, 它包含 structopt, structopt 也发过通知, 让别人直接用 clap<br>
而clap最大的变化, 就是这来源于 structopt 的过程宏了, 它允许你用声明的方式定义参数, 然后自动帮你解析, 这就是 <code>derive</code> feature</p>
<p>举个例子, 如果我们想定义 rwc, 那就这样写:</p>
<figure class="highlight rust"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::path::PathBuf;</span><br><span class="line"><span class="keyword">use</span> clap::&#123;AppSettings, ArgGroup, Parser&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Parser)]</span></span><br><span class="line"><span class="meta">#[clap(</span></span><br><span class="line"><span class="meta">    author = <span class="meta-string">&quot;Author: Jedsek &lt;jedsek@qq.com&gt;&quot;</span>,</span></span><br><span class="line"><span class="meta">    version,</span></span><br><span class="line"><span class="meta">    global_setting = AppSettings::DeriveDisplayOrder,</span></span><br><span class="line"><span class="meta">    group(ArgGroup::new(<span class="meta-string">&quot;options&quot;</span>)</span></span><br><span class="line"><span class="meta">      .multiple(true).required(true).args(&amp;[<span class="meta-string">&quot;bytes&quot;</span>, <span class="meta-string">&quot;chars&quot;</span>, <span class="meta-string">&quot;words&quot;</span>, <span class="meta-string">&quot;lines&quot;</span>, <span class="meta-string">&quot;longest-line&quot;</span>]</span>)),</span><br><span class="line">    about = </span><br><span class="line"><span class="string">r#&quot;</span></span><br><span class="line"><span class="string">This is just a simple GNU/wc command implementation, written in Rust</span></span><br><span class="line"><span class="string">It could print &lt;FILE&gt;&#x27;s count of bytes, chars, words, lines, and the longest line/word&#x27;s length</span></span><br><span class="line"><span class="string">&quot;#</span>,</span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cli</span></span> &#123;</span><br><span class="line">    <span class="comment">/// The path(s) you should provide</span></span><br><span class="line">    <span class="meta">#[clap(value_parser, value_name = <span class="meta-string">&quot;FILE&quot;</span>, required = true)]</span></span><br><span class="line">    <span class="keyword">pub</span> paths: <span class="built_in">Vec</span>&lt;PathBuf&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the count of bytes</span></span><br><span class="line">    <span class="meta">#[clap(value_parser, short, long, action)]</span></span><br><span class="line">    <span class="keyword">pub</span> bytes: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the count of chars</span></span><br><span class="line">    <span class="meta">#[clap(value_parser, short, long, action)]</span></span><br><span class="line">    <span class="keyword">pub</span> chars: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the count of words</span></span><br><span class="line">    <span class="meta">#[clap(value_parser, short, long, action)]</span></span><br><span class="line">    <span class="keyword">pub</span> words: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the count of lines</span></span><br><span class="line">    <span class="meta">#[clap(value_parser, short, long, action)]</span></span><br><span class="line">    <span class="keyword">pub</span> lines: <span class="built_in">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Print the length of the longest line</span></span><br><span class="line">    <span class="meta">#[clap(value_parser, short = &#x27;L&#x27;, long, action)]</span></span><br><span class="line">    <span class="keyword">pub</span> longest_line: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  Cli::parse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等下再解释, 现在先让我们看看效果吧, 查看下help:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">cargo run -- -h</span><br></pre></td></tr></table></figure>
<p>上面的 <code>--</code> 表示命令的结尾, 之后的全被视为传递给命令的文件名/参数<br>
若你去掉 <code>--</code>, <code>-h</code> 打印的就是 <code>cargo run</code> 的帮助信息, 而不是 <code>cargo run</code> 之后产生的程序 <code>rwc</code> 的帮助信息了</p>
<p>像 <code>-h/--help</code>, <code>-V/--version</code>, 这两个是 clap 自动为我们生成的, 之外的选项将什么也不会发生, 因为我们暂时未实现<br>
之后生成的help应该如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">rwc <span class="number">0.1</span>.<span class="number">0</span></span><br><span class="line">Author: Jedsek &lt;jedsek@qq.com&gt;</span><br><span class="line"></span><br><span class="line">This is just a simple GNU/wc command implementation, written <span class="keyword">in</span> Rust</span><br><span class="line">It could print &lt;FILE&gt;<span class="symbol">&#x27;s</span> count of bytes, chars, words, lines, and the longest line/word<span class="symbol">&#x27;s</span> length</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">    rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;FILE&gt;...</span><br><span class="line"></span><br><span class="line">ARGS:</span><br><span class="line">    &lt;FILE&gt;...    The path(s) you should provide</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">    -b, --bytes           Print the count of bytes</span><br><span class="line">    -c, --chars           Print the count of chars</span><br><span class="line">    -w, --words           Print the count of words</span><br><span class="line">    -l, --lines           Print the count of lines</span><br><span class="line">    -L, --longest-line    Print the length of the longest line</span><br><span class="line">    -h, --help            Print help information</span><br><span class="line">    -V, --version         Print version information</span><br></pre></td></tr></table></figure>
<p>如果仔细观察一下, 应该就搞懂之前的代码了, 毕竟是声明式的定义, 可以对照着看嘛, 而且 clap 的文档也很好, 可以自己去翻下</p>
<hr>
<h1 id="luo-ji-shi-xian">逻辑实现</h1>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Clap</tag>
        <tag>CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p1: 系列说明</title>
    <url>/posts/haskell-basic/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Haskell 的学习系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>
这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br>
<s>(毕竟是Haskell)</s></p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good! (趣学指南)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.haskell.org/tutorial/">A Gentle Introduction to Haskell, Version 98</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>论坛</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://discourse.haskell.org/">Haskell Discourse</a></p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p>博客</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97">Lambda Calculus (Lambda演算)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors In Pictures (图解函子)</a></p>
</li>
</ul>
<ol start="4">
<li class="lvl-3">
<p>Wiki</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://wiki.haskell.org/">Haskell Wiki</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后,谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p2: 环境搭建</title>
    <url>/posts/haskell-basic/p2.html</url>
    <content><![CDATA[<blockquote>
<p>首先, 我们得搭建好 Haskell 的环境</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<h1 id="bian-yi-qi-amp-amp-bao-guan-li">编译器 &amp;&amp; 包管理</h1>
<p>本文假设你使用的是Linux系统</p>
<p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>
随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ghc</code>: Haskell 的编译器</p>
</li>
<li class="lvl-2">
<p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p>
</li>
<li class="lvl-2">
<p><code>cabal</code>: Hsakell的包管理器</p>
</li>
</ul>
<p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p>
<p>请确保都能正确显示版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ghc -V</span><br><span class="line">ghci -V</span><br><span class="line">cabal -V</span><br></pre></td></tr></table></figure>
<p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p>
<hr>
<h1 id="dai-ma-bian-ji">代码编辑</h1>
<p>推荐的代码编辑器:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Helix (强推)</p>
</li>
<li class="lvl-2">
<p>Nvim/Vim</p>
</li>
<li class="lvl-2">
<p>Emacs</p>
</li>
<li class="lvl-2">
<p>Vscode</p>
</li>
</ul>
<p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>
如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p>
<p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf copr <span class="built_in">enable</span> -y petersen/haskell-language-server</span><br><span class="line">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure>
<p>如果你使用的是 <a href="https://helix-editor.com/">Helix</a>, LSP将会直接启用<br>
当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p>
<hr>
<h1 id="huan-yuan">换源</h1>
<p>Haskell的包都放在 <a href="https://hackage.haskell.org/">hackage</a>, 下载依赖时, 速度可能极慢<br>
这时, 我们应该进行将其换成镜像源</p>
<p>若你使用cabal, 可以按照下面的做:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cabal user-config init</span><br><span class="line">sed -i <span class="string">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/http:\/\/hackage.haskell.org\//http:\/\/mirrors.ustc.edu.cn\/hackage\//g&#x27;</span> ~/.cabal/config</span><br><span class="line">sed -i <span class="string">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class="line">cabal update</span><br></pre></td></tr></table></figure>
<p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p>
<p>至此, 环境准备工作已全部完成<br>
下一节, 我们将正式开始学习 Haskell</p>
<hr>
<h1 id="geng-gai-ghci-ti-shi-fu">更改ghci提示符</h1>
<p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>
但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p>
<p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p>
<p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class="line">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure>
<p>第一行更改提示符<br>
第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p3: 函数式介绍</title>
    <url>/posts/haskell-basic/p3.html</url>
    <content><![CDATA[<blockquote>
<p>何为函数式编程(FP, 即Functional Programming) ?</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>
那么, 开始吧!</p>
<h1 id="bian-cheng-fan-shi">编程范式</h1>
<h2 id="gai-lan" id="概览">概览</h2>
<p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p>
<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>
在世界上, 有许多编程范式, 最主要的有:</p>
<table>
<thead>
<tr>
<th>简称</th>
<th>中文名</th>
<th>英文名</th>
</tr>
</thead>
<tbody>
<tr>
<td>FP</td>
<td>函数式编程</td>
<td>Functional Programming</td>
</tr>
<tr>
<td>OOP</td>
<td>面向对象编程</td>
<td>Object-Oriented Programming</td>
</tr>
<tr>
<td>POP</td>
<td>面向过程编程</td>
<td>Procedure-Oriented Programming</td>
</tr>
<tr>
<td>LP</td>
<td>逻辑式编程</td>
<td>Logic Programming</td>
</tr>
<tr>
<td>DP</td>
<td>声明式编程</td>
<td>Declarative Programming</td>
</tr>
<tr>
<td>IP</td>
<td>命令式编程</td>
<td>Imperative Programming</td>
</tr>
</tbody>
</table>
<p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>
记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p>
<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>
下面是一些编程范式的例子:</p>
<div class="tips">
<p><strong>提示</strong><br>
如果你已经了解过以下范式, 直接跳到 <a href="#zong-jie"><strong>总结</strong></a> 吧</p>
</div>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程:<br>
优点:<br>
解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>
缺点:<br>
代码复用能力差, 扩展性差, 繁琐</p>
</li>
<li class="lvl-2">
<p>面向对象:<br>
优点:<br>
将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>
缺点:<br>
不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p>
</li>
<li class="lvl-2">
<p>逻辑式:<br>
优点:<br>
通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>
缺点:<br>
玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p>
</li>
<li class="lvl-2">
<p>函数式:<br>
优点:<br>
通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>
缺点:<br>
学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p>
</li>
<li class="lvl-2">
<p>命令式:<br>
有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>
我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>
毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>
现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p>
</li>
<li class="lvl-2">
<p>声明式:<br>
指你编程依靠描述, 而非面向过程地去思考<br>
这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>
DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>
特点是一旦脱离相关领域, 语法就不再便利</p>
</li>
</ul>
<h2 id="zong-jie" id="总结">总结</h2>
<p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>
编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p>
<p>比如:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>面向过程/面向对象 &amp;&amp; 命令式</p>
</li>
<li class="lvl-2">
<p>函数式/逻辑式 &amp;&amp; 声明式</p>
</li>
<li class="lvl-2">
<p>混合一种, 两种, 甚至各种范式</p>
</li>
</ul>
<p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>
比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>
再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p>
<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>
接下来, 我们就要专注于本节的主角, 函数式</p>
<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>
让我们开始对函数式的正式介绍吧!</p>
<hr>
<h1 id="gao-jie-han-shu">高阶函数</h1>
<p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p>
<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>
函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>
比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br>
<s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p>
<p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p>
<hr>
<h1 id="bu-ke-bian-shu-ju">不可变数据</h1>
<p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p>
<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>
被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p>
<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>
但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p>
<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>
但不可变的数据能够有效降低并发的难度</p>
<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>
比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p>
<hr>
<h1 id="fu-zuo-yong">副作用</h1>
<p>副作用(Side Effects), 指与外界发生的交互</p>
<p>假设有这么一个函数:<br>
它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>
可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p>
<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>
这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p>
<p>副作用包括, 但不限于:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>发送网络请求</p>
</li>
<li class="lvl-2">
<p>访问系统状态</p>
</li>
<li class="lvl-2">
<p>操作数据库</p>
</li>
<li class="lvl-2">
<p>操作DOM</p>
</li>
<li class="lvl-2">
<p>IO操作</p>
</li>
<li class="lvl-2">
<p>修改函数外部的变量</p>
</li>
<li class="lvl-2">
<p>使用具有副作用的函数 (传播性)</p>
</li>
</ul>
<p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>
比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>
那么这将无法保证相同输入, 能得到相同输出</p>
<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>
绝对的没有副作用, 意味着这个程序绝对的没用</p>
<hr>
<h1 id="yin-yong-tou-ming">引用透明</h1>
<p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p>
<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>
以下是数学中的 RT, 简单来讲, 就是等式推导:</p>
<p>f(x) = (x+1)<sup>2</sup><br>
f(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p>
<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>
某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>
计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p>
<p>总而言之, 就是替换, 替换, 还是替换<br>
即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p>
<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>
若有这么个函数:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">double_x</span>(x: <span class="type">Int</span>): <span class="type">Int</span> &#123;</span><br><span class="line">    println(x);</span><br><span class="line">    return x+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>
此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>
假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p>
<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>
使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>
你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>
这通常是一些 BUG 的来源</p>
<p>RT, 即引用透明, 注定与副作用互斥</p>
<hr>
<h1 id="chun-han-shu">纯函数</h1>
<p>纯函数(Pure Functions), 表示引用透明的函数</p>
<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>
相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p>
<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>
简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p>
<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>
有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>
这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p>
<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p>
<hr>
<h1 id="qi-ta">其他</h1>
<p>以上是对函数式的小小概括<br>
还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p>
<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>埃氏筛求素数:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">primes</span> = filterPrime [<span class="number">2.</span>.]</span><br><span class="line">  <span class="keyword">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>斐波那契数列:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">fibs</span> = <span class="number">0</span> : <span class="number">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>快速排列:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">qsort</span> [] = []</span><br><span class="line"><span class="title">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class="line">  <span class="keyword">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>辗转相除法求最大公约数:</p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">gcd&#x27;</span> x y</span><br><span class="line">  | y == <span class="number">0</span> = x</span><br><span class="line">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure>
<p>感谢你的观看, 咋们下期见!!<br>
先让我鸽几天 😃</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p4: 基础语法</title>
    <url>/posts/haskell-basic/p4.html</url>
    <content><![CDATA[<blockquote>
<p>关于 Haskell 的数字, Bool, List, If语句</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>
你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p>
<h1 id="shu-zi">数字</h1>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span> + <span class="number">8</span>) * <span class="number">9</span> - <span class="number">10</span>   <span class="comment">-- 80</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>              <span class="comment">-- 2.5</span></span><br><span class="line"><span class="number">5</span> ^ <span class="number">2</span>              <span class="comment">-- 25</span></span><br><span class="line"><span class="number">5</span> ^  (<span class="number">2.0</span>)         <span class="comment">-- error</span></span><br><span class="line"><span class="number">5</span> ** (<span class="number">2.0</span>)         <span class="comment">-- 25.0 </span></span><br></pre></td></tr></table></figure>
<p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>
但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>
以上的运算符号, 实际上都是函数</p>
<p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p><code>=&gt;</code> 后面的表示参数与返回值的类型<br>
<code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p>
<p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>
以上的东西, 实际上类似于:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="params">(+)</span>&lt;<span class="title">a</span>: <span class="title">Num</span>&gt; <span class="params">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>
Num 这个类型类了, 便起到一个约束的作用</p>
<p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>
因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p>
<hr>
<h1 id="bool">Bool</h1>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">True</span> &amp;&amp; <span class="type">False</span>      <span class="comment">-- False</span></span><br><span class="line"><span class="type">True</span> || <span class="type">False</span>      <span class="comment">-- True</span></span><br><span class="line"><span class="title">not</span> <span class="type">True</span>           <span class="comment">-- False</span></span><br></pre></td></tr></table></figure>
<p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>
(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">0</span>             <span class="comment">-- False</span></span><br><span class="line"><span class="number">2</span> + <span class="number">3</span> == <span class="number">1</span> + <span class="number">4</span>     <span class="comment">-- True</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span> /= <span class="string">&quot;AB&quot;</span>      <span class="comment">-- True</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>
这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>
可以键入 <code>:t (==)</code> 查看其类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>表示接受的两个参数, 其类型相同, 都是a<br>
并且a类型必须具有相等性, 返回值是Bool类型</p>
<p>注意:<br>
由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>
原因与先前的加法函数同理</p>
<p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>
甚至连 If语句, 我们都可以自己写个函数来代替</p>
<p>If语句在 Haskell 中仅仅是个语法糖而已<br>
在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>
感兴趣的话, 可以自己去看下: <a href="https://wiki.haskell.org/If-then-else">传送门</a></p>
<hr>
<h1 id="list">List</h1>
<p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>
就像是其他语言的数组一样, 但却更加强大</p>
<h2 id="sheng-lue-you-duan" id="省略右端">省略右端</h2>
<p>像下面, 就创建了一个有十个元素的List:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>
a 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p>
<p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>
你可以查看它的类型:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>
<p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>
比如:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">5</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]      <span class="comment">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p>
<p>回到刚才, 你可以一个个地输入元素, 创建List<br>
不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.100</span>]</span><br><span class="line">[<span class="number">1.</span><span class="number">.1000</span>]</span><br></pre></td></tr></table></figure>
<p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>
当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>
从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p>
<p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>
你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p>
<p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>
当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>
不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p>
<p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p>
<p>事实上, 这是 Haskell 中为数不多的隐式行为<br>
任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p>
<p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">a</span> = <span class="number">100</span>::<span class="type">Integer</span>      <span class="comment">-- 100</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>                 <span class="comment">-- 101</span></span><br><span class="line"><span class="title">a</span> + <span class="number">1</span>::<span class="type">Int</span>            <span class="comment">-- error</span></span><br></pre></td></tr></table></figure>
<p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>
对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>
根据 <a href="#shu-zi">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p>
<p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p>
<h2 id="she-zhi-bu-chang" id="设置步长">设置步长</h2>
<p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>
同时, 取决于元素的类型, 会产生无限或有界的List</p>
<p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>
如果你想调整步长的话, 可以像下面这样:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3.</span>.]          <span class="comment">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">10.</span>.]         <span class="comment">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure>
<p>你还可以设置小数的步长, 比如:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.0</span>, <span class="number">1.5</span>..]     <span class="comment">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure>
<p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p>
<h2 id="lie-biao-tui-dao" id="列表推导">列表推导</h2>
<p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>
听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x | x &lt;- [<span class="number">1.</span>.], mod x <span class="number">2</span> == <span class="number">0</span>]  <span class="comment">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure>
<p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>
希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p>
<p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p>
</li>
<li class="lvl-2">
<p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p>
</li>
<li class="lvl-2">
<p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p>
</li>
</ul>
<p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[x + y | x &lt;- [<span class="number">1.</span><span class="number">.3</span>], y &lt;- [<span class="number">1.</span><span class="number">.3</span>]]                   <span class="comment">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class="line">[x | x &lt;- [<span class="number">1.</span><span class="number">.100</span>], x `mod` <span class="number">2</span> == <span class="number">0</span>, x `mod` <span class="number">3</span> == <span class="number">0</span>]  <span class="comment">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure>
<p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>
随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">3</span>]</span><br><span class="line">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>..<span class="number">100</span>]</span><br><span class="line">  <span class="keyword">if</span> x `<span class="keyword">mod</span>` <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x `<span class="keyword">mod</span>` <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure>
<p>因此, 你可以对比下下面两种式子:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[ x * y | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], y &lt;- [<span class="number">1.</span>.x]  ]</span><br><span class="line">[ x * y | x &lt;- [<span class="number">1.</span>.y],  y &lt;- [<span class="number">1.</span><span class="number">.10</span>] ]</span><br></pre></td></tr></table></figure>
<p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p>
<p>好了, 关于List, 暂时先到这吧<br>
其实后面还有很多关于List的, 毕竟它太重要了</p>
<hr>
<h1 id="if-yu-ju">If语句</h1>
<p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>
顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p>
<p>毕竟 Haskell 比较特殊, 为了函数的 <a href="/posts/haskell-basic/p3/#chun-han-shu">纯度</a> , 特意搞了一堆东西<br>
再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p>
<p>开始吧!</p>
<h2 id="dan-if" id="单if">单if</h2>
<p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p>
<p>BMI, Body Mass Index (身体质量指数)<br>
它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p>
<p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p>
<div class="tips">
<p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p>
<ol>
<li class="lvl-3">在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</li>
<li class="lvl-3">输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></li>
</ol>
</div>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>  bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>
程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p>
<p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">    <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>也蛮美观的, 但我更喜欢压行 😃</p>
<h2 id="duo-if" id="多If">多If</h2>
<p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p>
<p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>
而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &gt; <span class="number">25</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt;= <span class="number">18.5</span> </span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;Healthy!!!&quot;</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>哇, 看着好美, 好熟悉!<br>
所以你为什么说没有多重If呢?</p>
<p>别急, 格式化之后:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- demo.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn <span class="string">&quot;Please input your BMI:&quot;</span></span><br><span class="line">  bmi &lt;- readLn</span><br><span class="line">  <span class="keyword">if</span> bmi &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">then</span> putStrLn <span class="string">&quot;What?&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> bmi &gt; <span class="number">25</span></span><br><span class="line">        <span class="keyword">then</span> putStrLn <span class="string">&quot;Fat!!!&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">if</span> bmi &lt;= <span class="number">25</span> &amp;&amp; bmi &lt; <span class="number">18.5</span></span><br><span class="line">            <span class="keyword">then</span> putStrLn <span class="string">&quot;12&quot;</span></span><br><span class="line">            <span class="keyword">else</span> putStrLn <span class="string">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>
<p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>
而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>
就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p>
<p>这节就到这, 看辉夜3的最后一集去了~~</p>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>haskell-basic-p5: 类型与类型类</title>
    <url>/posts/haskell-basic/p5.html</url>
    <content><![CDATA[<blockquote>
<p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/haskell-basic">haskell-basic</a></p>
<h1 id="kai-pian">开篇</h1>
]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-dm-p1: 系列说明</title>
    <url>/posts/rust-decl-macro/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>此系列,我们将学习Rust中的 <code>声明宏</code><br>
请注意, 是声明宏, 过程宏日后再说</p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://zjp-cn.github.io/tlborm/">宏小册</a></p>
</li>
<li class="lvl-2">
<p><a href="https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html">RustPrimer</a></p>
</li>
<li class="lvl-2">
<p><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">TRPL</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>文章</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://zhuanlan.zhihu.com/p/353421021">【译】Rust宏: 教程与示例 (一)</a></p>
</li>
<li class="lvl-2">
<p><a href="https://zhuanlan.zhihu.com/p/356427780">【译】Rust宏: 教程与示例 (二)</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后, 谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-dm-p2: 从println开始</title>
    <url>/posts/rust-decl-macro/p2.html</url>
    <content><![CDATA[<blockquote>
<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="kai-pian">开篇</h1>
<p>大家应该都用过一个宏<br>
它就是<code>println!</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Rush B!!!!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    <span class="built_in">println!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>
为什么后面要跟个感叹号?<br>
为什么括号里面的参数可以不一样?</p>
<p>亲爱的TRPl在教你写 <a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F">Hello World!</a> 的时候<br>
告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>
注: macro 的读音: [ˈmækroʊ]</p>
<p>可是macro到底是啥?<br>
<s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p>
<hr>
<h1 id="cha-kan-ding-yi">查看定义</h1>
<p>让我们按住Ctrl,鼠标左键点击println!<br>
(以 VSCode 为例)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可能会看到, 在 println! 的上面</span></span><br><span class="line"><span class="comment">// 有着类似下面的玩意:  </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// #[macro_export]</span></span><br><span class="line"><span class="comment">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class="line"><span class="comment">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class="line"><span class="comment">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>
<p>你悲催地发现根本看不懂这一大堆鬼画符…<br>
但看不懂根本没关系,后面几节过后,你肯定懂了<br>
现在只需明白的,是大致结构:</p>
<ol>
<li class="lvl-3">
<p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏<br>
(<code>macro_rules!</code>当作特定语法即可)</p>
</li>
<li class="lvl-3">
<p>之后用花括号包起来,里面是该宏的具体定义</p>
</li>
</ol>
<p>问题来了,关键是<code>println</code>的具体定义<br>
花括号内,到底在讲述着啥?</p>
<p>请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&quot;1&quot;</span>.repeat(<span class="number">10</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;2&quot;</span>.repeat(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// macro</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>macro有点像是match,能根据不同参数,展开不同的代码<br>
在macro最外层的花括号中,有许多匹配分支</p>
<p>match表达式,称呼每个匹配分支为<code>arm</code><br>
逗号分割它们彼此,或者不用逗号而用花括号包裹来分割<br>
最后一个arm可省略逗号</p>
<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)<br>
必须使用花括号包裹,使用分号分隔彼此<br>
最后一个rule可省略分号</p>
<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>
现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义部分</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    <span class="comment">// 空参时, 只输出换行符</span></span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参时, 输出参数, 并换行</span></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用部分</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"><span class="built_in">println!</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="zong-jie">总结</h1>
<ol>
<li class="lvl-3">
<p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>然后创建两个匹配分支:<br>
(匹配空参 =&gt; 不做任何事)<br>
(匹配123 =&gt; 打印123)</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>调用时, 要做到: 宏名+感叹号+传参:<br>
(传入的参数,若与任何rule都不匹配,则报错)</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    xxx!();      <span class="comment">// Nothing</span></span><br><span class="line">    xxx!(<span class="number">123</span>);   <span class="comment">// println!(&quot;123&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>
相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>
咱们下期见</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-dm-p3: 声明与使用</title>
    <url>/posts/rust-decl-macro/p3.html</url>
    <content><![CDATA[<blockquote>
<p>正式系统的关于 macro 的 声明与使用</p>
</blockquote>
<span id="more"></span>  
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="kuang-jia-jian-li">框架建立</h1>
<p>前一节,我们大概清楚了macro的结构<br>
现在让我们再来简单复习一遍:</p>
<ol>
<li class="lvl-3">
<p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p>
</li>
<li class="lvl-3">
<p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p>
</li>
<li class="lvl-3">
<p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p>
</li>
</ol>
<p>现在稍微深入一点:<br>
一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber)<br>
它由三个重要的部分组成:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>matcher (匹配器)</code>:<br>
用来匹配传入的参数</p>
</li>
<li class="lvl-2">
<p><code>metavariable/literal (元变量/字面量)</code>:<br>
绑定传入的代码片段,出现于 <code>matcher</code></p>
</li>
<li class="lvl-2">
<p><code>transcriber (转录器)</code>:<br>
用来在宏匹配成功后,进行代码替换</p>
</li>
</ul>
<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>
因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    (<span class="comment">/* 空参匹配 */</span>) =&gt; (<span class="comment">/* `换行` 的代码 */</span>);</span><br><span class="line">    (<span class="comment">/* 有参匹配 */</span>) =&gt; (<span class="comment">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code><br>
从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配<br>
匹配时, 括号具有多样性, 请看下面</p>
<ol>
<li class="lvl-3">
<p>匹配规则:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>匹配到: 就替换为<code>transcriber</code>里面的代码</p>
</li>
<li class="lvl-2">
<p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>括号多样性:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p>
</li>
<li class="lvl-2">
<p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p>
</li>
<li class="lvl-2">
<p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>
</li>
</ul>
<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>
在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p>
<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p>
<hr>
<h1 id="liang-chong-hong-can-shu">两种宏参数</h1>
<p>是时候引入一些新的东西了, 顺便加深下你的印象</p>
<h2 id="yuan-bian-liang" id="元变量">元变量</h2>
<p>元变量, 即Metavariable<br>
让我们来看个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class="line">        $a + $b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    my_macro!(<span class="number">1</span>);</span><br><span class="line">    my_macro!(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    1;</span></span><br><span class="line"><span class="comment">    1 + 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>
比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p>
<ol>
<li class="lvl-3">
<p><code>$</code> 这个前缀是干嘛的?<br>
这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>
至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗?<br>
下面就要讲到啦, 别着急~</p>
</li>
<li class="lvl-3">
<p>先看看 <code>expr</code> 类型:<br>
<code>expr</code>, 全称为 <code>expression(表达式)</code><br>
第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>
这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>
(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)</p>
</li>
</ol>
<p>简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>
macro就像个code generator: 一段用来生成code的code</p>
<p>注意:<br>
macro实际上, 是将传入部分解析为一个AST节点<br>
然后将调用部分, 替换为一个新的AST节点<br>
在本节下面, 会更详细地讲讲</p>
<h2 id="yuan-zi-mian-liang" id="元字面量">元字面量</h2>
<p>元字面量, 即Metaliteral<br>
为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">($a: expr) =&gt; &#123;$a&#125;;                     <span class="comment">// the first rule</span></span><br><span class="line">  |             |  </span><br><span class="line">  |         	|</span><br><span class="line">( <span class="number">1</span>      )      <span class="number">1</span>                       <span class="comment">// pass &amp;&amp; expand </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class="comment">// the second rule</span></span><br><span class="line">  |      |  |              |    |</span><br><span class="line">  |      |  |              |    |</span><br><span class="line">( <span class="number">1</span>      ,  <span class="number">2</span>      ) =&gt;    <span class="number">1</span> +  <span class="number">2</span>      <span class="comment">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>
<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>
你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p>
<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>
这种固定的参数, 如同token中的字面量一样<br>
我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>
(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p>
<p>假若 rule 中的参数没有 $前缀 进行区分:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> fuck &#123;</span><br><span class="line">    (a:expr) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    fuck!(<span class="number">1</span>);       <span class="comment">// No</span></span><br><span class="line">    fuck!(a:expr);  <span class="comment">// Yes ~~(Oh~)~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>)<br>
传入固定形式的 “a:expr” 时才可发生匹配</p>
<p>切记:<br>
当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰</p>
<h2 id="li-zi" id="例子">例子</h2>
<p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>
它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>
如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map![</span><br><span class="line">        <span class="string">&quot;吉良吉影&quot;</span> =&gt; <span class="number">33</span>,</span><br><span class="line">        <span class="string">&quot;空条承太郎&quot;</span> =&gt; <span class="number">41</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来写一个这样的宏吧!<br>
不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>
来看看两种宏参数在宏中, 发挥着怎样的作用:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Metavariable</code>: 将捕获的传入的代码片段绑定到自身<br>
并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p>
</li>
<li class="lvl-2">
<p><code>Metaliteral </code>: 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>
(这里只有一个rule, 空匹配的懒得放里面了)</p>
</li>
</ul>
<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>
考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>
之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>
(博客的话, 我周六放学回来慢慢更吧…)<br>
<s>(潜台词是随时会鸽子)</s></p>
<hr>
<h1 id="ben-zhi">本质</h1>
<p>macro的本质, 是生成一个AST节点可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p>
<p>假若由你来设计一个Rust编译器<br>
首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?</p>
<p>若我们将每遍扫描并做点事情的过程, 称为<code>pass</code><br>
pass一次就生成了, 对于很大的源码来说, 这不现实吧</p>
<p>那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题<br>
每一次pass都解决一个小问题, 那不就Ok了吗</p>
<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p>
<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)<br>
那是一种代码被抽象后的树状结构<br>
比如我们用Rust的enum表示一下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASTNode</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>), </span><br><span class="line">    BinaryExpr &#123;</span><br><span class="line">        op: Op,</span><br><span class="line">        lhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">        rhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Op</span></span> &#123;</span><br><span class="line">    Plus, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你只需明白AST是对源码封装的一层抽象产物就可以了</p>
<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小<br>
但是, 如果源码很大呢? AST已经很复杂了那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p>
<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的<br>
注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛</p>
<p><code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架<br>
而另外的IR, 也是有必要的, 这也增强了可维护性<br>
编译器在AST的基础上, 最终生成了目标码</p>
<p>问: 生成AST需要点啥? 或者说, 它由什么组成?<br>
答: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p>
<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>
它将token们联系起来, 表达了代码的骨架<br>
这个庞然大物便是 AST 了</p>
<hr>
<h1 id="hui-dao-macro">回到Macro</h1>
<h2 id="token-lei-xing-biao" id="Token类型表">Token类型表</h2>
<p>生成AST需要Token协助<br>
macro 中, 其参数的类型, 便是token类型</p>
<p>macro要操控传入的token (或AST节点, 等会讲)<br>
那么我们总得知道token类型吧, 不然怎知咋操控?</p>
<p>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p>
<p>所以, 辛苦你将下面的记一下<br>
稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>对应</th>
</tr>
</thead>
<tbody>
<tr>
<td>ident</td>
<td>标识符, 如函数名, 变量名, 关键字</td>
</tr>
<tr>
<td>expr</td>
<td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td>
</tr>
<tr>
<td>literal</td>
<td>literal expression, 即字面量表达式, 是expr的子集</td>
</tr>
<tr>
<td>pat</td>
<td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td>
</tr>
<tr>
<td>path</td>
<td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td>
</tr>
<tr>
<td>ty</td>
<td>type, 如 i32, u32, String, Option<T>等</td>
</tr>
<tr>
<td>tt</td>
<td>token tree, 之后我会单独再讲解下它的</td>
</tr>
<tr>
<td>meta</td>
<td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td>
</tr>
<tr>
<td>vis</td>
<td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td>
</tr>
<tr>
<td>lifetime</td>
<td>生命周期</td>
</tr>
<tr>
<td>item</td>
<td>条目/项, 例如函数定义</td>
</tr>
<tr>
<td>block</td>
<td>代码块</td>
</tr>
<tr>
<td>stmt</td>
<td>statemen, 语句</td>
</tr>
</tbody>
</table>
<h2 id="tt" id="TT">TT</h2>
<p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>
从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p>
<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>
作为 Token Tree 的根节点, 先让我们来点例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a:tt) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>($a));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Single Token</span></span><br><span class="line">    aa!(<span class="number">123</span>);          <span class="comment">// Yes: 123</span></span><br><span class="line">    aa!(FuckYou);      <span class="comment">// Yes: FuckYou</span></span><br><span class="line">    <span class="comment">// aa!(Fuck You);     // No</span></span><br><span class="line">    <span class="comment">// aa!(123 + 11);     // No</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (), [], &#123;&#125;</span></span><br><span class="line">    aa!([<span class="number">123</span>]);        <span class="comment">// Yes: [123]</span></span><br><span class="line">    aa!(&#123;<span class="number">123</span> + <span class="number">123</span>&#125;);  <span class="comment">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>
请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的眼中:</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + (<span class="number">3</span> + <span class="number">4</span>)</span><br><span class="line"><span class="comment">// tt的眼中:</span></span><br><span class="line">&lt;&lt;<span class="number">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class="number">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">                   &lt;&lt;<span class="number">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class="number">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码的Token Tree共有5个:</p>
<ol>
<li class="lvl-3">
<p>&lt;&lt;1&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;+&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;2&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;+&gt;&gt;</p>
</li>
<li class="lvl-3">
<p>&lt;&lt;(3 + 4)&gt;&gt;</p>
</li>
</ol>
<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>
对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p>
<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p>
<h2 id="ast-jie-dian" id="AST节点">AST节点</h2>
<p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>
比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们通过使用 macro , 站在了更抽象的视角上<br>
操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)</p>
<p>这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p>
<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果<br>
我直接用 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a> 上面的代码了:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class="line">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> match_tokens &#123;</span><br><span class="line">    ($a:tt + $b:tt) =&gt; &#123;<span class="string">&quot;got an addition&quot;</span>&#125;;</span><br><span class="line">    (($i:ident)) =&gt; &#123;<span class="string">&quot;got an identifier&quot;</span>&#125;;</span><br><span class="line">    ($($other:tt)*) =&gt; &#123;<span class="string">&quot;got something else&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;\n&quot;</span>,</span><br><span class="line">        match_tokens!((caravan)),</span><br><span class="line">        match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;&quot;</span>,</span><br><span class="line">        capture_then_match_tokens!((caravan)),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果会是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">got an identifier</span><br><span class="line">got an addition</span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点<br>
它不再是token, 而是个AST节点了!</p>
<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>
但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br>
<code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p>
<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p>
<p>总结:<br>
宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>
这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏<br>
(只要宏展开的AST节点正确即可 😄)</p>
<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>
最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言: 简单的文本替换</span></span><br><span class="line">#define SUM(a,b) a+b</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    SUM(<span class="number">2</span>, <span class="number">2</span>);     <span class="comment">// 2 * 2</span></span><br><span class="line">    <span class="number">5</span> * SUM(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 5 * 2 + 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    sum!(<span class="number">2</span>,<span class="number">2</span>);     <span class="comment">// 2 + 2</span></span><br><span class="line">    <span class="number">5</span> * sum!(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 5 * (2 + 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pi-pei-zhu-yi-dian" id="匹配注意点">匹配注意点</h2>
<p>在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制<br>
即下面要讲的东西, 有时间的也可以去看看 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a></p>
<h3 id="pi-pei-wu-qu" id="匹配误区">匹配误区</h3>
<p>来看看下面一段代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class="line">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    aa!(a);   <span class="comment">// Yes</span></span><br><span class="line">    aa!(a+);  <span class="comment">// No</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配<br>
但是实际上会报这么一个错误:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">expected expression, found end of <span class="keyword">macro</span> arguments</span><br><span class="line"><span class="comment">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>
<p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p>
<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>
而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p>
<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p>
<h3 id="qi-yi-xian-zhi" id="歧义限制">歧义限制</h3>
<p>由于一些歧义, 为了向后兼容性与不破坏代码<br>
当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Rust-Reference: 限制</a><br>
这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br>
<s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)</s><br>
<s>(因为我也没有全部搞懂)</s></p>
<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p>
<p>那么, 今天就到这了, 谢谢您的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-dm-p4: 重复</title>
    <url>/posts/rust-decl-macro/p4.html</url>
    <content><![CDATA[<blockquote>
<p>宏中非常重要的语法: 重复(repetition)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="jie-shao">介绍</h1>
<p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p>
<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p>
</li>
<li class="lvl-2">
<p>Transcriber: 将一段指定的模式, 重复地展开</p>
</li>
</ul>
<p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p>
<p>假设你要设计一个宏, 进行求和(参数个数不确定):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="built_in">assert_eq!</span>( <span class="number">0</span>,  sum!() );</span><br><span class="line"><span class="built_in">assert_eq!</span>( <span class="number">15</span>, sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) );</span><br></pre></td></tr></table></figure>
<p>让我们来看看, 如何使用重复吧</p>
<h1 id="yu-fa">语法</h1>
<p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> sum &#123;</span><br><span class="line">    ($($a:expr),*) =&gt; &#123;</span><br><span class="line">        <span class="number">0</span> $(+ $a)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    sum!();          <span class="comment">// 0</span></span><br><span class="line">    sum!(<span class="number">5</span>);         <span class="comment">// 5</span></span><br><span class="line">    sum!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伪代码表示:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$( Pattern )   Sep    RepOp</span><br><span class="line">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>
<p>它可以被分为三个部分:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模式(Pattern):<br>
被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p>
</li>
<li class="lvl-2">
<p>分隔符(Separator):<br>
用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p>
</li>
<li class="lvl-2">
<p>重复符号(Repetition Operator):<br>
对模式匹配次数, 进行说明限制, 不符合就编译报错</p>
</li>
</ul>
<p>以 <code>sum!</code> 为例子<br>
它在第二个rule中用到了重复:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>In Matcher:<br>
模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>
分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>
次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p>
</li>
<li class="lvl-2">
<p>In Transcriber:<br>
模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>
分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>
次数:	 同 Matcher</p>
</li>
</ul>
<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p>
<p>RepOp 有三种可选项, 有点像正则:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>
记忆法-&gt; 该符号看上去像是一个点, 联想为0</p>
</li>
<li class="lvl-2">
<p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>
记忆法-&gt; 联想为正数, 那就&gt;=1</p>
</li>
<li class="lvl-2">
<p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>
记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p>
</li>
</ul>
<p>有一些注意点:</p>
<ol>
<li class="lvl-3">
<p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p>
</li>
<li class="lvl-3">
<p>Sep 是有限制的, <a href="/posts/rust-decl-macro/p3#qi-yi-xian-zhi">p3#歧义限制</a> 提到过, 详情可见 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">rust-reference</a></p>
</li>
</ol>
<p>以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-dm-p5: 卫生性</title>
    <url>/posts/rust-decl-macro/p5.html</url>
    <content><![CDATA[<blockquote>
<p>本节将介绍宏的 卫生性(hygienic)</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="/categories/rust-decl-macro">博客: rust-decl-macro</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频: Rust编程语言-声明宏</a></p>
</li>
</ul>
<h1 id="kai-pian">开篇</h1>
<p>什么是 卫生性(Hygienic) 呢?<br>
简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>
如果你是第一次接触此概念, 我不信你不会懵逼<br>
不过实际上, 这个概念理解起来不算困难</p>
<p>让我们先来讨论一个问题, 请看下面的代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> create_var &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    create_var!();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Macro</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p1: 系列说明</title>
    <url>/posts/rust-async/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 异步(async) 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>
当然也会介绍异步方面的相关概念咯</p>
<hr>
<h1 id="zi-liao-lai-yuan">资料来源</h1>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://rust-lang.github.io/async-book/**">async-book</a></p>
</li>
<li class="lvl-2">
<p><a href="https://book.async.rs/overview/async-std">async_std/tutorials</a></p>
</li>
<li class="lvl-2">
<p><a href="https://tokio.rs/tokio/tutorial">tokio/tutorials</a></p>
</li>
<li class="lvl-2">
<p><a href="https://cfsamson.github.io/books-futures-explained/">Futures Explained in 200 Lines of Rust</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>博客</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://without.boats/blog/">Withoutboats’s blogs</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后,谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p2: 异步简介</title>
    <url>/posts/rust-async/p2.html</url>
    <content><![CDATA[<blockquote>
<p>来简单介绍一下异步吧</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="kai-pian">开篇</h1>
<p><strong>异步编程</strong> (Asynchronous programming)<br>
是一种<strong>并发编程模型</strong></p>
<p>特点是通过少量<code>OS_thread(系统线程)</code><br>
即可运行大量<code>并发任务</code><br>
在某些场景下,可以疯狂压榨cpu的性能<br>
<s>(好吧,有点废话…)</s></p>
<hr>
<h1 id="mo-xing-dui-bi">模型对比</h1>
<p>为何选择异步,它的优势有哪些?</p>
<p>对于这个问题,我们将对比<strong>异步</strong>与其他<strong>并发模型</strong><br>
以此来告诉大家,为什么选择异步:</p>
<p>1.<code>OS Thread (系统线程)</code><br>
由操作系统提供线程,进行并发,如std::thread<br>
Good_1:<br>
简单易使用,建模能力强,足够传统<br>
Good_2:<br>
操作系统就是运行时,与C语言交互方便<br>
Bad_1:<br>
数据同步困难,易发生数据竞争<br>
Bad_2:<br>
小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低</p>
<p>2.<code>Green Thread (绿色线程)</code><br>
它几乎与系统线程一样,不过<code>Runtime(运行时,jvm/.net听说过吗?)</code>从操作系统变为了程序本身<br>
绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程<br>
Good:<br>
这意味着,程序本身对绿色线程有绝对的管理权<br>
所以内存分配等方面的粒度更细,根据任务大小调度内存<br>
因此堆栈大小,能够随时间推移而增长<br>
并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务<br>
Bad_1:<br>
它是程序本身实现模拟出来的线程,Runtime较巨大<br>
运行时会一直存在,即使你不用该特性,导致拖累全局程序性能<br>
并且难以与C库交互<br>
这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象<br>
它无法在语言层面被Rust支持<br>
Bad_2:<br>
绿色线程在不同平台上,其实现可能不同<br>
对多平台的支持/维护/改进得靠实现者保证</p>
<p><code>OS Thread</code>与<code>Green Thread</code>与Rust关系比较大:<br>
一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的</p>
<hr>
<h1 id="yi-bu">异步</h1>
<p>我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !<br>
<s>(没把你憋坏吧伙计?)</s></p>
<p>我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一<br>
假设我们正在单线程下,读取文件,并进行一个计算:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件, 获取数据 </span></span><br><span class="line"><span class="keyword">let</span> data = read(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行一个计算</span></span><br><span class="line">compute()</span><br></pre></td></tr></table></figure>
<p>以上面代码为例子,我们会读取 <code>file</code> 获取 <code>data</code><br>
期间,我们的程序,做不了任何其他事情<br>
只有等待<code>IO操作(Input/Output, 输入/输出)</code>完毕,我们才能进行接下来的 <code>compute</code></p>
<p><code>读取文件</code>,属于<code>IO操作</code><br>
众所周知,IO操作很耗时,等待它完成的时间可能会很长</p>
<p>有没有什么办法加快速度?<br>
没错,系统线程yyds:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class="line"><span class="keyword">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class="line"><span class="keyword">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class="line"><span class="keyword">let</span> data = handle_a.join().unwrap();</span><br><span class="line">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>
<p>因为两个任务<code>read</code>与<code>compute</code>是独立的,无依赖性<br>
所以我们<code>spawn</code>了两个线程<br>
第一个: 用于读取文件,获取数据第二个: 用于在读取文件的同时,执行着 <code>compute</code><br>
虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销<br>
而异步,就是只依靠单线程,也能够完成上面的操作</p>
<p>单线程中的异步(伪)代码如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件, 获取数据 </span></span><br><span class="line"><span class="keyword">let</span> data = read_async(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行一个计算</span></span><br><span class="line">compute_async()</span><br></pre></td></tr></table></figure>
<p>你会注意到:<br>
<code>read</code> -&gt; <code>read_async</code><br>
<code>compute</code> -&gt; <code>compute_async</code></p>
<p>我用伪代码表示,这两个操作变成了异步操作<br>
你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念<br>
如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>read</code>:<br>
它会阻塞调用线程,等待该操作完毕后<br>
才继续往下执行<code>compute</code></p>
</li>
</ul>
<p>阻塞期间是几乎不需要cpu参与运行的<br>
程序此时傻乎乎地等待阻塞结束<br>
无疑是对性能的浪费,对cpu的不尊重</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>read_async</code>:<br>
它处于阻塞时,会运行<code>compute_async</code><br>
线程由<code>read_async</code>接管变为由<code>compute_async</code>接管<br>
当阻塞时间结束,则程序继续变为运行<code>read_async</code></p>
</li>
</ul>
<p><code>read_async</code>阻塞时,程序是不会傻傻等待的:</p>
<p>若检测到它处于阻塞,无法取得进展<br>
则会运行其他异步任务,由其他异步任务接管线程</p>
<p>总而言之,异步操作,其实就是:<br>
若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>
使得cpu一直处于运算,性能被极限压榨</p>
<p>异步操作,就像是可以随意<code>start/stop</code>一般<br>
调度程序能够对它们进行调度,决定当前要运算哪个操作<br>
确保不会因为阻塞而傻傻等待</p>
<p>只需单线程,就可以做到同时运行多个 <code>Task(异步任务)</code><br>
异步当然也不排斥多线程:<br>
一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?</p>
<hr>
<h1 id="wei-sheng">尾声</h1>
<p>Q:<br>
阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>
A:<br>
现代电脑发展出了一些分担IO操作压力的高科技<br>
所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>
只需要最后接收数据时, 出个场就行了</p>
<p>所以我们的程序不需要在等待输入输出时就那样等着<br>
给它们找事情, 让它们闲不下来吧!</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p3: Future</title>
    <url>/posts/rust-async/p3.html</url>
    <content><![CDATA[<blockquote>
<p>Rust 中的 Future/async/.await 说明</p>
</blockquote>
<span id="more"></span>  
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="kai-pian">开篇</h1>
<p>大家好! 我们上一节已经知晓异步的基础概念<br>
现在,来看看Rust中的异步语法吧</p>
<p>在本节,我们会知晓以下三个概念的大致含义:<br>
(暂时不涉及背后原理,原理之后专门出好几节来讲)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Future (trait)</p>
</li>
<li class="lvl-2">
<p>async (keyword)</p>
</li>
<li class="lvl-2">
<p>.await (keyword)</p>
</li>
</ul>
<p>开始旅途吧</p>
<hr>
<h1 id="future">Future</h1>
<h2 id="gai-nian" id="概念">概念</h2>
<p><code>Future</code>,一个标准/核心库中的trait<br>
其完整路径为<code>std/core::future::Future</code></p>
<p>此节我只会讲它的大致含义,原理则放到后面几节专门来讲 <s>(原理太难, 一节根本不够)</s></p>
<p>在Rust中,一个实现了Future(trait)的类型<br>
该类型的实例(有时候直接被简称为 <code>一个Future实例</code>)便代表 <code>一次异步计算</code><br>
可以将其交给<code>Runtime(运行时)</code>,从而异步执行</p>
<p><code>异步执行</code>, 也就是指:<br>
当其他异步任务阻塞时,当前异步任务有机会执行<br>
或当前异步任务阻塞时,其他异步任务有机会执行<br>
总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>
<p><strong>注意两个名词的区别:</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>异步 计算</code></p>
</li>
<li class="lvl-2">
<p><code>异步 任务</code></p>
</li>
</ul>
<p>两者有着区别,举个例子你就明白了:</p>
<p>假设有这么个父计算, 由两个子计算组成:</p>
<ol>
<li class="lvl-3">
<p>Open: 先异步打开一个文件(async open)</p>
</li>
<li class="lvl-3">
<p>Read: 再异步读取该文件(async read)</p>
</li>
</ol>
<p>我们可以看出,一次计算, 是可以由多个子计算组成的<br>
同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期<br>
因为<code>子计算们可能存在依赖关系</code> (在这里的例子中也确实存在)</p>
<p>因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算<br>
(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p>
<p><code>当前Task</code>阻塞时,接管执行权的,不能是当前Task中的<code>其他子计算</code><br>
只能是<code>其他Task中的子计算</code></p>
<p>来点总结吧:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Task是一个顶层Future实例 (即一次顶层异步计算)</p>
</li>
<li class="lvl-2">
<p>一个Future可以由多个Future组成,即一个Future里可以执行多个Future</p>
</li>
<li class="lvl-2">
<p>Task_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算</p>
</li>
<li class="lvl-2">
<p>Task可以只是一次单独计算</p>
</li>
</ul>
<p><code>一个Future (一次异步计算)</code><br>
可理解为,是组成<code>一个Task (一个异步任务)</code>的最小单位</p>
<p>了解到了那么一点点后,现在来正式看看呗 ?</p>
<h2 id="ding-yi" id="定义">定义</h2>
<p>让我们来看看它的定义:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简单了解一下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Future:<br>
代表一次异步计算</p>
</li>
<li class="lvl-2">
<p>Output:<br>
代表该Future,异步执行完毕后,产出的值的类型</p>
</li>
<li class="lvl-2">
<p>poll:<br>
所有执行操作都会放在该函数中<br>
Runtime 会不断调用<code>poll函数</code>来推进<code>该异步计算</code>的完成<br>
每次poll的返回值是一个枚举变体,代表是否完成</p>
</li>
<li class="lvl-2">
<p>Poll<T>:<br>
枚举类型,作为poll函数的返回值类型,其变体有:<br>
<code>Poll::Pending</code>:<br>
指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)<br>
<code>Poll::Ready(T)</code>:<br>
指明该计算执行完毕,并产出一个类型为T的值</p>
</li>
</ul>
<p>若只是普通使用者,并不需了解<code>Future的定义</code>背后之原理<br>
但若不了解它,又如何为某类型实现 Future 呢?</p>
<p>别急,Rust为我们提供了关键字<code>async</code>,接着往下看吧</p>
<hr>
<h1 id="async">Async</h1>
<p><code>async</code>: 一个关键字<br>
用来创建<code>一个匿名结构体的实例, 该结构体实现了Future</code><br>
即,它用来创建一个 <code>Future实例</code></p>
<p>来个例子,看看async的好处:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HelloStr</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> HelloStr &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">String</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, _cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>);</span><br><span class="line">        Poll::Ready(<span class="built_in">str</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以观察到,使用 async 进行了符合直觉的简化<br>
这两种函数,实际上是等价的</p>
<p>看看它们两的返回值,如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello_str_1() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr <span class="comment">// Future&lt;Output = String&gt; 的实例</span></span><br><span class="line">&#125;</span><br><span class="line">hello_str_2() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>
<p>注意,异步函数的调用,只是返回一个 Future实例<br>
<strong>但并没有开始执行, 它是惰性的</strong><br>
<strong>只有调用Future的poll方法, 才能推动它的执行</strong><br>
<strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong></p>
<p>这样的好处就在于:<br>
将一个异步计算看作一个变量,方便了传参等工作</p>
<p>比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可</p>
<p>async的作用就是创建一个Future实例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>async fn</code>: 异步函数, 要求返回一个 Future实例</p>
</li>
<li class="lvl-2">
<p><code>async block</code>: 异步代码块, 创建一个 Future实例</p>
</li>
<li class="lvl-2">
<p><code>async closure</code>: 异步闭包, (目前是不稳定特性) 创建一个 Future实例</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1_i32</span>;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `async block` 也可以使用move  </span></span><br><span class="line"><span class="comment">// 获得其中使用的变量的所有权  </span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    &amp;s </span><br><span class="line">&#125;</span><br><span class="line">s; <span class="comment">// Error: use of moved value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>
<p>创建一个Future实例, 想必大家已经了解一二<br>
但是如何执行一个Future实例?</p>
<p>请接着往下看</p>
<hr>
<h1 id="zhi-xing">执行</h1>
<h2 id="bei-jing-jie-shao" id="背景介绍">背景介绍</h2>
<p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>
异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序</p>
<p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>
注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future)</p>
<p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>
再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>
在嵌入式环境下, 也能够轻松运行异步程序</p>
<p>在正式开始之前请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123; version = <span class="string">&quot;1.9&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>
我们指定了版本, 并且启用了 <code>attributes</code> 这个特性</p>
<h2 id="runtime-zhi-xing" id="Runtime执行">Runtime执行</h2>
<p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>
并且使用 <code>async-std</code> 这个异步运行时环境来执行它:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello wrold!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们在本节开始不久,就提到过的<code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>
async_std::task,该模块,为我们提供了大量api,来执行/操控 这些 <code>Task</code></p>
<p>比如这里出现的<code>task::block_on</code>:<br>
传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程<br>
该任务执行完毕后产出的值,会作为<code>block_on</code>的返回值</p>
<p>我们执行了一个Task,并且这个Task是单个的Future<br>
但若我们想执行由多个子Future所组成的Task,又该怎么办?</p>
<p><code>.await</code> 关键字出场了!</p>
<hr>
<h1 id="await">Await</h1>
<p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>
在某个Future实例的后面,增加<code>.await</code>,那么<code>该Future实例</code>则会执行<br>
但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)<br>
真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future</p>
<p>来看看它的使用:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">world</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    hello().<span class="keyword">await</span>;</span><br><span class="line">    world().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>.await</code>是一个标记点,可以理解为是一个<code>yield point</code><br>
Runtime执行到<code>xxx.await</code>时,先会执行一次<code>xxx</code></p>
<p>一开始,会调用一次poll函数,推动执行进度<br>
通过它的返回值,<code>Poll&lt;T&gt;枚举的变体</code>,即<code>Pending</code>或<code>Ready(T)</code><br>
来决定:</p>
<ol>
<li class="lvl-3">
<p>让其他Task接管执行权(yield)</p>
</li>
<li class="lvl-3">
<p>该Future执行完毕,继续执行当前Task</p>
</li>
</ol>
<p>若为<code>Ready</code>: 则选 <code>2</code>,继续往下执行(一个Task可能是由多个Future所组成)<br>
若为<code>Pending</code>: 则选 <code>1</code>,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)</p>
<p>稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:</p>
<p><code>.await</code>会指明<code>执行某个Future</code> 这一逻辑<br>
当<code>xxx.await</code>所在的Task交给Runtime执行,并执行到<code>xxx.await</code> 时<br>
<code>xxx</code> 这个Future实例会执行</p>
<p>若它阻塞(这意味着该Future所在的Task也阻塞)<br>
所以调度程序安排其他Task,在该空档期执行<br>
若不阻塞,就继续往下执行(可能还有碰见<code>.await</code>哟), 直到该Task结束</p>
<hr>
<h1 id="bu-chong">补充</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>#[async_std::main]</code><br>
这玩意无比常见,是个属性宏,要加在main函数头上<br>
使得main前面能被async所修饰<br>
程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    hello_world().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    async_std::task::block_on( <span class="keyword">async</span> &#123;</span><br><span class="line">        hello_world().<span class="keyword">await</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>async_std::task::spawn</code><br>
因为这玩意也很常见,所以就讲一讲:<br>
向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例它实现了Future,与标准库中的<code>JoinHandle</code>无比相似<br>
不过那个运行Thread,而这个运行Task,<code>join</code>相应地变成<code>.await</code><br>
想让该handle代表的Task运行完毕,应该在该handle前放上<code>.await</code>,如下:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> handle = task::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> two:<span class="built_in">i32</span> = handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-async-p4: 状态的保存与变换</title>
    <url>/posts/rust-async/p4.html</url>
    <content><![CDATA[<blockquote>
<p>浅显的原理第一篇: 状态的保存/变换</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-async">rust-async</a></p>
<h1 id="kai-pian">开篇</h1>
<p><strong>注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看</strong><br>
为了更好地理解<code>Rust异步</code>背后的原理,我们先来了解下一些概念<br>
当然,不用太深入,只是小补充而已:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>抢占式/协作式多任务</code></p>
</li>
<li class="lvl-2">
<p><code>状态机</code></p>
</li>
<li class="lvl-2">
<p><code>自引用结构体</code></p>
</li>
</ul>
<p>现在,让我们开始吧!</p>
<hr>
<h1 id="liang-chong-duo-ren-wu">两种多任务</h1>
<h2 id="jie-shao" id="介绍">介绍</h2>
<p><code>抢占式多任务</code>与<code>协作式多任务</code>,都属于<code>多任务</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抢占式多任务:<br>
操作系统决定CPU的运行权<br>
比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会<br>
各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种<code>任务们同时运行</code>的感觉<br>
这是强迫/抢占的</p>
</li>
<li class="lvl-2">
<p>协作式多任务:<br>
任务们本身进行协调,决定CPU的运行权<br>
比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending<br>
自己放弃继续执行,并通知运行时执行其他Task<br>
这是自愿/协作的,Task们<code>自愿放弃CPU的执行权</code><br>
(上文中的<code>任务</code>与<code>Task</code>请区分一下,前者比后者广泛,后者在这用于Rust的举例)</p>
</li>
</ul>
<h2 id="zhuang-tai-de-hui-fu-bao-cun" id="状态的恢复-保存">状态的恢复/保存</h2>
<p>既然任务们能互相切换执行,那么,当再次轮到某任务执行时<br>
该任务,应当从先前暂停的地方开始,继续执行<br>
因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是<code>状态保存</code></p>
<p>对于<code>抢占式</code>与<code>协作式</code>,处理<code>状态保存</code>的思路是不一样的:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>抢占式:<br>
因为是强迫切换执行的,任务会在任意某个时刻被中断<br>
任务此时运行到了哪里?我们不知道啊!<br>
那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)</p>
</li>
</ul>
<p>反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间<br>
但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>协作式:<br>
因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的<br>
这种放弃执行权的操作,我们称为<code>yield</code></p>
</li>
</ul>
<p>比如在Rust中,<code>xxx.await</code>会执行一个Future  	<br>
意味着当程序执行到这里时,可能会<code>yield</code>(poll返回Poll::Pending,自愿放弃执行权)</p>
<p><code>xxx.await</code>就是一个<code>stop/yield point</code>,代表执行到此处时,可能会发生暂停并yield<br>
瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>
因此,我们可以准确分配Future执行所需要的最大空间</p>
<p>其实,每个<code>.await(也就是yield point)</code>,就代表着<code>一种状态</code>(之后会讲)</p>
<p>协作式的好处在于:<br>
能自己掌握所有<code>yield point</code>,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理<br>
毕竟机器定义的分配策略, 总是没有比不过我们特意设计的<br>
在任务暂停并转让执行权前,准确保存<code>下次继续所需要的状态</code>,内存/性能优势很大<br>
但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行</p>
<hr>
<h1 id="zhuang-tai-ji-de-gai-nian">状态机的概念</h1>
<p>在Rust中的异步,我们之前也说过,属于<code>协作式多任务</code><br>
而其<code>状态保存</code>的实现,就是利用<code>状态机(state machine)</code>来实现</p>
<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>,是一种数学模型</p>
<ol>
<li class="lvl-3">
<p>状态(state):<br>
比如有一扇门,它的状态就处于以下两种之一: Open or Closed</p>
</li>
<li class="lvl-3">
<p>事件(event):<br>
某事件发生后,会触发相应动作,可能改变状态<br>
比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p>
</li>
<li class="lvl-3">
<p>动作 (action):<br>
事件发生后,会触发动作</p>
</li>
<li class="lvl-3">
<p>变换 (transition):<br>
<code>State_X=&gt;State_Y</code>就叫<code>变换</code>,比如门的状态从<code>Open=&gt;Closed</code></p>
</li>
</ol>
<p>稍微了解下<code>状态机</code>的概念即可</p>
<p>那么现在,就要看具体代码了</p>
<p>如果你想亲自运行一下,先确保你的<code>Cargo.toml</code>中的依赖如下:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123;version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>, <span class="string">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>如下代码,读取一个文件的行数<br>
你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>
(通过target目录下的可执行文件,加上参数后运行,也可以哦)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    env::args,</span><br><span class="line">    process,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> async_std::&#123;</span><br><span class="line">    prelude::*,</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;<span class="keyword">self</span>,BufReader&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;              <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> path = args().nth(<span class="number">1</span>).unwrap_or_else(||&#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">let</span> file = File::open(path).<span class="keyword">await</span>?;          <span class="comment">// Yield point</span></span><br><span class="line">    <span class="keyword">let</span> lines = BufReader::new(file).lines();</span><br><span class="line">    <span class="keyword">let</span> count = lines.count().<span class="keyword">await</span>;             <span class="comment">// Yield point</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;                                                <span class="comment">// Done</span></span><br></pre></td></tr></table></figure>
<p>mian()产生一个新实例,异步运行<code>open(path)</code>与<code>count()</code>  	<br>
对于编译器,每一个<code>.await</code>其实都代表一种状态</p>
<p>Future实例,实际上是个状态机<br>
在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p>
<ol>
<li class="lvl-3">
<p>Start: 此Future刚开始执行</p>
</li>
<li class="lvl-3">
<p>Yield1: 第一个 yield point</p>
</li>
<li class="lvl-3">
<p>Yield2: 第二个 yield point</p>
</li>
<li class="lvl-3">
<p>Done: 此Future执行完毕</p>
</li>
</ol>
<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>
执行器调用当前Future的poll推动进度时,若在<code>某一阶段</code>返回了<code>Poll::Pending</code>,则放弃执行权<br>
当再次调用当前Future的poll推动进度时,则从上次暂停的状态<code>恢复(resume)</code>,继续执行</p>
<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机<br>
每一个状态都会存储一些数据, 便于进入下一个状态</p>
<p><strong>Note 1</strong>:<br>
Start状态,会存储传入函数的参数(如果有参数)</p>
<p><strong>Note 2</strong>:<br>
Done状态下,若进行resume,则可能得到panic!<br>
因为恢复已结束的计算是不可能, 也不应该的</p>
<p><strong>Note 3</strong>:<br>
怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br>
<code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>
如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存,因为从暂停中恢复后还需要使用<br>
其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象<br>
所以不需要特殊的持久化操作</p>
<hr>
<h1 id="zi-yin-yong-jie-gou-ti">自引用结构体</h1>
<h2 id="bao-cun-yin-yong" id="保存引用">保存引用</h2>
<p>当每个状态存储数据时,可能会导致发生<code>自引用</code>,比如:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>() -&gt; <span class="built_in">i32</span> &#123;                            <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> element = &amp;arr[<span class="number">2</span>];</span><br><span class="line">    write_file(<span class="string">&quot;foo.txt&quot;</span>, element.to_string()).<span class="keyword">await</span>;  <span class="comment">// Yield1</span></span><br><span class="line">    *element                                           <span class="comment">// Done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有三个状态: <code>Start</code>,<code>Yield1</code>,<code>Done</code><br>
而在<code>Yield1</code>这个状态,存储的数据如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Yield1State</span></span> &#123;</span><br><span class="line">    arr: [<span class="built_in">i32</span>; <span class="number">3</span>],</span><br><span class="line">    element: *<span class="keyword">const</span> <span class="built_in">i32</span>, <span class="comment">// 数组最后一个元素的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态的实例</span></span><br><span class="line">Yield1State &#123;</span><br><span class="line">    arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    element: &amp;arr[<span class="number">2</span>] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等,你可能会对上面的代码有疑惑:<br>
不是说,状态只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>
上面的代码,只有element这个引用需要被保存吧?</p>
<p>这是因为,它是<code>引用</code>嘛!<br>
没了<code>引用</code>背后的实际数据,那它还有啥用,不就是<code>悬垂引用</code>了吗?</p>
<p>因此我们还得保存,<code>该引用</code>指向的背后数据: <code>arr</code><br>
并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中</p>
<p>像这种 <code>结构体内部的指针,指向结构体本身</code><br>
就叫 <code>自引用结构</code></p>
<p>比如上面代码: 同一结构体下,成员element指向了成员arr</p>
<h2 id="nei-cun-yi-dong-wen-ti" id="内存移动问题">内存移动问题</h2>
<p>如上所述, 这可能导致悬垂引用的产生:<br>
若该struct实例的<code>内存地址发生改变</code><br>
(比如使用<code>std::mem</code>,让struct实例的内存地址,发生移动)</p>
<p>以上面的那段代码为例,如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>arr:<br>
内存地址会跟着结构体实例而改变<br>
但是, <code>值仍然是 [1,2,3]</code></p>
</li>
<li class="lvl-2">
<p>element:<br>
内存地址会跟着结构体实例而改变<br>
但是,值仍然是<code>先前arr的地址</code><br>
<code>注意,是先前的 ! 而不是后来arr的新地址</code></p>
</li>
</ul>
<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)</p>
<p>官方提出了<code>std::pin::Pin(trait)</code><br>
来解决自引用结构体方面的悬垂指针/引用问题</p>
<p>其实你听名字也很好理解:<br>
<code>Pin(中文意思是钉子)</code>的作用是,防止内存地址发生改变(给爷钉死吧!)</p>
<p>但是它又是怎么pin住的呢?<br>
下一节再慢慢讲吧</p>
<p>那又是一个值得探讨的话题了<br>
欲知后事如何, 且听下回分解</p>
<p><s>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-tui-p1: 系列说明</title>
    <url>/posts/rust-tui/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 TUI 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-tui">rust-tui</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>
当然, 还会介绍Rust中的两个crate: <code>tui</code> &amp;&amp; <code>crossterm</code></p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<ol>
<li class="lvl-3">
<p>博客:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/">Playing with tui-rs</a></p>
</li>
<li class="lvl-2">
<p><a href="https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/">Building a command-line interface in Rust</a></p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>文档:</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://docs.rs/tui/latest/tui/">tui-rs</a></p>
</li>
<li class="lvl-2">
<p><a href="https://docs.rs/crossterm/latest/crossterm/">crossterm</a></p>
</li>
</ul>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话, 请及时跟我联系<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后, 谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>TUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p1: 系列说明</title>
    <url>/posts/rust-gtk4/p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a><br>
GNOME入坑指南: <a href="/posts/gnome/guide">gnome-guide</a></p>
<h1 id="xi-lie-shuo-ming">系列说明</h1>
<p><a href="https://www.gtk.org/">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序</p>
<p>Rust语言自是其中之一, 具有相关的绑定库: <a href="https://gtk-rs.org/">gtk-rs</a> (gtk官方网页所指定)<br>
同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了</p>
<p>不定期更新, 毕竟我只有周末才能碰到电脑<br>
<s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p>
<hr>
<h1 id="can-kao-zi-liao">参考资料</h1>
<p>资料正在持续更新ing. . .</p>
<ol>
<li class="lvl-3">
<p>书籍</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://gtk-rs.org/gtk4-rs/stable/latest/book/">GUI development with Rust and GTK 4</a> (官方书籍)</p>
</li>
<li class="lvl-2">
<p><a href="https://toshiocp.github.io/Gtk4-tutorial/">Gtk4 Tutorial</a> (由社区编写的gtk4教学书籍)</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>博客/文档</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html">Rust Vs GUI</a></p>
</li>
<li class="lvl-2">
<p><a href="https://gi.readthedocs.io/en/latest/#gobject-introspection">GObject Introspection</a></p>
</li>
<li class="lvl-2">
<p><a href="https://developer.gnome.org/documentation/tutorials.html">GNOME Developer Doc/Tutorials</a></p>
</li>
</ul>
<hr>
<h1 id="huan-jing-pei-zhi">环境配置</h1>
<p>首先请参照 <a href="https://www.gtk.org/docs/installations/">GTK官方页面</a> , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Fedora, 及其衍生:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install gtk4-devel gcc</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Debian, 及其衍生:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libgtk-4-dev build-essential</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>Arch, 及其衍生:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gtk4 base-devel</span><br></pre></td></tr></table></figure>
<p>Windows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 <s>(无视即可)</s><br>
比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可</p>
<p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p>
<hr>
<h1 id="huan-ying-sao-rao">欢迎骚扰</h1>
<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>
你可以通过博客侧边栏上的联系方式找到我~~</p>
<p>最后, 谢谢你的观看 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p2: 创建窗口</title>
    <url>/posts/rust-gtk4/p2.html</url>
    <content><![CDATA[<blockquote>
<p>让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a><br>
GNOME入坑指南: <a href="/posts/gnome/guide">gnome-guide</a></p>
<h1 id="bei-jing-liao-jie">背景了解</h1>
<h2 id="gtk" id="GTK">GTK</h2>
<p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写<br>
在gtk3后, 由于GI(<a href="https://gi.readthedocs.io/en/latest/">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定<br>
这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript… <s>(不会真的有人用C语言写Gtk吧?)</s></p>
<p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p>
<h2 id="gtk-rs" id="gtk-rs">gtk-rs</h2>
<p>目前有个项目, 叫做 <a href="https://gtk-rs.org/">gtk-rs</a>, 负责GTK的Rust绑定, 在 <a href="https://crates.io/">crates.io</a> 上搜索 gtk, 所看到的 <a href="https://crates.io/crates/gtk">gtk</a> 与 <a href="https://crates.io/crates/gtk4">gtk4</a>, 就属于gtk-rs</p>
<p>gtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身<br>
所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上</p>
<hr>
<h1 id="xiang-mu-pei-zhi">项目配置</h1>
<p>首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 如下:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">gtk</span> = &#123;version = <span class="string">&quot;0.3.1&quot;</span>, package = <span class="string">&quot;gtk4&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4)<br>
下面就是正式的编码环节了</p>
<hr>
<h1 id="ji-chu-zhi-shi">基础知识</h1>
<p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>
同时还需 <code>use gtk::prelude::*</code>, 原因与 <a href="https://doc.rust-lang.org/std/prelude/index.html">std::prelude</a> 一样</p>
<p>先创建一个应用, 它目前连窗口也没有:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单吧? 但别急着运行, 先看看下面两处:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://developer.gnome.org/documentation/tutorials/application-id.html">application_id</a>:<br>
每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的, 一般使用反域名作为id, 如 “org.gnome.gedit”<br>
<code>app_id</code> 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!</p>
</li>
<li class="lvl-2">
<p><a href="http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>
我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: <code>application_id(id: &amp;str)</code><br>
在gtk4中, 它被高频次地使用, 最后调用的 <code>build</code> 会生成比如窗口, 按钮等部件的实例<br>
当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话</p>
</li>
</ul>
<hr>
<h1 id="xin-hao-liang">信号量</h1>
<p>当你跃跃欲试, <code>cargo run</code> 之后, 会看到:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GLib-GIO-WARNING : Your application does not implement g_application_activate()</span><br><span class="line">and has no handlers connected to the <span class="string">&#x27;activate&#x27;</span> signal.  </span><br><span class="line">It should <span class="keyword">do</span> one of these.</span><br></pre></td></tr></table></figure>
<p>靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然, 现在还无法执行, 请注意 <code>build_ui</code> 函数中的 <code>todo!()</code>, 我们还没有填充这个函数!<br>
因为我想逐步地讲解一下… 先来讲什么是 signal 吗:</p>
<p>当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度<br>
比如窗口打开, 按钮被点击, 拖动控件…这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了<br>
你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>我们把处理函数, 称之为 <code>handler</code></p>
</li>
<li class="lvl-2">
<p>我们将为 signal 绑定一个 handler 的过程, 称之为 <code>connect</code></p>
</li>
</ul>
<p>Gtk 的理念是: App只关心在特定的时候需要做的事情<br>
<code>事件发送的时间</code> , 即 signal 什么时候发送已经定好了, 至于 <code>事情的内容</code>, 即 handler 的具体实现, 由开发者自己负责</p>
<p>下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>startup:<br>
在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p>
</li>
<li class="lvl-2">
<p>shutdown:<br>
在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p>
</li>
<li class="lvl-2">
<p>activate:<br>
GtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口</p>
</li>
<li class="lvl-2">
<p>open<br>
当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p>
</li>
</ul>
<p>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>
当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口<br>
所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化</p>
<p>这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象</p>
<hr>
<h1 id="chuang-jian-kong-bai-chuang-kou">创建空白窗口</h1>
<p>回到之前的代码, 如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    todo!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Your <span class="built_in">application</span> <span class="keyword">does</span> <span class="keyword">not</span> implement g_application_activate()</span><br><span class="line"><span class="keyword">and</span> has no handlers connected <span class="keyword">to</span> <span class="keyword">the</span> &#x27;<span class="built_in">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure>
<p>现在你应该明白, 为什么之前会报出这个警告了吧? <code>connect_xxxx</code>, 代表着连接某个 signal , 即实现对应的虚函数/handler</p>
<p><code>connect_activate</code>, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 <code>&amp;Application</code><br>
我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这…啧, 不太聪明?</p>
<p>直接上 <code>build_ui</code> 的代码, 注意 use 那边多了东西:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My App&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它<br>
如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 <code>My App</code></p>
<p>在App启动之后的某时刻, <code>activate</code> 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现<br>
但现在, 我们已经将它覆盖成自己的 <code>build_ui</code> 了, 因此警告不再出现</p>
<hr>
<h1 id="xin-zeng-an-niu">新增按钮</h1>
<p>让我们再创建一个按钮, 提示信息是 <code>Press me!</code>, 在按下之后, 变成显示 <code>Hello World!</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::&#123;prelude::*, Button&#125;;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="keyword">let</span> btn = Button::builder().label(<span class="string">&quot;Press me!&quot;</span>).build();</span><br><span class="line">    btn.connect_clicked(|btn| btn.set_label(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My App&quot;</span>)</span><br><span class="line">        .child(&amp;btn)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已</p>
<p>之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler<br>
点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理</p>
<p>然后, 我们在使用 <code>Builder Pattern</code> 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中<br>
注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲</p>
<hr>
<h1 id="bu-chong">补充</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置间距:<br>
运行先前的代码, 你会发现按钮占满了整个窗口<br>
我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = Button::builder()</span><br><span class="line">    .label(<span class="string">&quot;Press me!&quot;</span>)</span><br><span class="line">    .margin_top(<span class="number">12</span>)</span><br><span class="line">    .margin_bottom(<span class="number">12</span>)</span><br><span class="line">    .margin_start(<span class="number">12</span>)</span><br><span class="line">    .margin_end(<span class="number">12</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>透明设置:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .opacity(<span class="number">0.8</span>)         <span class="comment">// 窗口不透明度, 越低越透明, 越高越不透明</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>默认高宽:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .default_height(<span class="number">100</span>)</span><br><span class="line">    .default_width(<span class="number">200</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p3: GObject-内存管理</title>
    <url>/posts/rust-gtk4/p3.html</url>
    <content><![CDATA[<blockquote>
<p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a><br>
GNOME入坑指南: <a href="/posts/gnome/guide">gnome-guide</a></p>
<h1 id="widget">Widget</h1>
<p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>
再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p>
<p><a href="https://docs.gtk.org/gtk4/visual_index.html">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p>
<p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>
例如 <code>Button</code>, 其继承树如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GObject</span><br><span class="line">└── Widget</span><br><span class="line">    └── Button</span><br></pre></td></tr></table></figure>
<p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>
举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p>
<p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>
</li>
</ul>
<hr>
<h1 id="cuo-wu-shi-xian">错误实现</h1>
<p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p>
<p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>
下面是代码, 已经讲过的概念不再重复:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> gtk::prelude::*;</span><br><span class="line"><span class="keyword">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_ID: &amp;<span class="built_in">str</span> = <span class="string">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class="line">    app.connect_activate(build_ui);</span><br><span class="line">    app.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class="line">    <span class="comment">// 创建两个按钮, 设置Label</span></span><br><span class="line">    <span class="keyword">let</span> btn_inc = Button::builder()</span><br><span class="line">        .label(<span class="string">&quot;Increase&quot;</span>)</span><br><span class="line">        .margin_top(<span class="number">12</span>)</span><br><span class="line">        .margin_bottom(<span class="number">20</span>)</span><br><span class="line">        .margin_start(<span class="number">12</span>)</span><br><span class="line">        .margin_end(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">let</span> btn_dec = Button::builder()</span><br><span class="line">        .label(<span class="string">&quot;Decrease&quot;</span>)</span><br><span class="line">        .margin_top(<span class="number">12</span>)</span><br><span class="line">        .margin_bottom(<span class="number">20</span>)</span><br><span class="line">        .margin_start(<span class="number">12</span>)</span><br><span class="line">        .margin_end(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Clicked` 事件发生后的处理函数</span></span><br><span class="line">    <span class="comment">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">0</span>;</span><br><span class="line">    btn_inc.connect_clicked(|_| &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    btn_dec.connect_clicked(|_| &#123;</span><br><span class="line">        num -= <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class="line">    <span class="comment">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class="line">    <span class="keyword">let</span> gtk_box = gtk::<span class="built_in">Box</span>::builder()</span><br><span class="line">        .orientation(Orientation::Vertical)</span><br><span class="line">        .build();</span><br><span class="line">    gtk_box.append(&amp;btn_inc);</span><br><span class="line">    gtk_box.append(&amp;btn_dec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class="line">    <span class="comment">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class="line">    <span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">        .application(app)</span><br><span class="line">        .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">        .child(&amp;gtk_box)</span><br><span class="line">        .build();</span><br><span class="line">    win.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>
如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p>
<p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>
因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p>
<p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>
这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p>
<p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>
有没有什么办法, 让这两个闭包都能拥有num的所有权?</p>
<p>请看下面的正确实现, 通过引用计数的方式 😃</p>
<hr>
<h1 id="yin-yong-ji-shu">引用计数</h1>
<p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>
那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p>
<p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>
于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p>
<div class="tips">
<p><strong>提示</strong><br>
对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>
因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p>
</div>
<p>下面是代码, 请务必记得use一下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> num_clone = num.clone();</span><br><span class="line"></span><br><span class="line">btn_inc.connect_clicked(|_| &#123;</span><br><span class="line">    num_clone.set(num_clone.get() + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn_dec.connect_clicked(|_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>
其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p>
<p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>
</li>
<li class="lvl-2">
<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>
</li>
</ul>
<p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>
要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p>
<p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>
因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p>
<p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>
所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p>
<hr>
<h1 id="clone">clone!</h1>
<p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href="https://docs.rs/glib/latest/glib/macro.clone.html">glib::clone</a><br>
请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> glib::clone;</span><br><span class="line"><span class="keyword">use</span> gtk::prelude::*;   <span class="comment">// 这里</span></span><br><span class="line"><span class="keyword">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class="comment">// 这里</span></span><br></pre></td></tr></table></figure>
<p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>
若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>
若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p>
<p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>
而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p>
</li>
<li class="lvl-2">
<p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>
我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p>
</li>
</ul>
<div class="tips">
<p><strong>注意:</strong><br>
<code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>
详情请见文档: <a href="https://docs.rs/glib/latest/glib/macro.clone.html">glib::clone</a></p>
</div>
<p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>
循环引用导致内存泄漏!</p>
<hr>
<h1 id="xun-huan-yin-yong">循环引用</h1>
<p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br>
<s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p>
<p>贴一份刚刚的代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>
两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>
这就是 <code>循环引用</code></p>
<p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p>
<p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = Rc::new(Cell::new(<span class="number">0</span>));</span><br><span class="line">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() + <span class="number">1</span>);</span><br><span class="line">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br><span class="line">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class="keyword">move</span> |_| &#123;</span><br><span class="line">    num.set(num.get() - <span class="number">1</span>);</span><br><span class="line">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>
在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p>
<p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>
答案是不会, 原因是以下两段代码</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一段:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gtk_box = gtk::<span class="built_in">Box</span>::builder()</span><br><span class="line">    .orientation(Orientation::Vertical)</span><br><span class="line">    .build();</span><br><span class="line">gtk_box.append(&amp;btn_inc);</span><br><span class="line">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>第二段:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> win = ApplicationWindow::builder()</span><br><span class="line">    .application(app)</span><br><span class="line">    .title(<span class="string">&quot;My Gtk App&quot;</span>)</span><br><span class="line">    .child(&amp;gtk_box)</span><br><span class="line">    .build();</span><br><span class="line">win.present();</span><br></pre></td></tr></table></figure>
<p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>
第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p>
<p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br>
<code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br>
<code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>
win活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p>
<p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>
尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p>
<p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>rust-gtk4-p4: GObject-子类化</title>
    <url>/posts/rust-gtk4/p4.html</url>
    <content><![CDATA[<blockquote>
<p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p>
</blockquote>
<span id="more"></span>
<p>同系列传送门: <a href="/categories/rust-gtk4">rust-gtk4</a><br>
GNOME入坑指南: <a href="/posts/gnome/guide">gnome-guide</a></p>
<h1 id=""></h1>
]]></content>
      <tags>
        <tag>Rust</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p1: 数据与信息</title>
    <url>/posts/high-school-it/p1.html</url>
    <content><![CDATA[<blockquote>
<p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p>
</blockquote>
<span id="more"></span>
<p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>
当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p>
<h1 id="shu-ju-de-ding-yi">数据的定义</h1>
<p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>
传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>
数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p>
</li>
<li class="lvl-2">
<p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p>
</li>
</ul>
<p>上面的两种情况中:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p>
</li>
<li class="lvl-2">
<p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p>
</li>
</ul>
<p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p>
<hr>
<h1 id="xin-xi-de-ding-yi">信息的定义</h1>
<p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>
其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p>
<p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>
比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这是一台电脑笔记本</p>
</li>
<li class="lvl-2">
<p>这是一台屏幕大小为15.6英寸的电脑笔记本</p>
</li>
<li class="lvl-2">
<p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p>
</li>
<li class="lvl-2">
<p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p>
</li>
</ul>
<p>你会看到, 信息越多, 越能消除随机不确定性</p>
<hr>
<h1 id="xin-xi-de-te-zheng">信息的特征</h1>
<p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>
但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p>
<p>下面是信息的5个特征, 教科书上搬的:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>载体依附性<br>
信息不能独立存在, 它是虚的, 必须有载体<br>
比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p>
</li>
<li class="lvl-2">
<p>时效性<br>
信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>
比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p>
</li>
<li class="lvl-2">
<p>共享性<br>
信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>
毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p>
</li>
<li class="lvl-2">
<p>可加工处理性/真伪性<br>
信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>
因此, 不要轻易跟随网上的人云亦云!</p>
</li>
<li class="lvl-2">
<p>价值性<br>
比如天气预报让你出门避免被雨淋湿, 这就是价值<br>
对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p>
</li>
</ul>
<hr>
<h1 id="zhi-shi-de-ding-yi">知识的定义</h1>
<p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的</p>
<p>这部分很简单, 简单概述即可</p>
<hr>
<h1 id="zong-jie">总结</h1>
<p>以下是一个很好的, 对三者进行了区分的例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p>
</li>
<li class="lvl-2">
<p>信息: 人们想到了圆周率就是3.1415926</p>
</li>
<li class="lvl-2">
<p>知识: 人们能够运用圆周率, 知道如何求解圆的面积</p>
</li>
</ul>
<p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>
您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p2: 基础科普与环境搭建</title>
    <url>/posts/high-school-it/p2.html</url>
    <content><![CDATA[<blockquote>
<p>p2: 让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p>
</blockquote>
<span id="more"></span>
<div class="tips">
<p><strong>注意:</strong><br>
本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p>
</div>
<h1 id="bian-yi-yu-jie-shi">编译与解释</h1>
<p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>
c/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p>
<p>反正记住一点:<br>
机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 也就是.exe结尾的文件<br>
我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p>
<p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>
我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p>
<p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>
新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p>
<p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>
因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p>
<div class="tips">
<p><strong>代码:</strong><br>
代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>
它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>
编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p>
</div>
<div class="tips">
<p><strong>文件后缀:</strong><br>
文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>
后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p>
<p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>
windows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p>
<p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>
一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p>
<p>如何显示文件后缀?<br>
按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>
在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>
此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p>
</div>
<hr>
<h1 id="python-de-te-dian">Python的特点</h1>
<ul class="lvl-0">
<li class="lvl-2">
<p>是一门 <ins>高级语言</ins></p>
</li>
<li class="lvl-2">
<p>是一门 <ins>面向对象</ins> 的语言</p>
</li>
<li class="lvl-2">
<p>是一门 <ins>解释型</ins> 语言</p>
</li>
<li class="lvl-2">
<p>语法简单, 拥有丰富强大的库, 适合快速开发</p>
</li>
</ul>
<div class="tips">
<p><strong>高级语言</strong><br>
计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p>
<ul class="lvl-1">
<li class="lvl-2">机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</li>
<li class="lvl-2">汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</li>
<li class="lvl-2">高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</li>
</ul>
<p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>
自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p>
</div>
<div class="tips">
<p><strong>面向对象</strong><br>
假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>
那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>
(非严谨版, 勿喷, 只是快速了解而已)</p>
</div>
<div class="tips">
<p><strong>库:</strong><br>
当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>
比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p>
</div>
<hr>
<h1 id="huan-jing-da-jian">环境搭建</h1>
<p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br>
<s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p>
<p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href="https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe">安装程序</a><br>
至于出现安装界面后点哪里, 你就记住两个地方:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p>
</li>
<li class="lvl-2">
<p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p>
</li>
</ul>
<p>如何检验自己是否安装成功?<br>
请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>
随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p>
<p>请输入以下命令, 检验python是否安装成功:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python  --version</span><br></pre></td></tr></table></figure>
<p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>
我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>
它应该会输出类似下面的文字:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Python 3.9.0</span><br></pre></td></tr></table></figure>
<p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p>
<div class="tips">
<p><strong>命令与路径</strong><br>
这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>
粗体闪烁的光标前的提示符, 表示你当前处于的路径</p>
<p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>
事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>
比如, 敲下 “C:\asdiasdadows\asdadtem32\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>
你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p>
<p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\asdad\xxx.exe” 该怎么办呢?<br>
这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p>
<p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>
就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p>
<p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>
因此, 出现了这个黑框框 😃</p>
<p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>
真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>
你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p>
</div>
<hr>
<h1 id="idle-de-bei-hou-yuan-li">idle的背后原理</h1>
<p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p>
<p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>
实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p>
<p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>
执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p>
<p>整个过程如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href="http://xxx.py">xxx.py</a>”</p>
</li>
<li class="lvl-2">
<p>在 cmd 中输入: <code>python xxx.py</code></p>
</li>
</ul>
<hr>
<h1 id="hello-world">Hello world!</h1>
<p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>
这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p>
<div class="tips">
<p><strong>注意:</strong><br>
这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>
你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p>
</div>
<p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>随后打开cmd/终端, 你的当前路径应该是 “C:\Users\用户名”<br>
我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br><span class="line">python first_app.txt</span><br></pre></td></tr></table></figure>
<p>这将会打印:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>
当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p>
<p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>
(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p>
<p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>
当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>
这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p>
<p>但还是有个问题<br>
那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>
执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p>
<p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>
实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p>
<p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>
但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p>
<p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>
windows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>
你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p>
<p>python是可以调用外部命令的!</p>
<p>你可以在 first_app.py 中, 这样改进你的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br>
<code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p>
<p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
  <entry>
    <title>high-school-it-p3: python基础语法</title>
    <url>/posts/high-school-it/p3.html</url>
    <content><![CDATA[<blockquote>
<p>正式的对python语法的学习, 包含常见库函数的使用</p>
</blockquote>
<span id="more"></span>
<div class="tips">
<p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href="/posts/high-school-it/p2">p2: 基础科普与环境搭建</a></p>
</div>
<h1 id="bian-liang-yu-fu-zhi">变量与赋值</h1>
<p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>
需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p>
<p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>
你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p>
<p>有两个概念:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声明变量:  创建变量 (声明一个变量出现了)</p>
</li>
<li class="lvl-2">
<p>赋值: 把一个值装到箱子(变量)里</p>
</li>
</ul>
<p>比如, 一个很简单的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>
右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p>
<p>你也可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>
<p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>
第二行表示, 把a里面的数值取出来, 传给了b</p>
<p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">d = e = f = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a,b,c = d,e,f</span><br></pre></td></tr></table></figure>
<p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p>
<p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure>
<p>你可能会疑惑:<br>
当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>
该想法对应的代码是这样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = b</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>
<p>但在交换数值的代码中, 你应该这样理解:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">_t1 = b</span><br><span class="line">_t2 = a</span><br><span class="line">a = _t1</span><br><span class="line">b = _t2</span><br></pre></td></tr></table></figure>
<p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>
只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了</p>
<p>现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p>
<hr>
<h1 id="zhu-shi">注释</h1>
<h2 id="zuo-yong" id="作用">作用</h2>
<p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>
注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p>
<p>举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  此时 a 的值为 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure>
<p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>
后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p>
<p>再举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"><span class="built_in">max</span> = -<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = a</span><br><span class="line"><span class="keyword">elif</span> b &gt; c:</span><br><span class="line">  <span class="built_in">max</span> = b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">max</span> = c</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure>
<p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p>
<h2 id="dan-duo-xing-zhu-shi" id="单-多行注释">单/多行注释</h2>
<p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 12345</span></span><br><span class="line"><span class="comment"># 上山打老虎</span></span><br><span class="line"><span class="comment"># 老虎打不着</span></span><br><span class="line"><span class="comment"># 打到小松鼠</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">12345</span></span><br><span class="line"><span class="string">上山打老虎</span></span><br><span class="line"><span class="string">老虎打不着</span></span><br><span class="line"><span class="string">打到小松鼠</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>
如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p>
<hr>
<h1 id="ji-ben-shu-ju-lei-xing">基本数据类型</h1>
<p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>
如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p>
<p>为了模拟现实, py将数据进行了抽象与分类:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>int: 对应整数</p>
</li>
<li class="lvl-2">
<p>float: 对应实数</p>
</li>
<li class="lvl-2">
<p>string: 对应文字</p>
</li>
<li class="lvl-2">
<p>bool: 对应真与假</p>
</li>
</ul>
<p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p>
<p>举些例子:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p>
</li>
<li class="lvl-2">
<p>我的年龄是16岁: 用int来表示 16 这个数字</p>
</li>
<li class="lvl-2">
<p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p>
</li>
</ul>
<p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>
你可以这样抽象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student &#123;</span><br><span class="line">  age:  <span class="built_in">int</span>,</span><br><span class="line">  height: <span class="built_in">float</span>,</span><br><span class="line">  name: string,</span><br><span class="line">  fat_or_not: <span class="built_in">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p>
<hr>
<h1 id="bian-liang-ming-ming-gui-fan">变量命名规范</h1>
<p>python中, 变量的命名必须符合规范, 不然直接报错<br>
在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p>
<p>命名规范如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>变量名由字母, 数字, 下划线组成</p>
</li>
<li class="lvl-2">
<p>数字不能在第一位</p>
</li>
<li class="lvl-2">
<p>不能与python中的关键字重名</p>
</li>
</ul>
<p>以下都是合法的变量名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">abada</span><br><span class="line">asd111231</span><br><span class="line">ad190123kkad</span><br><span class="line">asd_asd1_asd2</span><br><span class="line">_123daa</span><br><span class="line">_as11</span><br></pre></td></tr></table></figure>
<p>以下是不合法的变量名:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span></span></span><br><span class="line"><span class="function"><span class="title">not</span></span></span><br><span class="line"><span class="function"><span class="title">in</span></span></span><br><span class="line"><span class="function"><span class="title">lambda</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1123</span></span><br><span class="line"><span class="function">123<span class="title">adad</span></span></span><br><span class="line"><span class="function"><span class="title">sad</span>;;-``</span></span><br><span class="line"><span class="function">``?/</span></span><br><span class="line"><span class="function">&#x27;,</span></span><br></pre></td></tr></table></figure>
<div class="tips">
<p><strong>关键字:</strong><br>
关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>
这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>
比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p>
</div>
<p>如何判断一个变量名是不是关键字?<br>
呃…多认识下就知道了… 反正也不可能考没学过的关键字 😃</p>
<hr>
<h1 id="yun-suan-fu-yu-you-xian-ji">运算符与优先级</h1>
<p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>
这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>
在以下的图表中, 优先级1是最高, 数字越大优先级越低</p>
<h2 id="suan-zhu-yun-suan-fu" id="算术运算符">算术运算符</h2>
<p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td>x的y次方</td>
<td>x**y</td>
<td>1</td>
</tr>
<tr>
<td>*</td>
<td>x乘以y</td>
<td>x*y</td>
<td>2</td>
</tr>
<tr>
<td>/</td>
<td>x除以y, 产生实数值</td>
<td>x/y</td>
<td>2</td>
</tr>
<tr>
<td>//</td>
<td>x除以y, 产生整数值</td>
<td>x//y</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>x除以y, 取余数</td>
<td>x%y</td>
<td>2</td>
</tr>
<tr>
<td>+</td>
<td>x加y</td>
<td>x+y</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>x减y</td>
<td>x-y</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p>
<p>算术运算符, 可以与赋值运算符相互结合:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a += <span class="number">1</span>  <span class="comment"># 是上面的等价物</span></span><br></pre></td></tr></table></figure>
<p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>
这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p>
<h2 id="guan-xi-yun-suan-fu" id="关系运算符">关系运算符</h2>
<p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>
(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>x 大于 y</td>
<td>x &gt; y</td>
</tr>
<tr>
<td>&lt;</td>
<td>x 小于 y</td>
<td>x &lt; y</td>
</tr>
<tr>
<td>&gt;=</td>
<td>x 大于等于 y</td>
<td>x &gt;= y</td>
</tr>
<tr>
<td>&lt;=</td>
<td>x 小于等于 y</td>
<td>x &lt;= y</td>
</tr>
<tr>
<td>==</td>
<td>x 等于 y</td>
<td>x == y</td>
</tr>
<tr>
<td>!=</td>
<td>x 不等于 y</td>
<td>x != y</td>
</tr>
</tbody>
</table>
<p><strong>注:</strong><br>
本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p>
<hr>
<h1 id="ji-ben-shu-ju-jie-gou">基本数据结构</h1>
<p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p>
<p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>
在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>
此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p>
<p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>
当然, 我们此处仅学习基本数据结构</p>
<h2 id="lie-biao" id="列表">列表</h2>
<p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p>
<h3 id="dan-suo-yin" id="单索引">单索引</h3>
<p>我们可以通过单个索引, 访问对应的单个元素</p>
<p>举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有着 3 个元素的列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>] <span class="comment"># 300</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>] <span class="comment"># 400</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">2</span>] <span class="comment"># 500</span></span><br></pre></td></tr></table></figure>
<p>list 可以通过 index 来访问元素, 那么如果 index 过大呢, 比如下面这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有着 3 个元素的列表</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>]</span><br><span class="line"><span class="built_in">list</span>[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>脑子想一想都知道一定会报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  list[3]</span><br><span class="line">  ~~~~^^^</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>果不其然, 解释器告诉我们了报错信息, 提示 “列表的索引越界了”<br>
如果一个列表的长度length = n, 那么 index 自然要 &lt;= n-1 (从0开始哦~~)</p>
<div class="tips">
<p><strong>扩展: 为何 index 从 0 开始?</strong><br>
因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>
实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>
用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p>
<p>你可以这样理解:<br>
一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>
你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p>
<p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>
如何访问第 1 个格子? 第一个格子向右跳 0 格<br>
如何访问第 2 个格子? 第二个格子向右跳 1 格<br>
如何访问第 3 个格子? 第三个格子向右跳 2 格</p>
<p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>
要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p>
<p>如果你非要把下标从 1 开始, 那就得这样:<br>
list[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>
于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>
同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>
同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p>
<p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>
现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br>
<s>(好吧, 原因其实真的只是因为习俗)</s></p>
<p>而且在设计算法, 并且需要考虑下标的边界问题时, 下标从0开始会很方便</p>
</div>
<p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>
比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p>
<p>此时, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p>
<h3 id="qie-pian" id="切片">切片</h3>
<p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p>
<p>举个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>]  <span class="comment"># 定义列表</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">4</span>] <span class="comment"># [201, 202, 203, 204]</span></span><br><span class="line">numbers[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># [201, 202]</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>
如 <code>0:4</code> 代表 [0, 1, 2, 3], 再如 <code>0:2</code>, 代表 [0, 1]<br>
我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p>
<hr>
<h2 id="zi-dian" id="字典">字典</h2>
]]></content>
      <tags>
        <tag>高中信息技术</tag>
      </tags>
  </entry>
</search>
