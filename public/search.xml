<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>rs-async-p1-系列说明</title>
    <url>/posts/rs-async-p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 异步 系列教学  </p>
</blockquote>
<span id="more"></span>
<h1 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h1><p>传送门如下:  </p>
<ul>
<li><a href="https://jedsek.github.io/categories/rust-async/">博客 : Rust异步系列</a> </li>
<li><a href="https://www.bilibili.com/video/BV1uh41167Np">B站视频 : Rust编程语言-异步(Async)</a></li>
</ul>
<p><code>博客</code> 的更新速度, 快于 <code>视频</code><br><code>博客</code> 若经过重写, 则会抽时间更新 <code>视频</code>     </p>
<p>此系列, 我们将学习Rust中的 <code>异步 (Async)</code><br>当然也会介绍异步方面的相关概念咯</p>
<p>但你至少得明白 <code>线程</code>, <code>std::thread::spawn</code>, <code>handle(句柄)</code>, <code>Rust基础语法</code> 等基本概念  </p>
<p>不需要太深, 基础便已足够  </p>
<hr>
<h1 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h1><ol>
<li><p><code>官方书籍</code><br><a href="https://rust-lang.github.io/async-book/**">官方异步书籍</a></p>
</li>
<li><p><code>第三方书籍</code></p>
</li>
</ol>
<ul>
<li><p><a href="https://book.async.rs/overview/async-std">async_std</a></p>
</li>
<li><p><a href="https://tokio.rs/tokio/tutorial">tokio</a></p>
</li>
<li><p><a href="https://cfsamson.github.io/books-futures-explained/">Futures Explained in 200 Lines of Rust</a></p>
</li>
</ul>
<ol start="3">
<li><code>文章/博客</code></li>
</ol>
<ul>
<li><a href="https://without.boats/blog/">Withoutboats’s blogs</a></li>
</ul>
<hr>
<h1 id="欢迎骚扰"><a href="#欢迎骚扰" class="headerlink" title="欢迎骚扰"></a>欢迎骚扰</h1><p>在下QQ: <code>2948804617</code><br>如果有问题, 可以一起探讨 <del>(但别忘了我是大菜鸡哦)</del>  </p>
<p>你也可以在文章下进行评论</p>
]]></content>
      <categories>
        <category>rust-async</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-async-p2-异步简介</title>
    <url>/posts/rs-async-p2.html</url>
    <content><![CDATA[<blockquote>
<p>来简单介绍一下异步吧  </p>
</blockquote>
<span id="more"></span>
<h1 id="Intro-to-Async"><a href="#Intro-to-Async" class="headerlink" title="Intro to Async"></a>Intro to Async</h1><hr>
<h2 id="什么是异步编程"><a href="#什么是异步编程" class="headerlink" title="什么是异步编程?"></a>什么是异步编程?</h2><p><strong>异步编程</strong> (Asynchronous programming)<br>是一种 <strong>并发编程模型</strong> </p>
<p>特点是通过少量 <code>OS_thread (系统线程)</code><br>即可运行大量 <code>并发任务</code><br>在某些场景下, 可以疯狂压榨cpu的性能<br><del>(好吧, 有点废话……)</del></p>
<hr>
<h2 id="为什么选择异步"><a href="#为什么选择异步" class="headerlink" title="为什么选择异步?"></a>为什么选择异步?</h2><p>对于这个问题, 我们将对比 <strong>异步</strong> 与 其他 <strong>并发模型</strong><br>以此来告诉大家, 为什么选择异步:  </p>
<p>1.<code>OS Thread (系统线程)</code><br>由操作系统提供线程, 进行并发, 如std::thread<br>Good_1:<br>简单易使用, 建模能力强, 足够传统<br>Good_2:<br>操作系统就是运行时, 与C语言交互方便<br>Bad_1:<br>数据同步困难, 易发生数据竞争<br>Bad_2:<br>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>
<p>2.<code>Green Thread (绿色线程)</code><br>它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身<br>绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程<br>Good:<br>这意味着, 程序本身对 Green_thread 有绝对的管理权<br>所以内存分配等方面的粒度更细, 根据任务大小调度内存<br>因此堆栈大小, 能够随时间推移而增长<br>并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务<br>Bad_1:<br>它是程序本身实现模拟出来的线程, Runtime 比较巨大<br>运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互<br>这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象<br>它无法在语言层面被Rust支持<br>Bad_2:<br>绿色线程在不同平台上, 其实现可能不同<br>对多平台的 支持/维护/改进 得靠实现者保证  </p>
<p>由于 <code>OS Thread</code> 与 <code>Green Thread</code> 与 Rust 关系比较大:<br>一个是传统并发, 一个是Rust在1.0之后便舍弃的<br>所以只介绍这两个并发模型</p>
<hr>
<h2 id="异步优势"><a href="#异步优势" class="headerlink" title="异步优势"></a>异步优势</h2><p>3.<code>Async (异步)</code><br>我们终于要介绍异步了 ! 乌拉乌拉乌拉 ! ! !<br> <del>(没把你憋坏吧伙计?)</del>  </p>
<p>我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一<br>假设我们正在单线程下, 读取文件, 并进行一个计算:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件, 获取数据 </span></span><br><span class="line"><span class="keyword">let</span> data = read(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行一个计算</span></span><br><span class="line">compute()</span><br></pre></td></tr></table></figure>
<p>以上面代码为例子, 我们会读取 <code>file</code> 获取 <code>data</code><br>期间, 我们的程序, 做不了任何其他事情<br>只有等待 <code>IO操作 (Input/Output, 输入/输出)</code> 完毕, 我们才能进行接下来的 <code>compute</code>  </p>
<p><code>读取文件</code>, 属于 <code>IO操作</code><br>众所周知, IO操作很耗时, 等待它完成的时间可能会很长  </p>
<p>有没有什么办法加快速度?<br>没错, 系统线程yyds:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class="line"><span class="keyword">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class="line"><span class="keyword">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class="line"><span class="keyword">let</span> data = handle_a.join().unwrap();</span><br><span class="line">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>

<p>因为两个任务 <code>read</code> 与 <code>compute</code> 是独立的, 无依赖性<br>所以我们 <code>spawn</code> 了两个线程<br>第一个, 用于读取文件, 获取数据<br>第二个, 用于在读取文件的同时, 执行着 <code>compute</code><br>虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销<br>而异步, 就是只依靠单线程, 也能够完成上面的操作  </p>
<p>(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  </p>
<p>单线程中的异步(伪)代码如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="comment">/*  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件, 获取数据 </span></span><br><span class="line"><span class="keyword">let</span> data = read_async(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行一个计算</span></span><br><span class="line">compute_async()</span><br></pre></td></tr></table></figure>

<p>你会注意到:<br><code>read</code> -&gt; <code>read_async</code><br><code>compute</code> -&gt; <code>compute_async</code>  </p>
<p>我用伪代码表示, 这两个操作变成了异步操作<br>你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念<br>如下:    </p>
<ul>
<li><code>read</code>:<br>它会阻塞调用线程, 等待该操作完毕后<br>才继续往下执行 <code>compute</code>  </li>
</ul>
<p>阻塞期间是几乎不需要cpu参与运行的<br>程序此时傻乎乎地等待阻塞结束<br>无疑是对性能的浪费, 对cpu的不尊重  </p>
<ul>
<li><code>read_async</code>:<br>它处于阻塞时, 会运行<code>compute_async</code><br>线程由 <code>read_async</code> 接管变为由 <code>compute_async</code>接管<br>当阻塞时间结束, 则程序继续变为运行 <code>read_async</code></li>
</ul>
<p><code>read_async</code> 阻塞时, 程序是不会傻傻等待的:  </p>
<p>若检测到它处于阻塞, 无法取得进展<br>则会运行其他异步任务, 由其他异步任务接管线程  </p>
<hr>
<p>总而言之, 异步操作, 其实就是:<br>若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>使得cpu一直处于运算, 性能被极限压榨  </p>
<p>异步操作, 就像是可以随意 <code>start/stop</code> 一般<br>调度程序能够对它们进行调度, 决定当前要运算哪个操作<br>确保不会因为阻塞而傻傻等待</p>
<p>只需单线程, 就可以做到同时运行多个 <code>Task(异步任务)</code><br>异步当然也不排斥多线程:<br>一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?</p>
<hr>
<p>Q:<br>阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>A:<br>现代电脑发展出了一些分担IO操作压力的高科技<br>所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>只需要最后接收数据时, 出个场就行了  </p>
<p>所以我们的程序不需要在等待输入输出时就那样等着<br>给他们找事情, 让他们闲不下来吧!  </p>
]]></content>
      <categories>
        <category>rust-async</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-async-p3-Future</title>
    <url>/posts/rs-async-p3.html</url>
    <content><![CDATA[<blockquote>
<p>Rust 中的 Future/async/.await 说明  </p>
</blockquote>
<span id="more"></span>

<h1 id="Future-async-await"><a href="#Future-async-await" class="headerlink" title="Future/async/.await"></a>Future/async/.await</h1><hr>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>大家好! 我们上一节已经知晓异步的基础概念<br>现在, 来看看Rust中的异步语法吧    </p>
<p>在本节, 我们会知晓以下三个概念的大致含义:<br>(暂时不涉及背后原理, 原理之后专门出好几节来讲)   </p>
<ul>
<li>Future (trait)  </li>
<li>async (keyword)</li>
<li>.await (keyword)</li>
</ul>
<p>开始旅途吧  </p>
<hr>
<h2 id="What’s-Future"><a href="#What’s-Future" class="headerlink" title="What’s Future"></a>What’s Future</h2><p><code>Future</code>, 一个标准/核心库中的trait<br>其完整路径为 <code>std/core::future::Future</code>   </p>
<p>此节我只会讲它的大致含义, 原理则放到后面几节专门来讲 <del>(原理太难, 一节根本不够)</del>  </p>
<p>在Rust中, 一个实现了 Future(trait) 的类型<br>该类型的实例 (有时候直接被简称为 一个Future实例) 便代表 一次异步计算<br>可以将其交给 <code>Runtime(运行时)</code>, 从而异步执行   </p>
<p><code>异步执行</code>, 也就是指:<br>当其他 异步任务 阻塞时, 当前 异步任务 有机会执行<br>或当前 异步任务 阻塞时, 其他 异步任务 有机会执行<br>总而言之, 阻塞时期执行其他任务, 不给cpu空闲的机会</p>
<p><strong>注意两个名词的区别:</strong>  </p>
<ul>
<li><code>异步 计算</code>  </li>
<li><code>异步 任务</code></li>
</ul>
<p>两者有着区别, 举个例子你就明白了:  </p>
<p>假设有这么个 父计算, 由两个 子计算 组成:   </p>
<ol>
<li>Open: 先异步打开一个文件(async open)  </li>
<li>Read: 再异步读取该文件(async read)   </li>
</ol>
<p>我们可以看出, 一次 计算, 是可以由多个 子计算 组成的<br>同时, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>因为 <code>子计算们可能存在依赖关系</code> (在这里的例子中确实存在) </p>
<p>因此, 当某个 子计算 阻塞时, 它所属的最顶层的 父计算 也会阻塞, 避免了 Runtime 调度非法计算<br>(我们将 <code>最顶层的父计算 (top-level Future, 即最顶层的Future实例)</code> 称为 <code>Task(任务)</code>)  </p>
<p><code>当前Task</code> 阻塞时, 接管执行权的, 不能是 当前Task 中的 <code>其他子计算</code><br>只能是 <code>其他Task中的子计算</code>  </p>
<p>来点总结吧:  </p>
<ul>
<li><p>Task 是一个顶层Future实例 (即一次顶层异步计算) </p>
</li>
<li><p>一个Future可以由多个Future组成, 即一个Future里可以执行多个Future</p>
</li>
<li><p>Task_A阻塞时, 接管执行的是其他Task中的子计算, 不能是Task_A中的子计算</p>
</li>
<li><p>Task可以只是一次单独计算</p>
</li>
</ul>
<p><code>一个Future (一次异步计算)</code><br>可理解为, 是组成 <code>一个Task (一个异步任务)</code> 的最小单位 </p>
<p>了解到了那么一点点后, 现在来正式看看呗 ?  </p>
<hr>
<h2 id="Future的定义"><a href="#Future的定义" class="headerlink" title="Future的定义"></a>Future的定义</h2><p>让我们来看看它的定义:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简单了解一下:  </p>
<ul>
<li><p>Future:<br>代表一次异步计算  </p>
</li>
<li><p>Output:<br>代表 该Future, 异步执行完毕后, 产出的值的类型   </p>
</li>
<li><p>poll:<br>所有执行操作都会放在该函数中<br>Runtime 会不断调用 poll函数 来推进 该异步计算 的完成<br>每次 poll 的返回值是一个 枚举变体, 代表 是否完成</p>
</li>
<li><p>Poll<T>:<br>枚举类型, 作为 poll函数 的返回值类型, 其 变体 有:<br><code>Poll::Pending</code>:<br>指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br><code>Poll::Ready(T)</code>:<br>指明该计算执行完毕, 并产出一个类型为T的值   </p>
</li>
</ul>
<p>若只是普通使用者, 并不需了解 <code>Future的定义</code> 背后之原理<br>但若不了解它, 又如何为某类型实现 Future 呢?  </p>
<p>别急, Rust 为我们提供了关键字 <code>async</code>, 接着往下看吧   </p>
<hr>
<h2 id="What’s-async"><a href="#What’s-async" class="headerlink" title="What’s async"></a>What’s async</h2><p><code>async</code>, 一个关键字<br>用来创建 <code>一个匿名结构体的实例, 该结构体实现了Future</code><br>即, 它创建一个 <code>Future实例</code>  </p>
<p>来个例子, 看看 async 的好处:   </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HelloStr</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> HelloStr &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">String</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, _cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>);</span><br><span class="line">        Poll::Ready(<span class="built_in">str</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以观察到, 使用 async 进行了符合直觉的简化<br>这两种函数, 实际上是等价的  </p>
<p>看看它们两的返回值, 如下:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_str_1</span></span>() -&gt; <span class="built_in">String</span> &#123; </span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello! World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello_str_1() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello_str_2</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    HelloStr <span class="comment">// Future&lt;Output = String&gt; 的实例</span></span><br><span class="line">&#125;</span><br><span class="line">hello_str_2() <span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>

<hr>
<p>注意, 异步函数的调用, 只是返回一个 Future实例<br><strong>但并没有开始执行, 它是惰性的</strong><br><strong>只有调用Future的poll方法, 才能推动它的执行</strong><br><strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong>  </p>
<p>这样的好处就在于:<br>将一个异步计算看作一个变量, 方便了传参等工作  </p>
<p>比如, 你想舍弃某次 异步任务, 你只需要将 对应的Future实例 给 drop 掉, 使其所有权丢失即可</p>
<p>async 的作用就是创建一个 Future实例:  </p>
<ul>
<li><code>async fn</code> 异步函数, 要求返回一个 Future实例   </li>
<li><code>async block</code> 异步代码块, 创建一个 Future实例  </li>
<li><code>async closure</code> 异步闭包, (目前是不稳定特性) 创建一个 Future实例  </li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1_i32</span>;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `async block` 也可以使用move  </span></span><br><span class="line"><span class="comment">// 获得其中使用的变量的所有权  </span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    &amp;s </span><br><span class="line">&#125;</span><br><span class="line">s; <span class="comment">// Error: use of moved value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>

<p>创建一个Future实例, 想必大家已经了解一二<br>但是如何执行一个Future实例?  </p>
<p>欲知后事如何, 请听下文揭晓 </p>
<hr>
<h2 id="Future的执行"><a href="#Future的执行" class="headerlink" title="Future的执行"></a>Future的执行</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>Rust语言本身并不提供 <code>异步运行时 (async runtime)</code>, 以便于语言内核保持精小, 便于进化/迭代/维护<br>异步运行时 由社区提供, 围绕语言本身提供的定义 (比如 Future) 进行支持/扩充, 来运行异步程序  </p>
<p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) </p>
<p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>在嵌入式环境下, 也能够轻松运行异步程序   </p>
<p>在正式开始之前<br>请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:   </p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123; version = <span class="string">&quot;1.9&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>我们指定了版本, 并且启用了 <code>attributes</code> 这个特性  </p>
<p>好了, 马上开始咯!  </p>
<hr>
<h3 id="通过运行时执行"><a href="#通过运行时执行" class="headerlink" title="通过运行时执行"></a>通过运行时执行</h3><p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>并且使用 <code>async-std</code> 这个异步运行时环境来执行它:   </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello wrold!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们在本节开始不久, 就提到过的 <code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>async_std::task, 该模块, 为我们提供了大量api, 来执行/操控 这些 <code>Task</code>  </p>
<p>比如这里出现的 <code>task::block_on</code>:<br>传入一个 Future实例, Runtime 会执行它(调用poll方法), 并阻塞调用线程<br>该任务执行完毕后产出的值, 会作为 <code>block_on</code> 的返回值  </p>
<p>我们执行了一个 Task, 并且这个 Task 是单个的 Future<br>但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  </p>
<p><code>.await</code> 关键字出场了! </p>
<hr>
<h3 id="await-关键字"><a href="#await-关键字" class="headerlink" title=".await 关键字"></a>.await 关键字</h3><p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>在某个 Future实例 的后面, 增加 <code>.await</code>, 那么 <code>该Future实例</code> 则会执行<br>但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>真正执行的话, 得将 Future实例 交给运行时, 带动着执行里面的 子Future   </p>
<p>来看看它的使用:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">world</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_world</span></span>() &#123; </span><br><span class="line">    hello().<span class="keyword">await</span>;</span><br><span class="line">    world().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> fut = hello_world();</span><br><span class="line">    task::block_on(fut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.await</code> 是一个标记点, 可以理解为是一个 <code>yield point</code><br>Runtime 执行到 <code>xxx.await</code> 时, 先会执行一次 <code>xxx</code>  </p>
<p>一开始, 会调用一次poll函数, 推动执行进度<br>通过它的返回值, <code>Poll&lt;T&gt;枚举的变体</code>, 即 <code>Pending</code> 或 <code>Ready(T)</code><br>来决定: </p>
<ol>
<li>让 其他Task 接管执行权 (yield)  </li>
<li>该Future执行完毕, 继续执行当前 Task  </li>
</ol>
<p>若为 <code>Ready</code>, 则选 <code>2</code>, 继续往下执行 (一个 Task 可能是由多个 Future 所组成)<br>若为 <code>Pending</code>, 则选 <code>1</code>, 让其他任务接管执行权 (比如IO操作的阻塞期间, 让其他任务执行)  </p>
<p>稍微有点涉及原理部分, 可能有点难理解, 来个简单粗暴理解版:  </p>
<p><code>.await</code> 会指明 <code>执行某个Future</code> 这一逻辑<br>当 <code>xxx.await</code> 所在的 Task 交给 Runtime 执行, 并执行到 <code>xxx.await</code> 时<br><code>xxx</code> 这个Future实例会执行  </p>
<p>若它阻塞 (这意味着 该Future所在的Task 也阻塞)<br>所以调度程序安排 其他Task, 在该空档期执行<br>若不阻塞, 就继续往下执行 (可能还有碰见 <code>.await</code> 哟), 直到 该Task 结束   </p>
<hr>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li><code>#[async_std::main]</code><br>这玩意无比常见, 是个属性宏, 要加在 main函数 头上<br>使得 main 前面能被 async 所修饰<br>程序运行时, main函数返回的 Future, 会自动交给 Runtime 开始运行, 如下:  </li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    hello_world().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    async_std::task::block_on( <span class="keyword">async</span> &#123;</span><br><span class="line">        hello_world().<span class="keyword">await</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><code>async_std::task::spawn</code><br>因为这玩意也很常见, 所以就讲一讲:<br>向其传入 Future, 运行时会开始运行 该Task, 并返回 async_std::task::JoinHandle 的实例<br>它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似<br>不过那个运行 Thread, 而这个运行 Task, <code>join</code> 相应地变成 <code>.await</code><br>想让 该handle代表的Task 运行完毕, 应该在 该handle 前放上 <code>.await</code>:  </li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> handle = task::spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> two:<span class="built_in">i32</span> = handle.<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>终于结束了, 这一篇其实是重写版, 写到这真的累死了  </p>
<p>我们学到了一些东西 (不涉及原理, 之后专门抽几节讲……):      </p>
<ul>
<li><code>Future</code>   </li>
<li><code>async fn/block</code></li>
<li><code>.await</code>  </li>
<li><code>Async-Runtime&#39;s API</code>  </li>
</ul>
<p>只需要使用的, 看到这其实已经差不多了<br>普通异步程序也不怎么需要看 <code>Future</code> 定义中的 <code>poll</code> 方法<br>那里涉及到比较烦人的背后原理……  </p>
<p>如果有问题的话, 可以在评论区留言<br>或者加在下qq交流也行 : <code>2948804617</code>  </p>
<p>呼, 真的累死, 看番去了!<br>一周后再更吧 <del>(鸽神是也)</del></p>
]]></content>
      <categories>
        <category>rust-async</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-async-p4-状态的保存/变换</title>
    <url>/posts/rs-async-p4.html</url>
    <content><![CDATA[<blockquote>
<p>浅显的原理第一篇: 状态的保存/变换</p>
</blockquote>
<span id="more"></span>
<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>注: 参考了 《Writing an OS in Rust》中的async篇, 可以自己搜索下看看</strong><br>为了更好地理解 <code>Rust异步</code> 背后的原理, 我们先来了解下一些概念<br>当然, 不用太深入, 只是小补充而已:   </p>
<ul>
<li><code>抢占式/协作式多任务</code>  </li>
<li><code>状态机</code>  </li>
<li><code>自引用结构体</code>   </li>
</ul>
<p>现在, 让我们开始吧!  </p>
<hr>
<h1 id="抢占式-协作式多任务的概念"><a href="#抢占式-协作式多任务的概念" class="headerlink" title="抢占式/协作式多任务的概念"></a>抢占式/协作式多任务的概念</h1><p><code>抢占式多任务</code> 与 <code>协作式多任务</code>, 都属于 <code>多任务</code>         </p>
<ul>
<li><p>抢占式多任务:<br>操作系统决定CPU的运行权<br>比如, 操作系统先让 网易云音乐 运行一会, 再让 VSCode 运行一会<br>各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种 <code>任务们同时运行</code> 的感觉<br>这是强迫/抢占的     </p>
</li>
<li><p>协作式多任务:<br>任务们本身进行协调, 决定CPU的运行权<br>比如Rust中, 运行时调用 某Task(top-level Future) 的 poll方法 阻塞时, 返回 Poll::Pending<br>自己放弃继续执行, 并通知运行时执行 其他Task<br>这是自愿/协作的, Task们 <code>自愿放弃CPU的执行权</code><br>(上文中的 <code>任务</code> 与 <code>Task</code> 请区分一下, 前者比后者广泛, 后者在这, 用于Rust的举例)  </p>
</li>
</ul>
<hr>
<h1 id="两种多任务的恢复-状态保存"><a href="#两种多任务的恢复-状态保存" class="headerlink" title="两种多任务的恢复/状态保存"></a>两种多任务的恢复/状态保存</h1><p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>该任务, 应当从先前暂停的地方开始, 继续执行<br>因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 <code>状态保存</code>  </p>
<p>对于 <code>抢占式</code> 与 <code>协作式</code>, 处理 <code>状态保存</code> 的思路是不一样的:</p>
<h2 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式:"></a>抢占式:</h2><p>因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>任务此时运行到了哪里? 我们不知道啊!<br>那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    </p>
<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  </p>
<h2 id="协作式"><a href="#协作式" class="headerlink" title="协作式:"></a>协作式:</h2><p>因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>这种放弃执行权的操作, 我们称为 <code>yield</code>    </p>
<p>比如在Rust中, <code>xxx.await</code> 会执行一个Future<br>意味着当程序执行到这里时, 可能会 <code>yield</code> (poll 返回 Poll::Pending, 自愿放弃执行权)  </p>
<p><code>xxx.await</code> 就是一个 <code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>因此, 我们可以准确分配 Future 执行所需要的最大空间  </p>
<p>其实, 每个 <code>.await (也就是yield point)</code>, 就代表着 <code>一种状态</code> (之后会讲)</p>
<p>协作式 的好处在于便于掌握所有的 yield point<br>在暂停之前, 准确保存 <code>下次继续所需要的状态</code>, 内存/性能优势很大<br>但坏处也有, 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  </p>
<hr>
<h1 id="状态机的概念"><a href="#状态机的概念" class="headerlink" title="状态机的概念"></a>状态机的概念</h1><p>在Rust中的异步, 我们之前也说过, 属于 <code>协作式多任务</code><br>而其 <code>状态保存</code> 的实现, 就是利用 <code>状态机(state machine)</code> 来实现  </p>
<p><code>状态机 (state machine)</code> 一般指 <code>有限状态自动机</code>, 是一种 数学模型  </p>
<ol>
<li><p>状态 (state):<br>比如有一扇门, 它的状态就处于以下两种之一: Open or Closed    </p>
</li>
<li><p>事件 (event):<br>某事件 发生后, 会触发相应 动作, 可能改变状态, 比如: 用钥匙锁门(event) =&gt; 关门(action) =&gt; 门被锁住(state)   </p>
</li>
<li><p>动作 (action):<br>事件 发生后, 会触发 动作  </p>
</li>
<li><p>变换 (transition):<br><code>State_X =&gt; State_Y</code> 就叫 <code>变换</code>, 比如门的状态从 <code>Open =&gt; Closed</code>  </p>
</li>
</ol>
<p>稍微了解下 <code>状态机</code> 的概念即可  </p>
<p>那么现在, 就要看具体代码了  </p>
<p>如果你想亲自运行一下, 先确保你的 <code>Cargo.toml</code> 中的依赖如下:  </p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">async-std</span> = &#123;version = <span class="string">&quot;1&quot;</span>, features = [<span class="string">&quot;attributes&quot;</span>, <span class="string">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>如下, 读取一个文件的行数<br>你可以使用 <code>cargo run -- ./src/main.rs</code> 运行<br>(也可以编译后, 通过 <code>target/debug</code> 下的二进制文件运行)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> &#123;</span><br><span class="line">    std::env::args,</span><br><span class="line">    async_std::prelude::*,</span><br><span class="line">    async_std::fs::File,</span><br><span class="line">    async_std::io::&#123;<span class="keyword">self</span>,BufReader&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[async_std::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;              <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> path = args().nth(<span class="number">1</span>).expect(<span class="string">&quot;Fuck you! No path for working&quot;</span>); </span><br><span class="line">    <span class="keyword">let</span> file = File::open(path).<span class="keyword">await</span>?;          <span class="comment">// Yield point</span></span><br><span class="line">    <span class="keyword">let</span> lines = BufReader::new(file).lines();</span><br><span class="line">    <span class="keyword">let</span> count = lines.count().<span class="keyword">await</span>;             <span class="comment">// Yield point</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;                                                <span class="comment">// Done</span></span><br></pre></td></tr></table></figure>
<p>mian() 产生一个新实例, 异步运行 <code>open(path)</code> 与 <code>count()</code><br>对于编译器, 每一个 <code>.await</code> 其实都代表一种状态  </p>
<p>Future实例, 实际上是个 状态机<br>在这里共有四种状态/阶段 (其中包括两个 <code>.await point(yield point)</code>):  </p>
<ol>
<li>Start: 此Future刚开始执行  </li>
<li>Yield1: 第一个 yield point</li>
<li>Yield2: 第二个 yield point</li>
<li>Done: 此Future执行完毕</li>
</ol>
<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>执行器调用 当前Future 的 poll 推动进度时, 若在 <code>某一阶段</code> 返回了 <code>Poll::Pending</code>, 则放弃执行权<br>当再次调用 当前Future 的 poll 推动进度时, 则从上次暂停的状态 <code>恢复 (resume)</code>, 继续执行  </p>
<p>官方目前似乎采用 <code>Generator (生成器)</code> 为异步语法生成状态机<br>每一个状态都会存储一些数据, 便于进入下一个状态  </p>
<p><strong>Note 1</strong>:<br>Start状态, 会存储传入函数的参数 (如果有参数)</p>
<p><strong>Note 2</strong>:<br>Done状态下, 若进行 resume, 则可能得到 panic!<br>恢复已结束的计算是不应该的  </p>
<p><strong>Note 3</strong>:<br>怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br><code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>如上段代码中的 <code>file</code>, <code>count</code> 就需要被保存, 因为从暂停中恢复后还需要使用<br>其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>所以不需要特殊的持久化操作</p>
<hr>
<h1 id="自引用结构体"><a href="#自引用结构体" class="headerlink" title="自引用结构体"></a>自引用结构体</h1><h2 id="状态保存引用时"><a href="#状态保存引用时" class="headerlink" title="状态保存引用时"></a>状态保存引用时</h2><p>当每一个状态存储数据时, 可能会导致发生 <code>自引用</code>, 比如:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">example</span></span>() -&gt; <span class="built_in">i32</span> &#123;                            <span class="comment">// Start</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> element = &amp;arr[<span class="number">2</span>];</span><br><span class="line">    write_file(<span class="string">&quot;foo.txt&quot;</span>, element.to_string()).<span class="keyword">await</span>;  <span class="comment">// Yield1</span></span><br><span class="line">    *element                                           <span class="comment">// Done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code><br>而在 <code>Yield1</code> 这个状态, 存储的数据如下:</p>
<pre><code class="rust">// 状态的定义
struct Yield1State &#123;
    arr: [i32; 3],
    element: *const i32, // 数组最后一个元素的地址
&#125;

// 状态的实例
Yield1State &#123;
    arr: [1,2,3],
    element: &amp;arr[2] as *const i32,
&#125;
</code></pre>
<p>等等, 你可能会对上面的代码有疑惑:<br>不是说, 状态 只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>上面的代码, 只有 element 这个 引用 需要被保存吧?  </p>
<p>这是因为, 它是 <code>引用</code> 嘛!<br>没了 <code>引用</code> 背后的实际数据, 那它还有啥用, 不就是 <code>悬垂引用</code> 了吗?  </p>
<p>因此我们还得保存, <code>该引用</code> 指向的背后数据: <code>arr</code><br>并 <code>一起</code> 存储在同个 <code>struct (代表同一状态)</code>中  </p>
<p>像这种 <code>结构体内部的指针, 指向结构体本身</code><br>就叫 <code>自引用结构</code>  </p>
<p>比如上面代码: 同一结构体下, 成员 element 指向了成员 arr  </p>
<h2 id="内存移动问题-导致悬垂引用产生"><a href="#内存移动问题-导致悬垂引用产生" class="headerlink" title="内存移动问题(导致悬垂引用产生)"></a>内存移动问题(导致悬垂引用产生)</h2><p>这就可能有问题发生, 如果 该struct实例 的 <code>内存地址发生改变</code><br>比如使用 <code>std::mem</code>, 让 struct实例 的内存地址, 发生移动  </p>
<p>以上面的那段代码为例, 如下:  </p>
<ul>
<li><p>arr:<br>内存地址会跟着结构体实例而改变<br>但是, <code>值仍然是 [1,2,3]</code></p>
</li>
<li><p>element:<br>内存地址会跟着结构体实例而改变<br>但是, 值仍然是 <code>先前arr的地址</code><br><code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>
</li>
</ul>
<p>这就产生了一个问题: 引用可能是失效/错误的 (悬垂引用)  </p>
<p>官方提出了 <code>std::pin::Pin (trait)</code><br>来解决 自引用结构体 方面的 悬垂指针/引用问题 </p>
<p>其实你听名字也很好理解:<br><code>Pin(中文意思是钉子)</code> 的作用是, 防止内存地址发生改变 (给爷钉死吧!)  </p>
<p>但是它又是怎么pin住的呢?<br>下一节再慢慢讲吧  </p>
<p>那又是一个值得探讨的话题了<br>欲知后事如何, 且听下回分解  </p>
<p><del>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</del></p>
<hr>
<p>感谢大家观看! 有建议/发现错误/想聊天<br>请在评论区留言, 或者加本人qq也阔以</p>
]]></content>
      <categories>
        <category>rust-async</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-dm-p1-系列说明</title>
    <url>/posts/rs-dm-p1.html</url>
    <content><![CDATA[<blockquote>
<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列教学  </p>
</blockquote>
<span id="more"></span>
<h1 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明:"></a>课程说明:</h1><p><strong>注: 请注意是 声明宏</strong><br>传送门如下:  </p>
<ul>
<li><a href="https://jedsek.github.io/categories/rust-declarative-macro/">博客 : Rust声明宏系列</a> </li>
<li><a href="https://www.bilibili.com/video/BV1Wv411W7FH?p=1">B站视频 : Rust编程语言-声明宏</a></li>
</ul>
<p><code>博客</code> 的更新速度, 快于 <code>视频</code><br><code>博客</code> 若经过重写, 则会抽时间更新 <code>视频</code>  </p>
<p>此系列, 我们将学习Rust中的 <code>声明宏</code>  </p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><code>书籍</code></li>
</ol>
<ul>
<li><a href="https://zjp-cn.github.io/tlborm/">宏小册</a>  </li>
<li><a href="https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html">RustPrimer</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">TRPL</a></li>
</ul>
<ol start="2">
<li><code>文章</code>  </li>
</ol>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/353421021">【译】Rust宏: 教程与示例 (一)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/356427780">【译】Rust宏: 教程与示例 (二)</a></li>
</ul>
<hr>
<h1 id="欢迎骚扰"><a href="#欢迎骚扰" class="headerlink" title="欢迎骚扰"></a>欢迎骚扰</h1><p>在下QQ: <code>2948804617</code><br>如果有问题, 可以一起探讨 <del>(但别忘了我是大菜鸡哦)</del>  </p>
<p>你也可以在文章下进行评论</p>
<hr>
]]></content>
      <categories>
        <category>rust-decl-macro</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-dm-p2-从println开始</title>
    <url>/posts/rs-dm-p2.html</url>
    <content><![CDATA[<blockquote>
<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  </p>
</blockquote>
<span id="more"></span>
<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>大家应该都用过一个宏<br>它就是 <code>println!</code>:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&quot;Rush B!!!!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    <span class="built_in">println!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>为什么后面要跟个感叹号?<br>为什么括号里面的参数可以不一样?  </p>
<p>亲爱的 TRPl 在教你写 <a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F">Hello World!</a> 的时候, 告诉过你: 名字后加个感叹号, 就是个 <code>宏(macro)</code><br>注: macro 的读音: [ˈmækroʊ]</p>
<p>可是 macro 到底是啥?<br><del>(算了算了, 反正只要会用就行了, 于是你点击了该网页的叉叉)</del>  </p>
<hr>
<h1 id="查看定义"><a href="#查看定义" class="headerlink" title="查看定义"></a>查看定义</h1><p>让我们按住Ctrl, 鼠标左键 println!<br>(以 VSCode 为例)  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可能会看到, 在 println! 的上面</span></span><br><span class="line"><span class="comment">// 有着类似下面的玩意:  </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// #[macro_export]</span></span><br><span class="line"><span class="comment">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class="line"><span class="comment">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class="line"><span class="comment">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>

<p>你悲催地发现根本看不懂这一大堆鬼画符……<br>但看不懂根本没关系, 后面几节过后, 你肯定懂了<br>现在只需明白的, 是大致结构:  </p>
<ol>
<li><p>我们将 <code>macro_rules!</code> 放在 <code>println</code> 前面, 说明后者是个宏<br>(<code>macro_rules!</code> 当作特定语法即可)  </p>
</li>
<li><p>之后用花括号包起来, 里面是该宏的具体定义  </p>
</li>
</ol>
<p>问题来了, 关键是 <code>println</code> 的具体定义<br>花括号内, 到底在讲述着啥?  </p>
<p>请容许我来帮你粗暴地类比一下 <code>match表达式 &amp;&amp; macro</code>:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&quot;1&quot;</span>.repeat(<span class="number">10</span>),</span><br><span class="line">    <span class="number">2</span> =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;2&quot;</span>.repeat(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// macro</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>macro 有点像是 match, 能根据不同参数, 展开不同的代码<br>在 macro 最外层的花括号中, 有许多匹配分支  </p>
<p>match表达式, 称呼每个匹配分支为 <code>arm</code><br>逗号分割它们彼此, 或者不用逗号而用花括号包裹来分割<br>最后一个 arm 可省略逗号  </p>
<p>macro, 则称呼每个匹配分支为 <code>rule</code> (明白为什么使用 <code>macro_rules!</code> 创建宏了吗)<br>必须使用花括号包裹, 使用分号分隔彼此<br>最后一个 rule 可省略分号  </p>
<p>你并不需搞清所有细节, 现在先不用试图记忆具体语法, 有印象即可<br>现在再来看看 <code>println</code>, 是不是稍微有点感觉了 (看不懂的地方依然直接跳即可):  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义部分</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    <span class="comment">// 空参时, 只输出换行符</span></span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参时, 输出参数, 并换行</span></span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用部分</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"><span class="built_in">println!</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>创建 macro, 名字就叫 xxx, 花括号包裹具体定义:  </li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建两个匹配分支:<br>(匹配空参 =&gt; 不做任何事)<br>(匹配123 =&gt; 打印123)  </li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用, 宏名+感叹号+传参:<br>(传入的参数, 若与任何 rule 都不匹配, 则报错)</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> xxx &#123;</span><br><span class="line">    () =&gt; &#123;&#125;;</span><br><span class="line">    (<span class="number">123</span>) =&gt; &#123;<span class="built_in">println!</span>(<span class="string">&quot;123&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    xxx!();      <span class="comment">// Nothing</span></span><br><span class="line">    xxx!(<span class="number">123</span>);   <span class="comment">// println!(&quot;123&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>咱们下期见  </p>
]]></content>
      <categories>
        <category>rust-decl-macro</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-dm-p3-声明与使用</title>
    <url>/posts/rs-dm-p3.html</url>
    <content><![CDATA[<blockquote>
<p>正式系统的关于 macro 的 声明与使用</p>
</blockquote>
<span id="more"></span>  
<h1 id="框架建立"><a href="#框架建立" class="headerlink" title="框架建立"></a>框架建立</h1><p>前一节, 我们大概清楚了 macro 的结构<br>现在让我们再来简单复习一遍:  </p>
<ol>
<li><code>macro_rules! (这是特点语法)</code> 来创建一个 macro</li>
<li><code>rule(s) (匹配分支, 以 &quot;参数 =&gt; 展开代码&quot; 的形式)</code> 放在最外层的花括号内  </li>
<li>调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 <code>println!()</code>  </li>
</ol>
<p>现在稍微深入一点:<br>一个 <code>rule</code> 可以被这样抽象地表示 : (matcher) =&gt; (transcriber)<br>它由三个重要的部分组成:</p>
<ul>
<li><code>matcher (匹配器)</code>: 用来匹配传入的参数  </li>
<li><code>metavariable/literal (元 变量/字面量)</code>: 绑定传入的参数到变量上, 出现在 <code>matcher</code> 中</li>
<li><code>transcriber (转录器)</code>: 用来在宏匹配成功后, 进行代码替换</li>
</ul>
<p>以 <code>println!</code> 为例子, 我们向其传入了一些参数, 它给我们打印到标准输出上<br>因为原本的 <code>println!</code> 涉及到 <code>卫生性</code>, <code>重复语法</code>, <code>路径作用域</code> 等, 不适合新鸟阅读, 所以我抽象了它: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    (<span class="comment">/* 空参匹配 */</span>) =&gt; (<span class="comment">/* `换行` 的代码 */</span>);</span><br><span class="line">    (<span class="comment">/* 有参匹配 */</span>) =&gt; (<span class="comment">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>println</code> 由两个 <code>rule</code> 组成, 每个的形式都是: <code>matcher =&gt; transcriber</code><br>从上往下, 每个 rule 的 <code>matcher</code> 会与传入参数尝试匹配, 匹配到, 就替换为 <code>transcriber</code> 里面的代码<br>所有 <code>matcher</code> 都无法与 <code>传入参数</code> 进行匹配, 则报错  </p>
<p>同时, <code>matcher</code> 与 <code>transcriber</code> 的括号, 分别可以是 (), [], {} 三种之一<br>即, 对于一个rule, 它可以是: <code>(pattern) =&gt; (expansion)</code>, 也可以是 <code>[pattern] =&gt; &#123;expansion&#125;</code><br>在调用时, 包裹参数的括号也可以在这三种之一切换, 比如 <code>vec![0, 1,2,3</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>
<p>而 <code>metavariable/literal</code> 则出现在 <code>matcher</code> 中, 用于匹配并捕获 代码片段<br>在对应的 <code>transcriber</code> 中, 则可以操控这些 <code>元值</code>, 即操控 捕获到的代码片段  </p>
<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了  </p>
<hr>
<h1 id="两种宏参数"><a href="#两种宏参数" class="headerlink" title="两种宏参数"></a>两种宏参数</h1><p>是时候引入一些新的东西了, 顺便加深下你的印象  </p>
<h2 id="元变量-Metavariable"><a href="#元变量-Metavariable" class="headerlink" title="元变量(Metavariable)"></a>元变量(Metavariable)</h2><p>让我们来看个例子:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class="line">        $a + $b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    my_macro!(<span class="number">1</span>);</span><br><span class="line">    my_macro!(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    1;</span></span><br><span class="line"><span class="comment">    1 + 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>你会注意到, 每个 rule 之间的参数, 其声明都有点奇怪:<br>比如 <code>$a:expr</code> -&gt; <code>$ + 参数标识符 + 类型</code>  </p>
<p><code>$</code> 这个前缀干嘛的?<br>这显式地说明了, 它是 <code>metavariable</code>, 可以匹配并捕获相应类型的代码片段, 这里会捕获表达式<br>至于为何要特意加$前缀来说明, 本节下面就要讲到啦, 别着急~  </p>
<p>来看看 <code>expr</code> 这个后置的类型:<br><code>expr</code>, 全称为 <code>expression (表达式)</code><br>在第一次宏调用, 我们传入了 <code>1 (i32类型的字面量)</code>, 这当然是个表达式, 会与第一个 rule 成功匹配<br>这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为 <code>相应的展开代码</code><br>(matcher(匹配器), metavariable(元变量), transcriber(转录器) 都用到了)    </p>
<p>简单来讲, macro 的本质, 就是匹配捕获传入参数, 将调用部分 替换/展开 为相应代码<br>macro 不就是个代码生成器, 一段用来生成代码的代码吗  </p>
<p>注意: macro实际上是将传入部分解析为一个AST节点, 然后替换/展开调用部分, 变成一个AST节点<br>在本节下面的本质篇, 会更详细地讲讲</p>
<h2 id="元字面量-Metaliteral"><a href="#元字面量-Metaliteral" class="headerlink" title="元字面量(Metaliteral)"></a>元字面量(Metaliteral)</h2><p>为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">($a: expr) =&gt; &#123;$a&#125;;                     <span class="comment">// the first rule</span></span><br><span class="line">  |             |  </span><br><span class="line">  |         	|</span><br><span class="line">( <span class="number">1</span>      )      <span class="number">1</span>                       <span class="comment">// pass &amp;&amp; expand </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class="comment">// the second rule</span></span><br><span class="line">  |      |  |              |    |</span><br><span class="line">  |      |  |              |    |</span><br><span class="line">( <span class="number">1</span>      ,  <span class="number">2</span>      ) =&gt;    <span class="number">1</span> +  <span class="number">2</span>      <span class="comment">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>

<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code>  </p>
<p>其实, 你往括号里传入的东西, 都是参数 (除了空格)<br>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>这种固定的参数, 如同token中的字面量一样<br>我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)  </p>
<p>因此, 假若 rule 中的参数没有 $前缀 进行区分:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> fuck &#123;</span><br><span class="line">    (a:expr) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    fuck!(<span class="number">1</span>);       <span class="comment">// No</span></span><br><span class="line">    fuck!(a:expr);  <span class="comment">// Yes ~~(Oh~)~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a:expr</code> 的类型为 <code>tt</code>, 而非 <code>expr</code>, 只能传入固定形式的 <code>a:expr</code> 才发生匹配 (即它是 <code>MetaLiteral</code>)<br>是不是感觉一切都特别狗日?  </p>
<p>切记:<br><code>当你想在传参时, 绑定一段代码片段, 参数名前必须加上 $前缀 进行修饰</code>  </p>
<p><code>Meta variable/literal</code> 到底有啥用? 你用着用着就明白了……<br>但我可以提一嘴: <del>(为了自由)</del> 可以方便DSL/生成代码<br>接下来, 我们用一个例子, 来说明两者的缺一不可:  </p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设有这么个宏 <code>map!</code> (有没有想到 <code>vec!</code>)<br>它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>如下:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map![</span><br><span class="line">        <span class="string">&quot;吉良吉影&quot;</span> =&gt; <span class="number">33</span>,</span><br><span class="line">        <span class="string">&quot;空条承太郎&quot;</span> =&gt; <span class="number">41</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来写一个这样的宏吧!<br>不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key =&gt; Value</code><br>来看看两种宏参数在宏中, 发挥着怎样的作用:  </p>
<ul>
<li><p><code>Metavariable</code>: 将捕获的传入的代码片段绑定到自身<br>并在 <code>Transcriber</code> 中被使用, 最后展开为新代码  </p>
</li>
<li><p><code>Metaliteral </code>: 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配<br>若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>(这里只有一个rule, 空匹配的懒得放里面了)  </p>
</li>
</ul>
<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>(之后会讲几个实战: 比如B站视频中已经讲过的递推序列生成器, 博客的话, 我周六放学回来慢慢更吧……)</p>
<hr>
<h1 id="本质-AST-与-Token"><a href="#本质-AST-与-Token" class="headerlink" title="本质 (AST 与 Token)"></a>本质 (AST 与 Token)</h1><p>(如果还是不理解, 可以随便找个编译原理教程, 自己看看前几节即可)<br>(或者看看我B站的视频, 视频讲得比较浅, 比较通俗)  </p>
<p>假若由你来设计一个Rust编译器<br>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  </p>
<p>若我们将每遍扫描并做点事情的过程, 称为 <code>pass</code><br>pass 一次就生成了, 对于很大的源码来说, 这不现实吧  </p>
<p>那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题<br>每一次pass都解决一个小问题, 那不就Ok了吗</p>
<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code>  </p>
<p>我们可以先把源码抽象为AST (源码被抽象后的树状表示, 抽象语法树, Abstract Syntax Tree)<br>比如我们用Rust的enum表示一下:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该枚举: 一个AST节点可以是整数, 或者一个二元运算  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASTNode</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>), </span><br><span class="line">    BinaryExpr &#123;</span><br><span class="line">        op: Op,</span><br><span class="line">        lhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">        rhs: <span class="built_in">Box</span>&lt;ASTNode&gt;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Op</span></span> &#123;</span><br><span class="line">    Plus, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你只需明白AST是对源码的一层抽象产物就可以了  </p>
<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小<br>但是, 如果源码很大呢? AST已经很复杂了<br>那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  </p>
<p>基于AST, 我们可以再来一些 <code>IR</code>, 层层递进, 以达目的<br>注意, 是一些, 而不是一个, 这很好理解, 因为一层可能还是不够嘛  </p>
<p><code>AST</code> 很重要, 是生成目标码的关键, 是代码的骨架<br>而另外的IR, 也是有必要的, 这也增强了可维护性<br>编译器在AST的基础上, 最终生成了目标码<br>(像Lisp之类的比较特殊, 源码就已经形如AST, 可能很多人写的第一个编译器就是Lisp了……)  </p>
<p>生成AST需要点啥? 或者说, 它由什么组成?<br>由 expr(表达式), stmt(语句), ;(标点符号) 等组成<br>这些都叫做 <code>token</code>  </p>
<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>它将token们联系起来, 表达了代码的骨架<br>这个庞然大物便是 AST 了  </p>
<hr>
<h1 id="回到Macro"><a href="#回到Macro" class="headerlink" title="回到Macro"></a>回到Macro</h1><h2 id="Token类型表"><a href="#Token类型表" class="headerlink" title="Token类型表"></a>Token类型表</h2><p>生成AST需要Token协助  </p>
<p>macro 中, 其参数的类型, 便是token类型  </p>
<p>既然macro是要操控这些传入的token (或AST节点, 等会讲), 我们总得知道token类型吧?<br>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)  </p>
<p>所以, 辛苦你将下面的记一下<br>稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  </p>
<ul>
<li><code>ident</code> -&gt; 标识符, 如函数名字, 变量名字, 关键字  </li>
<li><code>stmt</code> -&gt; statemen, 语句</li>
<li><code>expr</code> -&gt; expression, 表达式, 如 <code>x</code> 与 <code>1_i32</code></li>
<li><code>literal</code> -&gt; literal expression, 字面量表达式, expr的子集</li>
<li><code>block</code> -&gt; 代码块  </li>
<li><code>pat</code> -&gt; pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),</li>
<li><code>path</code> -&gt; 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径</li>
<li><code>ty</code> -&gt; type, 如i32, u32, String, Option<T>等  </li>
<li><code>tt</code> -&gt; token tree, 之后我会单独再讲解下它的  </li>
<li><code>item</code> -&gt; 条目/项, 例如函数定义  </li>
<li><code>meta</code> -&gt; 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)</li>
<li><code>lifetime</code> -&gt; 生命周期  </li>
<li><code>vis</code> -&gt; visibility, 可见性, 比如pub等, 也可能为空  </li>
</ul>
<h2 id="TT"><a href="#TT" class="headerlink" title="TT"></a>TT</h2><p>这里有个比较特殊的类型 <code>tt</code>:  </p>
<p><code>tt (Token Tree)</code>, 可以捕获 <code>Single Token</code>, 或者由 (), [], {} 及括号包裹起来的东西<br>让我们来点例子吧:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a:tt) =&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>($a));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Single Token</span></span><br><span class="line">    aa!(<span class="number">123</span>);          <span class="comment">// Yes: 123</span></span><br><span class="line">    aa!(FuckYou);      <span class="comment">// Yes: FuckYou</span></span><br><span class="line">    <span class="comment">// aa!(Fuck You);     // No</span></span><br><span class="line">    <span class="comment">// aa!(123 + 11);     // No</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (), [], &#123;&#125;</span></span><br><span class="line">    aa!([<span class="number">123</span>]);        <span class="comment">// Yes: [123]</span></span><br><span class="line">    aa!(&#123;<span class="number">123</span> + <span class="number">123</span>&#125;);  <span class="comment">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AST节点"><a href="#AST节点" class="headerlink" title="AST节点"></a>AST节点</h2><p>macro 会将传入的token, 一个个解析为对应类型的AST节点 (除了少量token类型, 等会细讲)<br>比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> map &#123;</span><br><span class="line">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class="line">        m.insert($key, $val);</span><br><span class="line">        m</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = map!(<span class="string">&quot;普通上班族&quot;</span> =&gt; <span class="number">33</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 展开后, 可以看作是:</span></span><br><span class="line"><span class="comment">fn main() &#123;</span></span><br><span class="line"><span class="comment">    let m = &#123;</span></span><br><span class="line"><span class="comment">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class="line"><span class="comment">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class="line"><span class="comment">        m</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我们通过使用 macro , 站在了更抽象的视角上<br>操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码), 最后再一起形成目标码  </p>
<p>这有时会大大简化手写代码量, 如std中, 向宏传入些类型, 能自动生成为这些类型实现trait的代码</p>
<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果<br>我直接用 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a> 上面的代码了:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class="line">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">macro_rules!</span> match_tokens &#123;</span><br><span class="line">    ($a:tt + $b:tt) =&gt; &#123;<span class="string">&quot;got an addition&quot;</span>&#125;;</span><br><span class="line">    (($i:ident)) =&gt; &#123;<span class="string">&quot;got an identifier&quot;</span>&#125;;</span><br><span class="line">    ($($other:tt)*) =&gt; &#123;<span class="string">&quot;got something else&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;\n&quot;</span>,</span><br><span class="line">        match_tokens!((caravan)),</span><br><span class="line">        match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;\n&#123;&#125;\n&#123;&#125;&quot;</span>,</span><br><span class="line">        capture_then_match_tokens!((caravan)),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">3</span> + <span class="number">6</span>),</span><br><span class="line">        capture_then_match_tokens!(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果会是:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">got an identifier</span><br><span class="line">got an addition</span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br><span class="line">got something <span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点<br>它不再是token, 而是个AST节点了!  </p>
<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>但是经过二次传入(向 <code>capture_then_match_tokens</code> 传入的参数又传给 <code>match_tokens</code>) 后<br><code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code> 匹配, 而不能与 <code>$a:tt + $b:tt</code> 匹配  </p>
<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化<br>好好理解下这块  </p>
<h2 id="匹配误区-歧义限制"><a href="#匹配误区-歧义限制" class="headerlink" title="匹配误区/歧义限制"></a>匹配误区/歧义限制</h2><p>在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制<br>可以去看看 <a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md">宏小册</a></p>
<h3 id="匹配误区"><a href="#匹配误区" class="headerlink" title="匹配误区"></a>匹配误区</h3><p>来看看下面一段代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> aa &#123;</span><br><span class="line">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class="line">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    aa!(a);   <span class="comment">// Yes</span></span><br><span class="line">    aa!(a+);  <span class="comment">// No</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配<br>但是实际上会报这么一个错误:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">expected expression, found end of <span class="keyword">macro</span> arguments</span><br><span class="line"><span class="comment">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>

<p>你会发现实际上都是在与第一个rule尝试着进行匹配:  </p>
<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配<br>但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule  </p>
<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知道, 因此rule的顺序很重要  </p>
<h3 id="歧义限制"><a href="#歧义限制" class="headerlink" title="歧义限制"></a>歧义限制</h3><p>由于一些歧义, 为了向后兼容性与不破坏代码<br>当前对 <code>Metavariable</code> 后面可以跟的内容有所限制<br>详情可以去看 <a href="https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Rust-Reference</a>  </p>
]]></content>
      <categories>
        <category>rust-decl-macro</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rs-dm-p4-细枝末节的补充</title>
    <url>/posts/rs-dm-p4.html</url>
    <content><![CDATA[<blockquote>
<p>关于 p3 的一些小补充: “空格忽略性”, “传参限制”  </p>
</blockquote>
<span id="more"></span>
<p>这一节会比较轻松, 讲一讲 <code>空格忽略性</code> 与 <code>传参匹配限制</code></p>
<hr>
<h1 id="空格忽略性"><a href="#空格忽略性" class="headerlink" title="空格忽略性"></a>空格忽略性</h1><p>这是一个很简单的性质: macro不匹配传入的空格<br>以我们之前玩的 <code>对应游戏</code> 为例子:  </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class="comment">// rule: matcher =&gt; transcriber</span></span><br><span class="line">  |      |  |              |    |</span><br><span class="line">  |      |  |              |    |</span><br><span class="line">( <span class="number">1</span>      ,  <span class="number">2</span>      ) =&gt;    <span class="number">1</span> +  <span class="number">2</span>      <span class="comment">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>
<p>我们会忽略传入的空格, 以便于在设计 <code>DSL (自己定义的语法)</code> 时更加自由, 整齐, 干净<br><del>(真是一大堆废话, 函数传参不也忽略)</del> </p>
<h1 id="传参匹配限制"><a href="#传参匹配限制" class="headerlink" title="传参匹配限制"></a>传参匹配限制</h1><p>我们在传参时, 可能会报一些错误  </p>
]]></content>
      <categories>
        <category>rust-decl-macro</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
</search>
