{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next_custom/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next_custom/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/blue.jpg","path":"images/blue.jpg","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next_custom/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/cursor/fireworks.js","path":"js/cursor/fireworks.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/default.yaml","path":"lib/fastclick/default.yaml","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/index.js","path":"lib/fastclick/index.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/package.json","path":"lib/fastclick/package.json","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/lib/likely.js","path":"lib/fastclick/lib/likely.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/lib/needmoreshare.js","path":"lib/fastclick/lib/needmoreshare.js","modified":0,"renderable":1},{"_id":"themes/next_custom/source/lib/fastclick/lib/sharejs.js","path":"lib/fastclick/lib/sharejs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"eab818cfa50f806745f15ef6c75edd4ee4cdeb57","modified":1633158696553},{"_id":"source/categories/index.md","hash":"14d6e98e3f58de158848374e2a975330a81e8c5f","modified":1633158696553},{"_id":"source/tags/index.md","hash":"ecd929e94729acce862ce076b97aa57a93ec9e09","modified":1633158696553},{"_id":"source/_posts/rs-async/rs-async-p1-系列说明.md","hash":"7717369772e6d37a087e65e2a4ef182e12d9e2f3","modified":1633158696553},{"_id":"source/_posts/rs-async/rs-async-p2-异步简介.md","hash":"bbe244fb49323f6641b936e17c58502ade6e3701","modified":1633158696553},{"_id":"source/_posts/rs-async/rs-async-p3-Future.md","hash":"f1758ed8fbff476a64ef6276a1d334ab458fa57a","modified":1633158696553},{"_id":"source/_posts/rs-async/rs-async-p4-状态的保存-变换.md","hash":"fcdc92ba2dfa2d3cfce9be66482574aff713d0ca","modified":1633158696553},{"_id":"source/_posts/rs-dm/rs-dm-p1-系列说明.md","hash":"b33ef8ee40bf9087b9a25da80cb8fda169005ea6","modified":1633158696553},{"_id":"source/_posts/rs-dm/rs-dm-p3-声明与使用.md","hash":"cd02585beb225512806d8889f1bae84b9335b2f5","modified":1633159689877},{"_id":"source/_posts/rs-dm/rs-dm-p2-从println开始.md","hash":"042482a95e0ad5a36acc2f1c0e2f0c60badc805e","modified":1633158696553},{"_id":"themes/next_custom/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1633163378867},{"_id":"themes/next_custom/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1633163378867},{"_id":"themes/next_custom/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1633163378867},{"_id":"themes/next_custom/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1633163378867},{"_id":"themes/next_custom/package.json","hash":"0fdce9f5b80e6757be715953a19c46acfa00f2e7","modified":1633163378877},{"_id":"themes/next_custom/_vendors.yml","hash":"5949493e1390c34e094aee96489db37b4c3ad2ee","modified":1633163378867},{"_id":"themes/next_custom/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1633163378877},{"_id":"themes/next_custom/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1633163378867},{"_id":"themes/next_custom/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1633163378867},{"_id":"themes/next_custom/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1633163378867},{"_id":"themes/next_custom/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1633163378867},{"_id":"themes/next_custom/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1633163378867},{"_id":"themes/next_custom/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1633163378867},{"_id":"themes/next_custom/_config.yml","hash":"085393d1d207bd50930c418f1faa9ebae69d9ac9","modified":1633175867140},{"_id":"themes/next_custom/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1633163378867},{"_id":"themes/next_custom/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1633163378867},{"_id":"themes/next_custom/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1633163378867},{"_id":"themes/next_custom/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1633163378867},{"_id":"themes/next_custom/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1633163378867},{"_id":"themes/next_custom/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1633163378867},{"_id":"themes/next_custom/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1633163378867},{"_id":"themes/next_custom/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1633163378867},{"_id":"themes/next_custom/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1633163378867},{"_id":"themes/next_custom/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1633163378867},{"_id":"themes/next_custom/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1633163378867},{"_id":"themes/next_custom/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1633163378867},{"_id":"themes/next_custom/languages/zh-CN.yml","hash":"f24dd9bca8eaec2572a1ff30eaedd4a2215c1d4d","modified":1633167989977},{"_id":"themes/next_custom/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1633163378867},{"_id":"themes/next_custom/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1633163378867},{"_id":"themes/next_custom/layout/_layout.njk","hash":"8640dadad7505b16451887153bc118ee278ed92e","modified":1633173274970},{"_id":"themes/next_custom/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1633163378877},{"_id":"themes/next_custom/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1633163378877},{"_id":"themes/next_custom/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1633163378877},{"_id":"themes/next_custom/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1633163378877},{"_id":"themes/next_custom/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1633163378877},{"_id":"themes/next_custom/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1633163378877},{"_id":"themes/next_custom/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1633163378877},{"_id":"themes/next_custom/layout/_custom/custom.njk","hash":"dbd1329789b1c458cd0e2310e67d6bd43d02e991","modified":1633173134400},{"_id":"themes/next_custom/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1633163378867},{"_id":"themes/next_custom/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1633163378867},{"_id":"themes/next_custom/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1633163378867},{"_id":"themes/next_custom/layout/_macro/post.njk","hash":"b92d6c77d4b349c5d56fb8e0a44b578c194ef466","modified":1633169570225},{"_id":"themes/next_custom/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1633163378867},{"_id":"themes/next_custom/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1633163378867},{"_id":"themes/next_custom/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1633163378867},{"_id":"themes/next_custom/scripts/events/index.js","hash":"1ce12eda88fa5df7e76ec7b78b8463fc6618410c","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/post.js","hash":"ab8bb12e4d55640b1ac4252514468ce37ebcb0b0","modified":1633163378877},{"_id":"themes/next_custom/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1633163378877},{"_id":"themes/next_custom/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":1633163378877},{"_id":"themes/next_custom/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/minify.js","hash":"0af64049db8188d5f8cc226b353e0d7909819feb","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1633163378877},{"_id":"themes/next_custom/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1633163378877},{"_id":"themes/next_custom/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1633163378877},{"_id":"themes/next_custom/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1633163378877},{"_id":"themes/next_custom/source/css/_colors.styl","hash":"2d464c451fac10669c0c0d25b1694c7cf85bd25e","modified":1633163378877},{"_id":"themes/next_custom/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1633163378877},{"_id":"themes/next_custom/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":1633163378877},{"_id":"themes/next_custom/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1633163378877},{"_id":"themes/next_custom/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1633163378877},{"_id":"themes/next_custom/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1633163378877},{"_id":"themes/next_custom/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1633163378877},{"_id":"themes/next_custom/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1633169253725},{"_id":"themes/next_custom/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1633163378877},{"_id":"themes/next_custom/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1633163378877},{"_id":"themes/next_custom/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1633163378877},{"_id":"themes/next_custom/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1633163378877},{"_id":"themes/next_custom/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1633163378877},{"_id":"themes/next_custom/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1633163378877},{"_id":"themes/next_custom/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1633163378877},{"_id":"themes/next_custom/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1633163378877},{"_id":"themes/next_custom/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1633163378877},{"_id":"themes/next_custom/source/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1633163378877},{"_id":"themes/next_custom/source/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1633163378877},{"_id":"themes/next_custom/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1633163378877},{"_id":"themes/next_custom/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1633163378877},{"_id":"themes/next_custom/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1633163378877},{"_id":"themes/next_custom/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1633163378877},{"_id":"themes/next_custom/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1633163378877},{"_id":"themes/next_custom/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1633163378877},{"_id":"themes/next_custom/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1633163378877},{"_id":"themes/next_custom/source/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1633163378877},{"_id":"themes/next_custom/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1633163378877},{"_id":"themes/next_custom/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1633163378877},{"_id":"themes/next_custom/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1633163378867},{"_id":"themes/next_custom/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1633163378877},{"_id":"themes/next_custom/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1633163378877},{"_id":"themes/next_custom/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1633163378877},{"_id":"themes/next_custom/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1633163378877},{"_id":"themes/next_custom/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1633163378877},{"_id":"themes/next_custom/layout/_partials/head/head-unique.njk","hash":"9167e429a459686c9fc140790124a46d677e6b15","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/head/head.njk","hash":"d3c094aaef1431fbc9df333529a7b1789ccd134c","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1633163378867},{"_id":"themes/next_custom/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1633163378877},{"_id":"themes/next_custom/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1633163378867},{"_id":"themes/next_custom/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1633163378877},{"_id":"themes/next_custom/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/sidebar/site-overview.njk","hash":"5c01e380ba843f8016d8fa4593432430f5bd3584","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1633163378867},{"_id":"themes/next_custom/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1633163378867},{"_id":"themes/next_custom/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1633163378867},{"_id":"themes/next_custom/scripts/events/lib/config.js","hash":"b0ced2583fdd505da3ef27a9db9c55cc7b936732","modified":1633163378877},{"_id":"themes/next_custom/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1633163378877},{"_id":"themes/next_custom/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1633163378877},{"_id":"themes/next_custom/scripts/events/lib/vendors.js","hash":"08dac57e15c9f06c7cf54884b045f2362595f9d2","modified":1633163378877},{"_id":"themes/next_custom/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1633163378877},{"_id":"themes/next_custom/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1633163378867},{"_id":"themes/next_custom/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1633163378877},{"_id":"themes/next_custom/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1633163378877},{"_id":"themes/next_custom/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1633163378877},{"_id":"themes/next_custom/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1633163378877},{"_id":"themes/next_custom/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1633163378877},{"_id":"themes/next_custom/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1633163378877},{"_id":"themes/next_custom/source/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1633173096470},{"_id":"themes/next_custom/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1633163378877},{"_id":"themes/next_custom/source/css/_variables/base.styl","hash":"8e32c845ea477caa2069175ab5015451856e69c5","modified":1633167645917},{"_id":"themes/next_custom/source/lib/fastclick/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1633175584570},{"_id":"themes/next_custom/source/lib/fastclick/README.md","hash":"4fc97a125111f3cbec50cffeddf32c32fd024129","modified":1633175584580},{"_id":"themes/next_custom/source/lib/fastclick/package.json","hash":"6a30089543e4b639e85d857c4ca70897ae2e1432","modified":1633175584580},{"_id":"themes/next_custom/source/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1633175584580},{"_id":"themes/next_custom/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1633163378877},{"_id":"themes/next_custom/source/lib/fastclick/LICENSE","hash":"a8a12e6867d7ee39c21d9b11a984066099b6fb6b","modified":1633175584580},{"_id":"themes/next_custom/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1633163378877},{"_id":"themes/next_custom/source/lib/fastclick/default.yaml","hash":"63abbb8255bab5ea7a4f45de3bcf14b574d41fa6","modified":1633175584580},{"_id":"themes/next_custom/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1633163378877},{"_id":"themes/next_custom/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1633163378877},{"_id":"themes/next_custom/source/lib/fastclick/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/config","hash":"b3285b8a5b5ad0c3676cbeffd6fd7ea7b63902f1","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/index","hash":"dd61bb0f47fe89c262afcdca9886afabf6f89af2","modified":1633175584580},{"_id":"themes/next_custom/source/lib/fastclick/.git/packed-refs","hash":"174e9a11984091ad0a1324a2f7034e1a338c84d3","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1633175584580},{"_id":"themes/next_custom/source/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1633175584580},{"_id":"themes/next_custom/source/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1633175584580},{"_id":"themes/next_custom/source/lib/fastclick/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1633175584580},{"_id":"themes/next_custom/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1633163378877},{"_id":"themes/next_custom/source/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-header.styl","hash":"b1c99f34d65f994c89940bb7cdff4e36779ceb5d","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/third-party/index.styl","hash":"b1bcc5f9357a9f8b8d6f8f285f073aaf3157f9db","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/third-party/search.styl","hash":"c8e95e8ac4cbdba01cb93e9e0569b45603e41bc6","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/highlight/index.styl","hash":"0b3e2696eca39781c3524b2c5a2555ebc616e6e8","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/tabs.styl","hash":"9b34143aec49e390e18f380026a45096f7477722","modified":1633163378877},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/fsmonitor-watchman.sample","hash":"55a762007dd48d229ef89fe8d0882256dcbee41a","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1633175582660},{"_id":"themes/next_custom/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1633163378877},{"_id":"themes/next_custom/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1633163378877},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/logs/HEAD","hash":"9ce794659d0cbe1a9949b127755b86d89ae7d0f8","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/04/bfd30e2b510cb8bf4b0f043d0f39379fda344b","hash":"9a695281e501e565084abfdbe1795123bfeb068f","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/0a/041280bd00a9d068f503b8ee7ce35214bd24a1","hash":"2af3b23208162ae85f2c996375ae27e8402cb499","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/0d/66973f880e493956483a1472fe60dfb855339f","hash":"cff8b911bd70abe331e0450866b2403c9b8f6e74","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/14/70ec550667269b2b28104dee3f92b4e14a66bb","hash":"04e58a410ff49d08d35b3e68efa2e8607451f4c1","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/39/eecac957740db2155785ff231e1868f1464f5c","hash":"b571de4112f8f4a93933e9c38d994cf52cc87236","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1633175582660},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/42/1af9a020a9e8fedc55f82bceaa2c5091e3adce","hash":"b9c5d9eb0c8504e9f837dd89b40df66f26955ac5","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/42/c4fe3083d5eeaac86dbc81dbcea98d71f97a78","hash":"9ad2acaf712ceb77f38e43fb0d70782f096550a8","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/44/57ef8380ad2eb7b765da6b0028ee745c8f72e0","hash":"ed8c57416875de3ab6a9fb01f7f65462688e8448","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/47/85a003019cf76cd9d65d643e52b0f2d911fb0c","hash":"195ee21a9ea7f9e93a07873bf2b2fbef4be0654d","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/4a/4cdb4dac936e28cefd4b84149570d34a3d34c8","hash":"cf2891df987b4416950d61c3c97dbaa2cf02480f","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/53/3f84c565dbfa38acd9af674c32efc475560678","hash":"927f8037427ab0dd6494a2af35b9d64813f6103d","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/54/c1fbfeaf41ede10230c96df98de315c5491ed7","hash":"812f45cea4d0b49b2c94b91916b71bb04f3ae6db","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/55/45bdea46b7a21d65f8d41573e60bd1f4b341a3","hash":"82453735ead378f838b19412219afda65416a2d9","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/59/fad4e6042e33cdb4a75c6d450dec8bc4f405c0","hash":"ab9cdca6442c1a9ba69899c18bd3187f222fb9b2","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/5b/0536c94009657b73197a942d72f73edbb00094","hash":"edbfb0dc66747b57a830086c9470d67dd7933b2e","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/5b/168a3e689e7265e7263bd8a705d569f1ed2abd","hash":"dbe56ed0895e138dc3f64af7e79934376b79313f","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/5f/e65dc09b4b5acc74cdb4a69c21c246b0085291","hash":"ef0f2ee5d20c6942f8b799b9dfc71855fe188182","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/6d/89479fd27f5eaed049070b49b126aff3689d63","hash":"200dca19b76759ae835e9044066bd0bc8558f5b5","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/71/5c9e3f2c7bf89048b1b16ecb9b7d15609d65d5","hash":"ce326db17f251e0078d07a050a583bf0cfd3ac45","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/74/0748c6e3bb5550063f207afe6f711ec549461b","hash":"da8891e7ecc82d300afcc8b7ab4de10e8758ef00","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/7d/9e6fc08a9544ff57174c67757ff98d12913d90","hash":"5461ca6b5299b05382c8e5c948613622a0f0a5ea","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/8c/f591c468d5a80a9c25ffe092f3359bdd311d7c","hash":"3b32a623aa2e5a7fd5640f6b238882df4c0b6c4e","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/8d/221c3efab5d30db1e2969d4b7d5bceb07f51f4","hash":"7a36a63ef4b83886787cf3cf66ebef22481e4d95","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/9f/2c6aff274d694bbf3ac6e5a19acaca4cd41a0e","hash":"ace97f6a7900b0bfd0986ec69f8dd49d5911e22b","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/a0/cfd32ade7bd25b8d282366fa177afb7644d321","hash":"3cccb2a6ab155945972167c2bd6e2627cc7b75bd","modified":1633175584540},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/a1/a4ef0b4cb975a87af657cddf929fb303c24e03","hash":"717ab6517b8cf0d4c841eae0b72d03840e1294ce","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/a8/ac4146417080f9a79f70b679300f4495228cf0","hash":"1bb57653a607a267f64188a90a73824fed46e6de","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/a8/b7d65825aded2417e9498530d4a84274e66e03","hash":"0bbade092c9ed84a4b280fed3716775a1f1eb7a8","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/ae/5f7548b6de31e555b62d5929943270cdf70882","hash":"16028a233e7fd61d549b323e39948cb98dd8826f","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/b7/756f84efa37a6af1a8d63495e595dae69dc59c","hash":"e6d349fe6b83dd9b3ab402b4a9c958f961a2c562","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/b7/f52bc0462fa0ce9cf8c9cd0691f800ac87912c","hash":"11b5e0dfdfad1680d9b82060399c8558c6940ff1","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/bb/b7f201fc6d983c841b8538d2e4348e6fd10410","hash":"9a901800f310f25dfeae384d587414631db710b1","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/bb/fbb9645d8b80ceca6329a06f50ae5445df309b","hash":"b8ec78f29a75cce4b281482942eb1b9ee3aadb63","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/bc/358ef1e7b8427df05c3739e8b2fd939489d4b3","hash":"1959c86b00c466a7a28505f057dc31d19c6da33d","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/c0/0bbbce1e0ed7a9d53c3860ea6c934f775769af","hash":"5c25c88f047e3d870e3f6b1370c458ad59505af9","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/c4/d26070b481c7e6c7b0ded6a8afbdcfbe940f03","hash":"1da98ccbd616b9e04d5993e88479af4bda331100","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/c7/fbec335943fcc910186fccc3c1a2529efa20c4","hash":"dc08dc16b141a089831bb7ff2cb1cd0a93907ab8","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/cb/964303a9a8daf73aafed7f21bc910074874950","hash":"de06ae549cb5059c2beabe6194fd09e0b662a4bd","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/59/f7764acc6325fd8460efa1ce533f6c4ba1ab6e","hash":"c057795d340601456d367d9e77bf76167370d4f3","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/d1/7b6f553e4f9b6009ec16fc13b8ea1de0968465","hash":"74f745894b73b26dabacef20558aede3d83d74e7","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/d7/d75bef3d59f966b8c44c1142789e2a94836aad","hash":"5444dbcf0def99466609feaf431992300a16e313","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/d5/8fb7058713729b8a2d573110b22bd4f0e641f9","hash":"096db64afd1ae351983eb54924347e29b839ab3d","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/e5/2ecdba00cb9b2083bb3491508d10db30aef805","hash":"5e41e47a592bee16139fd948e666132d6d339668","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/e3/738a2ffd7d5082bfceabe50f4ce8ac88af41c9","hash":"24570a86d04ea9a63e1b8ae146d20ee812c2af76","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/e7/ffd87976f21a514cee500a5627a19e81961dcc","hash":"e3bc6f9637b7ef11c50eb18e52264112ba45273e","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/e8/e681d7034be8b0aaecdcb07e58275fb955a51c","hash":"846fa78e06044efd10dd58f8c510b6d360af14d8","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/f7/1b1e3be02f49fe52bf28afa7749410c3a8c830","hash":"5e43bd39b7e28c90282f334a54cc71873d11ffcf","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/objects/ff/b728baa6563211e2ea50061fcecaa285a28e7f","hash":"bcf43f1a7d4c476fe74ba5fbadd0c25d43be7f66","modified":1633175584550},{"_id":"themes/next_custom/source/lib/fastclick/.git/refs/heads/master","hash":"50a8a887e671d96e74b53affe344e960fb42c352","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/logs/refs/heads/master","hash":"9ce794659d0cbe1a9949b127755b86d89ae7d0f8","modified":1633175584560},{"_id":"themes/next_custom/source/lib/fastclick/.git/logs/refs/remotes/origin/HEAD","hash":"9ce794659d0cbe1a9949b127755b86d89ae7d0f8","modified":1633175584560},{"_id":"themes/next_custom/source/images/blue.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1633164874807},{"_id":"public/search.xml","hash":"63b02e0773906f2f1aeee36c615d0564fc08e806","modified":1633175977323},{"_id":"public/categories/index.html","hash":"0092467dcdb73d31cd9cf9e4d918b8ec194ceca9","modified":1633175977323},{"_id":"public/tags/index.html","hash":"b8aa06b74f9d86789bfb996fb6da0382acb3cb9c","modified":1633175977323},{"_id":"public/categories/rust-async/index.html","hash":"869ec4c8b15ebd1ac74a8185cd213ccf965d8996","modified":1633175977323},{"_id":"public/categories/rust-decl-macro/index.html","hash":"6786a242eaab0c22de42351b10d4c72e933fc2fd","modified":1633175977323},{"_id":"public/about/index.html","hash":"1fc66d1b7755c4a91168bee4e2773d11a85cb17d","modified":1633175977323},{"_id":"public/posts/rs-dm-p3.html","hash":"d28cbffc585870386ba4992674c54d1c042e5cc2","modified":1633175977323},{"_id":"public/posts/rs-dm-p2.html","hash":"dc4f960f6418cec008af58215c12e5bb69102ee9","modified":1633175977323},{"_id":"public/posts/rs-dm-p1.html","hash":"c934f41655728ad7537c26a712b9e35fd79afdcc","modified":1633175977323},{"_id":"public/posts/rs-async-p4.html","hash":"b83d22fe74da27a939d2a34d0bcb3c28b73ae515","modified":1633175977323},{"_id":"public/posts/rs-async-p3.html","hash":"52a9d29aa4371144939980d59c05e070f5653731","modified":1633175977323},{"_id":"public/posts/rs-async-p2.html","hash":"5e0090b77811da7eb40ff3631171aefaed5283f3","modified":1633175977323},{"_id":"public/posts/rs-async-p1.html","hash":"ba2a53989705e35adf1dc802c3247eadf7125c3c","modified":1633175977323},{"_id":"public/archives/index.html","hash":"b1e040edc669be6d3ff99c04084a6a755cb2887f","modified":1633175977323},{"_id":"public/archives/2021/index.html","hash":"8d65f4289c3ac1e53220ba241e403b6bd206d136","modified":1633175977323},{"_id":"public/archives/2021/09/index.html","hash":"5e27c424e79252710f76effcfa757449347fe7ff","modified":1633175977323},{"_id":"public/index.html","hash":"1980bfd0e04c859b15ea213c93e124074177148e","modified":1633175977323},{"_id":"public/tags/rust/index.html","hash":"a701d27aa333e9e73edef544a41d7edd9c9821ca","modified":1633175977323},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1633175977323},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1633175977323},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1633175977323},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1633175977323},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1633175977323},{"_id":"public/lib/fastclick/LICENSE","hash":"a8a12e6867d7ee39c21d9b11a984066099b6fb6b","modified":1633175977323},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1633175977323},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1633175977323},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1633175977323},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1633175977323},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1633175977323},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1633175977323},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1633175977323},{"_id":"public/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1633175977323},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1633175977323},{"_id":"public/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1633175977323},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1633175977323},{"_id":"public/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1633175977323},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1633175977323},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1633175977323},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1633175977323},{"_id":"public/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1633175977323},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1633175977323},{"_id":"public/lib/fastclick/README.html","hash":"51b078aa62fd9b8911ef40a9d03fc85d72990672","modified":1633175977323},{"_id":"public/lib/fastclick/default.json","hash":"5427a63d19b4b034a3a74e9ee6fcb8ae11b230df","modified":1633175977323},{"_id":"public/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1633175977323},{"_id":"public/lib/fastclick/package.json","hash":"1d7632f6e738677af1a67398ce09ab93e175740f","modified":1633175977323},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1633175977323},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1633175977323},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1633175977323},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1633175977323},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1633175977323},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1633175977323},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1633175977323},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1633175977323},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1633175977323},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1633175977323},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1633175977323},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1633175977323},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1633175977323},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1633175977323},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1633175977323},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1633175977323},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1633175977323},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1633175977323},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1633175977323},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1633175977323},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1633175977323},{"_id":"public/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1633175977323},{"_id":"public/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1633175977323},{"_id":"public/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1633175977323},{"_id":"public/css/main.css","hash":"1653f7b2797bac19092a5989904473e3b6a97ae8","modified":1633175977323},{"_id":"public/images/blue.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1633175977323}],"Category":[{"name":"rust-async","_id":"cku9qt5fp0004bw5k3x4o0g7y"},{"name":"rust-decl-macro","_id":"cku9qt5fy000mbw5k5fra2f7z"}],"Data":[],"Page":[{"title":"about","type":"about","date":"2021-09-19T15:00:11.000Z","comments":0,"_content":"- - - \n# 缘起\n就是汝, 召唤了吾吗......\n啥? 得称呼汝为Master才对?  \n\n那么......  \n(深吸一口气, 身体前倾)   \n\n欧~~拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！","source":"about/index.md","raw":"---\ntitle: about\ntype: about\ndate: 2021-09-19 23:00:11\ncomments: false\n---\n- - - \n# 缘起\n就是汝, 召唤了吾吗......\n啥? 得称呼汝为Master才对?  \n\n那么......  \n(深吸一口气, 身体前倾)   \n\n欧~~拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！","updated":"2021-10-02T07:11:36.553Z","path":"about/index.html","layout":"page","_id":"cku9qt5fh0000bw5k4kxl3roz","content":"<hr>\n<h1 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h1><p>就是汝, 召唤了吾吗……<br>啥? 得称呼汝为Master才对?  </p>\n<p>那么……<br>(深吸一口气, 身体前倾)   </p>\n<p>欧~~拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h1 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h1><p>就是汝, 召唤了吾吗……<br>啥? 得称呼汝为Master才对?  </p>\n<p>那么……<br>(深吸一口气, 身体前倾)   </p>\n<p>欧~~拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉欧拉！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>\n"},{"title":"categories","type":"categories","date":"2021-09-12T06:59:09.000Z","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: categories\ndate: 2021-09-12 14:59:09\ncomments: false\n---\n","updated":"2021-10-02T07:11:36.553Z","path":"categories/index.html","layout":"page","_id":"cku9qt5fm0002bw5k2h871p3c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","date":"2021-09-12T02:47:40.000Z","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: tags\ndate: 2021-09-12 10:47:40\ncomments: false\n---","updated":"2021-10-02T07:11:36.553Z","path":"tags/index.html","layout":"page","_id":"cku9qt5fr0006bw5k3y556s2a","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"rs-async-p1-系列说明","abbrlink":"rs-async-p1","date":"2021-09-12T03:43:19.000Z","top":9999,"_content":"> 欢迎大家来到 Rust 的 异步 系列教学  \n<!-- more -->\n# 课程说明  \n传送门如下:  \n- [博客 : Rust异步系列](https://jedsek.github.io/categories/rust-async/) \n- [B站视频 : Rust编程语言-异步(Async)](https://www.bilibili.com/video/BV1uh41167Np)\n\n`博客` 的更新速度, 快于 `视频`  \n`博客` 若经过重写, 则会抽时间更新 `视频`     \n\n此系列, 我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n\n但你至少得明白 `线程`, `std::thread::spawn`, `handle(句柄)`, `Rust基础语法` 等基本概念  \n\n不需要太深, 基础便已足够  \n- - - \n# 资料来源\n1. `官方书籍`  \n[官方异步书籍](https://rust-lang.github.io/async-book/**)\n\n2. `第三方书籍`\n\n- [async_std](https://book.async.rs/overview/async-std)\n\n- [tokio](https://tokio.rs/tokio/tutorial)\n\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n3. `文章/博客`\n\n- [Withoutboats's blogs](https://without.boats/blog/)\n\n\n\n______________ \n\n# 欢迎骚扰  \n在下QQ: `2948804617`   \n如果有问题, 可以一起探讨 ~~(但别忘了我是大菜鸡哦)~~  \n\n你也可以在文章下进行评论","source":"_posts/rs-async/rs-async-p1-系列说明.md","raw":"---\ntitle: rs-async-p1-系列说明\nabbrlink: rs-async-p1\ndate: 2021-09-12 11:43:19\ntop: 9999\ntags: rust  \ncategories: rust-async\n---\n> 欢迎大家来到 Rust 的 异步 系列教学  \n<!-- more -->\n# 课程说明  \n传送门如下:  \n- [博客 : Rust异步系列](https://jedsek.github.io/categories/rust-async/) \n- [B站视频 : Rust编程语言-异步(Async)](https://www.bilibili.com/video/BV1uh41167Np)\n\n`博客` 的更新速度, 快于 `视频`  \n`博客` 若经过重写, 则会抽时间更新 `视频`     \n\n此系列, 我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n\n但你至少得明白 `线程`, `std::thread::spawn`, `handle(句柄)`, `Rust基础语法` 等基本概念  \n\n不需要太深, 基础便已足够  \n- - - \n# 资料来源\n1. `官方书籍`  \n[官方异步书籍](https://rust-lang.github.io/async-book/**)\n\n2. `第三方书籍`\n\n- [async_std](https://book.async.rs/overview/async-std)\n\n- [tokio](https://tokio.rs/tokio/tutorial)\n\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n3. `文章/博客`\n\n- [Withoutboats's blogs](https://without.boats/blog/)\n\n\n\n______________ \n\n# 欢迎骚扰  \n在下QQ: `2948804617`   \n如果有问题, 可以一起探讨 ~~(但别忘了我是大菜鸡哦)~~  \n\n你也可以在文章下进行评论","slug":"rs-async/rs-async-p1-系列说明","published":1,"updated":"2021-10-02T07:11:36.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5fj0001bw5k4i591ixs","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步 系列教学  </p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"课程说明\"><a href=\"#课程说明\" class=\"headerlink\" title=\"课程说明\"></a>课程说明</h1><p>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-async/\">博客 : Rust异步系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1uh41167Np\">B站视频 : Rust编程语言-异步(Async)</a></li>\n</ul>\n<p><code>博客</code> 的更新速度, 快于 <code>视频</code><br><code>博客</code> 若经过重写, 则会抽时间更新 <code>视频</code>     </p>\n<p>此系列, 我们将学习Rust中的 <code>异步 (Async)</code><br>当然也会介绍异步方面的相关概念咯</p>\n<p>但你至少得明白 <code>线程</code>, <code>std::thread::spawn</code>, <code>handle(句柄)</code>, <code>Rust基础语法</code> 等基本概念  </p>\n<p>不需要太深, 基础便已足够  </p>\n<hr>\n<h1 id=\"资料来源\"><a href=\"#资料来源\" class=\"headerlink\" title=\"资料来源\"></a>资料来源</h1><ol>\n<li><p><code>官方书籍</code><br><a href=\"https://rust-lang.github.io/async-book/**\">官方异步书籍</a></p>\n</li>\n<li><p><code>第三方书籍</code></p>\n</li>\n</ol>\n<ul>\n<li><p><a href=\"https://book.async.rs/overview/async-std\">async_std</a></p>\n</li>\n<li><p><a href=\"https://tokio.rs/tokio/tutorial\">tokio</a></p>\n</li>\n<li><p><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><code>文章/博客</code></li>\n</ol>\n<ul>\n<li><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a></li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><p>在下QQ: <code>2948804617</code><br>如果有问题, 可以一起探讨 <del>(但别忘了我是大菜鸡哦)</del>  </p>\n<p>你也可以在文章下进行评论</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步 系列教学  </p>\n</blockquote>","more":"<h1 id=\"课程说明\"><a href=\"#课程说明\" class=\"headerlink\" title=\"课程说明\"></a>课程说明</h1><p>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-async/\">博客 : Rust异步系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1uh41167Np\">B站视频 : Rust编程语言-异步(Async)</a></li>\n</ul>\n<p><code>博客</code> 的更新速度, 快于 <code>视频</code><br><code>博客</code> 若经过重写, 则会抽时间更新 <code>视频</code>     </p>\n<p>此系列, 我们将学习Rust中的 <code>异步 (Async)</code><br>当然也会介绍异步方面的相关概念咯</p>\n<p>但你至少得明白 <code>线程</code>, <code>std::thread::spawn</code>, <code>handle(句柄)</code>, <code>Rust基础语法</code> 等基本概念  </p>\n<p>不需要太深, 基础便已足够  </p>\n<hr>\n<h1 id=\"资料来源\"><a href=\"#资料来源\" class=\"headerlink\" title=\"资料来源\"></a>资料来源</h1><ol>\n<li><p><code>官方书籍</code><br><a href=\"https://rust-lang.github.io/async-book/**\">官方异步书籍</a></p>\n</li>\n<li><p><code>第三方书籍</code></p>\n</li>\n</ol>\n<ul>\n<li><p><a href=\"https://book.async.rs/overview/async-std\">async_std</a></p>\n</li>\n<li><p><a href=\"https://tokio.rs/tokio/tutorial\">tokio</a></p>\n</li>\n<li><p><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><code>文章/博客</code></li>\n</ol>\n<ul>\n<li><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a></li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><p>在下QQ: <code>2948804617</code><br>如果有问题, 可以一起探讨 <del>(但别忘了我是大菜鸡哦)</del>  </p>\n<p>你也可以在文章下进行评论</p>"},{"title":"rs-async-p2-异步简介","abbrlink":"rs-async-p2","top":9998,"date":"2021-09-12T04:04:09.000Z","_content":"> 来简单介绍一下异步吧  \n<!-- more -->\n# Intro to Async\n- - -\n## 什么是异步编程?\n\n\n**异步编程** (Asynchronous programming)  \n是一种 **并发编程模型** \n\n特点是通过少量 `OS_thread (系统线程)`  \n即可运行大量 `并发任务`  \n在某些场景下, 可以疯狂压榨cpu的性能\n~~(好吧, 有点废话......)~~\n- - -\n## 为什么选择异步?\n对于这个问题, 我们将对比 **异步** 与 其他 **并发模型**  \n以此来告诉大家, 为什么选择异步:  \n\n1.`OS Thread (系统线程)`  \n由操作系统提供线程, 进行并发, 如std::thread  \nGood_1:  \n简单易使用, 建模能力强, 足够传统  \nGood_2:  \n操作系统就是运行时, 与C语言交互方便  \nBad_1:  \n数据同步困难, 易发生数据竞争  \nBad_2:  \n小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n\n\n2.`Green Thread (绿色线程)`  \n它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身  \n绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程  \nGood:  \n这意味着, 程序本身对 Green_thread 有绝对的管理权  \n所以内存分配等方面的粒度更细, 根据任务大小调度内存  \n因此堆栈大小, 能够随时间推移而增长  \n并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  \nBad_1:  \n它是程序本身实现模拟出来的线程, Runtime 比较巨大  \n运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互  \n这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象  \n它无法在语言层面被Rust支持  \nBad_2:  \n绿色线程在不同平台上, 其实现可能不同  \n对多平台的 支持/维护/改进 得靠实现者保证  \n\n由于 `OS Thread` 与 `Green Thread` 与 Rust 关系比较大:  \n一个是传统并发, 一个是Rust在1.0之后便舍弃的\n所以只介绍这两个并发模型\n- - -\n## 异步优势\n3.`Async (异步)`  \n我们终于要介绍异步了 ! 乌拉乌拉乌拉 ! ! !     \n ~~(没把你憋坏吧伙计?)~~  \n \n我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一  \n假设我们正在单线程下, 读取文件, 并进行一个计算:  \n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read(file);\n\n// 进行一个计算\ncompute()\n```\n以上面代码为例子, 我们会读取 `file` 获取 `data`   \n期间, 我们的程序, 做不了任何其他事情  \n只有等待 `IO操作 (Input/Output, 输入/输出)` 完毕, 我们才能进行接下来的 `compute`  \n\n`读取文件`, 属于 `IO操作`  \n众所周知, IO操作很耗时, 等待它完成的时间可能会很长  \n\n有没有什么办法加快速度?  \n没错, 系统线程yyds:\n\n```rust\n// 定义文件\nlet file = /*  */\n\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n\n// 使用join阻塞调用线程, 确保句柄线程执行结束\nlet data = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n因为两个任务 `read` 与 `compute` 是独立的, 无依赖性  \n所以我们 `spawn` 了两个线程  \n第一个, 用于读取文件, 获取数据\n第二个, 用于在读取文件的同时, 执行着 `compute`    \n虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销   \n而异步, 就是只依靠单线程, 也能够完成上面的操作  \n\n(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  \n\n单线程中的异步(伪)代码如下:\n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read_async(file);\n\n// 进行一个计算\ncompute_async()\n```\n\n你会注意到:  \n`read` -> `read_async`  \n`compute` -> `compute_async`  \n\n我用伪代码表示, 这两个操作变成了异步操作  \n你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念  \n如下:    \n\n- `read`:  \n它会阻塞调用线程, 等待该操作完毕后  \n才继续往下执行 `compute`  \n\n阻塞期间是几乎不需要cpu参与运行的  \n程序此时傻乎乎地等待阻塞结束  \n无疑是对性能的浪费, 对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时, 会运行`compute_async`  \n线程由 `read_async` 接管变为由 `compute_async`接管  \n当阻塞时间结束, 则程序继续变为运行 `read_async`\n\n`read_async` 阻塞时, 程序是不会傻傻等待的:  \n\n若检测到它处于阻塞, 无法取得进展    \n则会运行其他异步任务, 由其他异步任务接管线程  \n- - - \n总而言之, 异步操作, 其实就是:  \n若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)  \n使得cpu一直处于运算, 性能被极限压榨  \n\n异步操作, 就像是可以随意 `start/stop` 一般  \n调度程序能够对它们进行调度, 决定当前要运算哪个操作  \n确保不会因为阻塞而傻傻等待\n\n只需单线程, 就可以做到同时运行多个 `Task(异步任务)`  \n异步当然也不排斥多线程:  \n一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?\n- - -\n\n\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技  \n所以cpu对IO操作的压力较小/没有, IO时能进行其他运算  \n只需要最后接收数据时, 出个场就行了  \n\n所以我们的程序不需要在等待输入输出时就那样等着  \n给他们找事情, 让他们闲不下来吧!  \n\n","source":"_posts/rs-async/rs-async-p2-异步简介.md","raw":"---\ntitle: rs-async-p2-异步简介\nabbrlink: rs-async-p2\ntop: 9998\ntags: rust\ncategories: rust-async\ndate: 2021-09-12 12:04:09\n---\n> 来简单介绍一下异步吧  \n<!-- more -->\n# Intro to Async\n- - -\n## 什么是异步编程?\n\n\n**异步编程** (Asynchronous programming)  \n是一种 **并发编程模型** \n\n特点是通过少量 `OS_thread (系统线程)`  \n即可运行大量 `并发任务`  \n在某些场景下, 可以疯狂压榨cpu的性能\n~~(好吧, 有点废话......)~~\n- - -\n## 为什么选择异步?\n对于这个问题, 我们将对比 **异步** 与 其他 **并发模型**  \n以此来告诉大家, 为什么选择异步:  \n\n1.`OS Thread (系统线程)`  \n由操作系统提供线程, 进行并发, 如std::thread  \nGood_1:  \n简单易使用, 建模能力强, 足够传统  \nGood_2:  \n操作系统就是运行时, 与C语言交互方便  \nBad_1:  \n数据同步困难, 易发生数据竞争  \nBad_2:  \n小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n\n\n2.`Green Thread (绿色线程)`  \n它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身  \n绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程  \nGood:  \n这意味着, 程序本身对 Green_thread 有绝对的管理权  \n所以内存分配等方面的粒度更细, 根据任务大小调度内存  \n因此堆栈大小, 能够随时间推移而增长  \n并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  \nBad_1:  \n它是程序本身实现模拟出来的线程, Runtime 比较巨大  \n运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互  \n这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象  \n它无法在语言层面被Rust支持  \nBad_2:  \n绿色线程在不同平台上, 其实现可能不同  \n对多平台的 支持/维护/改进 得靠实现者保证  \n\n由于 `OS Thread` 与 `Green Thread` 与 Rust 关系比较大:  \n一个是传统并发, 一个是Rust在1.0之后便舍弃的\n所以只介绍这两个并发模型\n- - -\n## 异步优势\n3.`Async (异步)`  \n我们终于要介绍异步了 ! 乌拉乌拉乌拉 ! ! !     \n ~~(没把你憋坏吧伙计?)~~  \n \n我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一  \n假设我们正在单线程下, 读取文件, 并进行一个计算:  \n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read(file);\n\n// 进行一个计算\ncompute()\n```\n以上面代码为例子, 我们会读取 `file` 获取 `data`   \n期间, 我们的程序, 做不了任何其他事情  \n只有等待 `IO操作 (Input/Output, 输入/输出)` 完毕, 我们才能进行接下来的 `compute`  \n\n`读取文件`, 属于 `IO操作`  \n众所周知, IO操作很耗时, 等待它完成的时间可能会很长  \n\n有没有什么办法加快速度?  \n没错, 系统线程yyds:\n\n```rust\n// 定义文件\nlet file = /*  */\n\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n\n// 使用join阻塞调用线程, 确保句柄线程执行结束\nlet data = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n因为两个任务 `read` 与 `compute` 是独立的, 无依赖性  \n所以我们 `spawn` 了两个线程  \n第一个, 用于读取文件, 获取数据\n第二个, 用于在读取文件的同时, 执行着 `compute`    \n虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销   \n而异步, 就是只依靠单线程, 也能够完成上面的操作  \n\n(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  \n\n单线程中的异步(伪)代码如下:\n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read_async(file);\n\n// 进行一个计算\ncompute_async()\n```\n\n你会注意到:  \n`read` -> `read_async`  \n`compute` -> `compute_async`  \n\n我用伪代码表示, 这两个操作变成了异步操作  \n你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念  \n如下:    \n\n- `read`:  \n它会阻塞调用线程, 等待该操作完毕后  \n才继续往下执行 `compute`  \n\n阻塞期间是几乎不需要cpu参与运行的  \n程序此时傻乎乎地等待阻塞结束  \n无疑是对性能的浪费, 对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时, 会运行`compute_async`  \n线程由 `read_async` 接管变为由 `compute_async`接管  \n当阻塞时间结束, 则程序继续变为运行 `read_async`\n\n`read_async` 阻塞时, 程序是不会傻傻等待的:  \n\n若检测到它处于阻塞, 无法取得进展    \n则会运行其他异步任务, 由其他异步任务接管线程  \n- - - \n总而言之, 异步操作, 其实就是:  \n若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)  \n使得cpu一直处于运算, 性能被极限压榨  \n\n异步操作, 就像是可以随意 `start/stop` 一般  \n调度程序能够对它们进行调度, 决定当前要运算哪个操作  \n确保不会因为阻塞而傻傻等待\n\n只需单线程, 就可以做到同时运行多个 `Task(异步任务)`  \n异步当然也不排斥多线程:  \n一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?\n- - -\n\n\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技  \n所以cpu对IO操作的压力较小/没有, IO时能进行其他运算  \n只需要最后接收数据时, 出个场就行了  \n\n所以我们的程序不需要在等待输入输出时就那样等着  \n给他们找事情, 让他们闲不下来吧!  \n\n","slug":"rs-async/rs-async-p2-异步简介","published":1,"updated":"2021-10-02T07:11:36.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5fn0003bw5k5e0ddfdy","content":"<blockquote>\n<p>来简单介绍一下异步吧  </p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Intro-to-Async\"><a href=\"#Intro-to-Async\" class=\"headerlink\" title=\"Intro to Async\"></a>Intro to Async</h1><hr>\n<h2 id=\"什么是异步编程\"><a href=\"#什么是异步编程\" class=\"headerlink\" title=\"什么是异步编程?\"></a>什么是异步编程?</h2><p><strong>异步编程</strong> (Asynchronous programming)<br>是一种 <strong>并发编程模型</strong> </p>\n<p>特点是通过少量 <code>OS_thread (系统线程)</code><br>即可运行大量 <code>并发任务</code><br>在某些场景下, 可以疯狂压榨cpu的性能<br><del>(好吧, 有点废话……)</del></p>\n<hr>\n<h2 id=\"为什么选择异步\"><a href=\"#为什么选择异步\" class=\"headerlink\" title=\"为什么选择异步?\"></a>为什么选择异步?</h2><p>对于这个问题, 我们将对比 <strong>异步</strong> 与 其他 <strong>并发模型</strong><br>以此来告诉大家, 为什么选择异步:  </p>\n<p>1.<code>OS Thread (系统线程)</code><br>由操作系统提供线程, 进行并发, 如std::thread<br>Good_1:<br>简单易使用, 建模能力强, 足够传统<br>Good_2:<br>操作系统就是运行时, 与C语言交互方便<br>Bad_1:<br>数据同步困难, 易发生数据竞争<br>Bad_2:<br>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>\n<p>2.<code>Green Thread (绿色线程)</code><br>它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身<br>绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程<br>Good:<br>这意味着, 程序本身对 Green_thread 有绝对的管理权<br>所以内存分配等方面的粒度更细, 根据任务大小调度内存<br>因此堆栈大小, 能够随时间推移而增长<br>并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务<br>Bad_1:<br>它是程序本身实现模拟出来的线程, Runtime 比较巨大<br>运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互<br>这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象<br>它无法在语言层面被Rust支持<br>Bad_2:<br>绿色线程在不同平台上, 其实现可能不同<br>对多平台的 支持/维护/改进 得靠实现者保证  </p>\n<p>由于 <code>OS Thread</code> 与 <code>Green Thread</code> 与 Rust 关系比较大:<br>一个是传统并发, 一个是Rust在1.0之后便舍弃的<br>所以只介绍这两个并发模型</p>\n<hr>\n<h2 id=\"异步优势\"><a href=\"#异步优势\" class=\"headerlink\" title=\"异步优势\"></a>异步优势</h2><p>3.<code>Async (异步)</code><br>我们终于要介绍异步了 ! 乌拉乌拉乌拉 ! ! !<br> <del>(没把你憋坏吧伙计?)</del>  </p>\n<p>我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一<br>假设我们正在单线程下, 读取文件, 并进行一个计算:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>以上面代码为例子, 我们会读取 <code>file</code> 获取 <code>data</code><br>期间, 我们的程序, 做不了任何其他事情<br>只有等待 <code>IO操作 (Input/Output, 输入/输出)</code> 完毕, 我们才能进行接下来的 <code>compute</code>  </p>\n<p><code>读取文件</code>, 属于 <code>IO操作</code><br>众所周知, IO操作很耗时, 等待它完成的时间可能会很长  </p>\n<p>有没有什么办法加快速度?<br>没错, 系统线程yyds:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n\n<p>因为两个任务 <code>read</code> 与 <code>compute</code> 是独立的, 无依赖性<br>所以我们 <code>spawn</code> 了两个线程<br>第一个, 用于读取文件, 获取数据<br>第二个, 用于在读取文件的同时, 执行着 <code>compute</code><br>虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销<br>而异步, 就是只依靠单线程, 也能够完成上面的操作  </p>\n<p>(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  </p>\n<p>单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read_async(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到:<br><code>read</code> -&gt; <code>read_async</code><br><code>compute</code> -&gt; <code>compute_async</code>  </p>\n<p>我用伪代码表示, 这两个操作变成了异步操作<br>你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念<br>如下:    </p>\n<ul>\n<li><code>read</code>:<br>它会阻塞调用线程, 等待该操作完毕后<br>才继续往下执行 <code>compute</code>  </li>\n</ul>\n<p>阻塞期间是几乎不需要cpu参与运行的<br>程序此时傻乎乎地等待阻塞结束<br>无疑是对性能的浪费, 对cpu的不尊重  </p>\n<ul>\n<li><code>read_async</code>:<br>它处于阻塞时, 会运行<code>compute_async</code><br>线程由 <code>read_async</code> 接管变为由 <code>compute_async</code>接管<br>当阻塞时间结束, 则程序继续变为运行 <code>read_async</code></li>\n</ul>\n<p><code>read_async</code> 阻塞时, 程序是不会傻傻等待的:  </p>\n<p>若检测到它处于阻塞, 无法取得进展<br>则会运行其他异步任务, 由其他异步任务接管线程  </p>\n<hr>\n<p>总而言之, 异步操作, 其实就是:<br>若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>使得cpu一直处于运算, 性能被极限压榨  </p>\n<p>异步操作, 就像是可以随意 <code>start/stop</code> 一般<br>调度程序能够对它们进行调度, 决定当前要运算哪个操作<br>确保不会因为阻塞而傻傻等待</p>\n<p>只需单线程, 就可以做到同时运行多个 <code>Task(异步任务)</code><br>异步当然也不排斥多线程:<br>一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?</p>\n<hr>\n<p>Q:<br>阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>A:<br>现代电脑发展出了一些分担IO操作压力的高科技<br>所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>只需要最后接收数据时, 出个场就行了  </p>\n<p>所以我们的程序不需要在等待输入输出时就那样等着<br>给他们找事情, 让他们闲不下来吧!  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>来简单介绍一下异步吧  </p>\n</blockquote>","more":"<h1 id=\"Intro-to-Async\"><a href=\"#Intro-to-Async\" class=\"headerlink\" title=\"Intro to Async\"></a>Intro to Async</h1><hr>\n<h2 id=\"什么是异步编程\"><a href=\"#什么是异步编程\" class=\"headerlink\" title=\"什么是异步编程?\"></a>什么是异步编程?</h2><p><strong>异步编程</strong> (Asynchronous programming)<br>是一种 <strong>并发编程模型</strong> </p>\n<p>特点是通过少量 <code>OS_thread (系统线程)</code><br>即可运行大量 <code>并发任务</code><br>在某些场景下, 可以疯狂压榨cpu的性能<br><del>(好吧, 有点废话……)</del></p>\n<hr>\n<h2 id=\"为什么选择异步\"><a href=\"#为什么选择异步\" class=\"headerlink\" title=\"为什么选择异步?\"></a>为什么选择异步?</h2><p>对于这个问题, 我们将对比 <strong>异步</strong> 与 其他 <strong>并发模型</strong><br>以此来告诉大家, 为什么选择异步:  </p>\n<p>1.<code>OS Thread (系统线程)</code><br>由操作系统提供线程, 进行并发, 如std::thread<br>Good_1:<br>简单易使用, 建模能力强, 足够传统<br>Good_2:<br>操作系统就是运行时, 与C语言交互方便<br>Bad_1:<br>数据同步困难, 易发生数据竞争<br>Bad_2:<br>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>\n<p>2.<code>Green Thread (绿色线程)</code><br>它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身<br>绿色线程 只是由程序本身模拟出来的, 类似系统线程的小型线程<br>Good:<br>这意味着, 程序本身对 Green_thread 有绝对的管理权<br>所以内存分配等方面的粒度更细, 根据任务大小调度内存<br>因此堆栈大小, 能够随时间推移而增长<br>并且创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务<br>Bad_1:<br>它是程序本身实现模拟出来的线程, Runtime 比较巨大<br>运行时会一直存在, 即使你不用该特性, 导致拖累全局程序性能, 且难以与C库交互<br>这Rust在1.0版本前删去绿色线程的主要原因, 贯彻了零成本抽象<br>它无法在语言层面被Rust支持<br>Bad_2:<br>绿色线程在不同平台上, 其实现可能不同<br>对多平台的 支持/维护/改进 得靠实现者保证  </p>\n<p>由于 <code>OS Thread</code> 与 <code>Green Thread</code> 与 Rust 关系比较大:<br>一个是传统并发, 一个是Rust在1.0之后便舍弃的<br>所以只介绍这两个并发模型</p>\n<hr>\n<h2 id=\"异步优势\"><a href=\"#异步优势\" class=\"headerlink\" title=\"异步优势\"></a>异步优势</h2><p>3.<code>Async (异步)</code><br>我们终于要介绍异步了 ! 乌拉乌拉乌拉 ! ! !<br> <del>(没把你憋坏吧伙计?)</del>  </p>\n<p>我们以IO操作为例子, 毕竟这也是 异步 大放光彩的地方之一<br>假设我们正在单线程下, 读取文件, 并进行一个计算:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>以上面代码为例子, 我们会读取 <code>file</code> 获取 <code>data</code><br>期间, 我们的程序, 做不了任何其他事情<br>只有等待 <code>IO操作 (Input/Output, 输入/输出)</code> 完毕, 我们才能进行接下来的 <code>compute</code>  </p>\n<p><code>读取文件</code>, 属于 <code>IO操作</code><br>众所周知, IO操作很耗时, 等待它完成的时间可能会很长  </p>\n<p>有没有什么办法加快速度?<br>没错, 系统线程yyds:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n\n<p>因为两个任务 <code>read</code> 与 <code>compute</code> 是独立的, 无依赖性<br>所以我们 <code>spawn</code> 了两个线程<br>第一个, 用于读取文件, 获取数据<br>第二个, 用于在读取文件的同时, 执行着 <code>compute</code><br>虽然速度上来了, 但是代价也有, 那就是额外创建两个线程的开销<br>而异步, 就是只依靠单线程, 也能够完成上面的操作  </p>\n<p>(绿色线程不用想了, 不是说它不好, 但是它有较大的运行时, 语言层面是不可能支持的, 第三方库支持是可以的)  </p>\n<p>单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read_async(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到:<br><code>read</code> -&gt; <code>read_async</code><br><code>compute</code> -&gt; <code>compute_async</code>  </p>\n<p>我用伪代码表示, 这两个操作变成了异步操作<br>你无需关注这是如何变成异步版本的, 这里只是为了说明异步的概念<br>如下:    </p>\n<ul>\n<li><code>read</code>:<br>它会阻塞调用线程, 等待该操作完毕后<br>才继续往下执行 <code>compute</code>  </li>\n</ul>\n<p>阻塞期间是几乎不需要cpu参与运行的<br>程序此时傻乎乎地等待阻塞结束<br>无疑是对性能的浪费, 对cpu的不尊重  </p>\n<ul>\n<li><code>read_async</code>:<br>它处于阻塞时, 会运行<code>compute_async</code><br>线程由 <code>read_async</code> 接管变为由 <code>compute_async</code>接管<br>当阻塞时间结束, 则程序继续变为运行 <code>read_async</code></li>\n</ul>\n<p><code>read_async</code> 阻塞时, 程序是不会傻傻等待的:  </p>\n<p>若检测到它处于阻塞, 无法取得进展<br>则会运行其他异步任务, 由其他异步任务接管线程  </p>\n<hr>\n<p>总而言之, 异步操作, 其实就是:<br>若当前异步操作处于阻塞, 则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>使得cpu一直处于运算, 性能被极限压榨  </p>\n<p>异步操作, 就像是可以随意 <code>start/stop</code> 一般<br>调度程序能够对它们进行调度, 决定当前要运算哪个操作<br>确保不会因为阻塞而傻傻等待</p>\n<p>只需单线程, 就可以做到同时运行多个 <code>Task(异步任务)</code><br>异步当然也不排斥多线程:<br>一个线程就能压榨出高性能, 多个线程被压榨出来的性能岂不是更高?</p>\n<hr>\n<p>Q:<br>阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>A:<br>现代电脑发展出了一些分担IO操作压力的高科技<br>所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>只需要最后接收数据时, 出个场就行了  </p>\n<p>所以我们的程序不需要在等待输入输出时就那样等着<br>给他们找事情, 让他们闲不下来吧!  </p>"},{"title":"rs-async-p3-Future","abbrlink":"rs-async-p3","date":"2021-09-12T05:56:48.000Z","top":9997,"_content":"> Rust 中的 Future/async/.await 说明  \n<!-- more -->\n\n# Future/async/.await  \n- - - \n## 开篇\n大家好! 我们上一节已经知晓异步的基础概念   \n现在, 来看看Rust中的异步语法吧    \n\n在本节, 我们会知晓以下三个概念的大致含义:  \n(暂时不涉及背后原理, 原理之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n开始旅途吧  \n- - -\n## What's Future  \n`Future`, 一个标准/核心库中的trait  \n其完整路径为 `std/core::future::Future`   \n\n此节我只会讲它的大致含义, 原理则放到后面几节专门来讲 ~~(原理太难, 一节根本不够)~~  \n\n\n在Rust中, 一个实现了 Future(trait) 的类型  \n该类型的实例 (有时候直接被简称为 一个Future实例) 便代表 一次异步计算  \n可以将其交给 `Runtime(运行时)`, 从而异步执行   \n\n`异步执行`, 也就是指:    \n当其他 异步任务 阻塞时, 当前 异步任务 有机会执行  \n或当前 异步任务 阻塞时, 其他 异步任务 有机会执行  \n总而言之, 阻塞时期执行其他任务, 不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别, 举个例子你就明白了:  \n\n  \n假设有这么个 父计算, 由两个 子计算 组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出, 一次 计算, 是可以由多个 子计算 组成的  \n同时, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期  \n因为 `子计算们可能存在依赖关系` (在这里的例子中确实存在) \n\n\n因此, 当某个 子计算 阻塞时, 它所属的最顶层的 父计算 也会阻塞, 避免了 Runtime 调度非法计算  \n(我们将 `最顶层的父计算 (top-level Future, 即最顶层的Future实例)` 称为 `Task(任务)`)  \n\n`当前Task` 阻塞时, 接管执行权的, 不能是 当前Task 中的 `其他子计算`  \n只能是 `其他Task中的子计算`  \n\n来点总结吧:  \n- Task 是一个顶层Future实例 (即一次顶层异步计算) \n\n- 一个Future可以由多个Future组成, 即一个Future里可以执行多个Future\n- Task_A阻塞时, 接管执行的是其他Task中的子计算, 不能是Task_A中的子计算\n- Task可以只是一次单独计算\n\n`一个Future (一次异步计算)`  \n可理解为, 是组成 `一个Task (一个异步任务)` 的最小单位 \n\n了解到了那么一点点后, 现在来正式看看呗 ?  \n- - -\n## Future的定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output:  \n代表 该Future, 异步执行完毕后, 产出的值的类型   \n- poll:  \n所有执行操作都会放在该函数中  \nRuntime 会不断调用 poll函数 来推进 该异步计算 的完成  \n每次 poll 的返回值是一个 枚举变体, 代表 是否完成\n- Poll<T>:  \n枚举类型, 作为 poll函数 的返回值类型, 其 变体 有:  \n`Poll::Pending`:  \n指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)     \n`Poll::Ready(T)`: \n指明该计算执行完毕, 并产出一个类型为T的值   \n\n若只是普通使用者, 并不需了解 `Future的定义` 背后之原理  \n但若不了解它, 又如何为某类型实现 Future 呢?  \n\n别急, Rust 为我们提供了关键字 `async`, 接着往下看吧   \n- - -\n## What's async  \n`async`, 一个关键字  \n用来创建 `一个匿名结构体的实例, 该结构体实现了Future`  \n即, 它创建一个 `Future实例`  \n\n来个例子, 看看 async 的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n\n\n// 2 \nstruct HelloStr;\n\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\n\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到, 使用 async 进行了符合直觉的简化  \n这两种函数, 实际上是等价的  \n\n看看它们两的返回值, 如下:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n\n\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n- - -\n注意, 异步函数的调用, 只是返回一个 Future实例  \n**但并没有开始执行, 它是惰性的**  \n**只有调用Future的poll方法, 才能推动它的执行**  \n**而调用poll方法的工作, 则交给了运行时(执行器)**  \n\n这样的好处就在于:  \n将一个异步计算看作一个变量, 方便了传参等工作  \n\n比如, 你想舍弃某次 异步任务, 你只需要将 对应的Future实例 给 drop 掉, 使其所有权丢失即可\n\nasync 的作用就是创建一个 Future实例:  \n- `async fn` 异步函数, 要求返回一个 Future实例   \n- `async block` 异步代码块, 创建一个 Future实例  \n- `async closure` 异步闭包, (目前是不稳定特性) 创建一个 Future实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二  \n但是如何执行一个Future实例?  \n\n欲知后事如何, 请听下文揭晓 \n- - - \n\n## Future的执行\n### 背景介绍  \nRust语言本身并不提供 `异步运行时 (async runtime)`, 以便于语言内核保持精小, 便于进化/迭代/维护  \n异步运行时 由社区提供, 围绕语言本身提供的定义 (比如 Future) 进行支持/扩充, 来运行异步程序  \n\n可以仔细看看 Future 的完整路径: std::future/core::Future  \n注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) \n\n这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义  \n再加上异步运行时是可选的, 凭借 `cartes.io` 上提供的异步运行时相关的carte  \n在嵌入式环境下, 也能够轻松运行异步程序   \n\n在正式开始之前\n请确保你已经在 `Cargo.toml` 中添加了如下代码:   \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n以 `async-std` 这个比较主流, 对新人友好的 `异步运行时crate` 为例子   \n我们指定了版本, 并且启用了 `attributes` 这个特性  \n\n好了, 马上开始咯!  \n\n- - -\n### 通过运行时执行\n\n我们先来创建一个 `打印 \"hello world\" 的Future` 吧  \n并且使用 `async-std` 这个异步运行时环境来执行它:   \n\n```rust\nuse async_std::task;\n\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n还记得我们在本节开始不久, 就提到过的 `异步任务 (Top-level Future, 即顶层的异步计算)` 吗?  \nasync_std::task, 该模块, 为我们提供了大量api, 来执行/操控 这些 `Task`  \n\n比如这里出现的 `task::block_on`:  \n传入一个 Future实例, Runtime 会执行它(调用poll方法), 并阻塞调用线程  \n该任务执行完毕后产出的值, 会作为 `block_on` 的返回值  \n\n我们执行了一个 Task, 并且这个 Task 是单个的 Future  \n但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n\n`.await` 关键字出场了! \n\n- - -\n### .await 关键字  \n`.await` 只能出现在 `async fn/block` 内部  \n在某个 Future实例 的后面, 增加 `.await`, 那么 `该Future实例` 则会执行  \n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话, 得将 Future实例 交给运行时, 带动着执行里面的 子Future   \n\n来看看它的使用:  \n```rust\nuse async_std::task;\n\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await` 是一个标记点, 可以理解为是一个 `yield point`  \nRuntime 执行到 `xxx.await` 时, 先会执行一次 `xxx`  \n\n\n一开始, 会调用一次poll函数, 推动执行进度  \n通过它的返回值, `Poll<T>枚举的变体`, 即 `Pending` 或 `Ready(T)`  \n来决定: \n1. 让 其他Task 接管执行权 (yield)  \n2. 该Future执行完毕, 继续执行当前 Task  \n\n若为 `Ready`, 则选 `2`, 继续往下执行 (一个 Task 可能是由多个 Future 所组成)  \n若为 `Pending`, 则选 `1`, 让其他任务接管执行权 (比如IO操作的阻塞期间, 让其他任务执行)  \n\n稍微有点涉及原理部分, 可能有点难理解, 来个简单粗暴理解版:  \n\n`.await` 会指明 `执行某个Future` 这一逻辑  \n当 `xxx.await` 所在的 Task 交给 Runtime 执行, 并执行到 `xxx.await` 时    \n`xxx` 这个Future实例会执行  \n\n若它阻塞 (这意味着 该Future所在的Task 也阻塞)  \n所以调度程序安排 其他Task, 在该空档期执行  \n若不阻塞, 就继续往下执行 (可能还有碰见 `.await` 哟), 直到 该Task 结束   \n\n- - -  \n\n### 补充\n- `#[async_std::main]`  \n这玩意无比常见, 是个属性宏, 要加在 main函数 头上  \n使得 main 前面能被 async 所修饰  \n程序运行时, main函数返回的 Future, 会自动交给 Runtime 开始运行, 如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见, 所以就讲一讲:  \n向其传入 Future, 运行时会开始运行 该Task, 并返回 async_std::task::JoinHandle 的实例\n它实现了 Future, 与标准库中的 `JoinHandle` 无比相似  \n不过那个运行 Thread, 而这个运行 Task, `join` 相应地变成 `.await`  \n想让 该handle代表的Task 运行完毕, 应该在 该handle 前放上 `.await`:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n- - -\n\n## 尾声  \n终于结束了, 这一篇其实是重写版, 写到这真的累死了  \n\n我们学到了一些东西 (不涉及原理, 之后专门抽几节讲......):      \n- `Future`   \n- `async fn/block`\n- `.await`  \n- `Async-Runtime's API`  \n\n只需要使用的, 看到这其实已经差不多了  \n普通异步程序也不怎么需要看 `Future` 定义中的 `poll` 方法  \n那里涉及到比较烦人的背后原理......  \n\n如果有问题的话, 可以在评论区留言\n或者加在下qq交流也行 : `2948804617`  \n\n呼, 真的累死, 看番去了!  \n一周后再更吧 ~~(鸽神是也)~~\n","source":"_posts/rs-async/rs-async-p3-Future.md","raw":"---\ntitle: rs-async-p3-Future\nabbrlink: rs-async-p3\ndate: 2021-09-12 13:56:48\ntop: 9997\ntags: rust\ncategories: rust-async\n---\n> Rust 中的 Future/async/.await 说明  \n<!-- more -->\n\n# Future/async/.await  \n- - - \n## 开篇\n大家好! 我们上一节已经知晓异步的基础概念   \n现在, 来看看Rust中的异步语法吧    \n\n在本节, 我们会知晓以下三个概念的大致含义:  \n(暂时不涉及背后原理, 原理之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n开始旅途吧  \n- - -\n## What's Future  \n`Future`, 一个标准/核心库中的trait  \n其完整路径为 `std/core::future::Future`   \n\n此节我只会讲它的大致含义, 原理则放到后面几节专门来讲 ~~(原理太难, 一节根本不够)~~  \n\n\n在Rust中, 一个实现了 Future(trait) 的类型  \n该类型的实例 (有时候直接被简称为 一个Future实例) 便代表 一次异步计算  \n可以将其交给 `Runtime(运行时)`, 从而异步执行   \n\n`异步执行`, 也就是指:    \n当其他 异步任务 阻塞时, 当前 异步任务 有机会执行  \n或当前 异步任务 阻塞时, 其他 异步任务 有机会执行  \n总而言之, 阻塞时期执行其他任务, 不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别, 举个例子你就明白了:  \n\n  \n假设有这么个 父计算, 由两个 子计算 组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出, 一次 计算, 是可以由多个 子计算 组成的  \n同时, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期  \n因为 `子计算们可能存在依赖关系` (在这里的例子中确实存在) \n\n\n因此, 当某个 子计算 阻塞时, 它所属的最顶层的 父计算 也会阻塞, 避免了 Runtime 调度非法计算  \n(我们将 `最顶层的父计算 (top-level Future, 即最顶层的Future实例)` 称为 `Task(任务)`)  \n\n`当前Task` 阻塞时, 接管执行权的, 不能是 当前Task 中的 `其他子计算`  \n只能是 `其他Task中的子计算`  \n\n来点总结吧:  \n- Task 是一个顶层Future实例 (即一次顶层异步计算) \n\n- 一个Future可以由多个Future组成, 即一个Future里可以执行多个Future\n- Task_A阻塞时, 接管执行的是其他Task中的子计算, 不能是Task_A中的子计算\n- Task可以只是一次单独计算\n\n`一个Future (一次异步计算)`  \n可理解为, 是组成 `一个Task (一个异步任务)` 的最小单位 \n\n了解到了那么一点点后, 现在来正式看看呗 ?  \n- - -\n## Future的定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output:  \n代表 该Future, 异步执行完毕后, 产出的值的类型   \n- poll:  \n所有执行操作都会放在该函数中  \nRuntime 会不断调用 poll函数 来推进 该异步计算 的完成  \n每次 poll 的返回值是一个 枚举变体, 代表 是否完成\n- Poll<T>:  \n枚举类型, 作为 poll函数 的返回值类型, 其 变体 有:  \n`Poll::Pending`:  \n指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)     \n`Poll::Ready(T)`: \n指明该计算执行完毕, 并产出一个类型为T的值   \n\n若只是普通使用者, 并不需了解 `Future的定义` 背后之原理  \n但若不了解它, 又如何为某类型实现 Future 呢?  \n\n别急, Rust 为我们提供了关键字 `async`, 接着往下看吧   \n- - -\n## What's async  \n`async`, 一个关键字  \n用来创建 `一个匿名结构体的实例, 该结构体实现了Future`  \n即, 它创建一个 `Future实例`  \n\n来个例子, 看看 async 的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n\n\n// 2 \nstruct HelloStr;\n\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\n\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到, 使用 async 进行了符合直觉的简化  \n这两种函数, 实际上是等价的  \n\n看看它们两的返回值, 如下:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n\n\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n- - -\n注意, 异步函数的调用, 只是返回一个 Future实例  \n**但并没有开始执行, 它是惰性的**  \n**只有调用Future的poll方法, 才能推动它的执行**  \n**而调用poll方法的工作, 则交给了运行时(执行器)**  \n\n这样的好处就在于:  \n将一个异步计算看作一个变量, 方便了传参等工作  \n\n比如, 你想舍弃某次 异步任务, 你只需要将 对应的Future实例 给 drop 掉, 使其所有权丢失即可\n\nasync 的作用就是创建一个 Future实例:  \n- `async fn` 异步函数, 要求返回一个 Future实例   \n- `async block` 异步代码块, 创建一个 Future实例  \n- `async closure` 异步闭包, (目前是不稳定特性) 创建一个 Future实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二  \n但是如何执行一个Future实例?  \n\n欲知后事如何, 请听下文揭晓 \n- - - \n\n## Future的执行\n### 背景介绍  \nRust语言本身并不提供 `异步运行时 (async runtime)`, 以便于语言内核保持精小, 便于进化/迭代/维护  \n异步运行时 由社区提供, 围绕语言本身提供的定义 (比如 Future) 进行支持/扩充, 来运行异步程序  \n\n可以仔细看看 Future 的完整路径: std::future/core::Future  \n注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) \n\n这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义  \n再加上异步运行时是可选的, 凭借 `cartes.io` 上提供的异步运行时相关的carte  \n在嵌入式环境下, 也能够轻松运行异步程序   \n\n在正式开始之前\n请确保你已经在 `Cargo.toml` 中添加了如下代码:   \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n以 `async-std` 这个比较主流, 对新人友好的 `异步运行时crate` 为例子   \n我们指定了版本, 并且启用了 `attributes` 这个特性  \n\n好了, 马上开始咯!  \n\n- - -\n### 通过运行时执行\n\n我们先来创建一个 `打印 \"hello world\" 的Future` 吧  \n并且使用 `async-std` 这个异步运行时环境来执行它:   \n\n```rust\nuse async_std::task;\n\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n还记得我们在本节开始不久, 就提到过的 `异步任务 (Top-level Future, 即顶层的异步计算)` 吗?  \nasync_std::task, 该模块, 为我们提供了大量api, 来执行/操控 这些 `Task`  \n\n比如这里出现的 `task::block_on`:  \n传入一个 Future实例, Runtime 会执行它(调用poll方法), 并阻塞调用线程  \n该任务执行完毕后产出的值, 会作为 `block_on` 的返回值  \n\n我们执行了一个 Task, 并且这个 Task 是单个的 Future  \n但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n\n`.await` 关键字出场了! \n\n- - -\n### .await 关键字  \n`.await` 只能出现在 `async fn/block` 内部  \n在某个 Future实例 的后面, 增加 `.await`, 那么 `该Future实例` 则会执行  \n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话, 得将 Future实例 交给运行时, 带动着执行里面的 子Future   \n\n来看看它的使用:  \n```rust\nuse async_std::task;\n\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await` 是一个标记点, 可以理解为是一个 `yield point`  \nRuntime 执行到 `xxx.await` 时, 先会执行一次 `xxx`  \n\n\n一开始, 会调用一次poll函数, 推动执行进度  \n通过它的返回值, `Poll<T>枚举的变体`, 即 `Pending` 或 `Ready(T)`  \n来决定: \n1. 让 其他Task 接管执行权 (yield)  \n2. 该Future执行完毕, 继续执行当前 Task  \n\n若为 `Ready`, 则选 `2`, 继续往下执行 (一个 Task 可能是由多个 Future 所组成)  \n若为 `Pending`, 则选 `1`, 让其他任务接管执行权 (比如IO操作的阻塞期间, 让其他任务执行)  \n\n稍微有点涉及原理部分, 可能有点难理解, 来个简单粗暴理解版:  \n\n`.await` 会指明 `执行某个Future` 这一逻辑  \n当 `xxx.await` 所在的 Task 交给 Runtime 执行, 并执行到 `xxx.await` 时    \n`xxx` 这个Future实例会执行  \n\n若它阻塞 (这意味着 该Future所在的Task 也阻塞)  \n所以调度程序安排 其他Task, 在该空档期执行  \n若不阻塞, 就继续往下执行 (可能还有碰见 `.await` 哟), 直到 该Task 结束   \n\n- - -  \n\n### 补充\n- `#[async_std::main]`  \n这玩意无比常见, 是个属性宏, 要加在 main函数 头上  \n使得 main 前面能被 async 所修饰  \n程序运行时, main函数返回的 Future, 会自动交给 Runtime 开始运行, 如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见, 所以就讲一讲:  \n向其传入 Future, 运行时会开始运行 该Task, 并返回 async_std::task::JoinHandle 的实例\n它实现了 Future, 与标准库中的 `JoinHandle` 无比相似  \n不过那个运行 Thread, 而这个运行 Task, `join` 相应地变成 `.await`  \n想让 该handle代表的Task 运行完毕, 应该在 该handle 前放上 `.await`:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n- - -\n\n## 尾声  \n终于结束了, 这一篇其实是重写版, 写到这真的累死了  \n\n我们学到了一些东西 (不涉及原理, 之后专门抽几节讲......):      \n- `Future`   \n- `async fn/block`\n- `.await`  \n- `Async-Runtime's API`  \n\n只需要使用的, 看到这其实已经差不多了  \n普通异步程序也不怎么需要看 `Future` 定义中的 `poll` 方法  \n那里涉及到比较烦人的背后原理......  \n\n如果有问题的话, 可以在评论区留言\n或者加在下qq交流也行 : `2948804617`  \n\n呼, 真的累死, 看番去了!  \n一周后再更吧 ~~(鸽神是也)~~\n","slug":"rs-async/rs-async-p3-Future","published":1,"updated":"2021-10-02T07:11:36.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5fr0007bw5k5umff7cp","content":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明  </p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Future-async-await\"><a href=\"#Future-async-await\" class=\"headerlink\" title=\"Future/async/.await\"></a>Future/async/.await</h1><hr>\n<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p>大家好! 我们上一节已经知晓异步的基础概念<br>现在, 来看看Rust中的异步语法吧    </p>\n<p>在本节, 我们会知晓以下三个概念的大致含义:<br>(暂时不涉及背后原理, 原理之后专门出好几节来讲)   </p>\n<ul>\n<li>Future (trait)  </li>\n<li>async (keyword)</li>\n<li>.await (keyword)</li>\n</ul>\n<p>开始旅途吧  </p>\n<hr>\n<h2 id=\"What’s-Future\"><a href=\"#What’s-Future\" class=\"headerlink\" title=\"What’s Future\"></a>What’s Future</h2><p><code>Future</code>, 一个标准/核心库中的trait<br>其完整路径为 <code>std/core::future::Future</code>   </p>\n<p>此节我只会讲它的大致含义, 原理则放到后面几节专门来讲 <del>(原理太难, 一节根本不够)</del>  </p>\n<p>在Rust中, 一个实现了 Future(trait) 的类型<br>该类型的实例 (有时候直接被简称为 一个Future实例) 便代表 一次异步计算<br>可以将其交给 <code>Runtime(运行时)</code>, 从而异步执行   </p>\n<p><code>异步执行</code>, 也就是指:<br>当其他 异步任务 阻塞时, 当前 异步任务 有机会执行<br>或当前 异步任务 阻塞时, 其他 异步任务 有机会执行<br>总而言之, 阻塞时期执行其他任务, 不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong>  </p>\n<ul>\n<li><code>异步 计算</code>  </li>\n<li><code>异步 任务</code></li>\n</ul>\n<p>两者有着区别, 举个例子你就明白了:  </p>\n<p>假设有这么个 父计算, 由两个 子计算 组成:   </p>\n<ol>\n<li>Open: 先异步打开一个文件(async open)  </li>\n<li>Read: 再异步读取该文件(async read)   </li>\n</ol>\n<p>我们可以看出, 一次 计算, 是可以由多个 子计算 组成的<br>同时, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>因为 <code>子计算们可能存在依赖关系</code> (在这里的例子中确实存在) </p>\n<p>因此, 当某个 子计算 阻塞时, 它所属的最顶层的 父计算 也会阻塞, 避免了 Runtime 调度非法计算<br>(我们将 <code>最顶层的父计算 (top-level Future, 即最顶层的Future实例)</code> 称为 <code>Task(任务)</code>)  </p>\n<p><code>当前Task</code> 阻塞时, 接管执行权的, 不能是 当前Task 中的 <code>其他子计算</code><br>只能是 <code>其他Task中的子计算</code>  </p>\n<p>来点总结吧:  </p>\n<ul>\n<li><p>Task 是一个顶层Future实例 (即一次顶层异步计算) </p>\n</li>\n<li><p>一个Future可以由多个Future组成, 即一个Future里可以执行多个Future</p>\n</li>\n<li><p>Task_A阻塞时, 接管执行的是其他Task中的子计算, 不能是Task_A中的子计算</p>\n</li>\n<li><p>Task可以只是一次单独计算</p>\n</li>\n</ul>\n<p><code>一个Future (一次异步计算)</code><br>可理解为, 是组成 <code>一个Task (一个异步任务)</code> 的最小单位 </p>\n<p>了解到了那么一点点后, 现在来正式看看呗 ?  </p>\n<hr>\n<h2 id=\"Future的定义\"><a href=\"#Future的定义\" class=\"headerlink\" title=\"Future的定义\"></a>Future的定义</h2><p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:  </p>\n<ul>\n<li><p>Future:<br>代表一次异步计算  </p>\n</li>\n<li><p>Output:<br>代表 该Future, 异步执行完毕后, 产出的值的类型   </p>\n</li>\n<li><p>poll:<br>所有执行操作都会放在该函数中<br>Runtime 会不断调用 poll函数 来推进 该异步计算 的完成<br>每次 poll 的返回值是一个 枚举变体, 代表 是否完成</p>\n</li>\n<li><p>Poll<T>:<br>枚举类型, 作为 poll函数 的返回值类型, 其 变体 有:<br><code>Poll::Pending</code>:<br>指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br><code>Poll::Ready(T)</code>:<br>指明该计算执行完毕, 并产出一个类型为T的值   </p>\n</li>\n</ul>\n<p>若只是普通使用者, 并不需了解 <code>Future的定义</code> 背后之原理<br>但若不了解它, 又如何为某类型实现 Future 呢?  </p>\n<p>别急, Rust 为我们提供了关键字 <code>async</code>, 接着往下看吧   </p>\n<hr>\n<h2 id=\"What’s-async\"><a href=\"#What’s-async\" class=\"headerlink\" title=\"What’s async\"></a>What’s async</h2><p><code>async</code>, 一个关键字<br>用来创建 <code>一个匿名结构体的实例, 该结构体实现了Future</code><br>即, 它创建一个 <code>Future实例</code>  </p>\n<p>来个例子, 看看 async 的好处:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以观察到, 使用 async 进行了符合直觉的简化<br>这两种函数, 实际上是等价的  </p>\n<p>看看它们两的返回值, 如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>注意, 异步函数的调用, 只是返回一个 Future实例<br><strong>但并没有开始执行, 它是惰性的</strong><br><strong>只有调用Future的poll方法, 才能推动它的执行</strong><br><strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong>  </p>\n<p>这样的好处就在于:<br>将一个异步计算看作一个变量, 方便了传参等工作  </p>\n<p>比如, 你想舍弃某次 异步任务, 你只需要将 对应的Future实例 给 drop 掉, 使其所有权丢失即可</p>\n<p>async 的作用就是创建一个 Future实例:  </p>\n<ul>\n<li><code>async fn</code> 异步函数, 要求返回一个 Future实例   </li>\n<li><code>async block</code> 异步代码块, 创建一个 Future实例  </li>\n<li><code>async closure</code> 异步闭包, (目前是不稳定特性) 创建一个 Future实例  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个Future实例, 想必大家已经了解一二<br>但是如何执行一个Future实例?  </p>\n<p>欲知后事如何, 请听下文揭晓 </p>\n<hr>\n<h2 id=\"Future的执行\"><a href=\"#Future的执行\" class=\"headerlink\" title=\"Future的执行\"></a>Future的执行</h2><h3 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h3><p>Rust语言本身并不提供 <code>异步运行时 (async runtime)</code>, 以便于语言内核保持精小, 便于进化/迭代/维护<br>异步运行时 由社区提供, 围绕语言本身提供的定义 (比如 Future) 进行支持/扩充, 来运行异步程序  </p>\n<p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) </p>\n<p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>在嵌入式环境下, 也能够轻松运行异步程序   </p>\n<p>在正式开始之前<br>请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:   </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>我们指定了版本, 并且启用了 <code>attributes</code> 这个特性  </p>\n<p>好了, 马上开始咯!  </p>\n<hr>\n<h3 id=\"通过运行时执行\"><a href=\"#通过运行时执行\" class=\"headerlink\" title=\"通过运行时执行\"></a>通过运行时执行</h3><p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>并且使用 <code>async-std</code> 这个异步运行时环境来执行它:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们在本节开始不久, 就提到过的 <code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>async_std::task, 该模块, 为我们提供了大量api, 来执行/操控 这些 <code>Task</code>  </p>\n<p>比如这里出现的 <code>task::block_on</code>:<br>传入一个 Future实例, Runtime 会执行它(调用poll方法), 并阻塞调用线程<br>该任务执行完毕后产出的值, 会作为 <code>block_on</code> 的返回值  </p>\n<p>我们执行了一个 Task, 并且这个 Task 是单个的 Future<br>但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  </p>\n<p><code>.await</code> 关键字出场了! </p>\n<hr>\n<h3 id=\"await-关键字\"><a href=\"#await-关键字\" class=\"headerlink\" title=\".await 关键字\"></a>.await 关键字</h3><p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>在某个 Future实例 的后面, 增加 <code>.await</code>, 那么 <code>该Future实例</code> 则会执行<br>但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>真正执行的话, 得将 Future实例 交给运行时, 带动着执行里面的 子Future   </p>\n<p>来看看它的使用:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.await</code> 是一个标记点, 可以理解为是一个 <code>yield point</code><br>Runtime 执行到 <code>xxx.await</code> 时, 先会执行一次 <code>xxx</code>  </p>\n<p>一开始, 会调用一次poll函数, 推动执行进度<br>通过它的返回值, <code>Poll&lt;T&gt;枚举的变体</code>, 即 <code>Pending</code> 或 <code>Ready(T)</code><br>来决定: </p>\n<ol>\n<li>让 其他Task 接管执行权 (yield)  </li>\n<li>该Future执行完毕, 继续执行当前 Task  </li>\n</ol>\n<p>若为 <code>Ready</code>, 则选 <code>2</code>, 继续往下执行 (一个 Task 可能是由多个 Future 所组成)<br>若为 <code>Pending</code>, 则选 <code>1</code>, 让其他任务接管执行权 (比如IO操作的阻塞期间, 让其他任务执行)  </p>\n<p>稍微有点涉及原理部分, 可能有点难理解, 来个简单粗暴理解版:  </p>\n<p><code>.await</code> 会指明 <code>执行某个Future</code> 这一逻辑<br>当 <code>xxx.await</code> 所在的 Task 交给 Runtime 执行, 并执行到 <code>xxx.await</code> 时<br><code>xxx</code> 这个Future实例会执行  </p>\n<p>若它阻塞 (这意味着 该Future所在的Task 也阻塞)<br>所以调度程序安排 其他Task, 在该空档期执行<br>若不阻塞, 就继续往下执行 (可能还有碰见 <code>.await</code> 哟), 直到 该Task 结束   </p>\n<hr>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li><code>#[async_std::main]</code><br>这玩意无比常见, 是个属性宏, 要加在 main函数 头上<br>使得 main 前面能被 async 所修饰<br>程序运行时, main函数返回的 Future, 会自动交给 Runtime 开始运行, 如下:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><code>async_std::task::spawn</code><br>因为这玩意也很常见, 所以就讲一讲:<br>向其传入 Future, 运行时会开始运行 该Task, 并返回 async_std::task::JoinHandle 的实例<br>它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似<br>不过那个运行 Thread, 而这个运行 Task, <code>join</code> 相应地变成 <code>.await</code><br>想让 该handle代表的Task 运行完毕, 应该在 该handle 前放上 <code>.await</code>:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>终于结束了, 这一篇其实是重写版, 写到这真的累死了  </p>\n<p>我们学到了一些东西 (不涉及原理, 之后专门抽几节讲……):      </p>\n<ul>\n<li><code>Future</code>   </li>\n<li><code>async fn/block</code></li>\n<li><code>.await</code>  </li>\n<li><code>Async-Runtime&#39;s API</code>  </li>\n</ul>\n<p>只需要使用的, 看到这其实已经差不多了<br>普通异步程序也不怎么需要看 <code>Future</code> 定义中的 <code>poll</code> 方法<br>那里涉及到比较烦人的背后原理……  </p>\n<p>如果有问题的话, 可以在评论区留言<br>或者加在下qq交流也行 : <code>2948804617</code>  </p>\n<p>呼, 真的累死, 看番去了!<br>一周后再更吧 <del>(鸽神是也)</del></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明  </p>\n</blockquote>","more":"<h1 id=\"Future-async-await\"><a href=\"#Future-async-await\" class=\"headerlink\" title=\"Future/async/.await\"></a>Future/async/.await</h1><hr>\n<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p>大家好! 我们上一节已经知晓异步的基础概念<br>现在, 来看看Rust中的异步语法吧    </p>\n<p>在本节, 我们会知晓以下三个概念的大致含义:<br>(暂时不涉及背后原理, 原理之后专门出好几节来讲)   </p>\n<ul>\n<li>Future (trait)  </li>\n<li>async (keyword)</li>\n<li>.await (keyword)</li>\n</ul>\n<p>开始旅途吧  </p>\n<hr>\n<h2 id=\"What’s-Future\"><a href=\"#What’s-Future\" class=\"headerlink\" title=\"What’s Future\"></a>What’s Future</h2><p><code>Future</code>, 一个标准/核心库中的trait<br>其完整路径为 <code>std/core::future::Future</code>   </p>\n<p>此节我只会讲它的大致含义, 原理则放到后面几节专门来讲 <del>(原理太难, 一节根本不够)</del>  </p>\n<p>在Rust中, 一个实现了 Future(trait) 的类型<br>该类型的实例 (有时候直接被简称为 一个Future实例) 便代表 一次异步计算<br>可以将其交给 <code>Runtime(运行时)</code>, 从而异步执行   </p>\n<p><code>异步执行</code>, 也就是指:<br>当其他 异步任务 阻塞时, 当前 异步任务 有机会执行<br>或当前 异步任务 阻塞时, 其他 异步任务 有机会执行<br>总而言之, 阻塞时期执行其他任务, 不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong>  </p>\n<ul>\n<li><code>异步 计算</code>  </li>\n<li><code>异步 任务</code></li>\n</ul>\n<p>两者有着区别, 举个例子你就明白了:  </p>\n<p>假设有这么个 父计算, 由两个 子计算 组成:   </p>\n<ol>\n<li>Open: 先异步打开一个文件(async open)  </li>\n<li>Read: 再异步读取该文件(async read)   </li>\n</ol>\n<p>我们可以看出, 一次 计算, 是可以由多个 子计算 组成的<br>同时, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>因为 <code>子计算们可能存在依赖关系</code> (在这里的例子中确实存在) </p>\n<p>因此, 当某个 子计算 阻塞时, 它所属的最顶层的 父计算 也会阻塞, 避免了 Runtime 调度非法计算<br>(我们将 <code>最顶层的父计算 (top-level Future, 即最顶层的Future实例)</code> 称为 <code>Task(任务)</code>)  </p>\n<p><code>当前Task</code> 阻塞时, 接管执行权的, 不能是 当前Task 中的 <code>其他子计算</code><br>只能是 <code>其他Task中的子计算</code>  </p>\n<p>来点总结吧:  </p>\n<ul>\n<li><p>Task 是一个顶层Future实例 (即一次顶层异步计算) </p>\n</li>\n<li><p>一个Future可以由多个Future组成, 即一个Future里可以执行多个Future</p>\n</li>\n<li><p>Task_A阻塞时, 接管执行的是其他Task中的子计算, 不能是Task_A中的子计算</p>\n</li>\n<li><p>Task可以只是一次单独计算</p>\n</li>\n</ul>\n<p><code>一个Future (一次异步计算)</code><br>可理解为, 是组成 <code>一个Task (一个异步任务)</code> 的最小单位 </p>\n<p>了解到了那么一点点后, 现在来正式看看呗 ?  </p>\n<hr>\n<h2 id=\"Future的定义\"><a href=\"#Future的定义\" class=\"headerlink\" title=\"Future的定义\"></a>Future的定义</h2><p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:  </p>\n<ul>\n<li><p>Future:<br>代表一次异步计算  </p>\n</li>\n<li><p>Output:<br>代表 该Future, 异步执行完毕后, 产出的值的类型   </p>\n</li>\n<li><p>poll:<br>所有执行操作都会放在该函数中<br>Runtime 会不断调用 poll函数 来推进 该异步计算 的完成<br>每次 poll 的返回值是一个 枚举变体, 代表 是否完成</p>\n</li>\n<li><p>Poll<T>:<br>枚举类型, 作为 poll函数 的返回值类型, 其 变体 有:<br><code>Poll::Pending</code>:<br>指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br><code>Poll::Ready(T)</code>:<br>指明该计算执行完毕, 并产出一个类型为T的值   </p>\n</li>\n</ul>\n<p>若只是普通使用者, 并不需了解 <code>Future的定义</code> 背后之原理<br>但若不了解它, 又如何为某类型实现 Future 呢?  </p>\n<p>别急, Rust 为我们提供了关键字 <code>async</code>, 接着往下看吧   </p>\n<hr>\n<h2 id=\"What’s-async\"><a href=\"#What’s-async\" class=\"headerlink\" title=\"What’s async\"></a>What’s async</h2><p><code>async</code>, 一个关键字<br>用来创建 <code>一个匿名结构体的实例, 该结构体实现了Future</code><br>即, 它创建一个 <code>Future实例</code>  </p>\n<p>来个例子, 看看 async 的好处:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以观察到, 使用 async 进行了符合直觉的简化<br>这两种函数, 实际上是等价的  </p>\n<p>看看它们两的返回值, 如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>注意, 异步函数的调用, 只是返回一个 Future实例<br><strong>但并没有开始执行, 它是惰性的</strong><br><strong>只有调用Future的poll方法, 才能推动它的执行</strong><br><strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong>  </p>\n<p>这样的好处就在于:<br>将一个异步计算看作一个变量, 方便了传参等工作  </p>\n<p>比如, 你想舍弃某次 异步任务, 你只需要将 对应的Future实例 给 drop 掉, 使其所有权丢失即可</p>\n<p>async 的作用就是创建一个 Future实例:  </p>\n<ul>\n<li><code>async fn</code> 异步函数, 要求返回一个 Future实例   </li>\n<li><code>async block</code> 异步代码块, 创建一个 Future实例  </li>\n<li><code>async closure</code> 异步闭包, (目前是不稳定特性) 创建一个 Future实例  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个Future实例, 想必大家已经了解一二<br>但是如何执行一个Future实例?  </p>\n<p>欲知后事如何, 请听下文揭晓 </p>\n<hr>\n<h2 id=\"Future的执行\"><a href=\"#Future的执行\" class=\"headerlink\" title=\"Future的执行\"></a>Future的执行</h2><h3 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h3><p>Rust语言本身并不提供 <code>异步运行时 (async runtime)</code>, 以便于语言内核保持精小, 便于进化/迭代/维护<br>异步运行时 由社区提供, 围绕语言本身提供的定义 (比如 Future) 进行支持/扩充, 来运行异步程序  </p>\n<p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) </p>\n<p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>在嵌入式环境下, 也能够轻松运行异步程序   </p>\n<p>在正式开始之前<br>请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:   </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>我们指定了版本, 并且启用了 <code>attributes</code> 这个特性  </p>\n<p>好了, 马上开始咯!  </p>\n<hr>\n<h3 id=\"通过运行时执行\"><a href=\"#通过运行时执行\" class=\"headerlink\" title=\"通过运行时执行\"></a>通过运行时执行</h3><p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>并且使用 <code>async-std</code> 这个异步运行时环境来执行它:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们在本节开始不久, 就提到过的 <code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>async_std::task, 该模块, 为我们提供了大量api, 来执行/操控 这些 <code>Task</code>  </p>\n<p>比如这里出现的 <code>task::block_on</code>:<br>传入一个 Future实例, Runtime 会执行它(调用poll方法), 并阻塞调用线程<br>该任务执行完毕后产出的值, 会作为 <code>block_on</code> 的返回值  </p>\n<p>我们执行了一个 Task, 并且这个 Task 是单个的 Future<br>但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  </p>\n<p><code>.await</code> 关键字出场了! </p>\n<hr>\n<h3 id=\"await-关键字\"><a href=\"#await-关键字\" class=\"headerlink\" title=\".await 关键字\"></a>.await 关键字</h3><p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>在某个 Future实例 的后面, 增加 <code>.await</code>, 那么 <code>该Future实例</code> 则会执行<br>但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>真正执行的话, 得将 Future实例 交给运行时, 带动着执行里面的 子Future   </p>\n<p>来看看它的使用:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.await</code> 是一个标记点, 可以理解为是一个 <code>yield point</code><br>Runtime 执行到 <code>xxx.await</code> 时, 先会执行一次 <code>xxx</code>  </p>\n<p>一开始, 会调用一次poll函数, 推动执行进度<br>通过它的返回值, <code>Poll&lt;T&gt;枚举的变体</code>, 即 <code>Pending</code> 或 <code>Ready(T)</code><br>来决定: </p>\n<ol>\n<li>让 其他Task 接管执行权 (yield)  </li>\n<li>该Future执行完毕, 继续执行当前 Task  </li>\n</ol>\n<p>若为 <code>Ready</code>, 则选 <code>2</code>, 继续往下执行 (一个 Task 可能是由多个 Future 所组成)<br>若为 <code>Pending</code>, 则选 <code>1</code>, 让其他任务接管执行权 (比如IO操作的阻塞期间, 让其他任务执行)  </p>\n<p>稍微有点涉及原理部分, 可能有点难理解, 来个简单粗暴理解版:  </p>\n<p><code>.await</code> 会指明 <code>执行某个Future</code> 这一逻辑<br>当 <code>xxx.await</code> 所在的 Task 交给 Runtime 执行, 并执行到 <code>xxx.await</code> 时<br><code>xxx</code> 这个Future实例会执行  </p>\n<p>若它阻塞 (这意味着 该Future所在的Task 也阻塞)<br>所以调度程序安排 其他Task, 在该空档期执行<br>若不阻塞, 就继续往下执行 (可能还有碰见 <code>.await</code> 哟), 直到 该Task 结束   </p>\n<hr>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li><code>#[async_std::main]</code><br>这玩意无比常见, 是个属性宏, 要加在 main函数 头上<br>使得 main 前面能被 async 所修饰<br>程序运行时, main函数返回的 Future, 会自动交给 Runtime 开始运行, 如下:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><code>async_std::task::spawn</code><br>因为这玩意也很常见, 所以就讲一讲:<br>向其传入 Future, 运行时会开始运行 该Task, 并返回 async_std::task::JoinHandle 的实例<br>它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似<br>不过那个运行 Thread, 而这个运行 Task, <code>join</code> 相应地变成 <code>.await</code><br>想让 该handle代表的Task 运行完毕, 应该在 该handle 前放上 <code>.await</code>:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>终于结束了, 这一篇其实是重写版, 写到这真的累死了  </p>\n<p>我们学到了一些东西 (不涉及原理, 之后专门抽几节讲……):      </p>\n<ul>\n<li><code>Future</code>   </li>\n<li><code>async fn/block</code></li>\n<li><code>.await</code>  </li>\n<li><code>Async-Runtime&#39;s API</code>  </li>\n</ul>\n<p>只需要使用的, 看到这其实已经差不多了<br>普通异步程序也不怎么需要看 <code>Future</code> 定义中的 <code>poll</code> 方法<br>那里涉及到比较烦人的背后原理……  </p>\n<p>如果有问题的话, 可以在评论区留言<br>或者加在下qq交流也行 : <code>2948804617</code>  </p>\n<p>呼, 真的累死, 看番去了!<br>一周后再更吧 <del>(鸽神是也)</del></p>"},{"title":"rs-async-p4-状态的保存/变换","abbrlink":"rs-async-p4","date":"2021-09-12T06:50:14.000Z","top":9996,"_content":"> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n# 开篇\n**注: 参考了 《Writing an OS in Rust》中的async篇, 可以自己搜索下看看**  \n为了更好地理解 `Rust异步` 背后的原理, 我们先来了解下一些概念  \n当然, 不用太深入, 只是小补充而已:   \n- `抢占式/协作式多任务`  \n- `状态机`  \n- `自引用结构体`   \n\n\n现在, 让我们开始吧!  \n- - -\n# 抢占式/协作式多任务的概念  \n`抢占式多任务` 与 `协作式多任务`, 都属于 `多任务`         \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如, 操作系统先让 网易云音乐 运行一会, 再让 VSCode 运行一会  \n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种 `任务们同时运行` 的感觉  \n这是强迫/抢占的     \n\n- 协作式多任务:  \n任务们本身进行协调, 决定CPU的运行权  \n比如Rust中, 运行时调用 某Task(top-level Future) 的 poll方法 阻塞时, 返回 Poll::Pending  \n自己放弃继续执行, 并通知运行时执行 其他Task  \n这是自愿/协作的, Task们 `自愿放弃CPU的执行权`\n(上文中的 `任务` 与 `Task` 请区分一下, 前者比后者广泛, 后者在这, 用于Rust的举例)  \n\n- - -\n\n# 两种多任务的恢复/状态保存  \n既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时  \n该任务, 应当从先前暂停的地方开始, 继续执行  \n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 `状态保存`  \n\n对于 `抢占式` 与 `协作式`, 处理 `状态保存` 的思路是不一样的:\n\n## 抢占式:  \n因为是强迫切换执行的, 任务会在任意某个时刻被中断  \n任务此时运行到了哪里? 我们不知道啊!  \n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间  \n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n## 协作式:  \n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作, 我们称为 `yield`    \n\n比如在Rust中, `xxx.await` 会执行一个Future  \t\n意味着当程序执行到这里时, 可能会 `yield` (poll 返回 Poll::Pending, 自愿放弃执行权)  \n\n`xxx.await` 就是一个 `stop/yield point`, 代表执行到此处时, 可能会发生暂停并yield  \n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此, 我们可以准确分配 Future 执行所需要的最大空间  \n\n其实, 每个 `.await (也就是yield point)`, 就代表着 `一种状态` (之后会讲)\n\n协作式 的好处在于便于掌握所有的 yield point  \n在暂停之前, 准确保存 `下次继续所需要的状态`, 内存/性能优势很大    \n但坏处也有, 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n- - -\n# 状态机的概念  \n在Rust中的异步, 我们之前也说过, 属于 `协作式多任务`  \n而其 `状态保存` 的实现, 就是利用 `状态机(state machine)` 来实现  \n\n`状态机 (state machine)` 一般指 `有限状态自动机`, 是一种 数学模型  \n\n1. 状态 (state):  \n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed    \n\n2. 事件 (event):  \n某事件 发生后, 会触发相应 动作, 可能改变状态, 比如: 用钥匙锁门(event) => 关门(action) => 门被锁住(state)   \n3. 动作 (action):  \n事件 发生后, 会触发 动作  \n4. 变换 (transition):  \n`State_X => State_Y` 就叫 `变换`, 比如门的状态从 `Open => Closed`  \n\n稍微了解下 `状态机` 的概念即可  \n\n那么现在, 就要看具体代码了  \n\n如果你想亲自运行一下, 先确保你的 `Cargo.toml` 中的依赖如下:  \n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下, 读取一个文件的行数  \n你可以使用 `cargo run -- ./src/main.rs` 运行  \n(也可以编译后, 通过 `target/debug` 下的二进制文件运行)\n```rust\nuse {\n\tstd::env::args,\n\tasync_std::prelude::*,\n\tasync_std::fs::File,\n\tasync_std::io::{self,BufReader},\n};\n\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).expect(\"Fuck you! No path for working\"); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\nmian() 产生一个新实例, 异步运行 `open(path)` 与 `count()`  \t    \n对于编译器, 每一个 `.await` 其实都代表一种状态  \n\nFuture实例, 实际上是个 状态机  \n在这里共有四种状态/阶段 (其中包括两个 `.await point(yield point)`):  \n\n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用 当前Future 的 poll 推动进度时, 若在 `某一阶段` 返回了 `Poll::Pending`, 则放弃执行权  \n当再次调用 当前Future 的 poll 推动进度时, 则从上次暂停的状态 `恢复 (resume)`, 继续执行  \n\n官方目前似乎采用 `Generator (生成器)` 为异步语法生成状态机  \n每一个状态都会存储一些数据, 便于进入下一个状态  \n\n**Note 1**:  \nStart状态, 会存储传入函数的参数 (如果有参数)\n\n**Note 2**:  \nDone状态下, 若进行 resume, 则可能得到 panic!  \n恢复已结束的计算是不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义, 且point之后还需要使用的变量`  \n如上段代码中的 `file`, `count` 就需要被保存, 因为从暂停中恢复后还需要使用  \n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象  \n所以不需要特殊的持久化操作\n\n\n- - - \n# 自引用结构体  \n## 状态保存引用时\n当每一个状态存储数据时, 可能会导致发生 `自引用`, 比如:  \n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n这里有三个状态: `Start`, `Yield1`, `Done`  \n而在 `Yield1` 这个状态, 存储的数据如下:\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n}\n\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```   \n\n等等, 你可能会对上面的代码有疑惑:  \n不是说, 状态 只需要保存 `在yield point之前定义, 并且该point之后还需要使用的变量` 吗  \n上面的代码, 只有 element 这个 引用 需要被保存吧?  \n\n这是因为, 它是 `引用` 嘛!  \n没了 `引用` 背后的实际数据, 那它还有啥用, 不就是 `悬垂引用` 了吗?  \n\n因此我们还得保存, `该引用` 指向的背后数据: `arr`  \n并 `一起` 存储在同个 `struct (代表同一状态)`中  \n\n\n像这种 `结构体内部的指针, 指向结构体本身`  \n就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下, 成员 element 指向了成员 arr  \n\n## 内存移动问题(导致悬垂引用产生)\n这就可能有问题发生, 如果 该struct实例 的 `内存地址发生改变`  \n比如使用 `std::mem`, 让 struct实例 的内存地址, 发生移动  \n\n以上面的那段代码为例, 如下:  \n- arr:  \n内存地址会跟着结构体实例而改变  \n但是, `值仍然是 [1,2,3]`\n\n- element:  \n内存地址会跟着结构体实例而改变  \n但是, 值仍然是 `先前arr的地址`  \n`注意, 是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的 (悬垂引用)  \n\n官方提出了 `std::pin::Pin (trait)`  \n来解决 自引用结构体 方面的 悬垂指针/引用问题 \n\n其实你听名字也很好理解:  \n`Pin(中文意思是钉子)` 的作用是, 防止内存地址发生改变 (给爷钉死吧!)  \n\n但是它又是怎么pin住的呢?  \n下一节再慢慢讲吧  \n\n那又是一个值得探讨的话题了  \n欲知后事如何, 且听下回分解  \n\n~~(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~\n- - -\n感谢大家观看! 有建议/发现错误/想聊天  \n请在评论区留言, 或者加本人qq也阔以","source":"_posts/rs-async/rs-async-p4-状态的保存-变换.md","raw":"---\ntitle: rs-async-p4-状态的保存/变换\nabbrlink: rs-async-p4\ndate: 2021-09-12 14:50:14\ntop: 9996\ntags: rust\ncategories: rust-async\n---\n> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n# 开篇\n**注: 参考了 《Writing an OS in Rust》中的async篇, 可以自己搜索下看看**  \n为了更好地理解 `Rust异步` 背后的原理, 我们先来了解下一些概念  \n当然, 不用太深入, 只是小补充而已:   \n- `抢占式/协作式多任务`  \n- `状态机`  \n- `自引用结构体`   \n\n\n现在, 让我们开始吧!  \n- - -\n# 抢占式/协作式多任务的概念  \n`抢占式多任务` 与 `协作式多任务`, 都属于 `多任务`         \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如, 操作系统先让 网易云音乐 运行一会, 再让 VSCode 运行一会  \n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种 `任务们同时运行` 的感觉  \n这是强迫/抢占的     \n\n- 协作式多任务:  \n任务们本身进行协调, 决定CPU的运行权  \n比如Rust中, 运行时调用 某Task(top-level Future) 的 poll方法 阻塞时, 返回 Poll::Pending  \n自己放弃继续执行, 并通知运行时执行 其他Task  \n这是自愿/协作的, Task们 `自愿放弃CPU的执行权`\n(上文中的 `任务` 与 `Task` 请区分一下, 前者比后者广泛, 后者在这, 用于Rust的举例)  \n\n- - -\n\n# 两种多任务的恢复/状态保存  \n既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时  \n该任务, 应当从先前暂停的地方开始, 继续执行  \n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 `状态保存`  \n\n对于 `抢占式` 与 `协作式`, 处理 `状态保存` 的思路是不一样的:\n\n## 抢占式:  \n因为是强迫切换执行的, 任务会在任意某个时刻被中断  \n任务此时运行到了哪里? 我们不知道啊!  \n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间  \n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n## 协作式:  \n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作, 我们称为 `yield`    \n\n比如在Rust中, `xxx.await` 会执行一个Future  \t\n意味着当程序执行到这里时, 可能会 `yield` (poll 返回 Poll::Pending, 自愿放弃执行权)  \n\n`xxx.await` 就是一个 `stop/yield point`, 代表执行到此处时, 可能会发生暂停并yield  \n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此, 我们可以准确分配 Future 执行所需要的最大空间  \n\n其实, 每个 `.await (也就是yield point)`, 就代表着 `一种状态` (之后会讲)\n\n协作式 的好处在于便于掌握所有的 yield point  \n在暂停之前, 准确保存 `下次继续所需要的状态`, 内存/性能优势很大    \n但坏处也有, 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n- - -\n# 状态机的概念  \n在Rust中的异步, 我们之前也说过, 属于 `协作式多任务`  \n而其 `状态保存` 的实现, 就是利用 `状态机(state machine)` 来实现  \n\n`状态机 (state machine)` 一般指 `有限状态自动机`, 是一种 数学模型  \n\n1. 状态 (state):  \n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed    \n\n2. 事件 (event):  \n某事件 发生后, 会触发相应 动作, 可能改变状态, 比如: 用钥匙锁门(event) => 关门(action) => 门被锁住(state)   \n3. 动作 (action):  \n事件 发生后, 会触发 动作  \n4. 变换 (transition):  \n`State_X => State_Y` 就叫 `变换`, 比如门的状态从 `Open => Closed`  \n\n稍微了解下 `状态机` 的概念即可  \n\n那么现在, 就要看具体代码了  \n\n如果你想亲自运行一下, 先确保你的 `Cargo.toml` 中的依赖如下:  \n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下, 读取一个文件的行数  \n你可以使用 `cargo run -- ./src/main.rs` 运行  \n(也可以编译后, 通过 `target/debug` 下的二进制文件运行)\n```rust\nuse {\n\tstd::env::args,\n\tasync_std::prelude::*,\n\tasync_std::fs::File,\n\tasync_std::io::{self,BufReader},\n};\n\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).expect(\"Fuck you! No path for working\"); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\nmian() 产生一个新实例, 异步运行 `open(path)` 与 `count()`  \t    \n对于编译器, 每一个 `.await` 其实都代表一种状态  \n\nFuture实例, 实际上是个 状态机  \n在这里共有四种状态/阶段 (其中包括两个 `.await point(yield point)`):  \n\n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用 当前Future 的 poll 推动进度时, 若在 `某一阶段` 返回了 `Poll::Pending`, 则放弃执行权  \n当再次调用 当前Future 的 poll 推动进度时, 则从上次暂停的状态 `恢复 (resume)`, 继续执行  \n\n官方目前似乎采用 `Generator (生成器)` 为异步语法生成状态机  \n每一个状态都会存储一些数据, 便于进入下一个状态  \n\n**Note 1**:  \nStart状态, 会存储传入函数的参数 (如果有参数)\n\n**Note 2**:  \nDone状态下, 若进行 resume, 则可能得到 panic!  \n恢复已结束的计算是不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义, 且point之后还需要使用的变量`  \n如上段代码中的 `file`, `count` 就需要被保存, 因为从暂停中恢复后还需要使用  \n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象  \n所以不需要特殊的持久化操作\n\n\n- - - \n# 自引用结构体  \n## 状态保存引用时\n当每一个状态存储数据时, 可能会导致发生 `自引用`, 比如:  \n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n这里有三个状态: `Start`, `Yield1`, `Done`  \n而在 `Yield1` 这个状态, 存储的数据如下:\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n}\n\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```   \n\n等等, 你可能会对上面的代码有疑惑:  \n不是说, 状态 只需要保存 `在yield point之前定义, 并且该point之后还需要使用的变量` 吗  \n上面的代码, 只有 element 这个 引用 需要被保存吧?  \n\n这是因为, 它是 `引用` 嘛!  \n没了 `引用` 背后的实际数据, 那它还有啥用, 不就是 `悬垂引用` 了吗?  \n\n因此我们还得保存, `该引用` 指向的背后数据: `arr`  \n并 `一起` 存储在同个 `struct (代表同一状态)`中  \n\n\n像这种 `结构体内部的指针, 指向结构体本身`  \n就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下, 成员 element 指向了成员 arr  \n\n## 内存移动问题(导致悬垂引用产生)\n这就可能有问题发生, 如果 该struct实例 的 `内存地址发生改变`  \n比如使用 `std::mem`, 让 struct实例 的内存地址, 发生移动  \n\n以上面的那段代码为例, 如下:  \n- arr:  \n内存地址会跟着结构体实例而改变  \n但是, `值仍然是 [1,2,3]`\n\n- element:  \n内存地址会跟着结构体实例而改变  \n但是, 值仍然是 `先前arr的地址`  \n`注意, 是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的 (悬垂引用)  \n\n官方提出了 `std::pin::Pin (trait)`  \n来解决 自引用结构体 方面的 悬垂指针/引用问题 \n\n其实你听名字也很好理解:  \n`Pin(中文意思是钉子)` 的作用是, 防止内存地址发生改变 (给爷钉死吧!)  \n\n但是它又是怎么pin住的呢?  \n下一节再慢慢讲吧  \n\n那又是一个值得探讨的话题了  \n欲知后事如何, 且听下回分解  \n\n~~(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~\n- - -\n感谢大家观看! 有建议/发现错误/想聊天  \n请在评论区留言, 或者加本人qq也阔以","slug":"rs-async/rs-async-p4-状态的保存-变换","published":1,"updated":"2021-10-02T07:11:36.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5fs0008bw5k3t62dnvf","content":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p><strong>注: 参考了 《Writing an OS in Rust》中的async篇, 可以自己搜索下看看</strong><br>为了更好地理解 <code>Rust异步</code> 背后的原理, 我们先来了解下一些概念<br>当然, 不用太深入, 只是小补充而已:   </p>\n<ul>\n<li><code>抢占式/协作式多任务</code>  </li>\n<li><code>状态机</code>  </li>\n<li><code>自引用结构体</code>   </li>\n</ul>\n<p>现在, 让我们开始吧!  </p>\n<hr>\n<h1 id=\"抢占式-协作式多任务的概念\"><a href=\"#抢占式-协作式多任务的概念\" class=\"headerlink\" title=\"抢占式/协作式多任务的概念\"></a>抢占式/协作式多任务的概念</h1><p><code>抢占式多任务</code> 与 <code>协作式多任务</code>, 都属于 <code>多任务</code>         </p>\n<ul>\n<li><p>抢占式多任务:<br>操作系统决定CPU的运行权<br>比如, 操作系统先让 网易云音乐 运行一会, 再让 VSCode 运行一会<br>各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种 <code>任务们同时运行</code> 的感觉<br>这是强迫/抢占的     </p>\n</li>\n<li><p>协作式多任务:<br>任务们本身进行协调, 决定CPU的运行权<br>比如Rust中, 运行时调用 某Task(top-level Future) 的 poll方法 阻塞时, 返回 Poll::Pending<br>自己放弃继续执行, 并通知运行时执行 其他Task<br>这是自愿/协作的, Task们 <code>自愿放弃CPU的执行权</code><br>(上文中的 <code>任务</code> 与 <code>Task</code> 请区分一下, 前者比后者广泛, 后者在这, 用于Rust的举例)  </p>\n</li>\n</ul>\n<hr>\n<h1 id=\"两种多任务的恢复-状态保存\"><a href=\"#两种多任务的恢复-状态保存\" class=\"headerlink\" title=\"两种多任务的恢复/状态保存\"></a>两种多任务的恢复/状态保存</h1><p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>该任务, 应当从先前暂停的地方开始, 继续执行<br>因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 <code>状态保存</code>  </p>\n<p>对于 <code>抢占式</code> 与 <code>协作式</code>, 处理 <code>状态保存</code> 的思路是不一样的:</p>\n<h2 id=\"抢占式\"><a href=\"#抢占式\" class=\"headerlink\" title=\"抢占式:\"></a>抢占式:</h2><p>因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>任务此时运行到了哪里? 我们不知道啊!<br>那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    </p>\n<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  </p>\n<h2 id=\"协作式\"><a href=\"#协作式\" class=\"headerlink\" title=\"协作式:\"></a>协作式:</h2><p>因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>这种放弃执行权的操作, 我们称为 <code>yield</code>    </p>\n<p>比如在Rust中, <code>xxx.await</code> 会执行一个Future<br>意味着当程序执行到这里时, 可能会 <code>yield</code> (poll 返回 Poll::Pending, 自愿放弃执行权)  </p>\n<p><code>xxx.await</code> 就是一个 <code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>因此, 我们可以准确分配 Future 执行所需要的最大空间  </p>\n<p>其实, 每个 <code>.await (也就是yield point)</code>, 就代表着 <code>一种状态</code> (之后会讲)</p>\n<p>协作式 的好处在于便于掌握所有的 yield point<br>在暂停之前, 准确保存 <code>下次继续所需要的状态</code>, 内存/性能优势很大<br>但坏处也有, 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  </p>\n<hr>\n<h1 id=\"状态机的概念\"><a href=\"#状态机的概念\" class=\"headerlink\" title=\"状态机的概念\"></a>状态机的概念</h1><p>在Rust中的异步, 我们之前也说过, 属于 <code>协作式多任务</code><br>而其 <code>状态保存</code> 的实现, 就是利用 <code>状态机(state machine)</code> 来实现  </p>\n<p><code>状态机 (state machine)</code> 一般指 <code>有限状态自动机</code>, 是一种 数学模型  </p>\n<ol>\n<li><p>状态 (state):<br>比如有一扇门, 它的状态就处于以下两种之一: Open or Closed    </p>\n</li>\n<li><p>事件 (event):<br>某事件 发生后, 会触发相应 动作, 可能改变状态, 比如: 用钥匙锁门(event) =&gt; 关门(action) =&gt; 门被锁住(state)   </p>\n</li>\n<li><p>动作 (action):<br>事件 发生后, 会触发 动作  </p>\n</li>\n<li><p>变换 (transition):<br><code>State_X =&gt; State_Y</code> 就叫 <code>变换</code>, 比如门的状态从 <code>Open =&gt; Closed</code>  </p>\n</li>\n</ol>\n<p>稍微了解下 <code>状态机</code> 的概念即可  </p>\n<p>那么现在, 就要看具体代码了  </p>\n<p>如果你想亲自运行一下, 先确保你的 <code>Cargo.toml</code> 中的依赖如下:  </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下, 读取一个文件的行数<br>你可以使用 <code>cargo run -- ./src/main.rs</code> 运行<br>(也可以编译后, 通过 <code>target/debug</code> 下的二进制文件运行)</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> &#123;</span><br><span class=\"line\">    std::env::args,</span><br><span class=\"line\">    async_std::prelude::*,</span><br><span class=\"line\">    async_std::fs::File,</span><br><span class=\"line\">    async_std::io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).expect(<span class=\"string\">&quot;Fuck you! No path for working&quot;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n<p>mian() 产生一个新实例, 异步运行 <code>open(path)</code> 与 <code>count()</code><br>对于编译器, 每一个 <code>.await</code> 其实都代表一种状态  </p>\n<p>Future实例, 实际上是个 状态机<br>在这里共有四种状态/阶段 (其中包括两个 <code>.await point(yield point)</code>):  </p>\n<ol>\n<li>Start: 此Future刚开始执行  </li>\n<li>Yield1: 第一个 yield point</li>\n<li>Yield2: 第二个 yield point</li>\n<li>Done: 此Future执行完毕</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>执行器调用 当前Future 的 poll 推动进度时, 若在 <code>某一阶段</code> 返回了 <code>Poll::Pending</code>, 则放弃执行权<br>当再次调用 当前Future 的 poll 推动进度时, 则从上次暂停的状态 <code>恢复 (resume)</code>, 继续执行  </p>\n<p>官方目前似乎采用 <code>Generator (生成器)</code> 为异步语法生成状态机<br>每一个状态都会存储一些数据, 便于进入下一个状态  </p>\n<p><strong>Note 1</strong>:<br>Start状态, 会存储传入函数的参数 (如果有参数)</p>\n<p><strong>Note 2</strong>:<br>Done状态下, 若进行 resume, 则可能得到 panic!<br>恢复已结束的计算是不应该的  </p>\n<p><strong>Note 3</strong>:<br>怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br><code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>如上段代码中的 <code>file</code>, <code>count</code> 就需要被保存, 因为从暂停中恢复后还需要使用<br>其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"自引用结构体\"><a href=\"#自引用结构体\" class=\"headerlink\" title=\"自引用结构体\"></a>自引用结构体</h1><h2 id=\"状态保存引用时\"><a href=\"#状态保存引用时\" class=\"headerlink\" title=\"状态保存引用时\"></a>状态保存引用时</h2><p>当每一个状态存储数据时, 可能会导致发生 <code>自引用</code>, 比如:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code><br>而在 <code>Yield1</code> 这个状态, 存储的数据如下:</p>\n<pre><code class=\"rust\">// 状态的定义\nstruct Yield1State &#123;\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n&#125;\n\n// 状态的实例\nYield1State &#123;\n    arr: [1,2,3],\n    element: &amp;arr[2] as *const i32,\n&#125;\n</code></pre>\n<p>等等, 你可能会对上面的代码有疑惑:<br>不是说, 状态 只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>上面的代码, 只有 element 这个 引用 需要被保存吧?  </p>\n<p>这是因为, 它是 <code>引用</code> 嘛!<br>没了 <code>引用</code> 背后的实际数据, 那它还有啥用, 不就是 <code>悬垂引用</code> 了吗?  </p>\n<p>因此我们还得保存, <code>该引用</code> 指向的背后数据: <code>arr</code><br>并 <code>一起</code> 存储在同个 <code>struct (代表同一状态)</code>中  </p>\n<p>像这种 <code>结构体内部的指针, 指向结构体本身</code><br>就叫 <code>自引用结构</code>  </p>\n<p>比如上面代码: 同一结构体下, 成员 element 指向了成员 arr  </p>\n<h2 id=\"内存移动问题-导致悬垂引用产生\"><a href=\"#内存移动问题-导致悬垂引用产生\" class=\"headerlink\" title=\"内存移动问题(导致悬垂引用产生)\"></a>内存移动问题(导致悬垂引用产生)</h2><p>这就可能有问题发生, 如果 该struct实例 的 <code>内存地址发生改变</code><br>比如使用 <code>std::mem</code>, 让 struct实例 的内存地址, 发生移动  </p>\n<p>以上面的那段代码为例, 如下:  </p>\n<ul>\n<li><p>arr:<br>内存地址会跟着结构体实例而改变<br>但是, <code>值仍然是 [1,2,3]</code></p>\n</li>\n<li><p>element:<br>内存地址会跟着结构体实例而改变<br>但是, 值仍然是 <code>先前arr的地址</code><br><code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的 (悬垂引用)  </p>\n<p>官方提出了 <code>std::pin::Pin (trait)</code><br>来解决 自引用结构体 方面的 悬垂指针/引用问题 </p>\n<p>其实你听名字也很好理解:<br><code>Pin(中文意思是钉子)</code> 的作用是, 防止内存地址发生改变 (给爷钉死吧!)  </p>\n<p>但是它又是怎么pin住的呢?<br>下一节再慢慢讲吧  </p>\n<p>那又是一个值得探讨的话题了<br>欲知后事如何, 且听下回分解  </p>\n<p><del>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</del></p>\n<hr>\n<p>感谢大家观看! 有建议/发现错误/想聊天<br>请在评论区留言, 或者加本人qq也阔以</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>","more":"<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p><strong>注: 参考了 《Writing an OS in Rust》中的async篇, 可以自己搜索下看看</strong><br>为了更好地理解 <code>Rust异步</code> 背后的原理, 我们先来了解下一些概念<br>当然, 不用太深入, 只是小补充而已:   </p>\n<ul>\n<li><code>抢占式/协作式多任务</code>  </li>\n<li><code>状态机</code>  </li>\n<li><code>自引用结构体</code>   </li>\n</ul>\n<p>现在, 让我们开始吧!  </p>\n<hr>\n<h1 id=\"抢占式-协作式多任务的概念\"><a href=\"#抢占式-协作式多任务的概念\" class=\"headerlink\" title=\"抢占式/协作式多任务的概念\"></a>抢占式/协作式多任务的概念</h1><p><code>抢占式多任务</code> 与 <code>协作式多任务</code>, 都属于 <code>多任务</code>         </p>\n<ul>\n<li><p>抢占式多任务:<br>操作系统决定CPU的运行权<br>比如, 操作系统先让 网易云音乐 运行一会, 再让 VSCode 运行一会<br>各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种 <code>任务们同时运行</code> 的感觉<br>这是强迫/抢占的     </p>\n</li>\n<li><p>协作式多任务:<br>任务们本身进行协调, 决定CPU的运行权<br>比如Rust中, 运行时调用 某Task(top-level Future) 的 poll方法 阻塞时, 返回 Poll::Pending<br>自己放弃继续执行, 并通知运行时执行 其他Task<br>这是自愿/协作的, Task们 <code>自愿放弃CPU的执行权</code><br>(上文中的 <code>任务</code> 与 <code>Task</code> 请区分一下, 前者比后者广泛, 后者在这, 用于Rust的举例)  </p>\n</li>\n</ul>\n<hr>\n<h1 id=\"两种多任务的恢复-状态保存\"><a href=\"#两种多任务的恢复-状态保存\" class=\"headerlink\" title=\"两种多任务的恢复/状态保存\"></a>两种多任务的恢复/状态保存</h1><p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>该任务, 应当从先前暂停的地方开始, 继续执行<br>因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 <code>状态保存</code>  </p>\n<p>对于 <code>抢占式</code> 与 <code>协作式</code>, 处理 <code>状态保存</code> 的思路是不一样的:</p>\n<h2 id=\"抢占式\"><a href=\"#抢占式\" class=\"headerlink\" title=\"抢占式:\"></a>抢占式:</h2><p>因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>任务此时运行到了哪里? 我们不知道啊!<br>那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    </p>\n<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  </p>\n<h2 id=\"协作式\"><a href=\"#协作式\" class=\"headerlink\" title=\"协作式:\"></a>协作式:</h2><p>因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>这种放弃执行权的操作, 我们称为 <code>yield</code>    </p>\n<p>比如在Rust中, <code>xxx.await</code> 会执行一个Future<br>意味着当程序执行到这里时, 可能会 <code>yield</code> (poll 返回 Poll::Pending, 自愿放弃执行权)  </p>\n<p><code>xxx.await</code> 就是一个 <code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>因此, 我们可以准确分配 Future 执行所需要的最大空间  </p>\n<p>其实, 每个 <code>.await (也就是yield point)</code>, 就代表着 <code>一种状态</code> (之后会讲)</p>\n<p>协作式 的好处在于便于掌握所有的 yield point<br>在暂停之前, 准确保存 <code>下次继续所需要的状态</code>, 内存/性能优势很大<br>但坏处也有, 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  </p>\n<hr>\n<h1 id=\"状态机的概念\"><a href=\"#状态机的概念\" class=\"headerlink\" title=\"状态机的概念\"></a>状态机的概念</h1><p>在Rust中的异步, 我们之前也说过, 属于 <code>协作式多任务</code><br>而其 <code>状态保存</code> 的实现, 就是利用 <code>状态机(state machine)</code> 来实现  </p>\n<p><code>状态机 (state machine)</code> 一般指 <code>有限状态自动机</code>, 是一种 数学模型  </p>\n<ol>\n<li><p>状态 (state):<br>比如有一扇门, 它的状态就处于以下两种之一: Open or Closed    </p>\n</li>\n<li><p>事件 (event):<br>某事件 发生后, 会触发相应 动作, 可能改变状态, 比如: 用钥匙锁门(event) =&gt; 关门(action) =&gt; 门被锁住(state)   </p>\n</li>\n<li><p>动作 (action):<br>事件 发生后, 会触发 动作  </p>\n</li>\n<li><p>变换 (transition):<br><code>State_X =&gt; State_Y</code> 就叫 <code>变换</code>, 比如门的状态从 <code>Open =&gt; Closed</code>  </p>\n</li>\n</ol>\n<p>稍微了解下 <code>状态机</code> 的概念即可  </p>\n<p>那么现在, 就要看具体代码了  </p>\n<p>如果你想亲自运行一下, 先确保你的 <code>Cargo.toml</code> 中的依赖如下:  </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下, 读取一个文件的行数<br>你可以使用 <code>cargo run -- ./src/main.rs</code> 运行<br>(也可以编译后, 通过 <code>target/debug</code> 下的二进制文件运行)</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> &#123;</span><br><span class=\"line\">    std::env::args,</span><br><span class=\"line\">    async_std::prelude::*,</span><br><span class=\"line\">    async_std::fs::File,</span><br><span class=\"line\">    async_std::io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).expect(<span class=\"string\">&quot;Fuck you! No path for working&quot;</span>); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n<p>mian() 产生一个新实例, 异步运行 <code>open(path)</code> 与 <code>count()</code><br>对于编译器, 每一个 <code>.await</code> 其实都代表一种状态  </p>\n<p>Future实例, 实际上是个 状态机<br>在这里共有四种状态/阶段 (其中包括两个 <code>.await point(yield point)</code>):  </p>\n<ol>\n<li>Start: 此Future刚开始执行  </li>\n<li>Yield1: 第一个 yield point</li>\n<li>Yield2: 第二个 yield point</li>\n<li>Done: 此Future执行完毕</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>执行器调用 当前Future 的 poll 推动进度时, 若在 <code>某一阶段</code> 返回了 <code>Poll::Pending</code>, 则放弃执行权<br>当再次调用 当前Future 的 poll 推动进度时, 则从上次暂停的状态 <code>恢复 (resume)</code>, 继续执行  </p>\n<p>官方目前似乎采用 <code>Generator (生成器)</code> 为异步语法生成状态机<br>每一个状态都会存储一些数据, 便于进入下一个状态  </p>\n<p><strong>Note 1</strong>:<br>Start状态, 会存储传入函数的参数 (如果有参数)</p>\n<p><strong>Note 2</strong>:<br>Done状态下, 若进行 resume, 则可能得到 panic!<br>恢复已结束的计算是不应该的  </p>\n<p><strong>Note 3</strong>:<br>怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br><code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>如上段代码中的 <code>file</code>, <code>count</code> 就需要被保存, 因为从暂停中恢复后还需要使用<br>其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"自引用结构体\"><a href=\"#自引用结构体\" class=\"headerlink\" title=\"自引用结构体\"></a>自引用结构体</h1><h2 id=\"状态保存引用时\"><a href=\"#状态保存引用时\" class=\"headerlink\" title=\"状态保存引用时\"></a>状态保存引用时</h2><p>当每一个状态存储数据时, 可能会导致发生 <code>自引用</code>, 比如:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code><br>而在 <code>Yield1</code> 这个状态, 存储的数据如下:</p>\n<pre><code class=\"rust\">// 状态的定义\nstruct Yield1State &#123;\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n&#125;\n\n// 状态的实例\nYield1State &#123;\n    arr: [1,2,3],\n    element: &amp;arr[2] as *const i32,\n&#125;\n</code></pre>\n<p>等等, 你可能会对上面的代码有疑惑:<br>不是说, 状态 只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>上面的代码, 只有 element 这个 引用 需要被保存吧?  </p>\n<p>这是因为, 它是 <code>引用</code> 嘛!<br>没了 <code>引用</code> 背后的实际数据, 那它还有啥用, 不就是 <code>悬垂引用</code> 了吗?  </p>\n<p>因此我们还得保存, <code>该引用</code> 指向的背后数据: <code>arr</code><br>并 <code>一起</code> 存储在同个 <code>struct (代表同一状态)</code>中  </p>\n<p>像这种 <code>结构体内部的指针, 指向结构体本身</code><br>就叫 <code>自引用结构</code>  </p>\n<p>比如上面代码: 同一结构体下, 成员 element 指向了成员 arr  </p>\n<h2 id=\"内存移动问题-导致悬垂引用产生\"><a href=\"#内存移动问题-导致悬垂引用产生\" class=\"headerlink\" title=\"内存移动问题(导致悬垂引用产生)\"></a>内存移动问题(导致悬垂引用产生)</h2><p>这就可能有问题发生, 如果 该struct实例 的 <code>内存地址发生改变</code><br>比如使用 <code>std::mem</code>, 让 struct实例 的内存地址, 发生移动  </p>\n<p>以上面的那段代码为例, 如下:  </p>\n<ul>\n<li><p>arr:<br>内存地址会跟着结构体实例而改变<br>但是, <code>值仍然是 [1,2,3]</code></p>\n</li>\n<li><p>element:<br>内存地址会跟着结构体实例而改变<br>但是, 值仍然是 <code>先前arr的地址</code><br><code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的 (悬垂引用)  </p>\n<p>官方提出了 <code>std::pin::Pin (trait)</code><br>来解决 自引用结构体 方面的 悬垂指针/引用问题 </p>\n<p>其实你听名字也很好理解:<br><code>Pin(中文意思是钉子)</code> 的作用是, 防止内存地址发生改变 (给爷钉死吧!)  </p>\n<p>但是它又是怎么pin住的呢?<br>下一节再慢慢讲吧  </p>\n<p>那又是一个值得探讨的话题了<br>欲知后事如何, 且听下回分解  </p>\n<p><del>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</del></p>\n<hr>\n<p>感谢大家观看! 有建议/发现错误/想聊天<br>请在评论区留言, 或者加本人qq也阔以</p>"},{"title":"rs-dm-p1-系列说明","abbrlink":"rs-dm-p1","date":"2021-09-19T13:51:27.000Z","top":9899,"_content":"> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列教学  \n<!-- more -->\n# 课程说明:  \n**注: 请注意是 声明宏**\n传送门如下:  \n- [博客 : Rust声明宏系列](https://jedsek.github.io/categories/rust-declarative-macro/) \n- [B站视频 : Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n`博客` 的更新速度, 快于 `视频`  \n`博客` 若经过重写, 则会抽时间更新 `视频`  \n\n此系列, 我们将学习Rust中的 `声明宏`  \n- - - \n# 参考资料\n1. `书籍`\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. `文章`  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n- - -\n# 欢迎骚扰  \n在下QQ: `2948804617`   \n如果有问题, 可以一起探讨 ~~(但别忘了我是大菜鸡哦)~~  \n\n你也可以在文章下进行评论\n- - -\n","source":"_posts/rs-dm/rs-dm-p1-系列说明.md","raw":"---\ntitle: rs-dm-p1-系列说明\nabbrlink: rs-dm-p1\ndate: 2021-09-19 21:51:27\ntop: 9899\ntags: rust\ncategories: rust-decl-macro\n---\n> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列教学  \n<!-- more -->\n# 课程说明:  \n**注: 请注意是 声明宏**\n传送门如下:  \n- [博客 : Rust声明宏系列](https://jedsek.github.io/categories/rust-declarative-macro/) \n- [B站视频 : Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n`博客` 的更新速度, 快于 `视频`  \n`博客` 若经过重写, 则会抽时间更新 `视频`  \n\n此系列, 我们将学习Rust中的 `声明宏`  \n- - - \n# 参考资料\n1. `书籍`\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. `文章`  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n- - -\n# 欢迎骚扰  \n在下QQ: `2948804617`   \n如果有问题, 可以一起探讨 ~~(但别忘了我是大菜鸡哦)~~  \n\n你也可以在文章下进行评论\n- - -\n","slug":"rs-dm/rs-dm-p1-系列说明","published":1,"updated":"2021-10-02T07:11:36.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5ft0009bw5kdr6rf5cy","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列教学  </p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"课程说明\"><a href=\"#课程说明\" class=\"headerlink\" title=\"课程说明:\"></a>课程说明:</h1><p><strong>注: 请注意是 声明宏</strong><br>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-declarative-macro/\">博客 : Rust声明宏系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频 : Rust编程语言-声明宏</a></li>\n</ul>\n<p><code>博客</code> 的更新速度, 快于 <code>视频</code><br><code>博客</code> 若经过重写, 则会抽时间更新 <code>视频</code>  </p>\n<p>此系列, 我们将学习Rust中的 <code>声明宏</code>  </p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><code>书籍</code></li>\n</ol>\n<ul>\n<li><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a>  </li>\n<li><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></li>\n<li><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></li>\n</ul>\n<ol start=\"2\">\n<li><code>文章</code>  </li>\n</ol>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><p>在下QQ: <code>2948804617</code><br>如果有问题, 可以一起探讨 <del>(但别忘了我是大菜鸡哦)</del>  </p>\n<p>你也可以在文章下进行评论</p>\n<hr>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列教学  </p>\n</blockquote>","more":"<h1 id=\"课程说明\"><a href=\"#课程说明\" class=\"headerlink\" title=\"课程说明:\"></a>课程说明:</h1><p><strong>注: 请注意是 声明宏</strong><br>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-declarative-macro/\">博客 : Rust声明宏系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频 : Rust编程语言-声明宏</a></li>\n</ul>\n<p><code>博客</code> 的更新速度, 快于 <code>视频</code><br><code>博客</code> 若经过重写, 则会抽时间更新 <code>视频</code>  </p>\n<p>此系列, 我们将学习Rust中的 <code>声明宏</code>  </p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><code>书籍</code></li>\n</ol>\n<ul>\n<li><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a>  </li>\n<li><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></li>\n<li><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></li>\n</ul>\n<ol start=\"2\">\n<li><code>文章</code>  </li>\n</ol>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><p>在下QQ: <code>2948804617</code><br>如果有问题, 可以一起探讨 <del>(但别忘了我是大菜鸡哦)</del>  </p>\n<p>你也可以在文章下进行评论</p>\n<hr>"},{"title":"rs-dm-p3-声明与使用","abbrlink":"rs-dm-p3","top":9897,"date":"2021-09-20T12:06:15.000Z","_content":"> 正式系统的关于 macro 的 声明与使用\n<!-- more -->  \n前一节, 我们大概清楚了 macro 的结构  \n现在让我们再来简单复习一遍:  \n\n1. `macro_rules! (这是特点语法)` 来创建一个 macro\n2. `rule(s) (匹配分支: 参数 => 展开代码)` 放在最外层的花括号内  \n3. 调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 `println!()`\n\n- - -\n# 参数 && 展开\n是时候引入一些新的东西了, 让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\n\nfn main() {\n\tmy_macro!(1);      // 1\n\tmy_macro!(1, 2);   // 1 + 2\n}\n```\n\n你会注意到, 每个 rule 之间的参数, 都有点奇怪:  \n$ + 参数名 + 类型说明, 如 `$a: expr`  \n为何需要特意加上 $ 这个前缀? 马上就要讲到啦~  \n\n先来专注于 `expr` 这个后置的类型:  \n`expr`, 全称为 `expression (表达式)`  \n在第一次宏调用, 我们传入了 `1 (i32类型的字面量)`, 这当然是个表达式, 会与第一个 rule 成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为 `相应的展开代码`  \n\n当全部的宏, 都被 替换/展开 后, 再编译这些生成的最终版本代码 \n\n对于每个 rule, 实际上可以这么抽象它: `(pattern) => (expansion)` \n即 `(模式) => (展开代码)` \n\nmacro 的本质, 是根据传入的参数, 将调用部分给 替换/展开 为相应代码  \n即一个AST (Abstract Syntax Tree, 抽象语法树) 的节点 (设计编译原理, 马上就讲)\n简单理解: `macro 的本质, 就是代码生成器, 一段用于生成代码的代码`  \n\n\n为了加深印象, 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n\n\n\n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 && 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a && 1` 与 `$b && 2`, 还有个 `, && ,`  \n\n对于第三组关系, 其实它也是参数, 不过已经固定死了  \n这种固定的, 如同字面量一样的参数, 其类型其实叫做 `Literal Token Tree(字面量标记树)`  \n  \n\n因此, 假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! my {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tmy!(1);      // no\n\tmy!(a:expr);  // yes\n}\n```\n是不是特别狗日?  \n\n切记: `当你需要在传参时, 传入非字面量参数, 参数名前必须加上 $前缀 进行修饰`  \n\n接下来, 就要正式地讲讲本质了\n- - -\n\n# 本质  \n## 引入\n刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  \n\n为了理解这段话, 让我先来介绍一个概念: `token`  \n\n在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将\"xx\"视作&str类型  \n而是继续地进行抽象, 将这些值, 通通归类于 `expr类型(表达式类型)` 之下    \n\n`token类型`, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型  \n比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    \n\n实际上, 你写出来的Rust源代码, 将被解析为一大堆 `token`  \n而这些 token, 之后又会被解析为 `AST (抽象语法树)`  \n\n## 关于AST\n你想想, 假若由你来设计一个Rust编译器  \n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n一步登天, 直接由源码生成目标码是不现实的, 难度太大  \n\n因此啊, 得有一些介于 源码与目标码 之间的 `中间表示/代码 (IR)`, 层层递进, 以达目的  \n注意, 是一些, 而不是一个, 这很好理解, 因为一层可能不够嘛  \n所以多来几层 `IR (中间代码)` , 顺便进行下分工 (每一层都处理了些特定的事情), 这也增强了可维护性  \n\n比如 `AST` , 它就是一种 IR, 它是目标码被生成的关键, 是代码的骨架  \n编译器在AST的基础上, 可能会再来几层中间代码 (进行优化或者其他什么功能), 最后生成目标码  \n(以 Rust 为例, 出现的大致IR: AST -> HIR -> MIR -> LLVM_IR)\n\n而生成AST需要点啥? 需要一些 `token`  \n比如 expr(表达式), stmt(语句), ident(标识符) 等  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构  \n它将tokens组织起来, 表达了代码的逻辑  \n这个庞然大物便是 AST 了  \n\n而 token 的生成, 是万里长征的第一步  \n只有正确地将 token 分门别类, 你才能创建正确的AST (这里的正确不包括逻辑正确)\n\n还记得之前在对应游戏中的一对吗: `, && ,`  \n我们说它是 `Literal Token Tree(字面量标记树)`  \n字面上的意思: 这个 token 是字面量  \n\n但为什么它是单个token, 却又叫做token tree?  \n因为 `tree` 是可以只有一个节点的嘛  \n还可以有比较长的, 比如我们之前提到的宏:  \n```rust\nmacro_rules! my {\n\t// `a:expr` 是 `literal token tree`\n\t(a:expr) => { };\n}\n```\n\n- - - \n# 回到macro  \n## 例子\n通过中间代码, 我们层层递进, 向最终的目标码前进  \n\n其实你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助\n~~(不明白也根本没有关系, 因为我实在懒得多讲编译方面了, 真的麻烦)~~\n\nmacro 中, 其参数的类型, 便是token类型:  \n```rust\n// 定义一个macro, 求和传入的参数\nmacro_rules! sum {\n\t() => {};                            // 空参时, 啥也不干\n\t($a: expr) => { $a };                // 一个参数时, 求和结果是自己\n\t($a: expr ; $b:expr) => { $a + $b}    // 两个参数, 正常求和\n\t                                     // 更多参数, 等我们学 `重复` 语法后再说  \n}\n\nfn main() {\n\tsum!();        // 与第一个rule匹配, 木有展开的实际代码\n\tsum!(1);       // 与第二个rule匹配, 展开/替换为: 1\n\tsum!(1 ; 2); // 与第三个rule匹配, 展开为: 1 + 2\n}\n```\n\n我们通过使用 macro , 便能够站在更加抽象的视角上  \n操控传入的 token, 组成新的AST节点(生成新的代码), 参与编译的过程, 形成可执行的程序  \n\n像这种用代码生成代码的手段, 我们称之为 `Meta Programming (元编程)`  \n比如标准库的一些骚操作: 一个宏, 传入参数为 `i32 i64 u32 u64`, 便能为这些类型自动实现一些trait  \n\n因为我们还没有学习牛逼哄哄的 `重复` 语法, 这里就随便写个宏, 作用是创建函数, 来演示下:  \n```rust\nmacro_rules! create_func {\n\t($fn_name: ident) => {\n\t\tfn $fn_name() {\n\t\t\tprintln!(\"{}\", stringify!($fn_name)); \n\t\t\t// stringify 可以将传入的token字符串化, 记住就好, 内置的: `compiler built-in`\n\t\t\t// 这里使用它, 是因为无法直接打印 $fn_name, 不信你试试, 道理很简单, 懒得细讲了\n\t\t}\n\t};\n}\nfn main() {\n\tcreate_func!(foo);\n\tfoo();\n}\n\n/* 最后生成的代码:\nfn main() {\n    fn foo() {\n        println!(\"{}\", \"foo\");\n    }\n    foo();\n}\n*/\n```\n像标准库那种定义一个宏, 为传入的类型批量地自动化, 生成实现trait的代码  \n这事情函数做不到吧? 这就是元编程的魅力, 大幅度减少手写代码量, 提高幸福感  \nrust 中重要的元编程手段之一, 就是声明宏了  \n\n\n## token类型对照\nmacro通过操控传入的token, 生成相应的代码  \n编译器再通过这些代码, 生成目标码(这里指可执行的二进制程序)  \n\n既然macro是要操控这些传入的token, 我们总得知道token类型吧?  \n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指非字面量的参数)  \n\n所以, 辛苦你将下面的东西记一下哈  \n稍微记一下, 有个对照/印象就行, 多用几下保证你熟悉得不行:  \n\n- ident: 标识符, 如函数名字, 变量名字, 关键字  \n- stmt: statemen, 语句\n- expr: expression, 表达式\n- block: 代码块\n- pat: pattern, 比如在match表达式下的 (pattern) => todo!(),\n- path: 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径\n- ty: type, 如i32, u32, String, Option<T>等  \n- tt: token tree, 之后我会单独再讲解下它的  \n- item: 条目/项, 例如函数定义  \n- meta: 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)\n- lifetime: 生命周期  \n- vis: visibility, 可见性, 比如pub等, 也可能为空  \n\n\n那么今天就到这了, b站上的视频我会在周末一点点传到这个博客上的  \n视频上的文章内容, 当时没放到github上, 电脑坏了后直接没了......\n我索性来一点点重写/补充好了, 顺便来个备份  \n\ntmd还有作业, 中秋放假==没放, 真棒啊 (怒)  \n咋们下节见~  \n","source":"_posts/rs-dm/rs-dm-p3-声明与使用.md","raw":"---\ntitle: rs-dm-p3-声明与使用\nabbrlink: rs-dm-p3\ntop: 9897\ndate: 2021-09-20 20:06:15\ntags: rust\ncategories: rust-decl-macro\n---\n> 正式系统的关于 macro 的 声明与使用\n<!-- more -->  \n前一节, 我们大概清楚了 macro 的结构  \n现在让我们再来简单复习一遍:  \n\n1. `macro_rules! (这是特点语法)` 来创建一个 macro\n2. `rule(s) (匹配分支: 参数 => 展开代码)` 放在最外层的花括号内  \n3. 调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 `println!()`\n\n- - -\n# 参数 && 展开\n是时候引入一些新的东西了, 让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\n\nfn main() {\n\tmy_macro!(1);      // 1\n\tmy_macro!(1, 2);   // 1 + 2\n}\n```\n\n你会注意到, 每个 rule 之间的参数, 都有点奇怪:  \n$ + 参数名 + 类型说明, 如 `$a: expr`  \n为何需要特意加上 $ 这个前缀? 马上就要讲到啦~  \n\n先来专注于 `expr` 这个后置的类型:  \n`expr`, 全称为 `expression (表达式)`  \n在第一次宏调用, 我们传入了 `1 (i32类型的字面量)`, 这当然是个表达式, 会与第一个 rule 成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为 `相应的展开代码`  \n\n当全部的宏, 都被 替换/展开 后, 再编译这些生成的最终版本代码 \n\n对于每个 rule, 实际上可以这么抽象它: `(pattern) => (expansion)` \n即 `(模式) => (展开代码)` \n\nmacro 的本质, 是根据传入的参数, 将调用部分给 替换/展开 为相应代码  \n即一个AST (Abstract Syntax Tree, 抽象语法树) 的节点 (设计编译原理, 马上就讲)\n简单理解: `macro 的本质, 就是代码生成器, 一段用于生成代码的代码`  \n\n\n为了加深印象, 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n\n\n\n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 && 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a && 1` 与 `$b && 2`, 还有个 `, && ,`  \n\n对于第三组关系, 其实它也是参数, 不过已经固定死了  \n这种固定的, 如同字面量一样的参数, 其类型其实叫做 `Literal Token Tree(字面量标记树)`  \n  \n\n因此, 假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! my {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tmy!(1);      // no\n\tmy!(a:expr);  // yes\n}\n```\n是不是特别狗日?  \n\n切记: `当你需要在传参时, 传入非字面量参数, 参数名前必须加上 $前缀 进行修饰`  \n\n接下来, 就要正式地讲讲本质了\n- - -\n\n# 本质  \n## 引入\n刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  \n\n为了理解这段话, 让我先来介绍一个概念: `token`  \n\n在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将\"xx\"视作&str类型  \n而是继续地进行抽象, 将这些值, 通通归类于 `expr类型(表达式类型)` 之下    \n\n`token类型`, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型  \n比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    \n\n实际上, 你写出来的Rust源代码, 将被解析为一大堆 `token`  \n而这些 token, 之后又会被解析为 `AST (抽象语法树)`  \n\n## 关于AST\n你想想, 假若由你来设计一个Rust编译器  \n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n一步登天, 直接由源码生成目标码是不现实的, 难度太大  \n\n因此啊, 得有一些介于 源码与目标码 之间的 `中间表示/代码 (IR)`, 层层递进, 以达目的  \n注意, 是一些, 而不是一个, 这很好理解, 因为一层可能不够嘛  \n所以多来几层 `IR (中间代码)` , 顺便进行下分工 (每一层都处理了些特定的事情), 这也增强了可维护性  \n\n比如 `AST` , 它就是一种 IR, 它是目标码被生成的关键, 是代码的骨架  \n编译器在AST的基础上, 可能会再来几层中间代码 (进行优化或者其他什么功能), 最后生成目标码  \n(以 Rust 为例, 出现的大致IR: AST -> HIR -> MIR -> LLVM_IR)\n\n而生成AST需要点啥? 需要一些 `token`  \n比如 expr(表达式), stmt(语句), ident(标识符) 等  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构  \n它将tokens组织起来, 表达了代码的逻辑  \n这个庞然大物便是 AST 了  \n\n而 token 的生成, 是万里长征的第一步  \n只有正确地将 token 分门别类, 你才能创建正确的AST (这里的正确不包括逻辑正确)\n\n还记得之前在对应游戏中的一对吗: `, && ,`  \n我们说它是 `Literal Token Tree(字面量标记树)`  \n字面上的意思: 这个 token 是字面量  \n\n但为什么它是单个token, 却又叫做token tree?  \n因为 `tree` 是可以只有一个节点的嘛  \n还可以有比较长的, 比如我们之前提到的宏:  \n```rust\nmacro_rules! my {\n\t// `a:expr` 是 `literal token tree`\n\t(a:expr) => { };\n}\n```\n\n- - - \n# 回到macro  \n## 例子\n通过中间代码, 我们层层递进, 向最终的目标码前进  \n\n其实你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助\n~~(不明白也根本没有关系, 因为我实在懒得多讲编译方面了, 真的麻烦)~~\n\nmacro 中, 其参数的类型, 便是token类型:  \n```rust\n// 定义一个macro, 求和传入的参数\nmacro_rules! sum {\n\t() => {};                            // 空参时, 啥也不干\n\t($a: expr) => { $a };                // 一个参数时, 求和结果是自己\n\t($a: expr ; $b:expr) => { $a + $b}    // 两个参数, 正常求和\n\t                                     // 更多参数, 等我们学 `重复` 语法后再说  \n}\n\nfn main() {\n\tsum!();        // 与第一个rule匹配, 木有展开的实际代码\n\tsum!(1);       // 与第二个rule匹配, 展开/替换为: 1\n\tsum!(1 ; 2); // 与第三个rule匹配, 展开为: 1 + 2\n}\n```\n\n我们通过使用 macro , 便能够站在更加抽象的视角上  \n操控传入的 token, 组成新的AST节点(生成新的代码), 参与编译的过程, 形成可执行的程序  \n\n像这种用代码生成代码的手段, 我们称之为 `Meta Programming (元编程)`  \n比如标准库的一些骚操作: 一个宏, 传入参数为 `i32 i64 u32 u64`, 便能为这些类型自动实现一些trait  \n\n因为我们还没有学习牛逼哄哄的 `重复` 语法, 这里就随便写个宏, 作用是创建函数, 来演示下:  \n```rust\nmacro_rules! create_func {\n\t($fn_name: ident) => {\n\t\tfn $fn_name() {\n\t\t\tprintln!(\"{}\", stringify!($fn_name)); \n\t\t\t// stringify 可以将传入的token字符串化, 记住就好, 内置的: `compiler built-in`\n\t\t\t// 这里使用它, 是因为无法直接打印 $fn_name, 不信你试试, 道理很简单, 懒得细讲了\n\t\t}\n\t};\n}\nfn main() {\n\tcreate_func!(foo);\n\tfoo();\n}\n\n/* 最后生成的代码:\nfn main() {\n    fn foo() {\n        println!(\"{}\", \"foo\");\n    }\n    foo();\n}\n*/\n```\n像标准库那种定义一个宏, 为传入的类型批量地自动化, 生成实现trait的代码  \n这事情函数做不到吧? 这就是元编程的魅力, 大幅度减少手写代码量, 提高幸福感  \nrust 中重要的元编程手段之一, 就是声明宏了  \n\n\n## token类型对照\nmacro通过操控传入的token, 生成相应的代码  \n编译器再通过这些代码, 生成目标码(这里指可执行的二进制程序)  \n\n既然macro是要操控这些传入的token, 我们总得知道token类型吧?  \n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指非字面量的参数)  \n\n所以, 辛苦你将下面的东西记一下哈  \n稍微记一下, 有个对照/印象就行, 多用几下保证你熟悉得不行:  \n\n- ident: 标识符, 如函数名字, 变量名字, 关键字  \n- stmt: statemen, 语句\n- expr: expression, 表达式\n- block: 代码块\n- pat: pattern, 比如在match表达式下的 (pattern) => todo!(),\n- path: 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径\n- ty: type, 如i32, u32, String, Option<T>等  \n- tt: token tree, 之后我会单独再讲解下它的  \n- item: 条目/项, 例如函数定义  \n- meta: 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)\n- lifetime: 生命周期  \n- vis: visibility, 可见性, 比如pub等, 也可能为空  \n\n\n那么今天就到这了, b站上的视频我会在周末一点点传到这个博客上的  \n视频上的文章内容, 当时没放到github上, 电脑坏了后直接没了......\n我索性来一点点重写/补充好了, 顺便来个备份  \n\ntmd还有作业, 中秋放假==没放, 真棒啊 (怒)  \n咋们下节见~  \n","slug":"rs-dm/rs-dm-p3-声明与使用","published":1,"updated":"2021-10-02T07:28:09.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5fv000dbw5k71id5asc","content":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>\n<span id=\"more\"></span>  \n<p>前一节, 我们大概清楚了 macro 的结构<br>现在让我们再来简单复习一遍:  </p>\n<ol>\n<li><code>macro_rules! (这是特点语法)</code> 来创建一个 macro</li>\n<li><code>rule(s) (匹配分支: 参数 =&gt; 展开代码)</code> 放在最外层的花括号内  </li>\n<li>调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 <code>println!()</code></li>\n</ol>\n<hr>\n<h1 id=\"参数-amp-amp-展开\"><a href=\"#参数-amp-amp-展开\" class=\"headerlink\" title=\"参数 &amp;&amp; 展开\"></a>参数 &amp;&amp; 展开</h1><p>是时候引入一些新的东西了, 让我们来看个例子:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);      <span class=\"comment\">// 1</span></span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);   <span class=\"comment\">// 1 + 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到, 每个 rule 之间的参数, 都有点奇怪:<br>$ + 参数名 + 类型说明, 如 <code>$a: expr</code><br>为何需要特意加上 $ 这个前缀? 马上就要讲到啦~  </p>\n<p>先来专注于 <code>expr</code> 这个后置的类型:<br><code>expr</code>, 全称为 <code>expression (表达式)</code><br>在第一次宏调用, 我们传入了 <code>1 (i32类型的字面量)</code>, 这当然是个表达式, 会与第一个 rule 成功匹配<br>这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为 <code>相应的展开代码</code>  </p>\n<p>当全部的宏, 都被 替换/展开 后, 再编译这些生成的最终版本代码 </p>\n<p>对于每个 rule, 实际上可以这么抽象它: <code>(pattern) =&gt; (expansion)</code><br>即 <code>(模式) =&gt; (展开代码)</code> </p>\n<p>macro 的本质, 是根据传入的参数, 将调用部分给 替换/展开 为相应代码<br>即一个AST (Abstract Syntax Tree, 抽象语法树) 的节点 (设计编译原理, 马上就讲)<br>简单理解: <code>macro 的本质, 就是代码生成器, 一段用于生成代码的代码</code>  </p>\n<p>为了加深印象, 我们来玩个对应游戏:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n\n<p>我使用 <code>|</code> 来联系 <code>形参 &amp;&amp; 实参</code><br>你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a &amp;&amp; 1</code> 与 <code>$b &amp;&amp; 2</code>, 还有个 <code>, &amp;&amp; ,</code>  </p>\n<p>对于第三组关系, 其实它也是参数, 不过已经固定死了<br>这种固定的, 如同字面量一样的参数, 其类型其实叫做 <code>Literal Token Tree(字面量标记树)</code>  </p>\n<p>因此, 假若 rule 中的参数没有 $前缀 进行区分:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my!(<span class=\"number\">1</span>);      <span class=\"comment\">// no</span></span><br><span class=\"line\">    my!(a:expr);  <span class=\"comment\">// yes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是特别狗日?  </p>\n<p>切记: <code>当你需要在传参时, 传入非字面量参数, 参数名前必须加上 $前缀 进行修饰</code>  </p>\n<p>接下来, 就要正式地讲讲本质了</p>\n<hr>\n<h1 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  </p>\n<p>为了理解这段话, 让我先来介绍一个概念: <code>token</code>  </p>\n<p>在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将”xx”视作&amp;str类型<br>而是继续地进行抽象, 将这些值, 通通归类于 <code>expr类型(表达式类型)</code> 之下    </p>\n<p><code>token类型</code>, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型<br>比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    </p>\n<p>实际上, 你写出来的Rust源代码, 将被解析为一大堆 <code>token</code><br>而这些 token, 之后又会被解析为 <code>AST (抽象语法树)</code>  </p>\n<h2 id=\"关于AST\"><a href=\"#关于AST\" class=\"headerlink\" title=\"关于AST\"></a>关于AST</h2><p>你想想, 假若由你来设计一个Rust编译器<br>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>一步登天, 直接由源码生成目标码是不现实的, 难度太大  </p>\n<p>因此啊, 得有一些介于 源码与目标码 之间的 <code>中间表示/代码 (IR)</code>, 层层递进, 以达目的<br>注意, 是一些, 而不是一个, 这很好理解, 因为一层可能不够嘛<br>所以多来几层 <code>IR (中间代码)</code> , 顺便进行下分工 (每一层都处理了些特定的事情), 这也增强了可维护性  </p>\n<p>比如 <code>AST</code> , 它就是一种 IR, 它是目标码被生成的关键, 是代码的骨架<br>编译器在AST的基础上, 可能会再来几层中间代码 (进行优化或者其他什么功能), 最后生成目标码<br>(以 Rust 为例, 出现的大致IR: AST -&gt; HIR -&gt; MIR -&gt; LLVM_IR)</p>\n<p>而生成AST需要点啥? 需要一些 <code>token</code><br>比如 expr(表达式), stmt(语句), ident(标识符) 等  </p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>它将tokens组织起来, 表达了代码的逻辑<br>这个庞然大物便是 AST 了  </p>\n<p>而 token 的生成, 是万里长征的第一步<br>只有正确地将 token 分门别类, 你才能创建正确的AST (这里的正确不包括逻辑正确)</p>\n<p>还记得之前在对应游戏中的一对吗: <code>, &amp;&amp; ,</code><br>我们说它是 <code>Literal Token Tree(字面量标记树)</code><br>字面上的意思: 这个 token 是字面量  </p>\n<p>但为什么它是单个token, 却又叫做token tree?<br>因为 <code>tree</code> 是可以只有一个节点的嘛<br>还可以有比较长的, 比如我们之前提到的宏:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my &#123;</span><br><span class=\"line\">    <span class=\"comment\">// `a:expr` 是 `literal token tree`</span></span><br><span class=\"line\">    (a:expr) =&gt; &#123; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"回到macro\"><a href=\"#回到macro\" class=\"headerlink\" title=\"回到macro\"></a>回到macro</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>通过中间代码, 我们层层递进, 向最终的目标码前进  </p>\n<p>其实你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助<br><del>(不明白也根本没有关系, 因为我实在懒得多讲编译方面了, 真的麻烦)</del></p>\n<p>macro 中, 其参数的类型, 便是token类型:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个macro, 求和传入的参数</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;                            <span class=\"comment\">// 空参时, 啥也不干</span></span><br><span class=\"line\">    ($a: expr) =&gt; &#123; $a &#125;;                <span class=\"comment\">// 一个参数时, 求和结果是自己</span></span><br><span class=\"line\">    ($a: expr ; $b:expr) =&gt; &#123; $a + $b&#125;    <span class=\"comment\">// 两个参数, 正常求和</span></span><br><span class=\"line\">                                         <span class=\"comment\">// 更多参数, 等我们学 `重复` 语法后再说  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();        <span class=\"comment\">// 与第一个rule匹配, 木有展开的实际代码</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>);       <span class=\"comment\">// 与第二个rule匹配, 展开/替换为: 1</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span> ; <span class=\"number\">2</span>); <span class=\"comment\">// 与第三个rule匹配, 展开为: 1 + 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过使用 macro , 便能够站在更加抽象的视角上<br>操控传入的 token, 组成新的AST节点(生成新的代码), 参与编译的过程, 形成可执行的程序  </p>\n<p>像这种用代码生成代码的手段, 我们称之为 <code>Meta Programming (元编程)</code><br>比如标准库的一些骚操作: 一个宏, 传入参数为 <code>i32 i64 u32 u64</code>, 便能为这些类型自动实现一些trait  </p>\n<p>因为我们还没有学习牛逼哄哄的 <code>重复</code> 语法, 这里就随便写个宏, 作用是创建函数, 来演示下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_func &#123;</span><br><span class=\"line\">    ($fn_name: ident) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> $<span class=\"title\">fn_name</span></span>() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($fn_name)); </span><br><span class=\"line\">            <span class=\"comment\">// stringify 可以将传入的token字符串化, 记住就好, 内置的: `compiler built-in`</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里使用它, 是因为无法直接打印 $fn_name, 不信你试试, 道理很简单, 懒得细讲了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_func!(foo);</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 最后生成的代码:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    fn foo() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        println!(&quot;&#123;&#125;&quot;, &quot;foo&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    foo();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>像标准库那种定义一个宏, 为传入的类型批量地自动化, 生成实现trait的代码<br>这事情函数做不到吧? 这就是元编程的魅力, 大幅度减少手写代码量, 提高幸福感<br>rust 中重要的元编程手段之一, 就是声明宏了  </p>\n<h2 id=\"token类型对照\"><a href=\"#token类型对照\" class=\"headerlink\" title=\"token类型对照\"></a>token类型对照</h2><p>macro通过操控传入的token, 生成相应的代码<br>编译器再通过这些代码, 生成目标码(这里指可执行的二进制程序)  </p>\n<p>既然macro是要操控这些传入的token, 我们总得知道token类型吧?<br>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指非字面量的参数)  </p>\n<p>所以, 辛苦你将下面的东西记一下哈<br>稍微记一下, 有个对照/印象就行, 多用几下保证你熟悉得不行:  </p>\n<ul>\n<li>ident: 标识符, 如函数名字, 变量名字, 关键字  </li>\n<li>stmt: statemen, 语句</li>\n<li>expr: expression, 表达式</li>\n<li>block: 代码块</li>\n<li>pat: pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),</li>\n<li>path: 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径</li>\n<li>ty: type, 如i32, u32, String, Option<T>等  </li>\n<li>tt: token tree, 之后我会单独再讲解下它的  </li>\n<li>item: 条目/项, 例如函数定义  </li>\n<li>meta: 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)</li>\n<li>lifetime: 生命周期  </li>\n<li>vis: visibility, 可见性, 比如pub等, 也可能为空  </li>\n</ul>\n<p>那么今天就到这了, b站上的视频我会在周末一点点传到这个博客上的<br>视频上的文章内容, 当时没放到github上, 电脑坏了后直接没了……<br>我索性来一点点重写/补充好了, 顺便来个备份  </p>\n<p>tmd还有作业, 中秋放假==没放, 真棒啊 (怒)<br>咋们下节见~  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>","more":"<p>前一节, 我们大概清楚了 macro 的结构<br>现在让我们再来简单复习一遍:  </p>\n<ol>\n<li><code>macro_rules! (这是特点语法)</code> 来创建一个 macro</li>\n<li><code>rule(s) (匹配分支: 参数 =&gt; 展开代码)</code> 放在最外层的花括号内  </li>\n<li>调用宏时, 宏名 + 感叹号 + 括号内传参, 比如 <code>println!()</code></li>\n</ol>\n<hr>\n<h1 id=\"参数-amp-amp-展开\"><a href=\"#参数-amp-amp-展开\" class=\"headerlink\" title=\"参数 &amp;&amp; 展开\"></a>参数 &amp;&amp; 展开</h1><p>是时候引入一些新的东西了, 让我们来看个例子:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);      <span class=\"comment\">// 1</span></span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);   <span class=\"comment\">// 1 + 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到, 每个 rule 之间的参数, 都有点奇怪:<br>$ + 参数名 + 类型说明, 如 <code>$a: expr</code><br>为何需要特意加上 $ 这个前缀? 马上就要讲到啦~  </p>\n<p>先来专注于 <code>expr</code> 这个后置的类型:<br><code>expr</code>, 全称为 <code>expression (表达式)</code><br>在第一次宏调用, 我们传入了 <code>1 (i32类型的字面量)</code>, 这当然是个表达式, 会与第一个 rule 成功匹配<br>这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为 <code>相应的展开代码</code>  </p>\n<p>当全部的宏, 都被 替换/展开 后, 再编译这些生成的最终版本代码 </p>\n<p>对于每个 rule, 实际上可以这么抽象它: <code>(pattern) =&gt; (expansion)</code><br>即 <code>(模式) =&gt; (展开代码)</code> </p>\n<p>macro 的本质, 是根据传入的参数, 将调用部分给 替换/展开 为相应代码<br>即一个AST (Abstract Syntax Tree, 抽象语法树) 的节点 (设计编译原理, 马上就讲)<br>简单理解: <code>macro 的本质, 就是代码生成器, 一段用于生成代码的代码</code>  </p>\n<p>为了加深印象, 我们来玩个对应游戏:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n\n<p>我使用 <code>|</code> 来联系 <code>形参 &amp;&amp; 实参</code><br>你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a &amp;&amp; 1</code> 与 <code>$b &amp;&amp; 2</code>, 还有个 <code>, &amp;&amp; ,</code>  </p>\n<p>对于第三组关系, 其实它也是参数, 不过已经固定死了<br>这种固定的, 如同字面量一样的参数, 其类型其实叫做 <code>Literal Token Tree(字面量标记树)</code>  </p>\n<p>因此, 假若 rule 中的参数没有 $前缀 进行区分:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my!(<span class=\"number\">1</span>);      <span class=\"comment\">// no</span></span><br><span class=\"line\">    my!(a:expr);  <span class=\"comment\">// yes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是不是特别狗日?  </p>\n<p>切记: <code>当你需要在传参时, 传入非字面量参数, 参数名前必须加上 $前缀 进行修饰</code>  </p>\n<p>接下来, 就要正式地讲讲本质了</p>\n<hr>\n<h1 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>刚刚简单提了一嘴. macro 实际上是个代码生成器, 是一段用于生成代码的代码  </p>\n<p>为了理解这段话, 让我先来介绍一个概念: <code>token</code>  </p>\n<p>在更加抽象的层面上, 我并不将1视作i32类型, 并不将true视作bool类型, 并不将”xx”视作&amp;str类型<br>而是继续地进行抽象, 将这些值, 通通归类于 <code>expr类型(表达式类型)</code> 之下    </p>\n<p><code>token类型</code>, 我暂时以这么个简单名字, 指代某种更加抽象, 包含更广的类型<br>比如 表达式(expr类型), 语句(stmt类型), 标识符(ident类型) 等    </p>\n<p>实际上, 你写出来的Rust源代码, 将被解析为一大堆 <code>token</code><br>而这些 token, 之后又会被解析为 <code>AST (抽象语法树)</code>  </p>\n<h2 id=\"关于AST\"><a href=\"#关于AST\" class=\"headerlink\" title=\"关于AST\"></a>关于AST</h2><p>你想想, 假若由你来设计一个Rust编译器<br>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>一步登天, 直接由源码生成目标码是不现实的, 难度太大  </p>\n<p>因此啊, 得有一些介于 源码与目标码 之间的 <code>中间表示/代码 (IR)</code>, 层层递进, 以达目的<br>注意, 是一些, 而不是一个, 这很好理解, 因为一层可能不够嘛<br>所以多来几层 <code>IR (中间代码)</code> , 顺便进行下分工 (每一层都处理了些特定的事情), 这也增强了可维护性  </p>\n<p>比如 <code>AST</code> , 它就是一种 IR, 它是目标码被生成的关键, 是代码的骨架<br>编译器在AST的基础上, 可能会再来几层中间代码 (进行优化或者其他什么功能), 最后生成目标码<br>(以 Rust 为例, 出现的大致IR: AST -&gt; HIR -&gt; MIR -&gt; LLVM_IR)</p>\n<p>而生成AST需要点啥? 需要一些 <code>token</code><br>比如 expr(表达式), stmt(语句), ident(标识符) 等  </p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>它将tokens组织起来, 表达了代码的逻辑<br>这个庞然大物便是 AST 了  </p>\n<p>而 token 的生成, 是万里长征的第一步<br>只有正确地将 token 分门别类, 你才能创建正确的AST (这里的正确不包括逻辑正确)</p>\n<p>还记得之前在对应游戏中的一对吗: <code>, &amp;&amp; ,</code><br>我们说它是 <code>Literal Token Tree(字面量标记树)</code><br>字面上的意思: 这个 token 是字面量  </p>\n<p>但为什么它是单个token, 却又叫做token tree?<br>因为 <code>tree</code> 是可以只有一个节点的嘛<br>还可以有比较长的, 比如我们之前提到的宏:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my &#123;</span><br><span class=\"line\">    <span class=\"comment\">// `a:expr` 是 `literal token tree`</span></span><br><span class=\"line\">    (a:expr) =&gt; &#123; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"回到macro\"><a href=\"#回到macro\" class=\"headerlink\" title=\"回到macro\"></a>回到macro</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>通过中间代码, 我们层层递进, 向最终的目标码前进  </p>\n<p>其实你只需晓得, 编译成二进制的可执行版本, 需要 AST, 而 组成 AST 又需要 token 协助<br><del>(不明白也根本没有关系, 因为我实在懒得多讲编译方面了, 真的麻烦)</del></p>\n<p>macro 中, 其参数的类型, 便是token类型:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个macro, 求和传入的参数</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;                            <span class=\"comment\">// 空参时, 啥也不干</span></span><br><span class=\"line\">    ($a: expr) =&gt; &#123; $a &#125;;                <span class=\"comment\">// 一个参数时, 求和结果是自己</span></span><br><span class=\"line\">    ($a: expr ; $b:expr) =&gt; &#123; $a + $b&#125;    <span class=\"comment\">// 两个参数, 正常求和</span></span><br><span class=\"line\">                                         <span class=\"comment\">// 更多参数, 等我们学 `重复` 语法后再说  </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();        <span class=\"comment\">// 与第一个rule匹配, 木有展开的实际代码</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>);       <span class=\"comment\">// 与第二个rule匹配, 展开/替换为: 1</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span> ; <span class=\"number\">2</span>); <span class=\"comment\">// 与第三个rule匹配, 展开为: 1 + 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们通过使用 macro , 便能够站在更加抽象的视角上<br>操控传入的 token, 组成新的AST节点(生成新的代码), 参与编译的过程, 形成可执行的程序  </p>\n<p>像这种用代码生成代码的手段, 我们称之为 <code>Meta Programming (元编程)</code><br>比如标准库的一些骚操作: 一个宏, 传入参数为 <code>i32 i64 u32 u64</code>, 便能为这些类型自动实现一些trait  </p>\n<p>因为我们还没有学习牛逼哄哄的 <code>重复</code> 语法, 这里就随便写个宏, 作用是创建函数, 来演示下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_func &#123;</span><br><span class=\"line\">    ($fn_name: ident) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fn</span> $<span class=\"title\">fn_name</span></span>() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($fn_name)); </span><br><span class=\"line\">            <span class=\"comment\">// stringify 可以将传入的token字符串化, 记住就好, 内置的: `compiler built-in`</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里使用它, 是因为无法直接打印 $fn_name, 不信你试试, 道理很简单, 懒得细讲了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_func!(foo);</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 最后生成的代码:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    fn foo() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        println!(&quot;&#123;&#125;&quot;, &quot;foo&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    foo();</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>像标准库那种定义一个宏, 为传入的类型批量地自动化, 生成实现trait的代码<br>这事情函数做不到吧? 这就是元编程的魅力, 大幅度减少手写代码量, 提高幸福感<br>rust 中重要的元编程手段之一, 就是声明宏了  </p>\n<h2 id=\"token类型对照\"><a href=\"#token类型对照\" class=\"headerlink\" title=\"token类型对照\"></a>token类型对照</h2><p>macro通过操控传入的token, 生成相应的代码<br>编译器再通过这些代码, 生成目标码(这里指可执行的二进制程序)  </p>\n<p>既然macro是要操控这些传入的token, 我们总得知道token类型吧?<br>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指非字面量的参数)  </p>\n<p>所以, 辛苦你将下面的东西记一下哈<br>稍微记一下, 有个对照/印象就行, 多用几下保证你熟悉得不行:  </p>\n<ul>\n<li>ident: 标识符, 如函数名字, 变量名字, 关键字  </li>\n<li>stmt: statemen, 语句</li>\n<li>expr: expression, 表达式</li>\n<li>block: 代码块</li>\n<li>pat: pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),</li>\n<li>path: 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径</li>\n<li>ty: type, 如i32, u32, String, Option<T>等  </li>\n<li>tt: token tree, 之后我会单独再讲解下它的  </li>\n<li>item: 条目/项, 例如函数定义  </li>\n<li>meta: 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)</li>\n<li>lifetime: 生命周期  </li>\n<li>vis: visibility, 可见性, 比如pub等, 也可能为空  </li>\n</ul>\n<p>那么今天就到这了, b站上的视频我会在周末一点点传到这个博客上的<br>视频上的文章内容, 当时没放到github上, 电脑坏了后直接没了……<br>我索性来一点点重写/补充好了, 顺便来个备份  </p>\n<p>tmd还有作业, 中秋放假==没放, 真棒啊 (怒)<br>咋们下节见~  </p>"},{"title":"rs-dm-p2-从println开始","abbrlink":"rs-dm-p2","date":"2021-09-19T14:50:27.000Z","top":9898,"_content":"> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n# 开篇  \n大家应该都用过一个宏  \n它就是 `println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑:  \n为什么后面要跟个感叹号?  \n为什么括号里面的参数可以不一样?  \n\n亲爱的 TRPl 在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 的时候, 告诉过你: 名字后加个感叹号, 就是个 `宏(macro)`  \n注: macro 的读音: [ˈmækroʊ]\n\n可是 macro 到底是啥?  \n~~(算了算了, 反正只要会用就行了, 于是你点击了该网页的叉叉)~~  \n\n- - -\n# 查看定义  \n让我们按住Ctrl, 鼠标左键 println!  \n(以 VSCode 为例)  \n\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现根本看不懂这一大堆鬼画符......  \n但看不懂根本没关系, 后面几节过后, 你肯定懂了  \n现在只需明白的, 是大致结构:  \n\n1. 我们将 `macro_rules!` 放在 `println` 前面, 说明后者是个宏 \n(`macro_rules!` 当作特定语法即可)  \n\n2. 之后用花括号包起来, 里面是该宏的具体定义  \n\n问题来了, 关键是 `println` 的具体定义  \n花括号内, 到底在讲述着啥?  \n\n请容许我来帮你粗暴地类比一下 `match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro 有点像是 match, 能根据不同参数, 展开不同的代码  \n在 macro 最外层的花括号中, 有许多匹配分支  \n\nmatch表达式, 称呼每个匹配分支为 `arm`  \n逗号分割它们彼此, 或者不用逗号而用花括号包裹来分割  \n最后一个 arm 可省略逗号  \n(上面代码, 便是例子)\n\nmacro, 则称呼每个匹配分支为 `rule` (明白为什么使用 `macro_rules!` 创建宏了吗)  \n必须使用花括号包裹, 使用分号分隔彼此  \n最后一个 rule 可省略分号\n(上面代码, 便是例子)\n\n你并不需搞清所有细节, 现在先不用试图记忆具体语法, 有印象即可  \n现在再来看看 `println`, 是不是稍微有点感觉了 (看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建 macro, 名字就叫 xxx, 花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\n\nfn main() {}\n```\n\n2. 创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {}\n```\n\n3. 调用, 宏名+感叹号+传参:  \n(传入的参数, 若与任何 rule 都不匹配, 则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知  \n相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  ","source":"_posts/rs-dm/rs-dm-p2-从println开始.md","raw":"---\ntitle: rs-dm-p2-从println开始\nabbrlink: rs-dm-p2\ndate: 2021-09-19 22:50:27\ntop: 9898\ntags: rust\ncategories: rust-decl-macro\n---\n> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n# 开篇  \n大家应该都用过一个宏  \n它就是 `println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑:  \n为什么后面要跟个感叹号?  \n为什么括号里面的参数可以不一样?  \n\n亲爱的 TRPl 在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 的时候, 告诉过你: 名字后加个感叹号, 就是个 `宏(macro)`  \n注: macro 的读音: [ˈmækroʊ]\n\n可是 macro 到底是啥?  \n~~(算了算了, 反正只要会用就行了, 于是你点击了该网页的叉叉)~~  \n\n- - -\n# 查看定义  \n让我们按住Ctrl, 鼠标左键 println!  \n(以 VSCode 为例)  \n\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现根本看不懂这一大堆鬼画符......  \n但看不懂根本没关系, 后面几节过后, 你肯定懂了  \n现在只需明白的, 是大致结构:  \n\n1. 我们将 `macro_rules!` 放在 `println` 前面, 说明后者是个宏 \n(`macro_rules!` 当作特定语法即可)  \n\n2. 之后用花括号包起来, 里面是该宏的具体定义  \n\n问题来了, 关键是 `println` 的具体定义  \n花括号内, 到底在讲述着啥?  \n\n请容许我来帮你粗暴地类比一下 `match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro 有点像是 match, 能根据不同参数, 展开不同的代码  \n在 macro 最外层的花括号中, 有许多匹配分支  \n\nmatch表达式, 称呼每个匹配分支为 `arm`  \n逗号分割它们彼此, 或者不用逗号而用花括号包裹来分割  \n最后一个 arm 可省略逗号  \n(上面代码, 便是例子)\n\nmacro, 则称呼每个匹配分支为 `rule` (明白为什么使用 `macro_rules!` 创建宏了吗)  \n必须使用花括号包裹, 使用分号分隔彼此  \n最后一个 rule 可省略分号\n(上面代码, 便是例子)\n\n你并不需搞清所有细节, 现在先不用试图记忆具体语法, 有印象即可  \n现在再来看看 `println`, 是不是稍微有点感觉了 (看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建 macro, 名字就叫 xxx, 花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\n\nfn main() {}\n```\n\n2. 创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {}\n```\n\n3. 调用, 宏名+感叹号+传参:  \n(传入的参数, 若与任何 rule 都不匹配, 则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知  \n相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  ","slug":"rs-dm/rs-dm-p2-从println开始","published":1,"updated":"2021-10-02T07:11:36.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku9qt5fw000fbw5k9kpid0xx","content":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  </p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>大家应该都用过一个宏<br>它就是 <code>println!</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>为什么后面要跟个感叹号?<br>为什么括号里面的参数可以不一样?  </p>\n<p>亲爱的 TRPl 在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 的时候, 告诉过你: 名字后加个感叹号, 就是个 <code>宏(macro)</code><br>注: macro 的读音: [ˈmækroʊ]</p>\n<p>可是 macro 到底是啥?<br><del>(算了算了, 反正只要会用就行了, 于是你点击了该网页的叉叉)</del>  </p>\n<hr>\n<h1 id=\"查看定义\"><a href=\"#查看定义\" class=\"headerlink\" title=\"查看定义\"></a>查看定义</h1><p>让我们按住Ctrl, 鼠标左键 println!<br>(以 VSCode 为例)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n\n<p>你悲催地发现根本看不懂这一大堆鬼画符……<br>但看不懂根本没关系, 后面几节过后, 你肯定懂了<br>现在只需明白的, 是大致结构:  </p>\n<ol>\n<li><p>我们将 <code>macro_rules!</code> 放在 <code>println</code> 前面, 说明后者是个宏<br>(<code>macro_rules!</code> 当作特定语法即可)  </p>\n</li>\n<li><p>之后用花括号包起来, 里面是该宏的具体定义  </p>\n</li>\n</ol>\n<p>问题来了, 关键是 <code>println</code> 的具体定义<br>花括号内, 到底在讲述着啥?  </p>\n<p>请容许我来帮你粗暴地类比一下 <code>match表达式 &amp;&amp; macro</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>macro 有点像是 match, 能根据不同参数, 展开不同的代码<br>在 macro 最外层的花括号中, 有许多匹配分支  </p>\n<p>match表达式, 称呼每个匹配分支为 <code>arm</code><br>逗号分割它们彼此, 或者不用逗号而用花括号包裹来分割<br>最后一个 arm 可省略逗号<br>(上面代码, 便是例子)</p>\n<p>macro, 则称呼每个匹配分支为 <code>rule</code> (明白为什么使用 <code>macro_rules!</code> 创建宏了吗)<br>必须使用花括号包裹, 使用分号分隔彼此<br>最后一个 rule 可省略分号<br>(上面代码, 便是例子)</p>\n<p>你并不需搞清所有细节, 现在先不用试图记忆具体语法, 有印象即可<br>现在再来看看 <code>println</code>, 是不是稍微有点感觉了 (看不懂的地方依然直接跳即可):  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>创建 macro, 名字就叫 xxx, 花括号包裹具体定义:  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建两个匹配分支:<br>(匹配空参 =&gt; 不做任何事)<br>(匹配123 =&gt; 打印123)  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>调用, 宏名+感叹号+传参:<br>(传入的参数, 若与任何 rule 都不匹配, 则报错)</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>咱们下期见  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  </p>\n</blockquote>","more":"<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>大家应该都用过一个宏<br>它就是 <code>println!</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>为什么后面要跟个感叹号?<br>为什么括号里面的参数可以不一样?  </p>\n<p>亲爱的 TRPl 在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 的时候, 告诉过你: 名字后加个感叹号, 就是个 <code>宏(macro)</code><br>注: macro 的读音: [ˈmækroʊ]</p>\n<p>可是 macro 到底是啥?<br><del>(算了算了, 反正只要会用就行了, 于是你点击了该网页的叉叉)</del>  </p>\n<hr>\n<h1 id=\"查看定义\"><a href=\"#查看定义\" class=\"headerlink\" title=\"查看定义\"></a>查看定义</h1><p>让我们按住Ctrl, 鼠标左键 println!<br>(以 VSCode 为例)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n\n<p>你悲催地发现根本看不懂这一大堆鬼画符……<br>但看不懂根本没关系, 后面几节过后, 你肯定懂了<br>现在只需明白的, 是大致结构:  </p>\n<ol>\n<li><p>我们将 <code>macro_rules!</code> 放在 <code>println</code> 前面, 说明后者是个宏<br>(<code>macro_rules!</code> 当作特定语法即可)  </p>\n</li>\n<li><p>之后用花括号包起来, 里面是该宏的具体定义  </p>\n</li>\n</ol>\n<p>问题来了, 关键是 <code>println</code> 的具体定义<br>花括号内, 到底在讲述着啥?  </p>\n<p>请容许我来帮你粗暴地类比一下 <code>match表达式 &amp;&amp; macro</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>macro 有点像是 match, 能根据不同参数, 展开不同的代码<br>在 macro 最外层的花括号中, 有许多匹配分支  </p>\n<p>match表达式, 称呼每个匹配分支为 <code>arm</code><br>逗号分割它们彼此, 或者不用逗号而用花括号包裹来分割<br>最后一个 arm 可省略逗号<br>(上面代码, 便是例子)</p>\n<p>macro, 则称呼每个匹配分支为 <code>rule</code> (明白为什么使用 <code>macro_rules!</code> 创建宏了吗)<br>必须使用花括号包裹, 使用分号分隔彼此<br>最后一个 rule 可省略分号<br>(上面代码, 便是例子)</p>\n<p>你并不需搞清所有细节, 现在先不用试图记忆具体语法, 有印象即可<br>现在再来看看 <code>println</code>, 是不是稍微有点感觉了 (看不懂的地方依然直接跳即可):  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>创建 macro, 名字就叫 xxx, 花括号包裹具体定义:  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建两个匹配分支:<br>(匹配空参 =&gt; 不做任何事)<br>(匹配123 =&gt; 打印123)  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>调用, 宏名+感叹号+传参:<br>(传入的参数, 若与任何 rule 都不匹配, 则报错)</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>咱们下期见  </p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cku9qt5fs0008bw5k3t62dnvf","category_id":"cku9qt5fp0004bw5k3x4o0g7y","_id":"cku9qt5fx000gbw5kgz9hb1qc"},{"post_id":"cku9qt5fj0001bw5k4i591ixs","category_id":"cku9qt5fp0004bw5k3x4o0g7y","_id":"cku9qt5fy000kbw5karzk9pgh"},{"post_id":"cku9qt5fn0003bw5k5e0ddfdy","category_id":"cku9qt5fp0004bw5k3x4o0g7y","_id":"cku9qt5fz000nbw5k4skgax8w"},{"post_id":"cku9qt5fr0007bw5k5umff7cp","category_id":"cku9qt5fp0004bw5k3x4o0g7y","_id":"cku9qt5fz000qbw5kgdckfdk6"},{"post_id":"cku9qt5ft0009bw5kdr6rf5cy","category_id":"cku9qt5fy000mbw5k5fra2f7z","_id":"cku9qt5g0000ubw5ke9j3fqs8"},{"post_id":"cku9qt5fv000dbw5k71id5asc","category_id":"cku9qt5fy000mbw5k5fra2f7z","_id":"cku9qt5g0000vbw5k8jyo2owg"},{"post_id":"cku9qt5fw000fbw5k9kpid0xx","category_id":"cku9qt5fy000mbw5k5fra2f7z","_id":"cku9qt5g0000wbw5k8qwb9412"}],"PostTag":[{"post_id":"cku9qt5fs0008bw5k3t62dnvf","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fv000cbw5kap3o5biw"},{"post_id":"cku9qt5fj0001bw5k4i591ixs","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fw000ebw5kfeavayss"},{"post_id":"cku9qt5ft0009bw5kdr6rf5cy","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fy000jbw5k0nxj0adb"},{"post_id":"cku9qt5fv000dbw5k71id5asc","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fy000lbw5kdu585xix"},{"post_id":"cku9qt5fn0003bw5k5e0ddfdy","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fz000obw5k196o1ryd"},{"post_id":"cku9qt5fw000fbw5k9kpid0xx","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fz000pbw5khgbcdui3"},{"post_id":"cku9qt5fr0007bw5k5umff7cp","tag_id":"cku9qt5fq0005bw5k2ud53ttd","_id":"cku9qt5fz000sbw5k335m0har"}],"Tag":[{"name":"rust","_id":"cku9qt5fq0005bw5k2ud53ttd"}]}}