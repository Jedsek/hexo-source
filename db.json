{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/FiraCode-Regular.woff","path":"css/FiraCode-Regular.woff","modified":1,"renderable":1},{"_id":"themes/next/source/css/custom.css","path":"css/custom.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/demo.css","path":"css/demo.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/demo_index.html","path":"css/demo_index.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/download.zip","path":"css/download.zip","modified":1,"renderable":1},{"_id":"themes/next/source/css/genshin.woff2","path":"css/genshin.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.css","path":"css/iconfont.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.css.backup","path":"css/iconfont.css.backup","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.js","path":"css/iconfont.js","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.json","path":"css/iconfont.json","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.ttf","path":"css/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.woff","path":"css/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.woff2","path":"css/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.svg","path":"images/avatar.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/darkmode-js.min.js","path":"lib/darkmode-js.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/default.yaml","path":"lib/fastclick/default.yaml","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/index.js","path":"lib/fastclick/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/package.json","path":"lib/fastclick/package.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/cursor/fireworks.js","path":"js/cursor/fireworks.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/likely.js","path":"lib/fastclick/lib/likely.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/needmoreshare.js","path":"lib/fastclick/lib/needmoreshare.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/sharejs.js","path":"lib/fastclick/lib/sharejs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"source/404.html","path":"404.html","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/images/404-background.jpg","path":"images/404-background.jpg","modified":1,"renderable":0},{"_id":"source/downloads/gnome/kdeconnect.apk","path":"downloads/gnome/kdeconnect.apk","modified":1,"renderable":0},{"_id":"source/images/gnome/big-avatar.png","path":"images/gnome/big-avatar.png","modified":1,"renderable":0},{"_id":"source/images/gnome/color-app-menu-icon.png","path":"images/gnome/color-app-menu-icon.png","modified":1,"renderable":0},{"_id":"source/images/gnome/control-blur-effect-on-lock-screen.png","path":"images/gnome/control-blur-effect-on-lock-screen.png","modified":1,"renderable":0},{"_id":"source/images/gnome/eye-extended.png","path":"images/gnome/eye-extended.png","modified":1,"renderable":0},{"_id":"source/images/gnome/frequency-boost-switch.png","path":"images/gnome/frequency-boost-switch.png","modified":1,"renderable":0},{"_id":"source/images/gnome/gnome40-ui-improvements.png","path":"images/gnome/gnome40-ui-improvements.png","modified":1,"renderable":0},{"_id":"source/images/gnome/gnome-fuzzy-app-search.png","path":"images/gnome/gnome-fuzzy-app-search.png","modified":1,"renderable":0},{"_id":"source/images/gnome/gsconnect.png","path":"images/gnome/gsconnect.png","modified":1,"renderable":0},{"_id":"source/images/gnome/ibus.png","path":"images/gnome/ibus.png","modified":1,"renderable":0},{"_id":"source/images/gnome/nothing-to-say.png","path":"images/gnome/nothing-to-say.png","modified":1,"renderable":0},{"_id":"source/images/gnome/overview-navigation.png","path":"images/gnome/overview-navigation.png","modified":1,"renderable":0},{"_id":"source/images/gnome/overview_42.png","path":"images/gnome/overview_42.png","modified":1,"renderable":0},{"_id":"source/images/gnome/overview_43.png","path":"images/gnome/overview_43.png","modified":1,"renderable":0},{"_id":"source/images/gnome/overview_44.png","path":"images/gnome/overview_44.png","modified":1,"renderable":0},{"_id":"source/images/gnome/refresh-wifi-connections.png","path":"images/gnome/refresh-wifi-connections.png","modified":1,"renderable":0},{"_id":"source/images/gnome/right-corner.png","path":"images/gnome/right-corner.png","modified":1,"renderable":0},{"_id":"source/images/gnome/space-bar_name.png","path":"images/gnome/space-bar_name.png","modified":1,"renderable":0},{"_id":"source/images/gnome/space-bar_number.png","path":"images/gnome/space-bar_number.png","modified":1,"renderable":0},{"_id":"source/images/gnome/transparent-window-moving.png","path":"images/gnome/transparent-window-moving.png","modified":1,"renderable":0},{"_id":"source/images/gnome/workspace-switcher-manager.png","path":"images/gnome/workspace-switcher-manager.png","modified":1,"renderable":0},{"_id":"source/images/others/dda_1.png","path":"images/others/dda_1.png","modified":1,"renderable":0},{"_id":"source/images/others/dda_2.png","path":"images/others/dda_2.png","modified":1,"renderable":0},{"_id":"source/images/rust/gtk4/transform_buttons.webm","path":"images/rust/gtk4/transform_buttons.webm","modified":1,"renderable":0},{"_id":"source/images/rust/gtk4/bidirectional_switches.webm","path":"images/rust/gtk4/bidirectional_switches.webm","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"0a0982664414697effe8e4704840261052941402","modified":1684595636417},{"_id":"source/404.html","hash":"7fbfd18d223b7af343821bc3469045d8bd8362cd","modified":1684595636417},{"_id":"source/README.md","hash":"d18fa0c6e445d9bb7f8338ca10a0c5d8284ede54","modified":1684678921509},{"_id":"source/categories/index.md","hash":"755367b5c8d9067c09546f95d714b06e1e18db69","modified":1687518961074},{"_id":"source/_posts/post-rank.csv","hash":"bc447e733b323293643f3187deeb86f33cacbb87","modified":1687518792580},{"_id":"source/about/index.md","hash":"09720769921b62b70e8f5eb43e4d6e81624d8f2e","modified":1685799924541},{"_id":"source/_posts/desktop-beautify/hyprland.md","hash":"71dfd1853235656d5cafb9e8f867c6f3f0ab08ad","modified":1684595636421},{"_id":"source/_posts/high-school-it/p4-python基础语法-part2-md.md","hash":"91be06cfbfb4211dd3badeb3a32531a5b8f64280","modified":1684595636422},{"_id":"source/_posts/high-school-it/p1-数据与信息.md","hash":"08ffd36242a3116ed95c6642ad6e95694c17f579","modified":1684595636422},{"_id":"source/_posts/high-school-it/p2-基础科普.md","hash":"9f723917b1189ca92c691fdf0c182db8df907933","modified":1684595636422},{"_id":"source/_posts/desktop-beautify/gnome.md","hash":"169c9321ff6ebabddb9ed9ede9089c7e44cf1b3f","modified":1685799249642},{"_id":"source/_posts/high-school-it/p5-进制的转换与应用.md","hash":"881ffd60d7ff24f11d4ba925fee400a4eca1e4d7","modified":1684595636422},{"_id":"source/_posts/novel/墨染樱下幽魂.md","hash":"c524880a5b289e310fceff3f4bf1b0ed312b4858","modified":1684771422973},{"_id":"source/_posts/categories/desktop-beautify.md","hash":"0e6832741cce6b58c4248e33d2240f71f5aa1503","modified":1684595636417},{"_id":"source/_posts/other/光栅化-dda与bresenham算法.md","hash":"5142590f5ba1ad2fa9ba0d2df2d9c2981ab37669","modified":1684680440594},{"_id":"source/_posts/high-school-it/p3-python基础语法-part1.md","hash":"f0674bdba7b50cc5eb43629b81d56d6c7f941a4d","modified":1684595636422},{"_id":"source/images/gnome/color-app-menu-icon.png","hash":"c0f4a8600eeb0469460b13bc24de810eae94be48","modified":1684647071595},{"_id":"source/_posts/novel/浪潮涌没的终焉与永恒之爱.md","hash":"5fc7b2ea9efd0d6852f2765172e6c65e7f3f29a2","modified":1686204949785},{"_id":"source/images/gnome/eye-extended.png","hash":"cc320a5424d83445eef427da4cfa4e8670f2d839","modified":1684595636443},{"_id":"source/images/gnome/gsconnect.png","hash":"b10d2f2c9b9919077cc2c76ee49ddc88af0473b4","modified":1684595636444},{"_id":"source/images/gnome/nothing-to-say.png","hash":"2a01d35211519b528c223e9d4454236d24da1dd7","modified":1684595636444},{"_id":"source/images/gnome/ibus.png","hash":"534b4a1ce562a18651aa54aeab00f8ac3df7eba9","modified":1684649505185},{"_id":"source/images/gnome/space-bar_name.png","hash":"7dc8558cf55d2ab7dddc13ecfe3bea5a7bd23ac5","modified":1684595636452},{"_id":"source/images/gnome/right-corner.png","hash":"b6af54f899eb811d55eb160ee1875f5e33b698b0","modified":1684595636452},{"_id":"source/images/gnome/space-bar_number.png","hash":"214428efa3c35beae0306890c23b552fed2e5234","modified":1684602877642},{"_id":"source/images/others/dda_1.png","hash":"a260bdbbc45ae6d719ec7abbeaea828895069340","modified":1684595636455},{"_id":"source/_posts/haskell/basic/p2-环境搭建.md","hash":"31080d4f82b53dace24dcf82ae8edbdd651f34c3","modified":1684595636421},{"_id":"source/_posts/haskell/basic/p5-类型与类型类.md","hash":"ce388d2973776566c2c7f80d7c1447e61e940ed7","modified":1684595636421},{"_id":"source/_posts/haskell/basic/p3-函数式编程.md","hash":"9191c38ba5cf6465786fb4d7edf51dfd59f2fbff","modified":1684595636421},{"_id":"source/_posts/scala3/basic/p1-系列说明.md","hash":"cfafa8218695be55cf664f547b366c9c7fdca50d","modified":1684595636424},{"_id":"source/_posts/haskell/basic/p1-系列说明.md","hash":"323af42317e37c75e52184a635bd862ef03dfde5","modified":1684595636421},{"_id":"source/_posts/categories/scala3/basic.md","hash":"93432fc9e1e3df9915731ffa7ede9afc793ade85","modified":1684595636417},{"_id":"source/_posts/scala3/basic/p2-环境搭建.md","hash":"0ded914f9f701323d71ab685f8cd8f59b4f73caa","modified":1684595636424},{"_id":"source/_posts/categories/haskell/basic.md","hash":"5fb133b9c0b6f4f4762c74aaeeba2fa9874505ee","modified":1684595636417},{"_id":"source/_posts/categories/high-chool-it/index.md","hash":"7b790de8b4ddcf370290132cf719a0b36f708c21","modified":1684595636417},{"_id":"source/_posts/categories/rust/async.md","hash":"c35288798a503a616edf043c42b11475065e855f","modified":1684595636417},{"_id":"source/_posts/categories/rust/decl-macro.md","hash":"cf7e285173a0f47c2b768ee5be181f52f0e7a333","modified":1684595636417},{"_id":"source/_posts/categories/rust/gstreamer.md","hash":"707f2cf0bfaf40912f46d3c9eff54ec635ecab9c","modified":1684595636417},{"_id":"source/_posts/categories/rust/gui.md","hash":"398128f509848443556f13ace546d3dba16b4625","modified":1684595636417},{"_id":"source/_posts/categories/rust/tui.md","hash":"bd0662ed462996136c087d0f85acd21db5b7f827","modified":1687441050589},{"_id":"source/_posts/rust/async/p1-系列说明.md","hash":"569ab591bbbaa99b3d2f1e489efa8aef909b5f96","modified":1684595636422},{"_id":"source/_posts/categories/rust/atomics-and-locks.md","hash":"ef82233616bd46df5660b769bd53f01e118fefcb","modified":1687789043514},{"_id":"source/_posts/rust/async/p2-异步简介.md","hash":"2e080fd501341fbc1e283f737ee953602b0b0b44","modified":1684595636422},{"_id":"source/_posts/haskell/basic/p4-基础语法.md","hash":"655671e877bb15381ee0bdad2152716a5b47f408","modified":1684595636421},{"_id":"source/_posts/rust/decl-macro/p1-系列说明.md","hash":"5f54eda64fee252fd54cac1fe094ff901cb19804","modified":1684595636423},{"_id":"source/_posts/rust/decl-macro/p2-从println开始.md","hash":"0555774d475fa9cb4fd10782f5b8ce5b3b9d4eff","modified":1684595636423},{"_id":"source/_posts/rust/async/p3-Future.md","hash":"18cda9ce1c3aaaeca8047fd3668403a71aeaecce","modified":1684595636422},{"_id":"source/_posts/rust/async/p4-状态的保存与变换.md","hash":"c80acce9f3adec44ce05ff39ca41663b36c7860f","modified":1684595636422},{"_id":"source/_posts/rust/decl-macro/p4-重复.md","hash":"45a03143676b713c15cbb7a7adbd8ddb1cc0d360","modified":1684595636423},{"_id":"source/_posts/rust/decl-macro/p5-卫生性.md","hash":"503b3100af2e46bfa0ea0267e37ffbf251972ffc","modified":1684595636423},{"_id":"source/_posts/rust/gstreamer/p1-系列说明.md","hash":"b26b9e25ce1b3bb46f483d004818ab42afa97ab5","modified":1684595636423},{"_id":"source/_posts/rust/gstreamer/p2-管道的基础概念.md","hash":"2b3882f22f11fa71d2e6c3cbcd7a481bb26b9650","modified":1684595636423},{"_id":"source/_posts/rust/gstreamer/p3-管道的动态构建.md","hash":"5914a3b7c418f4d802973c34771debfc59b7aee7","modified":1684595636423},{"_id":"source/_posts/rust/gstreamer/p4-时间管理.md","hash":"1b8480319117d0f3612e69599ccf6477a5fbafa5","modified":1684595636423},{"_id":"source/_posts/rust/gstreamer/p5-与GUI集成.md","hash":"42f81a764159253ac4ea76a49d0a889f3d86fbe8","modified":1684595636423},{"_id":"source/_posts/rust/tui/p1-系列说明.md","hash":"3d686286f5956a5e4b309be5e9c851b63c64af6f","modified":1687519552627},{"_id":"source/_posts/rust/rust-atomics-and-locks/p1-系列说明.md","hash":"6cb441e5b58c3cea5dbea08a4757e91ce11d0fea","modified":1687519534698},{"_id":"source/_posts/rust/clap/intro.md","hash":"53eb7e3fc8b8f8b8fccbd8fca40d94f2d815f8d1","modified":1684595636423},{"_id":"source/_posts/rust/decl-macro/p3-声明与使用.md","hash":"77ded960090c945154ce430dea420f6a5747ebf8","modified":1684595636423},{"_id":"source/_posts/rust/syntax/Rust那些常见的错误.md","hash":"b5294f910ae4e9eda8d9c4d326856de6314810d2","modified":1687518738076},{"_id":"source/_posts/rust/tui/p2-基础架构.md","hash":"6992ec17fcc61b31865d03d54ab6eff17fce3ae5","modified":1687441003459},{"_id":"source/_posts/rust/gui/gtk4/p1-系列说明.md","hash":"5a30b8569376c8510fda2a649f4672fe2c5850e4","modified":1684595636423},{"_id":"source/_posts/rust/gui/gtk4/p2-创建窗口.md","hash":"0899085b5eabfcd7a3863b6ce1385d98ebc85adc","modified":1684595636423},{"_id":"source/_posts/rust/rust-atomics-and-locks/p2-基础概念.md","hash":"fefa9ffa19e32726652ff3653218bd90e2de9d4d","modified":1688054013438},{"_id":"source/_posts/rust/gui/gtk4/p3-GObject-内存管理.md","hash":"e420b35f33cc539bf5902484c17fad1047853e0d","modified":1684595636424},{"_id":"source/_posts/rust/gui/gtk4/p5-GObject-通用类型.md","hash":"ddcd462468f5cce4f8bbc1fe91af6996bf53d748","modified":1684595636424},{"_id":"source/_posts/rust/gui/gtk4/p7-GObject-信号.md","hash":"8bdb0671789d95b2ec38e46760a6848ace84eaac","modified":1684595636424},{"_id":"source/_posts/rust/gui/gtk4/p4-GObject-子类化.md","hash":"952ef5ba0dfc245ebe5dfe9cc40793b13a39f1aa","modified":1684595636424},{"_id":"source/_posts/rust/gui/gtk4/p8-主事件循环.md","hash":"5df8e13f698e500e4beffc1d2297358ac6cae1e5","modified":1684595636424},{"_id":"source/_posts/rust/gui/gtk4/p9-设置持久化.md","hash":"649ab2783285d0954224a970b44fba1577e483ef","modified":1684595636424},{"_id":"source/_posts/rust/gui/gtk4/p6-GObject-属性.md","hash":"32e162681dd33c4efb76fb869a59a0d492b09890","modified":1684595636424},{"_id":"source/_posts/rust/gui/iced/p1-系列说明.md","hash":"c79891a965e19a6276f48929f8b4662f041c697d","modified":1684595636424},{"_id":"source/_posts/rust/gui/iced/p2-Elm式架构.md","hash":"b8fefbd17fd6a78bcddefe32382f82feb8dabc5f","modified":1684595636424},{"_id":"source/_posts/rust/gui/iced/p4-样式.md","hash":"50a53d30af4ac49cbf9689b0734c0138e271615e","modified":1684595636424},{"_id":"source/_posts/rust/gui/iced/p3-布局.md","hash":"d1e83f4a957139ea561d4392e1ad01e3f1535a43","modified":1684595636424},{"_id":"source/images/gnome/big-avatar.png","hash":"8fca7f2efc0358dd37eb798d106d42355e170b9d","modified":1684595636443},{"_id":"source/images/gnome/frequency-boost-switch.png","hash":"80a40d591838da850c03d2803531c377616eb2d2","modified":1684603585768},{"_id":"source/images/gnome/gnome40-ui-improvements.png","hash":"f04061c64f6e0a32a2d2a1f371fc8965cf6e9915","modified":1684595636444},{"_id":"source/images/gnome/refresh-wifi-connections.png","hash":"f94d7390a3749d29da4b724ce951b3db56df4a4c","modified":1684595636452},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1684595636459},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1684595636459},{"_id":"source/images/others/dda_2.png","hash":"062bd865f47040a3d7c4e45121c5bcc4d515c061","modified":1684595636456},{"_id":"themes/next/_vendors.yml","hash":"3e7d7c27fdad121f4e03b1b826d5e8e32b2b806c","modified":1684595636459},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1684595636459},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1684595636459},{"_id":"themes/next/package.json","hash":"0fdce9f5b80e6757be715953a19c46acfa00f2e7","modified":1684595636463},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1684595636463},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1684595636459},{"_id":"themes/next/_config.yml","hash":"19647dd6ce93b2650e11b74d6580635adbbb7934","modified":1684598847414},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1684595636459},{"_id":"themes/next/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1684595636459},{"_id":"themes/next/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1684595636459},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1684595636459},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1684595636460},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1684595636460},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1684595636460},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1684595636460},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1684595636460},{"_id":"themes/next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1684595636460},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1684595636460},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1684595636460},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1684595636460},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1684595636460},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1684595636460},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1684595636460},{"_id":"themes/next/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1684595636460},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1684595636460},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1684595636460},{"_id":"themes/next/languages/zh-CN.yml","hash":"c8354b782482e80c6b3b16918825f8f9c5fb185a","modified":1684595636460},{"_id":"themes/next/layout/_layout.njk","hash":"8640dadad7505b16451887153bc118ee278ed92e","modified":1684595636460},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1684595636460},{"_id":"themes/next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1684595636463},{"_id":"themes/next/layout/index.njk","hash":"3671052adf74e60ada2cce7c2adeb3e8bf0947ea","modified":1685799593168},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1684595636463},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1684595636483},{"_id":"themes/next/layout/post.njk","hash":"dfa591d1243bd2a71a9182e3605d3523d30fcaab","modified":1684595636463},{"_id":"themes/next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1684595636463},{"_id":"themes/next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1684595636463},{"_id":"themes/next/layout/_custom/custom.njk","hash":"dbd1329789b1c458cd0e2310e67d6bd43d02e991","modified":1684595636460},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1684595636461},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"3b09a1659dcc0b104be8a6b51fb741d3b465a5d9","modified":1684595636461},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1684595636460},{"_id":"themes/next/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1684595636461},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1684595636462},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1684595636462},{"_id":"themes/next/layout/_partials/footer.njk","hash":"cda8c76857633d4110e609efa927a5b247c89d70","modified":1684595636461},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1684595636460},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1684595636462},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1684595636462},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1684595636462},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1684595636462},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1684595636462},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1684595636462},{"_id":"themes/next/layout/_macro/post.njk","hash":"b92d6c77d4b349c5d56fb8e0a44b578c194ef466","modified":1684595636460},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1684595636464},{"_id":"themes/next/scripts/events/index.js","hash":"1ce12eda88fa5df7e76ec7b78b8463fc6618410c","modified":1684595636463},{"_id":"themes/next/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1684595636464},{"_id":"themes/next/scripts/filters/post.js","hash":"ab8bb12e4d55640b1ac4252514468ce37ebcb0b0","modified":1684595636464},{"_id":"themes/next/scripts/filters/minify.js","hash":"0af64049db8188d5f8cc226b353e0d7909819feb","modified":1684595636464},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1684595636464},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1684595636464},{"_id":"themes/next/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1684595636464},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":1684595636464},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1684595636464},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1684595636464},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1684595636464},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1684595636464},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1684595636464},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1684595636464},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1684595636464},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1684595636464},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1684595636464},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1684595636464},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1684595636464},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1684595636464},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1684595636464},{"_id":"themes/next/source/css/custom.css","hash":"b6d6f404e28c74d6380046dbbb6922cc2d48c06d","modified":1688052237793},{"_id":"themes/next/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1684595636467},{"_id":"themes/next/source/css/_colors.styl","hash":"2d464c451fac10669c0c0d25b1694c7cf85bd25e","modified":1684595636465},{"_id":"themes/next/source/css/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1684595636468},{"_id":"themes/next/source/css/download.zip","hash":"034b20bd8ea91aee04a9fcc713e6f355a8fc7686","modified":1684595636469},{"_id":"themes/next/source/css/iconfont.css","hash":"8806c405841e1cc582ac0362e5472bb2d72f4e4d","modified":1684595636469},{"_id":"themes/next/source/css/demo_index.html","hash":"eb23998541d481c6923f9c0c8ff694bf7a3e2b6f","modified":1684595636468},{"_id":"themes/next/source/css/iconfont.css.backup","hash":"83303af46a2b75d4959371be747fb5b3cb79d689","modified":1684595636469},{"_id":"themes/next/source/css/iconfont.json","hash":"31c866a664f02a2b838aa4b8dab7a97a0b5c8f4f","modified":1684595636469},{"_id":"themes/next/source/css/iconfont.ttf","hash":"9af30b1a4b1405fc5f91464e5902f953b8068512","modified":1684595636469},{"_id":"themes/next/source/css/iconfont.woff","hash":"bcd7471a2ec5e457196f54a51d485bb19daa848b","modified":1684595636469},{"_id":"themes/next/source/css/iconfont.js","hash":"5f047b5796b11bfd2f2b94d5a1ab54667b7d7396","modified":1684595636469},{"_id":"themes/next/source/css/iconfont.woff2","hash":"ce8162de5535076a601089019d69c3054f986ee6","modified":1684595636469},{"_id":"themes/next/source/css/main.styl","hash":"f763283b1e2e27a3e7e19d3b78ff18f324b7d888","modified":1684595636469},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"369c77d4be3efe406ecbbdd7886a6ddafd93a940","modified":1684595636479},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"c587c9e0ad3da71d5d87ec5a17dbb2270c982679","modified":1684595636479},{"_id":"themes/next/source/lib/darkmode-js.min.js","hash":"29b6500c71a1952ed5c0e79c52b2f5d6ccd12c98","modified":1684595636482},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1684595636479},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1684595636479},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1684595636480},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1684595636480},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1684595636481},{"_id":"themes/next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1684595636481},{"_id":"themes/next/source/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1684595636481},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1684595636483},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1684595636483},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1684595636483},{"_id":"themes/next/source/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1684595636481},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1684595636483},{"_id":"themes/next/source/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1684595636482},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1684595636483},{"_id":"themes/next/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1684595636483},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1684595636483},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1684595636483},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1684595636483},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1684595636483},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1684595636483},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1684595636483},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1684595636483},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1684595636483},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1684595636483},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1684595636484},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"9167e429a459686c9fc140790124a46d677e6b15","modified":1684595636461},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"d3c094aaef1431fbc9df333529a7b1789ccd134c","modified":1684595636461},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1684595636461},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1684595636461},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1684595636461},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1684595636461},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1684595636461},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1684595636461},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1684595636461},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"9a6b0ec5befb0950902e12dac0be5808d43cf1e5","modified":1684595636461},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1684595636461},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1684595636461},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1684595636461},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1684595636461},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1684595636461},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1684595636461},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1684595636461},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1684595636461},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1684595636461},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"4ca45b8638dbfbb3a1ec633c4e1d078dfa9086dc","modified":1684595636461},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1684595636461},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1684595636462},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1684595636462},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1684595636462},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1684595636462},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"c2258949708070bfa3539d3b59e0beb4596bf5f0","modified":1684595636461},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1684595636462},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1684595636462},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1684595636462},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1684595636462},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1684595636462},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1684595636462},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1684595636462},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1684595636462},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1684595636463},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1684595636463},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1684595636462},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1684595636463},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1684595636463},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1684595636463},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1684595636463},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1684595636463},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1684595636463},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b0ced2583fdd505da3ef27a9db9c55cc7b936732","modified":1684595636463},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1684595636463},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1684595636463},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"08dac57e15c9f06c7cf54884b045f2362595f9d2","modified":1684595636463},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1684595636463},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1684595636463},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1684595636463},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1684595636463},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1684595636464},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1684595636464},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1684595636464},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1684595636464},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1684595636464},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1684595636468},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1684595636468},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1684595636468},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"d813aff1c30655ce2832ef2001898ffc6d14dd5c","modified":1684595636468},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ed6765e6e07bff9574fdae97dacf1ab6de169624","modified":1684595636468},{"_id":"themes/next/source/lib/fastclick/package.json","hash":"6a30089543e4b639e85d857c4ca70897ae2e1432","modified":1684595636482},{"_id":"themes/next/source/lib/fastclick/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1684595636482},{"_id":"themes/next/source/lib/fastclick/default.yaml","hash":"63abbb8255bab5ea7a4f45de3bcf14b574d41fa6","modified":1684595636482},{"_id":"themes/next/source/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1684595636482},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1684595636482},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1684595636482},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1684595636482},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1684595636482},{"_id":"themes/next/source/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1684595636481},{"_id":"themes/next/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1684595636481},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"9067915a45ab959d5a197bf1ffde4da980146618","modified":1684595636482},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1684595636482},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1684595636482},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1684595636481},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1684595636465},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1684595636466},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1684595636466},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1684595636466},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1684595636466},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1684595636468},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1684595636467},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1684595636468},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1684595636468},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1684595636468},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1684595636468},{"_id":"themes/next/source/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1684595636482},{"_id":"themes/next/source/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1684595636482},{"_id":"themes/next/source/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1684595636482},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1684595636481},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1684595636481},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1684595636481},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1684595636481},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1684595636481},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1684595636481},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1684595636481},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1684595636481},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1684595636481},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1684595636481},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1684595636481},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1684595636481},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1684595636481},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1684595636482},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1684595636481},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1684595636482},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1684595636482},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1684595636482},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1684595636482},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1684595636482},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1684595636482},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"424021c13182487a541f9256a0d67d67e8e2ccc0","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"b1c99f34d65f994c89940bb7cdff4e36779ceb5d","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"b1bcc5f9357a9f8b8d6f8f285f073aaf3157f9db","modified":1684595636466},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1684595636465},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1684595636466},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"c8e95e8ac4cbdba01cb93e9e0569b45603e41bc6","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1684595636466},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1684595636466},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1684595636466},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1684595636466},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"0b3e2696eca39781c3524b2c5a2555ebc616e6e8","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1684595636466},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"9b34143aec49e390e18f380026a45096f7477722","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1684595636467},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1684595636467},{"_id":"source/images/404-background.jpg","hash":"d04ff7a87d284cf44bcc2d4dfb70106681ef6768","modified":1684595636443},{"_id":"source/images/gnome/gnome-fuzzy-app-search.png","hash":"ad67ce1c81c0ba3476a81abc4e06a73a8a6c3728","modified":1684595636444},{"_id":"source/images/gnome/workspace-switcher-manager.png","hash":"2184be787d2619605775dec6b4be9f89c6b2c1e3","modified":1684595636455},{"_id":"themes/next/source/css/FiraCode-Regular.woff","hash":"8c160056d0f435e118beebe61ec9ed69f078535e","modified":1684595636465},{"_id":"source/images/rust/gtk4/bidirectional_switches.webm","hash":"ef1f1030d82f2588c9b75b88878a6e02aa0827dc","modified":1684595636457},{"_id":"themes/next/source/images/avatar.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1684595636470},{"_id":"source/images/rust/gtk4/transform_buttons.webm","hash":"fd16c0a6173f79ebb2bbe784146025510417b563","modified":1684595636459},{"_id":"source/images/gnome/transparent-window-moving.png","hash":"2171b11d661aaef009ce7e0ed6950bd493713c93","modified":1684595636454},{"_id":"source/images/gnome/overview-navigation.png","hash":"3ebcaf71b468e3cd42914314e4073025770d729a","modified":1684595636447},{"_id":"source/images/gnome/overview_42.png","hash":"f7a03e8897e0ccd149f569ef98213bbfac51ec26","modified":1684595636451},{"_id":"source/images/gnome/overview_44.png","hash":"b49759e68750f260767a2dd417a98c1a7cd83e19","modified":1684602617254},{"_id":"source/images/gnome/overview_43.png","hash":"b11283a4806f7197d3add590dfc329e7a12b5595","modified":1684596883560},{"_id":"themes/next/source/images/avatar.svg","hash":"85b7ae4a346c6832d1ef82537b816ff1e3a9efea","modified":1684595636478},{"_id":"source/images/gnome/control-blur-effect-on-lock-screen.png","hash":"5c32c4bcc0d5056be25d160d14066f99d153124d","modified":1684646617290},{"_id":"themes/next/source/css/genshin.woff2","hash":"a849fda9b22a8782b3c778d0c9b5abcc88e861be","modified":1684598557609},{"_id":"source/downloads/gnome/kdeconnect.apk","hash":"817e71e04488fd2fd7d59d6e712013d06528e92e","modified":1684595636442},{"_id":"public/baidusitemap.xml","hash":"814eb298292bf69318da4d73fa4e95afd0302681","modified":1688474698691},{"_id":"public/atom.xml","hash":"4a4fea421d5ee69c2c0e4131180b9627f7375b01","modified":1688474698691},{"_id":"public/search.xml","hash":"fc07e5f4fcfcfaa551d6cf9fa27a884c786e5856","modified":1688474698691},{"_id":"public/lib/animejs/lib/anime.min.js","hash":"332031949d78a49e8a18611556253660574e47db","modified":1688474698691},{"_id":"public/sitemap.xml","hash":"35fe1e72afe131de9f3bd2523e16f1247b8c937c","modified":1688474698691},{"_id":"public/sitemap.txt","hash":"dbb27e6b72225aefae24f7b5df207c3741878aad","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/css/all.min.css","hash":"a57ee68d11601b0fd8e5037fc241ff65a754473c","modified":1688474698691},{"_id":"public/lib/prismjs/components/prism-core.min.js","hash":"424bc619ca7daf98bf1d15567c9e42c3b09247fa","modified":1688474698691},{"_id":"public/lib/prismjs/plugins/autoloader/prism-autoloader.min.js","hash":"bbb328dbbfa9a3d2473f6fccbd482948dea89576","modified":1688474698691},{"_id":"public/lib/prismjs/plugins/line-numbers/prism-line-numbers.min.js","hash":"90224d0ba1a80cb9b518607fd4cba324585e062a","modified":1688474698691},{"_id":"public/lib/mathjax/es5/tex-mml-chtml.js","hash":"9277439416d93f5d58875293096f2f4ed56753df","modified":1688474698691},{"_id":"public/lib/katex/dist/katex.min.css","hash":"82a81c615c4c37c53ae30901b2cbb284efee96d1","modified":1688474698691},{"_id":"public/lib/katex/dist/contrib/copy-tex.min.js","hash":"76ff8d5b83dd7e7a73380a12b1e081124839293f","modified":1688474698691},{"_id":"public/lib/katex/dist/contrib/copy-tex.min.css","hash":"8f8c0231a2683448fbce772db48c2a7f6a0aa366","modified":1688474698691},{"_id":"public/lib/@next-theme/pjax/pjax.min.js","hash":"248f4b98d685fb9fee359731d96194cc50979461","modified":1688474698691},{"_id":"public/lib/jquery/dist/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1688474698691},{"_id":"public/lib/@fancyapps/fancybox/dist/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1688474698691},{"_id":"public/lib/@fancyapps/fancybox/dist/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1688474698691},{"_id":"public/lib/medium-zoom/dist/medium-zoom.min.js","hash":"ded611d294060e40f360f563a92cec80e1cfbdc0","modified":1688474698691},{"_id":"public/lib/lozad/dist/lozad.min.js","hash":"fc2b43e560c45bb887add98f17b084068a9232cb","modified":1688474698691},{"_id":"public/lib/pangu/dist/browser/pangu.min.js","hash":"3f4d7c03d1fd3e6244d40ff15d03dfca852de469","modified":1688474698691},{"_id":"public/lib/quicklink/dist/quicklink.umd.js","hash":"f1d1e85bc75cdc6ed8a8f6f84387e6cf6f27f39b","modified":1688474698691},{"_id":"public/lib/disqusjs/dist/disqus.js","hash":"b79249dfb619836cfd1251cb3c3d5c603bc55e61","modified":1688474698691},{"_id":"public/lib/disqusjs/dist/disqusjs.css","hash":"0d8ae5946142b17f9a75683c7649cf73d6fdbe17","modified":1688474698691},{"_id":"public/lib/gitalk/dist/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1688474698691},{"_id":"public/lib/gitalk/dist/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1688474698691},{"_id":"public/lib/firebase/firebase-app-compat.js","hash":"6bdb505370a1254eea35f2e79524419ac4338135","modified":1688474698691},{"_id":"public/lib/firebase/firebase-firestore-compat.js","hash":"deaf5574372ed08f20b8cda966ad1a3116114094","modified":1688474698691},{"_id":"public/lib/algoliasearch/dist/algoliasearch-lite.umd.js","hash":"9fdf56c741aab029531577fe8b820a4627a18e52","modified":1688474698691},{"_id":"public/lib/instantsearch.js/dist/instantsearch.production.min.js","hash":"7f3dd9ee691823088b5b8bede8c1ab3fc3cfd90a","modified":1688474698691},{"_id":"public/lib/hexo-generator-searchdb/dist/search.js","hash":"d9876182685dde25514bf959013c819b67fc5a06","modified":1688474698691},{"_id":"public/lib/pdfobject/pdfobject.min.js","hash":"4389409cb79b64afd5dad6c24634c2ae56b3aa2b","modified":1688474698691},{"_id":"public/lib/mermaid/dist/mermaid.min.js","hash":"7fbdda8c43db20d3de233cd51c346e582494b68f","modified":1688474698691},{"_id":"public/lib/animate.css/animate.min.css","hash":"c8e21199704bd904bc1b5869f31a84fb4ded63d4","modified":1688474698691},{"_id":"public/lib/pace-js/pace.min.js","hash":"167da09bcd855864f0fda03cb0e83840e299c048","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-barber-shop.css","hash":"4496a2b9f81ded5c1d115e39f0894a2bfae2a7c0","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-big-counter.css","hash":"2bcabd0936a45d4eeca2529dc6d11dc2e5aafb82","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-bounce.css","hash":"770ee46b551ff8a08e760b4766066881d11c5880","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-center-atom.css","hash":"996f0ea727b16368b970911a264b9cb64a64aae4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-center-circle.css","hash":"9da417c43cc0860ae0e78992954fe2d6d23975ed","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-center-radar.css","hash":"0302fa3013244f9d72bca7a6a5ec9968c40a6c5d","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-center-simple.css","hash":"8efc2c64932b682affa33bdb5490be6a2574d39e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-corner-indicator.css","hash":"45b53ec8d5f5eab92902a11f1357eb168c99c7d4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-fill-left.css","hash":"485fd1dbbd1dbf4dab24e678fa9568249b2701dc","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-flash.css","hash":"6a16001a0a60801d836455d5230e92bebf48ce8b","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-flat-top.css","hash":"5cdf482409ba5dfd10b1c757fd697be4cb539d5a","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-loading-bar.css","hash":"1f12d00d9d6317aac0a42c4eb582ce5806af5e08","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-mac-osx.css","hash":"1463f1221ee4d45c36f16f75d69f9f5ace8b9661","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-material.css","hash":"ca9ecd16d854ec7cc58a8b8e6330e867f648ca50","modified":1688474698691},{"_id":"public/lib/pace-js/themes/black/pace-theme-minimal.css","hash":"115da1a355eea311c10afeb5acba2049a6b5025e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-barber-shop.css","hash":"9de9f997616169e01db7d1c2f5c903172411d3cd","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-big-counter.css","hash":"23209e50670e06c1fe6d478775509687dffa97e4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-bounce.css","hash":"d2c707c30f198a0e6357b3a3681d24cdfe04a606","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-center-atom.css","hash":"5e0ee39b8ce3622ef579dcb8612529106a51a672","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-center-circle.css","hash":"845290fe028c5cf0ce9554c293ba45decb31263c","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-center-radar.css","hash":"3cacb090e8fe3d175bfe04cfa9b46b431b960f5b","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-center-simple.css","hash":"0292ac5475a75d17745d6553876a0df58d5ea9a4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-corner-indicator.css","hash":"de9074cf7491fe6558bb90f8468590c888d21629","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-fill-left.css","hash":"9c982cf81812d0ee85f3c0ebb982c381b1909c50","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-flash.css","hash":"1393c5ba6dee4037bf48993c16c88fdbf1095b05","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-flat-top.css","hash":"4d7fe3b20baa426efa66732799fc3e72cf5a386e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-loading-bar.css","hash":"2e9ec17b5ee830dbf41395723a04a27244d372f2","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-mac-osx.css","hash":"7123c235d5775338ff57cbebca5b1992693d7e93","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-material.css","hash":"af44b9e2bc64bba641810428c4e2eea68de6fd13","modified":1688474698691},{"_id":"public/lib/pace-js/themes/blue/pace-theme-minimal.css","hash":"c014ef2d8c144d37435a278b69b1ee32fe185ad4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-barber-shop.css","hash":"62031cf327879bf13622668cbdb646dc5a030aeb","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-big-counter.css","hash":"35088f69be5c0fe88efc2d1ab36e6720bb0715a1","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-bounce.css","hash":"e1ca8ebbff5cd3c7840c64cc75b9fa2292392d45","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-center-atom.css","hash":"edbd9bd43bfa3ac9c8818444f8b0459233f6a2a0","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-center-circle.css","hash":"27e7431e897847a3517d610989a5156d921bf477","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-center-radar.css","hash":"389dbe35dacb2a210d06021f4ab2dad31bd2a1c0","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-center-simple.css","hash":"2c9ef10e38a035555ed81d80f3263c1e9d0e5ca5","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-corner-indicator.css","hash":"ddcce5d762ed6f17c2c40e22e2f0d0e866fc1fb3","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-fill-left.css","hash":"800b472d85f10d8ae0b15e112b824d274955dc55","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-flash.css","hash":"a5edb891037648daaed305627df348e475d8ece0","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-flat-top.css","hash":"dfae7a82439fda7436f484f9b1cd032dbf12abe8","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-loading-bar.css","hash":"3dd35251642a24cefafcfc12b63b249166b91e52","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-mac-osx.css","hash":"33d13e86dbefb0629cd0b51b81a9bf03f72bec3e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-material.css","hash":"ea571a4ad0a37e4346a7a7db50db7dde05bae3bc","modified":1688474698691},{"_id":"public/lib/pace-js/themes/green/pace-theme-minimal.css","hash":"f6f59ca049e3a0c416770116dfd09fda1c13627f","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-barber-shop.css","hash":"0360743ef2b703932db00a3c80148d72b3914164","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-big-counter.css","hash":"9315086341c4c16a2e088cfa6d39d8281748c827","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-bounce.css","hash":"fb16a053c9994467047458ef501c8ece9065a2a9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-center-atom.css","hash":"9d591d843d192d1f5e7679620e6792975f4bf839","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-center-circle.css","hash":"24fb6326b753e35618259d96a83e63e658cfcdd2","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-center-radar.css","hash":"e30d80d9a071435721665669a7690f412f3d61f4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-center-simple.css","hash":"5b7d4c64ce99a83cbba65ea4ef249f4cab7cb70c","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-corner-indicator.css","hash":"02625fac0d898c34a33ab466e60463078172ed22","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-fill-left.css","hash":"df1ebc450c1ede169cda189fd7954f7ef939ba38","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-flash.css","hash":"54799058c4c0fbebdec862b55cc1d4f57a3abe06","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-flat-top.css","hash":"948c41865b2cc4248cd6a179c1ff17a6d0d3adc2","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-loading-bar.css","hash":"ed5b863dd478242641b0b68628645095eae868e0","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-mac-osx.css","hash":"89a98a6c164a29dd88ae8ad0531cabb9a3510c71","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-material.css","hash":"28493c23900c3e4d25b997a31dc3c6e987540c1d","modified":1688474698691},{"_id":"public/lib/pace-js/themes/orange/pace-theme-minimal.css","hash":"e335a1e9d1abd45f8388780c10aed1c99f307dfd","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-barber-shop.css","hash":"3c693ee98a61179e66fb53d9095ec9702de8efcb","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-big-counter.css","hash":"1c2a704efcba4985e9eef69a08c2dc35629afc41","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-bounce.css","hash":"8ae2c81858ef13d632fe9e980c7a2a3801b14a29","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-center-atom.css","hash":"efde33cf6053d67525dccaaf7c92e758c9e0f397","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-center-circle.css","hash":"65df967b460a4e7b1b59eadb5dce4e20d63c8156","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-center-radar.css","hash":"accc0ce26cca9a18b3c4f0b57ec8f3c4f48079b8","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-center-simple.css","hash":"f72a5bd6b7599de03c14d97949711e84a9103641","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-corner-indicator.css","hash":"4e2ea556d823f430cb996ffeb2c5efb9e4d33380","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-fill-left.css","hash":"694f1633b65d10682ea667e1198e088116e2f1cd","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-flash.css","hash":"187a30bd4b690f067acc2b86644cafb6f889c47a","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-flat-top.css","hash":"ee01912ff65ec348d847477beed01aeb68082fe7","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-loading-bar.css","hash":"4ea035c3e3636102e7ec4d054ab8bf4c85fc4001","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-mac-osx.css","hash":"92f5e2eb742c33d202e0d04762362c202d019948","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-material.css","hash":"2ffa93e0f388f264c4c9afc451677b3a0c65f078","modified":1688474698691},{"_id":"public/lib/pace-js/themes/pink/pace-theme-minimal.css","hash":"019bcda522c87aa1f62d41b61464dc694f8b6a15","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-barber-shop.css","hash":"47e731b4ffc315956dc1a7be06881571a07e063e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-big-counter.css","hash":"29146f787a9283d85d9bd875a95e69560cd64e3d","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-bounce.css","hash":"6bfc666e0dc04356ce119c6920dab7f0503a24ba","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-center-atom.css","hash":"e8daa4dc7ae28bf8e8f13e9833ab070d4c59d8ac","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-center-circle.css","hash":"e6642333ed5d0c8244c5d8e2a2ad9246f4fec927","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-center-radar.css","hash":"a77c6461dcd191323fc543d5c0a55ef1f89032b2","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-center-simple.css","hash":"cdfad724b878b9ef28a49a39ee60116f6c8b0e7d","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-corner-indicator.css","hash":"95dff9ab2acc687bdca7e793341a2cfa4a1cabaf","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-fill-left.css","hash":"8a6dcc76f1f9adc46d31ae092eb274d8d9847e9b","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-flash.css","hash":"6f258caa125a2bf75eca179c924722bc274e2329","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-flat-top.css","hash":"167f82dfcb073e5a2dc787e322a4cf5d4c306049","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-loading-bar.css","hash":"a97dc9dd9e7f1d4eee016e7ce95105ac5c6a8d30","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-mac-osx.css","hash":"06e7cd3cb50bc1952c402e3a8e6edf1b6cee2fc3","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-material.css","hash":"81ad31431b543aa1cecdf035479aef988e53a2a9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/purple/pace-theme-minimal.css","hash":"aa17cebd247fe914a26f2465f6c6309265dbf023","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-big-counter.css","hash":"1211c96ebba36080015c1152ccc42097575c168a","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-bounce.css","hash":"85b3a502b3f3af67fb0d737395b959369bf49bbe","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-barber-shop.css","hash":"1d752bfbb339d89fd6dd0132c53084e9a0056086","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-center-atom.css","hash":"c2dc55d6f9b87d247be88da44d5d5d51ed5d34ba","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-center-circle.css","hash":"7111ded0dcb687616a05215729c0a8df449e6b33","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-center-radar.css","hash":"8d8f29acdd2f0f9bf7fbe2d0ad35fe2b6d015a84","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-center-simple.css","hash":"f7a06bef90fa85c28c58405d9f9299c30ed28494","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-corner-indicator.css","hash":"f54f223688456d346f84438fceae779c3b9e5ec8","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-fill-left.css","hash":"c9d9be57a9ead7d3b22ab961b6953ccb5cae9f47","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-flash.css","hash":"d83cd2e6ac90da71c4a545006787950323f9bbb4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-flat-top.css","hash":"2f1ba289631adc907800b93fc27f6a64f9423cca","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-loading-bar.css","hash":"fcb51f2bc5a35d272260809e82d510c7f550846b","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-mac-osx.css","hash":"cbf3d6f1ec028d1a2da28193614a37eb1afe8cf9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-material.css","hash":"cecea5da478b67b00ef04af515d1569ee0b8ddb0","modified":1688474698691},{"_id":"public/lib/pace-js/themes/red/pace-theme-minimal.css","hash":"433ea7594c4eee182b5d8cf1cbdd706fa6beae55","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-barber-shop.css","hash":"b0019eb48e0247ccc35d8bff7b327b1cfd1252a4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-big-counter.css","hash":"7195c33ceb15be271ee7d4b8183b9d770ec3184f","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-bounce.css","hash":"570de4ae310e3c78c81ca4c1c24ce02fd258dce6","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-center-atom.css","hash":"0e6a33008de3aae55c7e9bdf155098d5df676bc4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-center-circle.css","hash":"90258ba51762dea3b2e0dd27190111b8deff7ab9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-center-radar.css","hash":"e887fe0cfba8a7628144d85eaf465705edb3b6ed","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-center-simple.css","hash":"ed719a7564900c1c0967969fdbbf6cc2e1e032f9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-corner-indicator.css","hash":"08932de3d621ced1179703e0444fe1dc87f9694e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-fill-left.css","hash":"a95987bfd438fbd934e644fb5583e9085c3f9717","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-flash.css","hash":"62e86e0bfb523c05fac978fcb783239f4824416a","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-loading-bar.css","hash":"cbdbfb32019923aadbdc76d1a760ccd335ec8349","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-flat-top.css","hash":"4bd994d5dc165c37f7040ba10783c543088e4c58","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-mac-osx.css","hash":"72f29098b5196f32bc508d70c7c33b5b2da06fff","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-material.css","hash":"45abb76d60cf20711d6552ab498d98d7d4a8ff86","modified":1688474698691},{"_id":"public/lib/pace-js/themes/silver/pace-theme-minimal.css","hash":"f3b1629142f38df2ff04e43c622308eeddf5779b","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-barber-shop.css","hash":"1d056c4e7baf781832d2cba6cba95f001fe63906","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-big-counter.css","hash":"87e125b0f8ece115ba23bf61a5e7d76036e9cb39","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-bounce.css","hash":"a456b1009ece0a75aaa0ff7b8e9e054cee4b23c9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-center-atom.css","hash":"d10748805eb715b9cec569db49f596ca7976e288","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-center-circle.css","hash":"5aedfec8ddc145e1941a8825e3e5d186b2d6adbd","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-center-radar.css","hash":"5b2f819ddd86bddbe4bab3cd62aefad95c6f61ba","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-center-simple.css","hash":"5764fd33a66051e1cf1ab4bc804ec4721db3dcad","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-corner-indicator.css","hash":"9a7b3896925da9c5a585fcff7da2c0fdce57a26f","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-fill-left.css","hash":"56e8a144ceec8bb8d916d2ce21007127d6b8d91f","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-flash.css","hash":"c8b7b1c32538d534fe6174a3e57245d145873eb1","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-flat-top.css","hash":"175e469820c8881651ec0ae97ad39fe9799e8770","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-loading-bar.css","hash":"4af43f47979f2070dac19d1b534797cc18b54f23","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-mac-osx.css","hash":"ecfbfbbcdd6966560df6f67a2d2c01b637e3b364","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-material.css","hash":"5113f6573021d9f1d8b9946fb884f9859012c5c1","modified":1688474698691},{"_id":"public/lib/pace-js/themes/white/pace-theme-minimal.css","hash":"cefa0e7676c2b220153e8b49a66928892a1fe252","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-barber-shop.css","hash":"76f45cc7c39140ba79595e4a3c672039beca701e","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-big-counter.css","hash":"a41e866c8c1035d8a8d10953751871d399bc17f2","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-center-atom.css","hash":"6e402a1ce41df72411a52e70cda74a9fd85f7659","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-bounce.css","hash":"088fcbe9fbfbedf7cdc0bd16756afc4db80757f2","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-center-circle.css","hash":"7c5f1b1f9387f05169e73e601cd1d1138710cbbb","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-center-radar.css","hash":"9d419c7c3b266f6a9ca3e1adccce7fbd868db029","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-center-simple.css","hash":"a6c1e439163586f303670ee998bc72bc51ac2fa4","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-corner-indicator.css","hash":"e8b3ace38b8419d1c31cfcdbae837ddd2cdd2bc5","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-fill-left.css","hash":"9d096b2b643ecd10e4b283bacc108bd1ab776de1","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-flash.css","hash":"630e49bf0c17e5caabfe0a4a93e525f753cef871","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-flat-top.css","hash":"613fcdc1e8a050e016a36faea7ad8cd288e40631","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-loading-bar.css","hash":"2dac75b2b3a68dfc2dc878d3a2e68c8f0aa254b9","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-mac-osx.css","hash":"0710a1ce39c7a43de61e20541b8a071f76f337bd","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-material.css","hash":"4d41c41aeb3f580fb165c92bea261fe9b8c37aff","modified":1688474698691},{"_id":"public/lib/pace-js/themes/yellow/pace-theme-minimal.css","hash":"574475917c2d78255d91b483b75f21575fa7da2a","modified":1688474698691},{"_id":"public/lib/ribbon.js/dist/ribbon.min.js","hash":"3c8e4d717ca107f3723def1795c8ed62a5f1a8d0","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by.svg","hash":"b91d19f5053d196e688ac54c239963f468227acb","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc.eu.svg","hash":"2067867dba581d6cb6d2be6dff9acfd1aeab6c8e","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc.svg","hash":"7cbe7ffac0c7ac583b9123cdb13a3ad776bed61e","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc_nd.svg","hash":"01218e449351528ed45838f21c07e36e4336e6e8","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc_nd.eu.svg","hash":"33034a747bc9fe22b2aee2a71eb382c82a8ea740","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc_sa.eu.svg","hash":"ed506437507b7fadf4df4f2a60f37383410451ad","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc_sa.svg","hash":"41e967eccdb535a2e60c4c0b0ab55d40942d18b4","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nd.svg","hash":"22c4186c53f342c0a7678c78d8dff83ea5c77b5b","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/by_sa.svg","hash":"98a9a8688542f35a3024bc3b80b9441314599ed2","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/cc_zero.svg","hash":"d38fdfc0348611e306badad79fb8b9a2971edd6b","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/big/publicdomain.svg","hash":"548a36025b36209b37f7c5c65ac976eba455b777","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/by.svg","hash":"e5b7d42a24ac64eb41574bbe73c6e24a7543fdbe","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/by_nc.svg","hash":"91a61cc58207f988bac9e38d59a04866ac09825c","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/by_nc_nd.svg","hash":"3edbb22607ac7a501a3e74f71796cf977ea20e1a","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/by_nd.svg","hash":"e72b275939c62d9534f615bcf303f10f281389f6","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/by_nc_sa.svg","hash":"269e1100449864526300dd27a6e785c4ea95c736","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/by_sa.svg","hash":"40a7a1484440a935589dcffc6248f04e8c32287c","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/cc_zero.svg","hash":"c83174699dd526346829db41b9bbe758d7c18364","modified":1688474698691},{"_id":"public/lib/@creativecommons/vocabulary/assets/license_badges/small/publicdomain.svg","hash":"a474a749260de675ac3bb7e725f69ecbb9551f12","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-brands-400.eot","hash":"d1ffd6340cdbf72890ccb67f32015eafc5df51a7","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-brands-400.svg","hash":"907bfbbe295332750575900984a00136de0f0e90","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-brands-400.ttf","hash":"8ab907083fecaaa2a9ec93b27f884ad74573705c","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff","hash":"1e1f02bfa89e179fe2dd1383273b8812aa873418","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2","hash":"0613c7ebba55ee47ef302c0f7766324692f899a7","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-regular-400.eot","hash":"670fb01e4930ae46fe8d6d2b75ead288f54e8e61","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-regular-400.svg","hash":"326e1d8f0b23f6df95cd6784fdf330bc6414ecd0","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-regular-400.ttf","hash":"c34acd6818df6db6be41a2e331886765d601f2eb","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-regular-400.woff","hash":"3ad4f4e4b1fb3edee3d4ba25e6cdfed2f0b88a54","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-regular-400.woff2","hash":"13517529affa39e2585c591acae6dc336b6aa917","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-solid-900.eot","hash":"ea845c59bee4a5c6db774b8d8060f5641b789ae9","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-solid-900.svg","hash":"d92687d30fa0d43f9ae71009398507bf813a6875","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-solid-900.ttf","hash":"eb8914f6b1797b45ee0883e6089d92695d9f9441","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-solid-900.woff","hash":"a22acd7697f36e7d4cc31a853c70e776eac54bb1","modified":1688474698691},{"_id":"public/lib/@fortawesome/fontawesome-free/webfonts/fa-solid-900.woff2","hash":"0ccb2c814a7e4ca12c4778821633809cb0361eaa","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_AMS-Regular.ttf","hash":"0ed9bbc59fbdf912586dbf369f46951cd78e651d","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_AMS-Regular.woff","hash":"3ba48164ac0df8109d3205934b4021fe5380ac50","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_AMS-Regular.woff2","hash":"8b400e7250dd10b5ec45b371e36ec897cfb7637a","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Caligraphic-Bold.ttf","hash":"2c684bdd9bc3b42e9598535454f60938b59f3e99","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Caligraphic-Bold.woff","hash":"a02380ffe3955f6630e23402ef31d0eb5302a07f","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Caligraphic-Bold.woff2","hash":"393931a006fa24f818e5af0b51e6ac2e15e10649","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Caligraphic-Regular.ttf","hash":"a0ecbcbb70aff38180482aee42e59d3759bca690","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Caligraphic-Regular.woff","hash":"fc5e4c89de422a1ae76e7b8d9d70a122e141f4f3","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Caligraphic-Regular.woff2","hash":"b0d0f63fa87b91cf4a84c682c0ef30b1d4ed8ebb","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Fraktur-Bold.ttf","hash":"6329ff783c72483ca6f2c024de3c9c84cb280784","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Fraktur-Bold.woff","hash":"27e611e380003e4d8b892bd8b2846536c366e7ce","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Fraktur-Bold.woff2","hash":"f8fab94d8f3b4c11e245e928d5aa9704f14d78ad","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Fraktur-Regular.ttf","hash":"44ccec9a6c947e59ce1554ca5ebb6e65236381f7","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Fraktur-Regular.woff","hash":"a3eb3fba388ebc3b148965012de4ddd6564746f2","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Fraktur-Regular.woff2","hash":"5c2765a12f1de1c6e19db7161254e75838f9bd77","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Bold.ttf","hash":"a5e53220da9536210bd0fb289582cd270463b08b","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Bold.woff","hash":"2a1a96010e1538da8e0c831fd0eff9f590ff508d","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Bold.woff2","hash":"053ab9519cdc7f573ed39c0be28c8f0b3bd22b47","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-BoldItalic.ttf","hash":"bdffecbe6f8d8a39659cfb429829582db7c2f9c0","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-BoldItalic.woff","hash":"7b4be14a4ef87c4797d0afbb38b66d0f0d17691e","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-BoldItalic.woff2","hash":"ffaefbc5b466276552639275bda764801ac66d7c","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Italic.ttf","hash":"7f2e80c7538b5e34d4c058941f5eb97d779e727f","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Italic.woff","hash":"effa4ef35c6bd0b67d0344a750f17b27e74a2e04","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Italic.woff2","hash":"8ab79b2cebc2cc5b1f65e67b34a83afce293e5de","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Regular.ttf","hash":"45dc9433f25978dc52e6d6ebbbffa9149423ad76","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Regular.woff","hash":"e0ec75729402c71523c1443bb0cf173923f9e664","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Main-Regular.woff2","hash":"ca84a3d1317d534c97fcb5872ed1ba1ee79db56c","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Math-BoldItalic.ttf","hash":"5a8d0dd8f45e5f71a254d7db08b61517730e7dee","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Math-BoldItalic.woff","hash":"6e408dd5f986e1fe628140bb34453bc3786f0c5d","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Math-BoldItalic.woff2","hash":"f28fdd425f0d9881c5992995c9605d10951b48da","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Math-Italic.ttf","hash":"c6958d6ac5ab2def4cabb5f01e1dba4599b0d722","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Math-Italic.woff","hash":"5bbbc879df46c609838e8e133342a5f3c7e4e501","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Math-Italic.woff2","hash":"51ef990db4660b37b21b587c76063102b349fe83","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Bold.ttf","hash":"0df06ca56eadfd7a678c4084321776a8337c7bd5","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Bold.woff","hash":"05089a8a8854adb9e9302b2d905b31eddebb117a","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Bold.woff2","hash":"83293ac1f4b7afc4d12f018327259228a62381e5","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Italic.ttf","hash":"5a28ee4f24f2226d27a52e64ff5ae42b74db4dc2","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Italic.woff","hash":"6793c492ecef880e4600981225c7d3411b397cf6","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Italic.woff2","hash":"653ee8929a608f831d9a3495b51e228b9aa16fde","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Regular.ttf","hash":"a7b40708d5557958762dd265c10011568195e8fe","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Regular.woff","hash":"7742a6921515d9e5bd878db6796b516a5a87d0e8","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_SansSerif-Regular.woff2","hash":"9273248046aa3f1e2527edc3191d44a50b67bf41","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Script-Regular.ttf","hash":"a1868668fb360894eae125f0cb760880f99981fb","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Script-Regular.woff","hash":"c27731117b38abaf90a57d90ce82e75be8c9bc61","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Script-Regular.woff2","hash":"9d0bc72aa401f3aa2459d90f496c9926c292a190","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size1-Regular.ttf","hash":"d258fa0c0a61f30225004109b553387f9b77975d","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size1-Regular.woff","hash":"f0700fe74e24b56ac1efebedc5ce10eb6e837073","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size1-Regular.woff2","hash":"46b46a22297a205c360ac9b0a9d78017534adaed","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size2-Regular.ttf","hash":"2c314127be907cf5383f49c3bdb26f159fd662aa","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size2-Regular.woff","hash":"4fdf5d5b7f1fe804cbc0c437f29df303dd6576e8","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size2-Regular.woff2","hash":"12fee83a7c55c6373d08c848463bd3bceaf1cba0","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size3-Regular.ttf","hash":"a7602baca7464ce571c0c0a579c7cd0fecf4f92f","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size3-Regular.woff","hash":"92cf7c08c1865a3404dac0e67151ec2cdd1a9324","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size3-Regular.woff2","hash":"cfc832e9230ab840d14c7279a889648708073844","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size4-Regular.ttf","hash":"0017d8f3f0bcdba49542261318ef8b323acead91","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size4-Regular.woff","hash":"47e81641731abd490b186b88e760265425fc57d5","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Size4-Regular.woff2","hash":"b42b1dfe65062b5e2086ce9b797bffdafdf8fc3b","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Typewriter-Regular.ttf","hash":"9f5b02fac638761737efe38937e5d0fff92e481c","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Typewriter-Regular.woff","hash":"97f6f3c87f8e72368eac5fcd94dff2632d9fe884","modified":1688474698691},{"_id":"public/lib/katex/dist/fonts/KaTeX_Typewriter-Regular.woff2","hash":"0f9148824e8f286ad4e879c75c9de1e27fcc630b","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/tex.js","hash":"5b8d478cd0d5572e66cce91cdc7c879628b3d388","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff","hash":"6bc2c425db1226bf91a45c5ac4bf92c6a2659e4c","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff","hash":"4f45a4737793be31b0cf5606a717b27d4f33633f","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff","hash":"69abf851342ea0ea88cd7a48a3855a8da85144ce","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff","hash":"0db97c087590f9e4866e376183d5dc11f10db0be","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff","hash":"28704c6a56970ba681fc09763ad3b6d4d1f408a4","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff","hash":"1b39dd27087cec46eb36b4b0cb967c7a2b7548ae","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff","hash":"b83eded6d73439a0387219214d0a320a3c3b0d7e","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff","hash":"89d2c8d274693c5a6e250e96e2a2e26e25619079","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff","hash":"de80661cd5bc7e2328217db699a0ef7159d27a2e","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff","hash":"91a4025dd3b18ca6bda63a215869773705435041","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff","hash":"8ec440016063a0dcd1e8d7e806ec86b2babfea29","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Math-Regular.woff","hash":"440031e5fd0684c5e38a9221114d280a55763ad4","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff","hash":"9a30c856fa1957552d0226a600bf28fd8f417413","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff","hash":"b14c723751a0ac1f8a94ed55fabf6ebeb38559ce","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff","hash":"c668b55e8405d2f8acf2bcf1578d01838a8ef399","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff","hash":"9c98f9f022647eb802434947e062b569ccedd5f0","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff","hash":"53e2fb218469bb4b2118437e542cc018f849747b","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff","hash":"5848fbf600fbb7d4a67e720e60da885ba4e12bb8","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff","hash":"683c23731b31b766d8ed805b2d258eaab52085db","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff","hash":"8dc0fe3bcd2cf9d3e46c3feb3a21b62961aa557c","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff","hash":"14dd272bd9ce18c5a32bcaef50107d872a7d8543","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff","hash":"1c6d1ec6fcfecc0585e93c2ac52a4ab8a34b1b77","modified":1688474698691},{"_id":"public/lib/mathjax/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff","hash":"6712cf0aa5c12edc1cbbca8a1732a9cde0854c48","modified":1688474698691},{"_id":"public/posts/rust-atomics-and-locks/p1.html","hash":"9c9b50bb5f9fb40c611c542b633a664ed559ff69","modified":1688474698691},{"_id":"public/posts/novel/墨染樱下幽魂.html","hash":"9a7f6dbdf6613c1c977ff1c31683217851332634","modified":1688474698691},{"_id":"public/posts/rust-iced/p4.html","hash":"a93bc2da402bd167bcbdab0c3d3d991e884ca27c","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p9.html","hash":"2ffcf160371decc4fb3b40b7a7d9f2bf03ef71a5","modified":1688474698691},{"_id":"public/posts/rust-iced/p3.html","hash":"8cff7a59cf194c7064eef983b52db50e2268ad90","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p8.html","hash":"d51fc9f83746126773b240ffa6b25785840724d6","modified":1688474698691},{"_id":"public/posts/rust-iced/p2.html","hash":"fc0fbb70fe0b5033acde9f360357e76161c11a9d","modified":1688474698691},{"_id":"public/posts/rust-iced/p1.html","hash":"313f005a62b597873dda155f15b3ef832efd7b68","modified":1688474698691},{"_id":"public/posts/scala3-basic/p2.html","hash":"de1b52fcf0ad103b4301723da3cd057e515c222a","modified":1688474698691},{"_id":"public/posts/scala3-basic/p1.html","hash":"3b4d788d9f24c41036164ed2857df2f49e2d0397","modified":1688474698691},{"_id":"public/posts/desktop-beautify/hyprland.html","hash":"9d2f65a7a46fc3814155cb6b79d8455c81a05a27","modified":1688474698691},{"_id":"public/posts/high-school-it/p5.html","hash":"1c98cef9c1dda951a66c1dbd3f2685a22e165886","modified":1688474698691},{"_id":"public/posts/high-school-it/p4.html","hash":"d7789cdf746a702d962f0f0603b026077ad13256","modified":1688474698691},{"_id":"public/posts/rust-gstreamer/p5.html","hash":"741a201c205da7f4ba948f0dcd1feb453c300477","modified":1688474698691},{"_id":"public/posts/rust-gstreamer/p4.html","hash":"1628b3e9f8d2f6755cc751f5c6562d4c26b5ff5f","modified":1688474698691},{"_id":"public/posts/rust-gstreamer/p3.html","hash":"7c0cafdd10b398e41aab2b0ffe1d3cd895c9c055","modified":1688474698691},{"_id":"public/posts/rust-gstreamer/p2.html","hash":"450353ac6e535d0cf3aa1bc2b0960d3f291cc7c0","modified":1688474698691},{"_id":"public/posts/rust-gstreamer/p1.html","hash":"f3f81c9f581e270f6d1971f0a127010f78f2d95a","modified":1688474698691},{"_id":"public/posts/haskell-basic/p5.html","hash":"b4744b66589de4ea13a2081d4b65bf56ed97e09f","modified":1688474698691},{"_id":"public/posts/haskell-basic/p1.html","hash":"cfd25bdacbb6ff42180f8ddbec0d5b1e94cabf82","modified":1688474698691},{"_id":"public/posts/rust-tui/p1.html","hash":"61630d413fa3bfc5dfcd79ed68785c4f273ffc50","modified":1688474698691},{"_id":"public/posts/rust-decl-macro/p5.html","hash":"0aeac4b40ad78a75cd0140ec17d3a0a160bef696","modified":1688474698691},{"_id":"public/posts/rust-decl-macro/p1.html","hash":"0871497a3c70ef831abee1a861863c5d02102513","modified":1688474698691},{"_id":"public/posts/rust-async/p1.html","hash":"efcc2b44e72589191aca33d9efd0d95c7ab7c563","modified":1688474698691},{"_id":"public/categories/rust-atomics-and-locks.html","hash":"9c52fdf78fd41d2e953a0a88934a94f6ddfd1879","modified":1688474698691},{"_id":"public/categories/scala3-basic.html","hash":"3d6738f1887ff7a91466c0726b9acb78297b74aa","modified":1688474698691},{"_id":"public/categories/desktop-beautify.html","hash":"4e1cca68b0dd126fba3d6471b2195b618d8b171a","modified":1688474698691},{"_id":"public/categories/rust-gstreamer.html","hash":"bd0eab36ce8bc71d31617b7018ab7cca0e4b2629","modified":1688474698691},{"_id":"public/categories/high-school-it.html","hash":"1a8df8061efa77e9f25331236f3eaf339a4801dd","modified":1688474698691},{"_id":"public/categories/haskell-basic.html","hash":"5b9500036dff2361e55fa080de8000fc5cf3092c","modified":1688474698691},{"_id":"public/categories/rust-tui.html","hash":"c31fec60d58d9c663f2620b5bd3f333148454989","modified":1688474698691},{"_id":"public/categories/rust-gui.html","hash":"61cbb57ce4bce901d2355bf3ef3685b513a0b98c","modified":1688474698691},{"_id":"public/categories/rust-async.html","hash":"eea4c4298b8d811b8538664341890a8a8bf8efb4","modified":1688474698691},{"_id":"public/categories/rust-decl-macro.html","hash":"142bb4849e56129ddea95f1d587960e3e75a7dbf","modified":1688474698691},{"_id":"public/archives/2021/page/2/index.html","hash":"34140ddb006031abc93f0a784ec66bc3f2be0ba6","modified":1688474698691},{"_id":"public/archives/2021/09/index.html","hash":"57f7322975163daa4d982e801c8b8e582fa31060","modified":1688474698691},{"_id":"public/archives/2021/11/index.html","hash":"d1099f6c7afa54b63ca79b602596f619156a10d6","modified":1688474698691},{"_id":"public/archives/2021/10/index.html","hash":"a1746db5d74d738af0cee3d876b43e0769d7475c","modified":1688474698691},{"_id":"public/archives/2022/page/3/index.html","hash":"6bc1608f1c174e0e4e82792a73252f22eb15a30f","modified":1688474698691},{"_id":"public/archives/2022/03/index.html","hash":"2044b0f39e908c8533e07fa44ee4e055555770ef","modified":1688474698691},{"_id":"public/archives/2022/06/index.html","hash":"56d9caeec902868a2124449450ba016f69a15db1","modified":1688474698691},{"_id":"public/archives/2022/07/index.html","hash":"8dd4bb970520d950c9c85ad4c56170ebda9b6685","modified":1688474698691},{"_id":"public/archives/2022/08/index.html","hash":"e83dd54a5de19f2679b885a28129d95907bd7c20","modified":1688474698691},{"_id":"public/archives/2022/09/index.html","hash":"5fffd0afa8b635444658e06a25357e85c4f034c8","modified":1688474698691},{"_id":"public/archives/2022/10/index.html","hash":"30d1582f1a666dd3aa153f815c93ac564bd30d11","modified":1688474698691},{"_id":"public/archives/2022/11/index.html","hash":"189cb93f3375c18a4d4eb24a5b4dfcaf2850f931","modified":1688474698691},{"_id":"public/archives/2022/12/index.html","hash":"ce8c40f078687ed75f125095204ca87d11f62d9b","modified":1688474698691},{"_id":"public/archives/2023/01/index.html","hash":"6835169658ec045db25ec21fe72938076fb4f133","modified":1688474698691},{"_id":"public/archives/2023/page/2/index.html","hash":"b224623dc9e15cc8d50647aea3acfe17f6b0697d","modified":1688474698691},{"_id":"public/archives/2023/05/index.html","hash":"64f0e5e23e60a32f39f7c935eb6d07cad2e81ec3","modified":1688474698691},{"_id":"public/archives/2023/06/index.html","hash":"e69c36b6181f7a81ce4f9cf46995a440d7c07737","modified":1688474698691},{"_id":"public/tags/Linux/index.html","hash":"592def89e6a5b8d9da01b57c5cba837d097f15ea","modified":1688474698691},{"_id":"public/tags/GNOME/index.html","hash":"ff74e1ac760ca85acbd73a1b54b051426ece1d89","modified":1688474698691},{"_id":"public/tags/Waylnad/index.html","hash":"a2f4003e99b0ae71afa038722a897a0ccf20067a","modified":1688474698691},{"_id":"public/tags/Desktop/index.html","hash":"d538b882753f1311f6317bec03fb2dfa3fc4d1f8","modified":1688474698691},{"_id":"public/tags/Hyprland/index.html","hash":"9cf06aef74ca46388a3aefc5221e32715f6f9aa2","modified":1688474698691},{"_id":"public/tags/高中信息技术/index.html","hash":"cd3bb296a005bb5b17701baaf8fdc2c037e614be","modified":1688474698691},{"_id":"public/tags/Novel/index.html","hash":"6a749165f5001cbe8751fc92744f51a6f4650bdf","modified":1688474698691},{"_id":"public/tags/东方Project/index.html","hash":"e1afdb44cd4ac1b4c35df02ff0d64538d39b870d","modified":1688474698691},{"_id":"public/tags/明日方舟/index.html","hash":"e30eebaf85ab870834a16bc5313a98495b122b65","modified":1688474698691},{"_id":"public/tags/Haskell/index.html","hash":"d8e13e26049e6b22a8ad2d1f3417b429c9ed3e61","modified":1688474698691},{"_id":"public/tags/Scala3/index.html","hash":"3dc7fcaa832678c5eb9a112d5c9e4ecde838e92a","modified":1688474698691},{"_id":"public/tags/Rust/page/4/index.html","hash":"df20eef8cfbe5e0803d6d3042fbaa0c87aa0a84e","modified":1688474698691},{"_id":"public/tags/Async/index.html","hash":"2aa34c15aa4c75583f3513fce93c4dd2d5666f97","modified":1688474698691},{"_id":"public/tags/Clap/index.html","hash":"c53df40691d089ffb2eec3e23e25a4c865d080b2","modified":1688474698691},{"_id":"public/tags/CLI/index.html","hash":"31017524a7aa5772fa7e5c0e7137ff9b4cb513fe","modified":1688474698691},{"_id":"public/tags/Macro/index.html","hash":"d1b3fcfc9e5743d747871c2ffd1c382179affc2e","modified":1688474698691},{"_id":"public/tags/GStreamer/index.html","hash":"6b4f83e46c099e1d06ebd5ce1bf848ed92b51bb6","modified":1688474698691},{"_id":"public/tags/Video/index.html","hash":"36f4f76d53ca674a84635dac824b38d5c0346f35","modified":1688474698691},{"_id":"public/tags/Audio/index.html","hash":"405d885b160035490027ca916deb66d8bce5e39b","modified":1688474698691},{"_id":"public/tags/Concurrency/index.html","hash":"c4b227177a7538f97bb7b17ca4a3360e82992b33","modified":1688474698691},{"_id":"public/tags/TUI/index.html","hash":"f0955a713613df498c64df54a553abd6b3dc9673","modified":1688474698691},{"_id":"public/tags/GUI/page/2/index.html","hash":"6ba3f08f3c7fd080a8083bfe839743eec513cac0","modified":1688474698691},{"_id":"public/about/index.html","hash":"a65d325c922be4b4bece5f76cad5d6cb839acbaf","modified":1688474698691},{"_id":"public/categories/index.html","hash":"19caf94a57b623df0d966eaae7880eb0bc743bb5","modified":1688474698691},{"_id":"public/posts/rust-atomics-and-locks/p2.html","hash":"2d821d23d2095dc76b52d781679280baad1105a1","modified":1688474698691},{"_id":"public/posts/rust-tui/p2.html","hash":"542c2f2dfcd9e6c4596ccb2da4fe27a3a0733297","modified":1688474698691},{"_id":"public/posts/rust-common-errors.html","hash":"1c6ffd8e4ebbe5f06981913a0285d9961a049e01","modified":1688474698691},{"_id":"public/posts/novel/浪潮涌没的终焉与永恒之爱.html","hash":"6a0af4f72d8396f9145c3f5a4ae814919be35aab","modified":1688474698691},{"_id":"public/posts/other/rasterization-dda-bresenham.html","hash":"3ac1e8d6aadb61c5bab72ec6b5faa19286cce31f","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p7.html","hash":"5ab927138b2565f85b9a34e4352d4e7928910e1f","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p6.html","hash":"c3b17a441773297f261c876205d367ee59db2c43","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p5.html","hash":"8c5046d0d794e46a7e3d5e2c9bb18e3929305ee3","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p4.html","hash":"425851b18e7515a9278b09bf4c8815d64de65a0f","modified":1688474698691},{"_id":"public/posts/high-school-it/p3.html","hash":"4a627c25efbcccd5e12839488f7595742539edab","modified":1688474698691},{"_id":"public/posts/high-school-it/p2.html","hash":"7b987cba85a31785197c5c1380c34515433c68cb","modified":1688474698691},{"_id":"public/posts/high-school-it/p1.html","hash":"5eb34b5903945b5750193405e87a71f4a098e6cc","modified":1688474698691},{"_id":"public/posts/rust-clap/intro.html","hash":"42c7ff4cf0f98d0e21ca6db1be0f8af917106132","modified":1688474698691},{"_id":"public/posts/desktop-beautify/gnome.html","hash":"d7058b4e33b43151e94b8f7463f9dc8934bd4a4b","modified":1688474698691},{"_id":"public/posts/haskell-basic/p4.html","hash":"34cb9d74877665443338d0a59210969936054770","modified":1688474698691},{"_id":"public/posts/haskell-basic/p3.html","hash":"047172ed81b612868ac877bda1adeb732f5394ae","modified":1688474698691},{"_id":"public/posts/haskell-basic/p2.html","hash":"34fd8f34e3bc9288af64fe49f23596d381000e41","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p3.html","hash":"0222c1e8ca2bef70081439a368b261eee0855147","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p2.html","hash":"5c8a12fb6f99e7e64a2a94d9839ee3d76dbddc10","modified":1688474698691},{"_id":"public/posts/rust-gtk4/p1.html","hash":"98236cf97fac67e9acf64696b5ae39543f47d3a7","modified":1688474698691},{"_id":"public/posts/rust-decl-macro/p4.html","hash":"df68041b5eee88a5dc1a6d9fa77f256ca62b49b1","modified":1688474698691},{"_id":"public/posts/rust-decl-macro/p3.html","hash":"29174c4e5ae07a1319e981dbbd3679dc4c8faddc","modified":1688474698691},{"_id":"public/posts/rust-decl-macro/p2.html","hash":"40c088b8e5d05e91f6420d87bf6f224a75d5567d","modified":1688474698691},{"_id":"public/posts/rust-async/p4.html","hash":"e88c6f59b463547c1983277bb6c3619f19421d76","modified":1688474698691},{"_id":"public/posts/rust-async/p3.html","hash":"e987d30e5fbdaa2e9c0a32badf3061090abab304","modified":1688474698691},{"_id":"public/posts/rust-async/p2.html","hash":"4a3896efcd2562c6b0de129fe6aedd767dc0f5dc","modified":1688474698691},{"_id":"public/archives/index.html","hash":"7dd419448a78a827c25e067ef15c791446675e26","modified":1688474698691},{"_id":"public/archives/page/2/index.html","hash":"7434a4d963a2438076103c51e9f340c013365e6e","modified":1688474698691},{"_id":"public/archives/page/3/index.html","hash":"97495ef13c0d2bafbca419d4a0023a79f15c054b","modified":1688474698691},{"_id":"public/archives/page/4/index.html","hash":"d14e8f048b2de2d20d280944637d07a310e2cc4e","modified":1688474698691},{"_id":"public/archives/page/5/index.html","hash":"4d888203d9f8e71cca59b06ef3670d47c798cfda","modified":1688474698691},{"_id":"public/archives/2021/index.html","hash":"53ffec708472a7bce3648200c424cf55259c43b6","modified":1688474698691},{"_id":"public/archives/2022/index.html","hash":"5ea88fa579eabd644b2927c7fce1df2cb45c1c4b","modified":1688474698691},{"_id":"public/archives/2022/page/2/index.html","hash":"d40387d735631c206826b5ef24cf2d7ef257dbaa","modified":1688474698691},{"_id":"public/archives/2023/index.html","hash":"5886c2c35302443c4fccbc53878dc8cfccbfdd6d","modified":1688474698691},{"_id":"public/index.html","hash":"cf960d55210098a33bd7dca93b0184fe7b83967b","modified":1688474698691},{"_id":"public/page/3/index.html","hash":"9922e6539073b30fddcd682a7cce5b5e2b9a5feb","modified":1688474698691},{"_id":"public/page/2/index.html","hash":"082ac855411901f91db5600279893668ae457417","modified":1688474698691},{"_id":"public/page/4/index.html","hash":"5771033125844725e7844c5f73e64d2ec18a3f2b","modified":1688474698691},{"_id":"public/page/5/index.html","hash":"d05ab37eb972dc280bed36d890a8efe50e6517a3","modified":1688474698691},{"_id":"public/tags/Rust/index.html","hash":"ca3d5a0baae55f9dbd23ddfaf6ef9cc6bd69e2f0","modified":1688474698691},{"_id":"public/tags/Rust/page/2/index.html","hash":"871be0e731f757c6120af338d9e4a341a6009d31","modified":1688474698691},{"_id":"public/tags/Rust/page/3/index.html","hash":"12a6cadde9f9eaf10496c07e4ab29be3453b5624","modified":1688474698691},{"_id":"public/tags/GUI/index.html","hash":"0e78b7f0460cf25dc7c9126de1343fc8cc43a1ac","modified":1688474698691},{"_id":"public/css/download.zip","hash":"034b20bd8ea91aee04a9fcc713e6f355a8fc7686","modified":1688474698691},{"_id":"public/css/iconfont.css.backup","hash":"83303af46a2b75d4959371be747fb5b3cb79d689","modified":1688474698691},{"_id":"public/css/iconfont.ttf","hash":"9af30b1a4b1405fc5f91464e5902f953b8068512","modified":1688474698691},{"_id":"public/css/iconfont.woff2","hash":"ce8162de5535076a601089019d69c3054f986ee6","modified":1688474698691},{"_id":"public/images/favicon-32x32.png","hash":"c587c9e0ad3da71d5d87ec5a17dbb2270c982679","modified":1688474698691},{"_id":"public/css/iconfont.woff","hash":"bcd7471a2ec5e457196f54a51d485bb19daa848b","modified":1688474698691},{"_id":"public/images/favicon-16x16.png","hash":"369c77d4be3efe406ecbbdd7886a6ddafd93a940","modified":1688474698691},{"_id":"public/404.html","hash":"7fbfd18d223b7af343821bc3469045d8bd8362cd","modified":1688474698691},{"_id":"public/README.md","hash":"d18fa0c6e445d9bb7f8338ca10a0c5d8284ede54","modified":1688474698691},{"_id":"public/CNAME","hash":"0a0982664414697effe8e4704840261052941402","modified":1688474698691},{"_id":"public/images/gnome/color-app-menu-icon.png","hash":"c0f4a8600eeb0469460b13bc24de810eae94be48","modified":1688474698691},{"_id":"public/images/gnome/eye-extended.png","hash":"cc320a5424d83445eef427da4cfa4e8670f2d839","modified":1688474698691},{"_id":"public/images/gnome/gsconnect.png","hash":"b10d2f2c9b9919077cc2c76ee49ddc88af0473b4","modified":1688474698691},{"_id":"public/images/gnome/ibus.png","hash":"534b4a1ce562a18651aa54aeab00f8ac3df7eba9","modified":1688474698691},{"_id":"public/images/gnome/nothing-to-say.png","hash":"2a01d35211519b528c223e9d4454236d24da1dd7","modified":1688474698691},{"_id":"public/images/gnome/right-corner.png","hash":"b6af54f899eb811d55eb160ee1875f5e33b698b0","modified":1688474698691},{"_id":"public/images/gnome/space-bar_name.png","hash":"7dc8558cf55d2ab7dddc13ecfe3bea5a7bd23ac5","modified":1688474698691},{"_id":"public/images/gnome/space-bar_number.png","hash":"214428efa3c35beae0306890c23b552fed2e5234","modified":1688474698691},{"_id":"public/images/others/dda_1.png","hash":"a260bdbbc45ae6d719ec7abbeaea828895069340","modified":1688474698691},{"_id":"public/images/gnome/big-avatar.png","hash":"8fca7f2efc0358dd37eb798d106d42355e170b9d","modified":1688474698691},{"_id":"public/images/gnome/frequency-boost-switch.png","hash":"80a40d591838da850c03d2803531c377616eb2d2","modified":1688474698691},{"_id":"public/images/gnome/gnome40-ui-improvements.png","hash":"f04061c64f6e0a32a2d2a1f371fc8965cf6e9915","modified":1688474698691},{"_id":"public/images/gnome/refresh-wifi-connections.png","hash":"f94d7390a3749d29da4b724ce951b3db56df4a4c","modified":1688474698691},{"_id":"public/images/others/dda_2.png","hash":"062bd865f47040a3d7c4e45121c5bcc4d515c061","modified":1688474698691},{"_id":"public/css/custom.css","hash":"b6d6f404e28c74d6380046dbbb6922cc2d48c06d","modified":1688474698691},{"_id":"public/css/demo_index.html","hash":"eb23998541d481c6923f9c0c8ff694bf7a3e2b6f","modified":1688474698691},{"_id":"public/css/iconfont.css","hash":"8806c405841e1cc582ac0362e5472bb2d72f4e4d","modified":1688474698691},{"_id":"public/css/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1688474698691},{"_id":"public/css/iconfont.js","hash":"5f047b5796b11bfd2f2b94d5a1ab54667b7d7396","modified":1688474698691},{"_id":"public/css/iconfont.json","hash":"3d672e0046ce1525471249f3d12ed89eb7239d9e","modified":1688474698691},{"_id":"public/lib/darkmode-js.min.js","hash":"29b6500c71a1952ed5c0e79c52b2f5d6ccd12c98","modified":1688474698691},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1688474698691},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1688474698691},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1688474698691},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1688474698691},{"_id":"public/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1688474698691},{"_id":"public/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1688474698691},{"_id":"public/lib/fastclick/default.json","hash":"5427a63d19b4b034a3a74e9ee6fcb8ae11b230df","modified":1688474698691},{"_id":"public/lib/fastclick/package.json","hash":"1d7632f6e738677af1a67398ce09ab93e175740f","modified":1688474698691},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1688474698691},{"_id":"public/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1688474698691},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1688474698691},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1688474698691},{"_id":"public/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1688474698691},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1688474698691},{"_id":"public/js/third-party/quicklink.js","hash":"9067915a45ab959d5a197bf1ffde4da980146618","modified":1688474698691},{"_id":"public/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1688474698691},{"_id":"public/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1688474698691},{"_id":"public/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1688474698691},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1688474698691},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1688474698691},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1688474698691},{"_id":"public/css/main.css","hash":"4f2739626c0147c038b185cd1fb6f03a6fcc50e9","modified":1688474698691},{"_id":"public/css/FiraCode-Regular.woff","hash":"8c160056d0f435e118beebe61ec9ed69f078535e","modified":1688474698691},{"_id":"public/images/404-background.jpg","hash":"d04ff7a87d284cf44bcc2d4dfb70106681ef6768","modified":1688474698691},{"_id":"public/images/gnome/gnome-fuzzy-app-search.png","hash":"ad67ce1c81c0ba3476a81abc4e06a73a8a6c3728","modified":1688474698691},{"_id":"public/images/gnome/workspace-switcher-manager.png","hash":"2184be787d2619605775dec6b4be9f89c6b2c1e3","modified":1688474698691},{"_id":"public/images/avatar.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1688474698691},{"_id":"public/images/rust/gtk4/bidirectional_switches.webm","hash":"ef1f1030d82f2588c9b75b88878a6e02aa0827dc","modified":1688474698691},{"_id":"public/images/rust/gtk4/transform_buttons.webm","hash":"fd16c0a6173f79ebb2bbe784146025510417b563","modified":1688474698691},{"_id":"public/images/gnome/transparent-window-moving.png","hash":"2171b11d661aaef009ce7e0ed6950bd493713c93","modified":1688474698691},{"_id":"public/images/gnome/overview-navigation.png","hash":"3ebcaf71b468e3cd42914314e4073025770d729a","modified":1688474698691},{"_id":"public/images/gnome/overview_42.png","hash":"f7a03e8897e0ccd149f569ef98213bbfac51ec26","modified":1688474698691},{"_id":"public/images/gnome/overview_43.png","hash":"b11283a4806f7197d3add590dfc329e7a12b5595","modified":1688474698691},{"_id":"public/images/gnome/overview_44.png","hash":"b49759e68750f260767a2dd417a98c1a7cd83e19","modified":1688474698691},{"_id":"public/images/avatar.svg","hash":"85b7ae4a346c6832d1ef82537b816ff1e3a9efea","modified":1688474698691},{"_id":"public/images/gnome/control-blur-effect-on-lock-screen.png","hash":"5c32c4bcc0d5056be25d160d14066f99d153124d","modified":1688474698691},{"_id":"public/css/genshin.woff2","hash":"a849fda9b22a8782b3c778d0c9b5abcc88e861be","modified":1688474698691},{"_id":"public/downloads/gnome/kdeconnect.apk","hash":"817e71e04488fd2fd7d59d6e712013d06528e92e","modified":1688474698691}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2022-01-29T12:53:24.000Z","_content":"\n# 曾经的冒险者\n曾经...\n我和你一样, 也是个冒险者...\n直到我的膝盖中了一剑\n\n- - -\n\n# 伟大の左特\n听好了, 愚蠢</span>的虫子们! 我是:  \n<span style=\"font-size: 130%; line-height: 0.1em\">无敌的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">勇猛的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">性感的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">神秘的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">迷人的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">神气的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">勤勉的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">强势的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">华丽的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">激情的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">可怕的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">漂亮的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">强大的!</span>\n<span style=\"font-size: 220%;\">灰色王子</span>, 左特!\n\n- - -\n\n# 适之的日记\n- 2022.7.6\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业, 然后是预习高二的新课, 争做21世纪三好青年  \n计划一个月内背完一本英语词典, 刷完三本教辅, 在 B 站上看一数, 一化, 一英, 黄夫人的课进行复习预习  \n明天开始奋斗!!!!!  \n- 2022.7.7\n看番\n- 2022.7.8\n看番\n- 2022.7.9\n看番\n- 2022.7.10\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗? 子曰: \"吾日三省吾身\", 你不能再这样下去了! 吃得苦中苦, 方为人上人!  \n- 2022.7.11\n看番\n- 2022.7.12\n看番\n\n- - -\n# 猪, 四战, 宗教\n2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨  \n\n你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等可爱小猪的尸体而痛哭流涕  \n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索  \n\n一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道  \n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播  \n\n为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻  \n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉  \n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 \"大变革降临的标志\"  \n\n你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实  \n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响  \n\n世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发  \n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾  \n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背  \n\n\"那群疯子\", 你喃喃自语道, 一个伟大的计划在你心中形成  \n\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n\n\n五十年后  \n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教  \n\"拒绝猪肉\" 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!  \n\n你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音  \n你用尽全力挣扎地想要阻止渐渐消散的意识  \n你感受到那些正簇拥在你身边痛哭着的教徒  \n你看到死亡在俯瞰自己暴露在躯壳外的灵魂\n\n这是你回忆起你的一生时, 脑海中最后的念头:\n\n\"我终于改变了这个猪肉至上, 扭曲且肮脏的世界了...\"  \n\"我做到了...我终于...做到了...\"\n\n世界因为你而流动, 第四次世界大战得以避免, 人类甚至因共同的信仰, 而达到了空前的团结与统一  \n世界亦在你逝去后, 举世默哀, 全人类的时间仿佛随着你的逝去, 而永远地停在了那一天  \n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-29 20:53:24\n---\n\n# 曾经的冒险者\n曾经...\n我和你一样, 也是个冒险者...\n直到我的膝盖中了一剑\n\n- - -\n\n# 伟大の左特\n听好了, 愚蠢</span>的虫子们! 我是:  \n<span style=\"font-size: 130%; line-height: 0.1em\">无敌的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">勇猛的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">性感的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">神秘的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">迷人的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">神气的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">勤勉的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">强势的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">华丽的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">激情的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">可怕的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">漂亮的!</span>\n<span style=\"font-size: 130%; line-height: 0.1em\">强大的!</span>\n<span style=\"font-size: 220%;\">灰色王子</span>, 左特!\n\n- - -\n\n# 适之的日记\n- 2022.7.6\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业, 然后是预习高二的新课, 争做21世纪三好青年  \n计划一个月内背完一本英语词典, 刷完三本教辅, 在 B 站上看一数, 一化, 一英, 黄夫人的课进行复习预习  \n明天开始奋斗!!!!!  \n- 2022.7.7\n看番\n- 2022.7.8\n看番\n- 2022.7.9\n看番\n- 2022.7.10\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗? 子曰: \"吾日三省吾身\", 你不能再这样下去了! 吃得苦中苦, 方为人上人!  \n- 2022.7.11\n看番\n- 2022.7.12\n看番\n\n- - -\n# 猪, 四战, 宗教\n2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨  \n\n你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等可爱小猪的尸体而痛哭流涕  \n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索  \n\n一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道  \n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播  \n\n为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻  \n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉  \n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 \"大变革降临的标志\"  \n\n你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实  \n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响  \n\n世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发  \n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾  \n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背  \n\n\"那群疯子\", 你喃喃自语道, 一个伟大的计划在你心中形成  \n\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n\n\n五十年后  \n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教  \n\"拒绝猪肉\" 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!  \n\n你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音  \n你用尽全力挣扎地想要阻止渐渐消散的意识  \n你感受到那些正簇拥在你身边痛哭着的教徒  \n你看到死亡在俯瞰自己暴露在躯壳外的灵魂\n\n这是你回忆起你的一生时, 脑海中最后的念头:\n\n\"我终于改变了这个猪肉至上, 扭曲且肮脏的世界了...\"  \n\"我做到了...我终于...做到了...\"\n\n世界因为你而流动, 第四次世界大战得以避免, 人类甚至因共同的信仰, 而达到了空前的团结与统一  \n世界亦在你逝去后, 举世默哀, 全人类的时间仿佛随着你的逝去, 而永远地停在了那一天  \n\n","updated":"2022-01-29T12:53:24.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cljoa8ofq0000j1s6fm244cni","content":"<h1 id=\"ceng-jing-de-mou-xian-zhe\">曾经的冒险者</h1>\n<p>曾经…<br>\n我和你一样, 也是个冒险者…<br>\n直到我的膝盖中了一剑</p>\n<hr>\n<h1 id=\"wei-da-no-zuo-te\">伟大の左特</h1>\n<p>听好了, 愚蠢</span>的虫子们! 我是:<br>\n<span style=\"font-size: 130%; line-height: 0.1em\">无敌的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">勇猛的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">性感的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">神秘的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">迷人的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">神气的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">勤勉的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">强势的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">华丽的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">激情的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">可怕的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">漂亮的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">强大的!</span><br>\n<span style=\"font-size: 220%;\">灰色王子</span>, 左特!</p>\n<hr>\n<h1 id=\"gua-zhi-de-ri-ji\">适之的日记</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2022.7.6<br>\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业, 然后是预习高二的新课, 争做21世纪三好青年<br>\n计划一个月内背完一本英语词典, 刷完三本教辅, 在 B 站上看一数, 一化, 一英, 黄夫人的课进行复习预习<br>\n明天开始奋斗!!!</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.7<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.8<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.9<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.10<br>\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗? 子曰: “吾日三省吾身”, 你不能再这样下去了! 吃得苦中苦, 方为人上人!</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.11<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.12<br>\n看番</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"zhu-si-zhan-zong-jiao\">猪, 四战, 宗教</h1>\n<p>2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨</p>\n<p>你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等可爱小猪的尸体而痛哭流涕<br>\n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索</p>\n<p>一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道<br>\n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:<br>\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播</p>\n<p>为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻<br>\n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉<br>\n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 “大变革降临的标志”</p>\n<p>你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实<br>\n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响</p>\n<p>世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发<br>\n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾<br>\n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背</p>\n<p>“那群疯子”, 你喃喃自语道, 一个伟大的计划在你心中形成</p>\n<p>. . . . . . . .<br>\n. . . . . . . .<br>\n. . . . . . . .</p>\n<p>五十年后<br>\n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教<br>\n“拒绝猪肉” 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!</p>\n<p>你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音<br>\n你用尽全力挣扎地想要阻止渐渐消散的意识<br>\n你感受到那些正簇拥在你身边痛哭着的教徒<br>\n你看到死亡在俯瞰自己暴露在躯壳外的灵魂</p>\n<p>这是你回忆起你的一生时, 脑海中最后的念头:</p>\n<p>“我终于改变了这个猪肉至上, 扭曲且肮脏的世界了…”<br>\n“我做到了…我终于…做到了…”</p>\n<p>世界因为你而流动, 第四次世界大战得以避免, 人类甚至因共同的信仰, 而达到了空前的团结与统一<br>\n世界亦在你逝去后, 举世默哀, 全人类的时间仿佛随着你的逝去, 而永远地停在了那一天</p>\n","site":{"data":{}},"length":1331,"excerpt":"","more":"<h1 id=\"ceng-jing-de-mou-xian-zhe\">曾经的冒险者</h1>\n<p>曾经…<br>\n我和你一样, 也是个冒险者…<br>\n直到我的膝盖中了一剑</p>\n<hr>\n<h1 id=\"wei-da-no-zuo-te\">伟大の左特</h1>\n<p>听好了, 愚蠢</span>的虫子们! 我是:<br>\n<span style=\"font-size: 130%; line-height: 0.1em\">无敌的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">勇猛的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">性感的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">神秘的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">迷人的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">神气的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">勤勉的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">强势的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">华丽的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">激情的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">可怕的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">漂亮的!</span><br>\n<span style=\"font-size: 130%; line-height: 0.1em\">强大的!</span><br>\n<span style=\"font-size: 220%;\">灰色王子</span>, 左特!</p>\n<hr>\n<h1 id=\"gua-zhi-de-ri-ji\">适之的日记</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2022.7.6<br>\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业, 然后是预习高二的新课, 争做21世纪三好青年<br>\n计划一个月内背完一本英语词典, 刷完三本教辅, 在 B 站上看一数, 一化, 一英, 黄夫人的课进行复习预习<br>\n明天开始奋斗!!!</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.7<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.8<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.9<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.10<br>\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗? 子曰: “吾日三省吾身”, 你不能再这样下去了! 吃得苦中苦, 方为人上人!</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.11<br>\n看番</p>\n</li>\n<li class=\"lvl-2\">\n<p>2022.7.12<br>\n看番</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"zhu-si-zhan-zong-jiao\">猪, 四战, 宗教</h1>\n<p>2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨</p>\n<p>你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等可爱小猪的尸体而痛哭流涕<br>\n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索</p>\n<p>一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道<br>\n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:<br>\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播</p>\n<p>为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻<br>\n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉<br>\n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 “大变革降临的标志”</p>\n<p>你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实<br>\n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响</p>\n<p>世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发<br>\n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾<br>\n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背</p>\n<p>“那群疯子”, 你喃喃自语道, 一个伟大的计划在你心中形成</p>\n<p>. . . . . . . .<br>\n. . . . . . . .<br>\n. . . . . . . .</p>\n<p>五十年后<br>\n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教<br>\n“拒绝猪肉” 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!</p>\n<p>你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音<br>\n你用尽全力挣扎地想要阻止渐渐消散的意识<br>\n你感受到那些正簇拥在你身边痛哭着的教徒<br>\n你看到死亡在俯瞰自己暴露在躯壳外的灵魂</p>\n<p>这是你回忆起你的一生时, 脑海中最后的念头:</p>\n<p>“我终于改变了这个猪肉至上, 扭曲且肮脏的世界了…”<br>\n“我做到了…我终于…做到了…”</p>\n<p>世界因为你而流动, 第四次世界大战得以避免, 人类甚至因共同的信仰, 而达到了空前的团结与统一<br>\n世界亦在你逝去后, 举世默哀, 全人类的时间仿佛随着你的逝去, 而永远地停在了那一天</p>\n"},{"title":"分类","abbrlink":"categories","hidden":true,"date":"2021-09-12T06:59:09.000Z","quicklink":true,"_content":"这个博客的更新十分缓慢... 因为我很懒, 也很忙, 由于各种事情, 比如学业  \n到底有多慢? 举个例子, Rust的声明宏系列, B站老早录完了, 但博客的文章却一直没写完...  \n\n虽然很慢, 但我会尽量保持更新的, 只要有空 ~~(应该吧)~~ :)  \n请根据需要进行选择, 善用目录功能  \n\n同时, 还有一些比如 haskell/scala3 的文章, 难度过大, 资料太少, 鉴于个人能力正在慢慢学习  \n在此贴出来, 相当于给自己定个小目标, 提醒自己不要忘记, 要坚持学习  \n\n- - -\n# Novel\n二作同人文, 会在文章名前标出原创作品  \n[x]  [明日方舟/浪潮涌没的终焉与永恒之爱](/posts/novel/浪潮涌没的终焉与永恒之爱)\n[ ]  [东方Project/墨染樱下幽魂](/posts/novel/墨染樱下幽魂)\n\n- - -\n\n# Rust\nRust, 是一门高性能, 工具链友善, 类型严格显式的编程语言\n[ ]  [Rust中那些常见的错误](/posts/rust-common-errors)\n[ ]  [声明宏](/categories/rust-decl-macro)\n[ ]  [异步](/categories/rust-async)\n[ ]  [音视频处理 (gstreamer)](/categories/rust-gstreamer)\n[x]  [命令行 (clap-rs)](/posts/rust-clap/intro)\n[ ]  [GUI (gtk4/iced/relm4)](/categories/rust-gui)\n[ ]  [TUI (ratatui-rs)](/categories/rust-tui)\n[ ]  [并发中的原子与锁](/categories/rust-atomics-and-locks)\n\n- - -\n\n# 光栅化\n[ ]  [光栅化中的dda与bresenham两种算法](/posts/other/rasterization-dda-bresenham)\n\n- - -\n\n# 桌面美化\n关于桌面美化的一些文章, 大家可以参考一下  \n[目录~~>](/categories/desktop-beautify)\n\n[x]  [GNOME 入坑指南](/posts/desktop-beautify/gnome)\n[ ]  [Hyprland 入坑指南](/posts/desktop-beautify/hyprland)\n\n- - -\n\n# Scala3\nscala, 是一本结合了面向对象与函数式风格, 优雅高效, 类库丰富, 运行在 jvm 上的编程语言\n[ ]  [基础](/categories/scala3-basic)\n\n- - -\n\n# 高中信息技术\n目前高中信息技术的课程, 欢迎感兴趣的同学们观看  \n[目录~~>](/categories/high-school-it)\n\n- - -\n\n# Haskell\nHaskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言\n[ ]  [基础](/categories/haskell-basic)\n\n- - -\n\n","source":"categories/index.md","raw":"---\ntitle: 分类\nabbrlink: categories\nhidden: true\ndate: 2021-09-12 14:59:09\nquicklink: true\n---\n这个博客的更新十分缓慢... 因为我很懒, 也很忙, 由于各种事情, 比如学业  \n到底有多慢? 举个例子, Rust的声明宏系列, B站老早录完了, 但博客的文章却一直没写完...  \n\n虽然很慢, 但我会尽量保持更新的, 只要有空 ~~(应该吧)~~ :)  \n请根据需要进行选择, 善用目录功能  \n\n同时, 还有一些比如 haskell/scala3 的文章, 难度过大, 资料太少, 鉴于个人能力正在慢慢学习  \n在此贴出来, 相当于给自己定个小目标, 提醒自己不要忘记, 要坚持学习  \n\n- - -\n# Novel\n二作同人文, 会在文章名前标出原创作品  \n[x]  [明日方舟/浪潮涌没的终焉与永恒之爱](/posts/novel/浪潮涌没的终焉与永恒之爱)\n[ ]  [东方Project/墨染樱下幽魂](/posts/novel/墨染樱下幽魂)\n\n- - -\n\n# Rust\nRust, 是一门高性能, 工具链友善, 类型严格显式的编程语言\n[ ]  [Rust中那些常见的错误](/posts/rust-common-errors)\n[ ]  [声明宏](/categories/rust-decl-macro)\n[ ]  [异步](/categories/rust-async)\n[ ]  [音视频处理 (gstreamer)](/categories/rust-gstreamer)\n[x]  [命令行 (clap-rs)](/posts/rust-clap/intro)\n[ ]  [GUI (gtk4/iced/relm4)](/categories/rust-gui)\n[ ]  [TUI (ratatui-rs)](/categories/rust-tui)\n[ ]  [并发中的原子与锁](/categories/rust-atomics-and-locks)\n\n- - -\n\n# 光栅化\n[ ]  [光栅化中的dda与bresenham两种算法](/posts/other/rasterization-dda-bresenham)\n\n- - -\n\n# 桌面美化\n关于桌面美化的一些文章, 大家可以参考一下  \n[目录~~>](/categories/desktop-beautify)\n\n[x]  [GNOME 入坑指南](/posts/desktop-beautify/gnome)\n[ ]  [Hyprland 入坑指南](/posts/desktop-beautify/hyprland)\n\n- - -\n\n# Scala3\nscala, 是一本结合了面向对象与函数式风格, 优雅高效, 类库丰富, 运行在 jvm 上的编程语言\n[ ]  [基础](/categories/scala3-basic)\n\n- - -\n\n# 高中信息技术\n目前高中信息技术的课程, 欢迎感兴趣的同学们观看  \n[目录~~>](/categories/high-school-it)\n\n- - -\n\n# Haskell\nHaskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言\n[ ]  [基础](/categories/haskell-basic)\n\n- - -\n\n","updated":"2021-09-12T06:59:09.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cljoa8ofy0002j1s6c1kt8j5s","content":"<p>这个博客的更新十分缓慢… 因为我很懒, 也很忙, 由于各种事情, 比如学业<br>\n到底有多慢? 举个例子, Rust的声明宏系列, B站老早录完了, 但博客的文章却一直没写完…</p>\n<p>虽然很慢, 但我会尽量保持更新的, 只要有空 <s>(应该吧)</s> 😃<br>\n请根据需要进行选择, 善用目录功能</p>\n<p>同时, 还有一些比如 haskell/scala3 的文章, 难度过大, 资料太少, 鉴于个人能力正在慢慢学习<br>\n在此贴出来, 相当于给自己定个小目标, 提醒自己不要忘记, 要坚持学习</p>\n<hr>\n<h1 id=\"novel\">Novel</h1>\n<p>二作同人文, 会在文章名前标出原创作品<br>\n<input type=\"checkbox\" id=\"checkbox50\" checked=\"true\"><label for=\"checkbox50\"> </label><a href=\"/posts/novel/%E6%B5%AA%E6%BD%AE%E6%B6%8C%E6%B2%A1%E7%9A%84%E7%BB%88%E7%84%89%E4%B8%8E%E6%B0%B8%E6%81%92%E4%B9%8B%E7%88%B1\">明日方舟/浪潮涌没的终焉与永恒之爱</a><br>\n<input type=\"checkbox\" id=\"checkbox49\"><label for=\"checkbox49\"> </label><a href=\"/posts/novel/%E5%A2%A8%E6%9F%93%E6%A8%B1%E4%B8%8B%E5%B9%BD%E9%AD%82\">东方Project/墨染樱下幽魂</a></p>\n<hr>\n<h1 id=\"rust\">Rust</h1>\n<p>Rust, 是一门高性能, 工具链友善, 类型严格显式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox58\"><label for=\"checkbox58\"> </label><a href=\"/posts/rust-common-errors\">Rust中那些常见的错误</a><br>\n<input type=\"checkbox\" id=\"checkbox57\"><label for=\"checkbox57\"> </label><a href=\"/categories/rust-decl-macro\">声明宏</a><br>\n<input type=\"checkbox\" id=\"checkbox56\"><label for=\"checkbox56\"> </label><a href=\"/categories/rust-async\">异步</a><br>\n<input type=\"checkbox\" id=\"checkbox55\"><label for=\"checkbox55\"> </label><a href=\"/categories/rust-gstreamer\">音视频处理 (gstreamer)</a><br>\n<input type=\"checkbox\" id=\"checkbox54\" checked=\"true\"><label for=\"checkbox54\"> </label><a href=\"/posts/rust-clap/intro\">命令行 (clap-rs)</a><br>\n<input type=\"checkbox\" id=\"checkbox53\"><label for=\"checkbox53\"> </label><a href=\"/categories/rust-gui\">GUI (gtk4/iced/relm4)</a><br>\n<input type=\"checkbox\" id=\"checkbox52\"><label for=\"checkbox52\"> </label><a href=\"/categories/rust-tui\">TUI (ratatui-rs)</a><br>\n<input type=\"checkbox\" id=\"checkbox51\"><label for=\"checkbox51\"> </label><a href=\"/categories/rust-atomics-and-locks\">并发中的原子与锁</a></p>\n<hr>\n<h1 id=\"guang-zha-hua\">光栅化</h1>\n<p><input type=\"checkbox\" id=\"checkbox59\"><label for=\"checkbox59\"> </label><a href=\"/posts/other/rasterization-dda-bresenham\">光栅化中的dda与bresenham两种算法</a></p>\n<hr>\n<h1 id=\"zhuo-mian-mei-hua\">桌面美化</h1>\n<p>关于桌面美化的一些文章, 大家可以参考一下<br>\n<a href=\"/categories/desktop-beautify\">目录~~&gt;</a></p>\n<p><input type=\"checkbox\" id=\"checkbox61\" checked=\"true\"><label for=\"checkbox61\"> </label><a href=\"/posts/desktop-beautify/gnome\">GNOME 入坑指南</a><br>\n<input type=\"checkbox\" id=\"checkbox60\"><label for=\"checkbox60\"> </label><a href=\"/posts/desktop-beautify/hyprland\">Hyprland 入坑指南</a></p>\n<hr>\n<h1 id=\"scala-3\">Scala3</h1>\n<p>scala, 是一本结合了面向对象与函数式风格, 优雅高效, 类库丰富, 运行在 jvm 上的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox62\"><label for=\"checkbox62\"> </label><a href=\"/categories/scala3-basic\">基础</a></p>\n<hr>\n<h1 id=\"gao-zhong-xin-xi-ji-zhu\">高中信息技术</h1>\n<p>目前高中信息技术的课程, 欢迎感兴趣的同学们观看<br>\n<a href=\"/categories/high-school-it\">目录~~&gt;</a></p>\n<hr>\n<h1 id=\"haskell\">Haskell</h1>\n<p>Haskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox63\"><label for=\"checkbox63\"> </label><a href=\"/categories/haskell-basic\">基础</a></p>\n<hr>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":590,"excerpt":"","more":"<p>这个博客的更新十分缓慢… 因为我很懒, 也很忙, 由于各种事情, 比如学业<br>\n到底有多慢? 举个例子, Rust的声明宏系列, B站老早录完了, 但博客的文章却一直没写完…</p>\n<p>虽然很慢, 但我会尽量保持更新的, 只要有空 <s>(应该吧)</s> 😃<br>\n请根据需要进行选择, 善用目录功能</p>\n<p>同时, 还有一些比如 haskell/scala3 的文章, 难度过大, 资料太少, 鉴于个人能力正在慢慢学习<br>\n在此贴出来, 相当于给自己定个小目标, 提醒自己不要忘记, 要坚持学习</p>\n<hr>\n<h1 id=\"novel\">Novel</h1>\n<p>二作同人文, 会在文章名前标出原创作品<br>\n<input type=\"checkbox\" id=\"checkbox50\" checked=\"true\"><label for=\"checkbox50\"> </label><a href=\"/posts/novel/%E6%B5%AA%E6%BD%AE%E6%B6%8C%E6%B2%A1%E7%9A%84%E7%BB%88%E7%84%89%E4%B8%8E%E6%B0%B8%E6%81%92%E4%B9%8B%E7%88%B1\">明日方舟/浪潮涌没的终焉与永恒之爱</a><br>\n<input type=\"checkbox\" id=\"checkbox49\"><label for=\"checkbox49\"> </label><a href=\"/posts/novel/%E5%A2%A8%E6%9F%93%E6%A8%B1%E4%B8%8B%E5%B9%BD%E9%AD%82\">东方Project/墨染樱下幽魂</a></p>\n<hr>\n<h1 id=\"rust\">Rust</h1>\n<p>Rust, 是一门高性能, 工具链友善, 类型严格显式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox58\"><label for=\"checkbox58\"> </label><a href=\"/posts/rust-common-errors\">Rust中那些常见的错误</a><br>\n<input type=\"checkbox\" id=\"checkbox57\"><label for=\"checkbox57\"> </label><a href=\"/categories/rust-decl-macro\">声明宏</a><br>\n<input type=\"checkbox\" id=\"checkbox56\"><label for=\"checkbox56\"> </label><a href=\"/categories/rust-async\">异步</a><br>\n<input type=\"checkbox\" id=\"checkbox55\"><label for=\"checkbox55\"> </label><a href=\"/categories/rust-gstreamer\">音视频处理 (gstreamer)</a><br>\n<input type=\"checkbox\" id=\"checkbox54\" checked=\"true\"><label for=\"checkbox54\"> </label><a href=\"/posts/rust-clap/intro\">命令行 (clap-rs)</a><br>\n<input type=\"checkbox\" id=\"checkbox53\"><label for=\"checkbox53\"> </label><a href=\"/categories/rust-gui\">GUI (gtk4/iced/relm4)</a><br>\n<input type=\"checkbox\" id=\"checkbox52\"><label for=\"checkbox52\"> </label><a href=\"/categories/rust-tui\">TUI (ratatui-rs)</a><br>\n<input type=\"checkbox\" id=\"checkbox51\"><label for=\"checkbox51\"> </label><a href=\"/categories/rust-atomics-and-locks\">并发中的原子与锁</a></p>\n<hr>\n<h1 id=\"guang-zha-hua\">光栅化</h1>\n<p><input type=\"checkbox\" id=\"checkbox59\"><label for=\"checkbox59\"> </label><a href=\"/posts/other/rasterization-dda-bresenham\">光栅化中的dda与bresenham两种算法</a></p>\n<hr>\n<h1 id=\"zhuo-mian-mei-hua\">桌面美化</h1>\n<p>关于桌面美化的一些文章, 大家可以参考一下<br>\n<a href=\"/categories/desktop-beautify\">目录~~&gt;</a></p>\n<p><input type=\"checkbox\" id=\"checkbox61\" checked=\"true\"><label for=\"checkbox61\"> </label><a href=\"/posts/desktop-beautify/gnome\">GNOME 入坑指南</a><br>\n<input type=\"checkbox\" id=\"checkbox60\"><label for=\"checkbox60\"> </label><a href=\"/posts/desktop-beautify/hyprland\">Hyprland 入坑指南</a></p>\n<hr>\n<h1 id=\"scala-3\">Scala3</h1>\n<p>scala, 是一本结合了面向对象与函数式风格, 优雅高效, 类库丰富, 运行在 jvm 上的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox62\"><label for=\"checkbox62\"> </label><a href=\"/categories/scala3-basic\">基础</a></p>\n<hr>\n<h1 id=\"gao-zhong-xin-xi-ji-zhu\">高中信息技术</h1>\n<p>目前高中信息技术的课程, 欢迎感兴趣的同学们观看<br>\n<a href=\"/categories/high-school-it\">目录~~&gt;</a></p>\n<hr>\n<h1 id=\"haskell\">Haskell</h1>\n<p>Haskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox63\"><label for=\"checkbox63\"> </label><a href=\"/categories/haskell-basic\">基础</a></p>\n<hr>\n","sitemap":false}],"Post":[{"title":"GNOME 入坑指南","abbrlink":"posts/desktop-beautify/gnome","hidden":false,"date":"2022-07-20T03:22:42.000Z","top":99999,"keywords":["GNOME","桌面环境","DE","Linux","Wayland","Desktop"],"is_series":true,"next_post":["posts/desktop-beautify/hyprland","Hyprland 平铺式"],"_content":"> 关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境\n<!-- more -->\n\n# 开篇说明\n\n**注意:**  \n本篇文章的配置皆在注重 **简洁**, **美观**, **高效**  \n想要平铺式, 炫酷效果, 更多功能的, 请自行配置, 或查看我的另外一篇博客: [Hyprland 平铺式](/posts/desktop-beautify/hyprland)  \n请注意 GNOME 版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新  \n目前, 该篇文章的适用 GNOME 版本为: **44**  (**于2023年5月21更新本文**)\n\n**注意:**  \n如果你是在我的博客上阅读本文, 请善用右侧目录功能  \n\n- - -\n\n# 更新说明\n\n**每次更新本文时, 一切更改记录都会放在这里, 方便读者进行版本迁移 (比如从 43 -> 44), 或者发现新的有用的插件**\n**版本的不同, 在除了插件方面会有所差异, 其他地方是几乎一样的, 就算真有不一样的地方我也会标注的, 请放心**  \n**一般来说, 每次更新本文时, 主要更新的是 [推荐插件列表](#tui-jian-cha-jian-lie-biao) 这部分, 如果你已经看过本文了, 一般只需要跳转至那一部分即可**\n\n- 2023.5.21  \n更新了本文版本以适配 GNOME-44  \n更新了推荐插件列表及相应配图  \n添加了 \"gdm下部分设置无法生效\" 的解决方法  \n\n\n\n- - -\n\n# 成品展示\n2023年了, GNOME 又靠谱又好用, 但有些人的界面仍处于是十年前的样子...  \n我个人认为 **简洁** + **大气** + **美观** 比较重要, 当然你也可以自行修改进行DIY  \n如果真的有需求, 请自己动手, 丰衣足食吧! ~~(虽然我认为本文已经详细地不能再详细了)~~ \n\n![44(当前版本的图片)](/images/gnome/overview_44.png)\n![42(旧版本的保留图片)](/images/gnome/overview_42.png)  \n\n- - -\n\n# 使用工具说明\n\n- `dconf`:\n是一套基于键的配置系统, 十分高效, 你可以将其视作 Windows 下的注册表, 但修改起来非常简单  \n\n- `gsettings`:\n是 GNOME 下的高级API, 是一个命令行工具, 用来简化对 dconf 的操作  \n \n\n你可能在年份久远的文章中听说过 `gconf`, 这是什么? 与 `dconf` 有啥区别?  \n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 `dconf` 所取代  \n\n接下来的大部分配置, 都会使用 `gsettings` 在命令行中进行操作\n\n当然, 你也可以通过图形化界面, 比如 `gnome-control-center` 进行设置, 但有一些东西是界面里不存在/无法调整的  \n同时, 为了方便读者进行复制粘贴, 特此写成命令形式 ~~(快说蟹蟹!!)~~  \n\n- - - \n\n# 常用设置\n以下是各种方面的设置, 直接复制粘贴, 有些地方进行下修改, 适配自己情况即可  \n\n## 触摸板\n触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO ~~(但CS我也能用触摸板玩)~~\n\n有一些 Linux 发行版的 GNOME比较贴近上游, `轻击模拟鼠标点击` 默认未开启  \n这导致触摸板很难用, 得按下去才能模拟鼠标的点击  \n\n你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指...  \n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改...  \n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒...  \n\n你可以在终端输入如下命令进行调整:  \n\n```bash\ngsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true\ngsettings set org.gnome.desktop.peripherals.touchpad speed 0.57\ngsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing false\n```\n\n分别对应:  \n- 轻击模拟鼠标点击, 默认为false\n- 调整触摸板速度, 默认为0\n- 打字时禁用触摸板, 默认为true\n\n常用手势:  \n- 单指: 移动鼠标\n- 双指上下: 翻页\n- 三指左右: 切换Workspace\n- 三指上: 打开Overview (不常用, 按Super更快)\n- 三指下: 显示任务栏 (当你隐藏任务栏时)\n\n(安装一些插件后, 相关快捷键可能会发生改变)\n\n## 窗口与工作区\n我个人喜欢将工作区设置为静态, 也就是禁止动态工作区, 防止窗口自由移动, 同时将工作区设置为10个:  \n\n```bash\ngsettings set org.gnome.mutter dynamic-workspaces false\ngsettings set org.gnome.desktop.wm.preferences num-workspaces 10\n```\n\n(Mutter 是 GNOME 自己的窗口管理器)  \n \n\n对于快捷键, 你可以自定义窗口的最大化/最小化/全屏/隐藏/更改大小/移动, 与有关工作区的部分  \n鉴于这一部分属于设置快捷键系列, 请您移动至本文后面的 **[修改快捷键](#xiu-gai-kuai-jie-jian)** 目录  \n\n举个例子:  \n比如 \"move window\", 普通来讲你可能会双击窗口的标题栏, 然后拖动窗口进行移动, 但你完全可以将这个操作绑定在快捷键 \"Super+x\" 上  \n然后按一次该快捷键, 进入 \"move mode\", 移动完毕之后再按一次(或者点击一下), 就可以确定窗口位置  \n如果你不满意, 可以按一下 `Esc`, 恢复到初始位置  \n\n还有很多操作, 比如移动某个窗口至指定工作区, 或者切换至某个工作区, 就像是使用着类似 \"i3/sway/hyprland\" 等 \"window manager\" 一样的体验  \n\n- - -\n\n# GDM\n稍微说明下, 如果你在登陆之后使用 gsettings 进行的设置, 无法在 GDM 中生效时, 极大概率是用户与权限问题  \n\n比如, 你发现触摸板明明已经设置了轻触模拟点击, 但在 GDM 中无效, 那就指定 `gdm` 用户, 再设置一遍即可:  \n\n```bash\nxhost +SI:localuser:gdm\nsudo -u gdm gsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true\nsudo -u gdm gsettings set org.gnome.desktop.peripherals.touchpad speed 0.57\nsudo -u gdm gsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing false\n```\n\n- - -\n\n# 插件\n## 安装插件\nGNOME 的插件(Extensions)是其重要的组成, 赋予了随意组合的 **自由** 与 **强大**, 说是 GNOME 一半的 **灵魂** 所在, 也不为过之  \n我将先介绍如何安装/使用它们, 因为后面需要用到插件  \n\n有两种安装方法, 一种从命令行安装, 一种从浏览器安装  \n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍  \n\n### 从命令行\n**提示**  \n请确保拥有以下命令: `unzip`, `jq`, 有些发行版默认连 `unzip` 都没有...  \n下载成功后, 切记要 logout, 然后再登进来, 运行 `gnome-session-quit` 即可  \n\n每个GNOME插件都拥有独一无二的, 名为 `uuid` 的标识符, 我们可以通过 `uuid`, 下载插件  \n\n你可以在 [Extensions-GNOME](https://extensions.gnome.org/) 这个网站上, 浏览并下载插件  \n请将以 .zip 结尾的插件放在同一目录下, 假设该目录叫 `exts_list`  \n\n下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:  \n\n{% tabs install-extensions%}\n<!-- tab Bash-->\n\n```bash install-extensions.sh\n#!/usr/bin/env bash\ndeclare -a UUID_LIST\nEXTS_DIR=$HOME/.local/share/gnome-shell/extensions\nEXTS_LIST=${1}\nstr_join() {\n  echo \"$*\" | sed 's/\"\"/\",\"/g'\n}\nmkdir -p $EXTS_DIR\nchmod -R 755 $HOME/.local/\nfor EXT in $EXTS_LIST/*.zip\ndo\n  UUID=$(unzip -p $EXT metadata.json | jq -r \".uuid\")\n  mkdir -p $EXTS_DIR/$UUID\n  unzip -q -o $EXT -d $EXTS_DIR/$UUID\n  UUID_LIST+=\"\\\"$UUID\\\"\"\ndone\nUUID_LIST=[$(str_join ${UUID_LIST[@]})]\ngsettings set org.gnome.shell enabled-extensions ${UUID_LIST[@]}\n```\n\n<!-- endtab -->\n\n<!-- tab Fish -->\n\n```bash install-extensions.fish\nset exts_list $argv[1]\nset exts_dir $HOME/.local/share/gnome-shell/extensions/\nset uuid_list\nmkdir -p $exts_dir\nfor ext in exts_list/*.zip\n  set uuid ( unzip -p $ext metadata.json | jq -r \".uuid\" )\n  mkdir -p $ext_dir/$uuid\n  unzip -q -o $ext -d $ext_dir/$uuid\n  set -a uuid_list \\'$uuid\\'\nend\nset uuid_list [( string join \",\" $uuid_list )]\ngsettings set org.gnome.shell enabled-extensions $uuid_list\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n假设使用Bash: 执行 `sh install-extensions.sh exts_list` 下载该目录下的所有插件  \n\n**注意: 先logout, 再登进来**  \n\n也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:  \n\n```bash\nsudo dbus-send --type=method_call --dest=org.gnome.Shell /org/gnome/Shell \\\n  org.gnome.Shell.Extensions.InstallRemoteExtension string:'xxxxx_uuid'\n```\n\n### 从浏览器\n该方法其实也蛮方便的, 但不适合快速部署  \n你需要安装两个玩意, 才能直接从 [Extension-GNOME](https://extensions.gnome.org/) 上直接下载  \n\n- `chrome-gnome-shell`:  \n本地软件, 你可以通过包管理器, 直接搜这个名字  \n\n- `GNOME Shell integration`:  \n浏览器插件, Chrome/Firefox 的浏览器商店都有它  \nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件  \n\n一个在本地, 一个在浏览器,  因此可以支持你从 [网站](https://extensions.gnome.org/) 上 直接安装到本地  \n\n- - -\n\n## 查看与配置插件\n此处推荐使用浏览器来设置插件, 在 [https://extensions.gnome.org/local/](https://extensions.gnome.org/local/) 页面管理与配置插件  \n\n如果你想通过命令行, 则可以使用 `gnome-extensions` 这个命令, 来查看并配置插件:  \n\n```bash\n# 获取帮助, `Command` 为可选项\ngnome-extensions help [Command]\n\n# 查看插件列表\ngnome-extensions list --user    # 查看用户级插件\ngnome-extensions list --system  # 查看系统级插件\n\n# 查看插件的信息\ngnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com\n\n# 启用/禁用某个插件\ngnome-extensions enable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\ngnome-extensions disable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n\n# 配置某个插件 (打开 GUI 界面)\ngnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n```\n\n或者通过 `gsettings` 来配置某个插件, 但不推荐, 因为麻烦:  \n\n```bash\n# 查看某个插件的所有选项\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  list-recursively org.gnome.shell.extensions.nothing-to-say\n  \n# 得到/重置/设置 某个插件的某选项当前的值 (根据上面这条命令查看所有选项)\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  get    org.gnome.shell.extensions.nothing-to-say show-osd\n# reset  org.gnome.shell.extensions.nothing-to-say show-osd\n# set    org.gnome.shell.extensions.nothing-to-say show-osd\n```\n\n你可以在已经配置好插件的机器上, 导出 `dconf.settings` 文件, 并在新机器上加载它, 避免更换机器/重装系统之后再次设置插件  \n详情请见 [**加载配置**](#jia-zai-pei-zhi)  \n\n- - -\n\n# 推荐插件列表\n以下是我目前正在使用且推荐的插件, 适用版本为 **44**  \n\n**注意:**\n<!-- 如果你是通过我的博客 [jedsek.xyz](https://jedsek.xyz) 观看的话, 我默认隐藏了这些图片  -->\n<!-- 你可以展开任意一张图片后, 点击图片, 然后可以通过方向键切换图片 :)  -->\n\n- [transparent-top-bar(adjustable-transparency)](https://extensions.gnome.org/extension/3960/transparent-top-bar-adjustable-transparency/)\n让顶栏变透明的插件, 当窗口最大化或者与顶栏重叠时, 为了显示清晰会自动重新变回不透明  \n\n- [auto-move-windows](https://extensions.gnome.org/extension/16/auto-move-windows/)  \n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)  \n\n- [color-app-menu-icon](https://extensions.gnome.org/extension/5473/color-app-menu-icon-for-gnome-40/)\n顶栏左上角会显示你当前所在应用的图标与名称  \n\n- [draw-on-your-screen-2](https://extensions.gnome.org/extension/4937/draw-on-you-screen-2/)\n通过设置的快捷键, 让你可以在屏幕上用画笔画画, 在录制视频, 向他人演示, 标记重点的时候非常有用  \n\n- [removable-drive-menu](https://extensions.gnome.org/extension/7/removable-drive-menu/)\n当你插入u盘之后, 顶栏会出现显示图标, 让你快速访问文件, u盘拔出之后图标自动消失  \n\n- [run-cat](https://extensions.gnome.org/extension/2986/runcat/)\n在顶栏出现一只奔跑的小猫与 cpu 的利用率, cpu 利用率越高, 小猫跑得越快  \n\n- [quick-touchpad-toggle](https://extensions.gnome.org/extension/5292/quick-touchpad-toggle/)\n在 quick-settings 中增加一个选项, 让你快速启用/禁用触摸板  \n\n- [quick-close-in-overview](https://extensions.gnome.org/extension/352/middle-click-to-close-in-overview/)\n在 overview 中, 当你的鼠标移动到对应窗口时, 右上角增加一个叉叉, 让你快速关闭窗口  \n\n- [just-another-search-bar](https://extensions.gnome.org/extension/5522/just-another-search-bar/)\n让你自己设置一个快捷键, 按下之后打开一个搜索框, 然后用你的默认浏览器搜索输入内容, 你可以设置搜索引擎(google/bing)  \n这个操作在 overview 中也可以做到, 名字都说了是 just-another, 是为了更美观  \n\n- [coverflow-alt-tab](https://extensions.gnome.org/extension/97/coverflow-alt-tab/)\n让你在使用 `super+tab`/`alt+tab` 切换窗口时, 获得好看美观的特效  \n\n- [customize-iBus](https://extensions.gnome.org/extension/4112/customize-ibus/)\nibus 是 gnome 内置的一个输入法, 已经和 fcitx5 差不多了, 默认情况下就已经非常好看了  \n你可以使用这个插件, 深度自定义 ibus 的行为, 比如我现在, 打字时就能够让候选框随着我打字的节奏而抖动, 非常爽  \n再比如设置中英文切换时, 指示器的显示时间, 抖动效果, 闪烁特效等  \n>>> **点击展开/隐藏图片**\n![ibus默认情况下的外表/系统暗色主题](/images/gnome/ibus.png)\n>>>\n\n- [quake-mode](https://extensions.gnome.org/extension/1411/quake-mode/)  \n雷神模式!! 该插件可以让你以雷神模式打开一些与快捷键绑定的应用, 即以下拉式打开任意一个app, 全部工作区共享一个app  \nquake-mode 配上你喜欢的任意一个终端, 都会产生非常棒的奇效, 具体效果可以点击链接看动图演示即可    \n\n- [color-pciker](https://extensions.gnome.org/extension/3396/color-picker/)\n采色笔, 用来采集颜色, 有相关需求的话非常有用, 没什么好说的  \n\n- [battery-time](https://extensions.gnome.org/extension/5425/battery-time/)\n在 quick-setting 中显示你的电量还可以撑多久  \n\n- [bluetooth-battery-indicator](https://extensions.gnome.org/extension/3991/bluetooth-battery/)\n当你连接蓝牙设备之后, 会在顶栏显示电量  \n\n- [bluetooth-quick-connect](https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/)\n在 quick-setting 中, 让你快速连接/断开已经配对过的蓝牙设备, 非常有用  \n\n- [control-blur-effect-on-lock-screen](https://extensions.gnome.org/extension/2935/control-blur-effect-on-lock-screen/)\n锁屏之后, 背景图片会变得模糊(blur), 这个插件可以修改模糊度, 我个人喜欢背景完全不模糊  \n\n<!-- Deprecated -->\n<!-- - [refresh-wifi-connections](https://extensions.gnome.org/extension/905/refresh-wifi-connections/) -->\n<!-- 当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键   -->\n<!--  -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![refresh-wifi-connections](/images/gnome/refresh-wifi-connections.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [transparent-window-moving](https://extensions.gnome.org/extension/1446/transparent-window-moving/)\n在对窗口进行移动/调整大小时, 使窗口变得透明  \n\n- [just-perfection](https://extensions.gnome.org/extension/3843/just-perfection/)\n我最喜欢的一个插件, 用于对界面进行大量自定义与精简  \n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等  \n>>> **点击展开/隐藏图片**\n![just-perfection](/images/gnome/overview_44.png)\n>>>\n\n<br>\n\n\n- [nothing-to-say](https://extensions.gnome.org/extension/1113/nothing-to-say/)\n用于切断/恢复声音的输入, 对我来说蛮有用的:  \n当与同学打游戏, 撞上爸妈查房, 立刻按下 `Super+\\`, 防止爸妈训我的声音流入同学耳中, 维护尊严 :)  \n\n- [space-bar](https://extensions.gnome.org/extension/5090/space-bar/)\n模仿 I3/Sway/Bspwm 等窗口管理器, 在左上角显示工作区, 有些类似的插件, 但个人认为, 这个插件最好  \n>>> **点击展开/隐藏图片**\n![space-bar/名称](/images/gnome/space-bar_name.png)\n![space-bar/数字](/images/gnome/space-bar_number.png)\n>>>\n\n<br>\n\n<!-- Deprecated -->\n<!-- - [workspace-switcher-manager](https://extensions.gnome.org/extension/4788/workspace-switcher-manager/) -->\n<!-- 美化通过键盘(我配成了 `Super + 1..9`), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![workspace-switcher-manager](/images/gnome/workspace-switcher-manager.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [disable-workspace-switch-animation-for-GNOME40+](https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/)\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感  \n\n- [gsconnect](https://extensions.gnome.org/extension/1319/gsconnect/)\nGNOME版的 `kdeconnect`, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开  \n手机需安装 `kdeconnect`, 你可以从本博客下载 apk 进行安装: [kdeconnect](/downloads/gnome/kdeconnect.apk)  \n>>> **点击展开/隐藏图片**\n![gsconnect](/images/gnome/gsconnect.png)\n>>>\n\n<br>\n\n<!-- Deprecated -->\n<!-- - [blur-my-shell](https://extensions.gnome.org/extension/3193/blur-my-shell/) -->\n<!-- 用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的插件   -->\n<!-- 但我并不推荐这个插件, 因为修改的东西太多, 和其他插件一起的话, 有概率发生死机等问题   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![blur-my-shell](/images/gnome/overview.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [user-avatar-in-quick-settings](https://extensions.gnome.org/extension/5506/user-avatar-in-quick-settings/)\n让右上角菜单出现你的头像, 提升美观而已  \n\n- [gnome40-ui-improvements](https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/)\n按下 `Super`, 进入 `Overview` 后, 在中上方显示工作区, 与下面的插件 `v-shell`  不兼容, 二选一, 我推荐下面的 `v-shell`  \n>>> **点击展开/隐藏图片**\n![gnome40-ui-improvements](/images/gnome/gnome40-ui-improvements.png)\n>>>\n\n<br>\n\n- [v-shell](https://extensions.gnome.org/extension/5177/vertical-workspaces/)\n按下 `Super`, 进入 `Overview` 后, 在左边显示工作区, 同时附赠了各种非常好用的操作, 与上面的 `gnome40-ui-improvements` 二选一    \n当你进入 `Overview` 后, 按下 `space` 后可以查询打开的窗口, `alt+space` 查询最近修改的文件  \n>>> **点击展开/隐藏图片**\n![v-shell](/images/gnome/overview_44.png)\n>>>\n\n<br>\n\n- [gnome-fuzzy-app-search](https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/)\n出于某些目的, 默认的 `GNOME` 在 `Overview` 中不支持模糊查找, 可以通过该插件修改行为  \n\n- [pip-on-top](https://extensions.gnome.org/extension/4691/pip-on-top/)\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口  \n\n- [frequency-boost-switch](https://extensions.gnome.org/extension/4792/frequency-boost-switch/)\n在右上角菜单中的 `电池策略` 中添加一个 `Checkox`, 用于切换 `是否允许超频`  \n\n<!-- Deprecated -->\n<!-- - [overview-navigation](https://extensions.gnome.org/extension/1702/overview-navigation/) -->\n<!-- 当按下 `Super` 进入 `Overview` 后, 可以按下 `空格键`, 窗口上会出现字母   -->\n<!-- 输入小写字母就切换到对应窗口, 按下 `Shift` 会使字母颜色变红, 此时输入字母会关闭对应窗口   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![overview-navigation](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n<!-- Deprecated -->\n<!-- - [cleaner-overview](https://extensions.gnome.org/extension/3759/cleaner-overview/) -->\n<!-- 进入 `Overview` 时, 将窗口排列整齐, 简单实用   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![cleaner-overview](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [user-theme](https://extensions.gnome.org/extension/19/user-themes/)\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)  \n注意: 还需要使用 `gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com` 指定主题  \n但我个人还是喜欢 GNOME 默认的暗色主题, 默认的就已经非常好看了  \n\n- [user-syle-sheet](https://extensions.gnome.org/extension/3414/user-stylesheet-font/)\n读取 `~/.local/share/gnome-shell/gnome-shell.css` 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者  \n\n\n\n- - -\n\n# 美化\n以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等  \n还有很多插件有帮助, 上面 [推荐插件列表](#tui-jian-cha-jian-lie-biao) 里有提到, 比如那个更改css的, 这里不说了  \n\n- 启动暗模式:  \n\n```bash\ngsettings set org.gnome.desktop.interface color-scheme \"prefer-dark\"\n```\n\n- 背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下  \n\n```bash\ngsettings set org.gnome.desktop.background picture-uri 'file:///usr/share/backgrounds/aaa.png'\ngsettings set org.gnome.desktop.background picture-uri-dark 'file:///usr/share/backgrounds/aaa.png'\n```\n\n- 头像: 假设用户名是 `Xyz`, 则需要将图片命名为 `Xyz`, 随后放到 `/var/lib/AccountsService/icons/` 下\n\n```bash\nsudo mv ./Xyz /var/lib/AccountsService/icons/\n\n# 或将图片命名为.face, 放到家目录\n# mv ./Xyz ~/.face  \n```\n\n- 主题: 单用户的放 `~/.themes/` , 多用户的放 `/usr/share/themes/`, 可前往 [gnome-look](https://www.gnome-look.org/) 挑选主题  \n\n```bash\n# 以 Nordic 为例子\nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.git\ngsettings set org.gnome.desktop.interface gtk-theme 'Nordic'\ngsettings set org.gnome.desktop.wm.preferences theme 'Nordic'\n\n# 你也可以使用 `user-theme` 这个插件进行设置:  \nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.gi\ngnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com\n```\n\n- 字体: 将顶栏字体换成 `Fira Code`, 顺便调整下大小  \n\n```bash\ngsettings set org.gnome.desktop.interface font-name 'Fira Code 11.8'\n```\n\n- 隐藏 `Dash` 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了  \n\n```bash\ngsettings set org.gnome.shell favorite-apps \"[]\"\n```\n\n**注意:**  \n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 `Just-perfection` 插件  \n此插件得到官方支持, 可以将桌面 `化简`, 包括Dash  \n如果你只是使用插件, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的[禁用快捷键](#jin-yong-kuai-jie-jian)  \n\n- 去掉左上角的 `Activities`: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装插件: `space-bar`)  \n\n```bash\n# 自定义工作区的名称, 不然就是默认的数字\ngsettings set org.gnome.desktop.wm.preferences workspace-names \"['Browser', 'Terminal', 'Game', 'Box', 'Other']\"\n```\n- 隐藏顶栏: 安装 `just-perfection` && `blur-my-shell`, 配置后就是本文 [成品展示](#cheng-pin-zhan-shi) 中的了, 处于 `Overview` 中才显示顶栏  \n\n- - -\n\n# 快捷键\n这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改  \n\n我个人就不喜欢 `Alt+Fn数字`, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 `I3/Sway` 那样  \n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash  \n\n**注意:**  \n快捷键部分, 还是推荐通过 `gnome-control-center keyboard` 打开设置中心的键盘区, 在其中自定义快捷键  \n(如果图形界面无法满足你的需求, 你可以再捉摸着, 看看下面的命令行部分, 或许可以帮到你)\n\n快捷键之间有冲突的话, 可能无法生效, 请通过 `gnome-control-center keyboard` 查看快捷键冲突并重置快捷键至默认  \n\n\n## 查找快捷键\n首先, 我们得明白如何查找对应的快捷键  \n\n下面的命令会列出极大部分的快捷键:  \n\n```bash\ngsettings list-recursively | grep -E \"Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left\" | cat\n```\n\n你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语  \n如果实在找不到, 一点点看过去也行 :)  \n\n\n## 禁用快捷键\n某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组  \n想要禁用该快捷键, 将对应的数组设置为空就行了  \n\n举个例子, 禁用Dash的快捷键 (见上文的置空 `favorite-apps`):  \n\n```bash\n# Default: Super+\"1..9\"\nfor i in $(seq 9)\ndo\n    gsettings set org.gnome.shell.keybindings switch-to-application-$i \"[]\"  \ndone    \n```\n\n禁用快捷键还可以让你避免冲突, 比如:  \n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次  \n这时就要借助 GUI 的力量了: 输入 `gnome-control-center keyboard`, 然后进入自定义那栏, 会显示冲突的键  \n\n举个例子, 我想修改 `Super+Esc` 变成锁屏, 我就要这样做:  \n\n```bash\ngsettings set org.gnome.settings-daemon.plugins.media-keys screensaver \"['<Super>Escape']\" #Default: Sup+L\ngsettings set org.gnome.mutter.wayland.keybindings restore-shortcuts \"[]\" # Default: Sup+Esc\n```\n\n## 修改快捷键\n修改, 也就是覆写默认的快捷键, 与下文要讲的 [添加快捷键](#tian-jia-kuai-jie-jian) 不是一个概念  \n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考  \n\n- Vim 式的按键, 改变窗口布局, 替代原有的 `Super+方向键`:  \n\n```bash\n# 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......\n\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-left  \"['<Super>h']\" # 放左边\ngsettings set org.gnome.desktop.wm.keybindings  maximize           \"['<Super>j']\" # 最大化\ngsettings set org.gnome.desktop.wm.keybindings  unmaximize         \"['<Super>k']\" # 最小化\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-right \"['<Super>l']\" # 放右边\n```\n\n对了, 如果你追求平铺式的话, 插件可以满足一部分要求, 但肯定比不上专业的窗管...  \n\n- move, resize, kill 一个窗口:  \n\n```bash\n# Move\ngsettings set org.gnome.desktop.wm.keybindings begin-move   \"['<Super>x']\"        #Default: Alt+F7\n\n# Resize\ngsettings set org.gnome.desktop.wm.keybindings begin-resize \"['<Super>r']\"        #Default: Alt+F8\n\n# Kill\ngsettings set org.gnome.desktop.wm.keybindings close        \"['<Super><Shift>q']\" #Default: Alt+F4\n```\n\n- toggle-max, max, min, toggle-fullscreen, show-desktop:  \n\n```bash\n# Toggle max\ngsettings set org.gnome.desktop.wm.keybindings toggle-maximized  \"['<Super>m']\"     #Default: Alt+F10\n\n# Max/Min\ngsettings set org.gnome.desktop.wm.keybindings maximize          \"['<Super>j']\"\ngsettings set org.gnome.desktop.wm.keybindings unmaximize        \"['<Super>k']\"\ngsettings set org.gnome.desktop.wm.keybindings minimize          \"['<Super>comma']\" #Default: Super+H\n\n# Toggle fullscreen\ngsettings set org.gnome.desktop.wm.keybindings toggle-fullscreen \"['<Super>f']\"     #Default: None\n\n# Show desktop\ngsettings set org.gnome.desktop.wm.keybindings show-desktop      \"['<Super>d']\"     #Default: None\n```\n\n- 还有套很重要的快捷键, 就是切换工作区了, 搭配先前提到过的消除过渡动画的插件, 流畅感Max:  \n\n```bash\nfor i in $(seq 9)\ndo\n  gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-$i \"['<Super>$i']\"\n  gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-$i   \"['<Super><Shift>$i']\"\ndone\ngsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-10   \"['<Super>0']\"\ngsettings set org.gnome.desktop.wm.keybindings move-to-workspace-10     \"['<Super><Shift>0']\"\n```\n\n- 再比如, 覆写 `run-dialog` 的快捷键 (默认是按Alt-F2, 但太远了...):  \n\n```bash\ngsettings set org.gnome.desktop.wm.keybindings panel-run-dialog \"['<Super>c']\" #Default: Alt+F2\n```\n\n## 添加快捷键\n此处指的是真正的, 添加自己的快捷键. 不是简单的覆写  \n比如 `Super+Return` 打开一个终端, `Super+B` 打开浏览器, `Super+E` 打开文件管理器...  \n\n废话不多说, 你按下面照猫画虎, 就阔以了:  \n\n```bash\ngp0=\"/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\ngp1=\"org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\\n/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\n\n# Custom Keys\n# 注意!!!!!!!\n# 不要在最后添加逗号\ngsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings \"[             \\\n    '$gp0/custom0/', '$gp0/custom1/', '$gp0/custom2/', '$gp0/custom3/', '$gp0/custom4/'      \\\n]\"\n\n## Terminal\ngsettings set $gp1/custom0/ name     'Terminal'\ngsettings set $gp1/custom0/ command  'alacritty'\ngsettings set $gp1/custom0/ binding  '<Super>Return'\n\n## Files\ngsettings set $gp1/custom1/ name     'Files'\ngsettings set $gp1/custom1/ command  'nautilus'\ngsettings set $gp1/custom1/ binding  '<Super>e'\n\n## Browser\ngsettings set $gp1/custom2/ name     'Browser'\ngsettings set $gp1/custom2/ command  'firefox'\ngsettings set $gp1/custom2/ binding  '<Super>b'\n\n## Logout\ngsettings set $gp1/custom3  name     'Logout'\ngsettings set $gp1/custom3/ command  'gnome-session-quit'\ngsettings set $gp1/custom3/ binding  '<Super><Shift>Escape'\n\n## Fcitx5 Reload\ngsettings set $gp1/custom4/ name     'Fcitx5_Reload'\ngsettings set $gp1/custom4/ command  'fcitx5 -r'\ngsettings set $gp1/custom4/ binding  '<Alt><Shift>space'\n```\n\n上面的一切已经非常非常详细, 但接下来还要解决最后的问题:  \n如果你更换了机器/重装了系统, 如何快速恢复先前的工作环境?  \n\n- - -\n\n# 加载配置\n我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件  \n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上  \n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE  \n\n**注意:**  \n我相信你还没有忘记, 如何把插件下载下来, 将十几个zip文件放在一个文件夹里面, 然后用bash脚本自动下载安装吧?  \n请跳转至上面的 [安装插件/从命令行](#cong-ming-ling-xing) 目录\n\n\n## 对于非Nixos\n对于普通的Linux发行版, 直接按下面的方式  \n\n- 导出当前的dconf数据到某个文件:  \n\n```bash\ndconf dump / > dconf.settings\n```\n\n- 加载/导入某个dconf文件到当前系统:\n\n```bash\ncat dconf.settings | dconf load -f /\n```\n\n对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置  \n同时确认 `dconf.settings` 中的 `picture-uri` / `picture-uri-dark` 指向对应文件  \n\n## 对于Nixos\n\n如果你使用 Nixos, 请先确保已经安装了 [HomeManager](https://github.com/nix-community/home-manager)  \nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具  \n\n虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档  \n请先下载 `dconf2nix`, 这是一个将 dconf文件, 转换为 nix 表达式的工具  \n随后, 在终端输入以下内容, 得到 `dconf.nix` :  \n\n```bash\ndconf dump / > dconf.settings\ndconf2nix -i dconf.settings -o dconf.nix\n```\n\n在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):  \n\n```\nnixpkgs/\n├── gnome\n│   ├── .background\n│   ├── .face\n│   └── dconf.nix\n└── home.nix\n```\n\n这里的 `dconf.nix` 就是刚刚转换得到的nix表达式, 在 `home.nix` 中导入它:  \n\n```nix\nimports = [\n  ./gnome/dconf.nix\n];\n```\n\n\n介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 `$HOME` 下  \n这里将两个图片放在了 `~/.config/nixpkgs/gnome/` 下, 因此要修改下相应文件  \n\n\n- 对于背景图像, 修改 `dconf.nix` 中的 `picture-uri`:  \n\n```nix\n\"org/gnome/desktop/background\" =\nlet picture = ../.background.png; in\n{\n  picture-uri = \"file://${picture}\";\n  picture-uri-dark = \"file://${picture}\";\n};\n```\n\n- 对于人物头像, 在 `home.nix` 添加以下内容:  \n\n```nix\nhome.file.\".face\".source = ./.face;\n```\n\n大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了  \n\n","source":"_posts/desktop-beautify/gnome.md","raw":"---\ntitle: \"GNOME 入坑指南\"\nabbrlink: posts/desktop-beautify/gnome\nhidden: false\ndate: 2022-07-20 11:22:42\ntop: 99999\ntags: [Linux, GNOME, Waylnad, Desktop]\nkeywords: [GNOME, 桌面环境, DE, Linux, Wayland, Desktop]\nis_series: true\nnext_post: [posts/desktop-beautify/hyprland, Hyprland 平铺式]\n---\n> 关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境\n<!-- more -->\n\n# 开篇说明\n\n**注意:**  \n本篇文章的配置皆在注重 **简洁**, **美观**, **高效**  \n想要平铺式, 炫酷效果, 更多功能的, 请自行配置, 或查看我的另外一篇博客: [Hyprland 平铺式](/posts/desktop-beautify/hyprland)  \n请注意 GNOME 版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新  \n目前, 该篇文章的适用 GNOME 版本为: **44**  (**于2023年5月21更新本文**)\n\n**注意:**  \n如果你是在我的博客上阅读本文, 请善用右侧目录功能  \n\n- - -\n\n# 更新说明\n\n**每次更新本文时, 一切更改记录都会放在这里, 方便读者进行版本迁移 (比如从 43 -> 44), 或者发现新的有用的插件**\n**版本的不同, 在除了插件方面会有所差异, 其他地方是几乎一样的, 就算真有不一样的地方我也会标注的, 请放心**  \n**一般来说, 每次更新本文时, 主要更新的是 [推荐插件列表](#tui-jian-cha-jian-lie-biao) 这部分, 如果你已经看过本文了, 一般只需要跳转至那一部分即可**\n\n- 2023.5.21  \n更新了本文版本以适配 GNOME-44  \n更新了推荐插件列表及相应配图  \n添加了 \"gdm下部分设置无法生效\" 的解决方法  \n\n\n\n- - -\n\n# 成品展示\n2023年了, GNOME 又靠谱又好用, 但有些人的界面仍处于是十年前的样子...  \n我个人认为 **简洁** + **大气** + **美观** 比较重要, 当然你也可以自行修改进行DIY  \n如果真的有需求, 请自己动手, 丰衣足食吧! ~~(虽然我认为本文已经详细地不能再详细了)~~ \n\n![44(当前版本的图片)](/images/gnome/overview_44.png)\n![42(旧版本的保留图片)](/images/gnome/overview_42.png)  \n\n- - -\n\n# 使用工具说明\n\n- `dconf`:\n是一套基于键的配置系统, 十分高效, 你可以将其视作 Windows 下的注册表, 但修改起来非常简单  \n\n- `gsettings`:\n是 GNOME 下的高级API, 是一个命令行工具, 用来简化对 dconf 的操作  \n \n\n你可能在年份久远的文章中听说过 `gconf`, 这是什么? 与 `dconf` 有啥区别?  \n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 `dconf` 所取代  \n\n接下来的大部分配置, 都会使用 `gsettings` 在命令行中进行操作\n\n当然, 你也可以通过图形化界面, 比如 `gnome-control-center` 进行设置, 但有一些东西是界面里不存在/无法调整的  \n同时, 为了方便读者进行复制粘贴, 特此写成命令形式 ~~(快说蟹蟹!!)~~  \n\n- - - \n\n# 常用设置\n以下是各种方面的设置, 直接复制粘贴, 有些地方进行下修改, 适配自己情况即可  \n\n## 触摸板\n触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO ~~(但CS我也能用触摸板玩)~~\n\n有一些 Linux 发行版的 GNOME比较贴近上游, `轻击模拟鼠标点击` 默认未开启  \n这导致触摸板很难用, 得按下去才能模拟鼠标的点击  \n\n你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指...  \n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改...  \n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒...  \n\n你可以在终端输入如下命令进行调整:  \n\n```bash\ngsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true\ngsettings set org.gnome.desktop.peripherals.touchpad speed 0.57\ngsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing false\n```\n\n分别对应:  \n- 轻击模拟鼠标点击, 默认为false\n- 调整触摸板速度, 默认为0\n- 打字时禁用触摸板, 默认为true\n\n常用手势:  \n- 单指: 移动鼠标\n- 双指上下: 翻页\n- 三指左右: 切换Workspace\n- 三指上: 打开Overview (不常用, 按Super更快)\n- 三指下: 显示任务栏 (当你隐藏任务栏时)\n\n(安装一些插件后, 相关快捷键可能会发生改变)\n\n## 窗口与工作区\n我个人喜欢将工作区设置为静态, 也就是禁止动态工作区, 防止窗口自由移动, 同时将工作区设置为10个:  \n\n```bash\ngsettings set org.gnome.mutter dynamic-workspaces false\ngsettings set org.gnome.desktop.wm.preferences num-workspaces 10\n```\n\n(Mutter 是 GNOME 自己的窗口管理器)  \n \n\n对于快捷键, 你可以自定义窗口的最大化/最小化/全屏/隐藏/更改大小/移动, 与有关工作区的部分  \n鉴于这一部分属于设置快捷键系列, 请您移动至本文后面的 **[修改快捷键](#xiu-gai-kuai-jie-jian)** 目录  \n\n举个例子:  \n比如 \"move window\", 普通来讲你可能会双击窗口的标题栏, 然后拖动窗口进行移动, 但你完全可以将这个操作绑定在快捷键 \"Super+x\" 上  \n然后按一次该快捷键, 进入 \"move mode\", 移动完毕之后再按一次(或者点击一下), 就可以确定窗口位置  \n如果你不满意, 可以按一下 `Esc`, 恢复到初始位置  \n\n还有很多操作, 比如移动某个窗口至指定工作区, 或者切换至某个工作区, 就像是使用着类似 \"i3/sway/hyprland\" 等 \"window manager\" 一样的体验  \n\n- - -\n\n# GDM\n稍微说明下, 如果你在登陆之后使用 gsettings 进行的设置, 无法在 GDM 中生效时, 极大概率是用户与权限问题  \n\n比如, 你发现触摸板明明已经设置了轻触模拟点击, 但在 GDM 中无效, 那就指定 `gdm` 用户, 再设置一遍即可:  \n\n```bash\nxhost +SI:localuser:gdm\nsudo -u gdm gsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true\nsudo -u gdm gsettings set org.gnome.desktop.peripherals.touchpad speed 0.57\nsudo -u gdm gsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing false\n```\n\n- - -\n\n# 插件\n## 安装插件\nGNOME 的插件(Extensions)是其重要的组成, 赋予了随意组合的 **自由** 与 **强大**, 说是 GNOME 一半的 **灵魂** 所在, 也不为过之  \n我将先介绍如何安装/使用它们, 因为后面需要用到插件  \n\n有两种安装方法, 一种从命令行安装, 一种从浏览器安装  \n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍  \n\n### 从命令行\n**提示**  \n请确保拥有以下命令: `unzip`, `jq`, 有些发行版默认连 `unzip` 都没有...  \n下载成功后, 切记要 logout, 然后再登进来, 运行 `gnome-session-quit` 即可  \n\n每个GNOME插件都拥有独一无二的, 名为 `uuid` 的标识符, 我们可以通过 `uuid`, 下载插件  \n\n你可以在 [Extensions-GNOME](https://extensions.gnome.org/) 这个网站上, 浏览并下载插件  \n请将以 .zip 结尾的插件放在同一目录下, 假设该目录叫 `exts_list`  \n\n下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:  \n\n{% tabs install-extensions%}\n<!-- tab Bash-->\n\n```bash install-extensions.sh\n#!/usr/bin/env bash\ndeclare -a UUID_LIST\nEXTS_DIR=$HOME/.local/share/gnome-shell/extensions\nEXTS_LIST=${1}\nstr_join() {\n  echo \"$*\" | sed 's/\"\"/\",\"/g'\n}\nmkdir -p $EXTS_DIR\nchmod -R 755 $HOME/.local/\nfor EXT in $EXTS_LIST/*.zip\ndo\n  UUID=$(unzip -p $EXT metadata.json | jq -r \".uuid\")\n  mkdir -p $EXTS_DIR/$UUID\n  unzip -q -o $EXT -d $EXTS_DIR/$UUID\n  UUID_LIST+=\"\\\"$UUID\\\"\"\ndone\nUUID_LIST=[$(str_join ${UUID_LIST[@]})]\ngsettings set org.gnome.shell enabled-extensions ${UUID_LIST[@]}\n```\n\n<!-- endtab -->\n\n<!-- tab Fish -->\n\n```bash install-extensions.fish\nset exts_list $argv[1]\nset exts_dir $HOME/.local/share/gnome-shell/extensions/\nset uuid_list\nmkdir -p $exts_dir\nfor ext in exts_list/*.zip\n  set uuid ( unzip -p $ext metadata.json | jq -r \".uuid\" )\n  mkdir -p $ext_dir/$uuid\n  unzip -q -o $ext -d $ext_dir/$uuid\n  set -a uuid_list \\'$uuid\\'\nend\nset uuid_list [( string join \",\" $uuid_list )]\ngsettings set org.gnome.shell enabled-extensions $uuid_list\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n假设使用Bash: 执行 `sh install-extensions.sh exts_list` 下载该目录下的所有插件  \n\n**注意: 先logout, 再登进来**  \n\n也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:  \n\n```bash\nsudo dbus-send --type=method_call --dest=org.gnome.Shell /org/gnome/Shell \\\n  org.gnome.Shell.Extensions.InstallRemoteExtension string:'xxxxx_uuid'\n```\n\n### 从浏览器\n该方法其实也蛮方便的, 但不适合快速部署  \n你需要安装两个玩意, 才能直接从 [Extension-GNOME](https://extensions.gnome.org/) 上直接下载  \n\n- `chrome-gnome-shell`:  \n本地软件, 你可以通过包管理器, 直接搜这个名字  \n\n- `GNOME Shell integration`:  \n浏览器插件, Chrome/Firefox 的浏览器商店都有它  \nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件  \n\n一个在本地, 一个在浏览器,  因此可以支持你从 [网站](https://extensions.gnome.org/) 上 直接安装到本地  \n\n- - -\n\n## 查看与配置插件\n此处推荐使用浏览器来设置插件, 在 [https://extensions.gnome.org/local/](https://extensions.gnome.org/local/) 页面管理与配置插件  \n\n如果你想通过命令行, 则可以使用 `gnome-extensions` 这个命令, 来查看并配置插件:  \n\n```bash\n# 获取帮助, `Command` 为可选项\ngnome-extensions help [Command]\n\n# 查看插件列表\ngnome-extensions list --user    # 查看用户级插件\ngnome-extensions list --system  # 查看系统级插件\n\n# 查看插件的信息\ngnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com\n\n# 启用/禁用某个插件\ngnome-extensions enable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\ngnome-extensions disable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n\n# 配置某个插件 (打开 GUI 界面)\ngnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n```\n\n或者通过 `gsettings` 来配置某个插件, 但不推荐, 因为麻烦:  \n\n```bash\n# 查看某个插件的所有选项\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  list-recursively org.gnome.shell.extensions.nothing-to-say\n  \n# 得到/重置/设置 某个插件的某选项当前的值 (根据上面这条命令查看所有选项)\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  get    org.gnome.shell.extensions.nothing-to-say show-osd\n# reset  org.gnome.shell.extensions.nothing-to-say show-osd\n# set    org.gnome.shell.extensions.nothing-to-say show-osd\n```\n\n你可以在已经配置好插件的机器上, 导出 `dconf.settings` 文件, 并在新机器上加载它, 避免更换机器/重装系统之后再次设置插件  \n详情请见 [**加载配置**](#jia-zai-pei-zhi)  \n\n- - -\n\n# 推荐插件列表\n以下是我目前正在使用且推荐的插件, 适用版本为 **44**  \n\n**注意:**\n<!-- 如果你是通过我的博客 [jedsek.xyz](https://jedsek.xyz) 观看的话, 我默认隐藏了这些图片  -->\n<!-- 你可以展开任意一张图片后, 点击图片, 然后可以通过方向键切换图片 :)  -->\n\n- [transparent-top-bar(adjustable-transparency)](https://extensions.gnome.org/extension/3960/transparent-top-bar-adjustable-transparency/)\n让顶栏变透明的插件, 当窗口最大化或者与顶栏重叠时, 为了显示清晰会自动重新变回不透明  \n\n- [auto-move-windows](https://extensions.gnome.org/extension/16/auto-move-windows/)  \n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)  \n\n- [color-app-menu-icon](https://extensions.gnome.org/extension/5473/color-app-menu-icon-for-gnome-40/)\n顶栏左上角会显示你当前所在应用的图标与名称  \n\n- [draw-on-your-screen-2](https://extensions.gnome.org/extension/4937/draw-on-you-screen-2/)\n通过设置的快捷键, 让你可以在屏幕上用画笔画画, 在录制视频, 向他人演示, 标记重点的时候非常有用  \n\n- [removable-drive-menu](https://extensions.gnome.org/extension/7/removable-drive-menu/)\n当你插入u盘之后, 顶栏会出现显示图标, 让你快速访问文件, u盘拔出之后图标自动消失  \n\n- [run-cat](https://extensions.gnome.org/extension/2986/runcat/)\n在顶栏出现一只奔跑的小猫与 cpu 的利用率, cpu 利用率越高, 小猫跑得越快  \n\n- [quick-touchpad-toggle](https://extensions.gnome.org/extension/5292/quick-touchpad-toggle/)\n在 quick-settings 中增加一个选项, 让你快速启用/禁用触摸板  \n\n- [quick-close-in-overview](https://extensions.gnome.org/extension/352/middle-click-to-close-in-overview/)\n在 overview 中, 当你的鼠标移动到对应窗口时, 右上角增加一个叉叉, 让你快速关闭窗口  \n\n- [just-another-search-bar](https://extensions.gnome.org/extension/5522/just-another-search-bar/)\n让你自己设置一个快捷键, 按下之后打开一个搜索框, 然后用你的默认浏览器搜索输入内容, 你可以设置搜索引擎(google/bing)  \n这个操作在 overview 中也可以做到, 名字都说了是 just-another, 是为了更美观  \n\n- [coverflow-alt-tab](https://extensions.gnome.org/extension/97/coverflow-alt-tab/)\n让你在使用 `super+tab`/`alt+tab` 切换窗口时, 获得好看美观的特效  \n\n- [customize-iBus](https://extensions.gnome.org/extension/4112/customize-ibus/)\nibus 是 gnome 内置的一个输入法, 已经和 fcitx5 差不多了, 默认情况下就已经非常好看了  \n你可以使用这个插件, 深度自定义 ibus 的行为, 比如我现在, 打字时就能够让候选框随着我打字的节奏而抖动, 非常爽  \n再比如设置中英文切换时, 指示器的显示时间, 抖动效果, 闪烁特效等  \n>>> **点击展开/隐藏图片**\n![ibus默认情况下的外表/系统暗色主题](/images/gnome/ibus.png)\n>>>\n\n- [quake-mode](https://extensions.gnome.org/extension/1411/quake-mode/)  \n雷神模式!! 该插件可以让你以雷神模式打开一些与快捷键绑定的应用, 即以下拉式打开任意一个app, 全部工作区共享一个app  \nquake-mode 配上你喜欢的任意一个终端, 都会产生非常棒的奇效, 具体效果可以点击链接看动图演示即可    \n\n- [color-pciker](https://extensions.gnome.org/extension/3396/color-picker/)\n采色笔, 用来采集颜色, 有相关需求的话非常有用, 没什么好说的  \n\n- [battery-time](https://extensions.gnome.org/extension/5425/battery-time/)\n在 quick-setting 中显示你的电量还可以撑多久  \n\n- [bluetooth-battery-indicator](https://extensions.gnome.org/extension/3991/bluetooth-battery/)\n当你连接蓝牙设备之后, 会在顶栏显示电量  \n\n- [bluetooth-quick-connect](https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/)\n在 quick-setting 中, 让你快速连接/断开已经配对过的蓝牙设备, 非常有用  \n\n- [control-blur-effect-on-lock-screen](https://extensions.gnome.org/extension/2935/control-blur-effect-on-lock-screen/)\n锁屏之后, 背景图片会变得模糊(blur), 这个插件可以修改模糊度, 我个人喜欢背景完全不模糊  \n\n<!-- Deprecated -->\n<!-- - [refresh-wifi-connections](https://extensions.gnome.org/extension/905/refresh-wifi-connections/) -->\n<!-- 当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键   -->\n<!--  -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![refresh-wifi-connections](/images/gnome/refresh-wifi-connections.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [transparent-window-moving](https://extensions.gnome.org/extension/1446/transparent-window-moving/)\n在对窗口进行移动/调整大小时, 使窗口变得透明  \n\n- [just-perfection](https://extensions.gnome.org/extension/3843/just-perfection/)\n我最喜欢的一个插件, 用于对界面进行大量自定义与精简  \n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等  \n>>> **点击展开/隐藏图片**\n![just-perfection](/images/gnome/overview_44.png)\n>>>\n\n<br>\n\n\n- [nothing-to-say](https://extensions.gnome.org/extension/1113/nothing-to-say/)\n用于切断/恢复声音的输入, 对我来说蛮有用的:  \n当与同学打游戏, 撞上爸妈查房, 立刻按下 `Super+\\`, 防止爸妈训我的声音流入同学耳中, 维护尊严 :)  \n\n- [space-bar](https://extensions.gnome.org/extension/5090/space-bar/)\n模仿 I3/Sway/Bspwm 等窗口管理器, 在左上角显示工作区, 有些类似的插件, 但个人认为, 这个插件最好  \n>>> **点击展开/隐藏图片**\n![space-bar/名称](/images/gnome/space-bar_name.png)\n![space-bar/数字](/images/gnome/space-bar_number.png)\n>>>\n\n<br>\n\n<!-- Deprecated -->\n<!-- - [workspace-switcher-manager](https://extensions.gnome.org/extension/4788/workspace-switcher-manager/) -->\n<!-- 美化通过键盘(我配成了 `Super + 1..9`), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![workspace-switcher-manager](/images/gnome/workspace-switcher-manager.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [disable-workspace-switch-animation-for-GNOME40+](https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/)\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感  \n\n- [gsconnect](https://extensions.gnome.org/extension/1319/gsconnect/)\nGNOME版的 `kdeconnect`, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开  \n手机需安装 `kdeconnect`, 你可以从本博客下载 apk 进行安装: [kdeconnect](/downloads/gnome/kdeconnect.apk)  \n>>> **点击展开/隐藏图片**\n![gsconnect](/images/gnome/gsconnect.png)\n>>>\n\n<br>\n\n<!-- Deprecated -->\n<!-- - [blur-my-shell](https://extensions.gnome.org/extension/3193/blur-my-shell/) -->\n<!-- 用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的插件   -->\n<!-- 但我并不推荐这个插件, 因为修改的东西太多, 和其他插件一起的话, 有概率发生死机等问题   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![blur-my-shell](/images/gnome/overview.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [user-avatar-in-quick-settings](https://extensions.gnome.org/extension/5506/user-avatar-in-quick-settings/)\n让右上角菜单出现你的头像, 提升美观而已  \n\n- [gnome40-ui-improvements](https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/)\n按下 `Super`, 进入 `Overview` 后, 在中上方显示工作区, 与下面的插件 `v-shell`  不兼容, 二选一, 我推荐下面的 `v-shell`  \n>>> **点击展开/隐藏图片**\n![gnome40-ui-improvements](/images/gnome/gnome40-ui-improvements.png)\n>>>\n\n<br>\n\n- [v-shell](https://extensions.gnome.org/extension/5177/vertical-workspaces/)\n按下 `Super`, 进入 `Overview` 后, 在左边显示工作区, 同时附赠了各种非常好用的操作, 与上面的 `gnome40-ui-improvements` 二选一    \n当你进入 `Overview` 后, 按下 `space` 后可以查询打开的窗口, `alt+space` 查询最近修改的文件  \n>>> **点击展开/隐藏图片**\n![v-shell](/images/gnome/overview_44.png)\n>>>\n\n<br>\n\n- [gnome-fuzzy-app-search](https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/)\n出于某些目的, 默认的 `GNOME` 在 `Overview` 中不支持模糊查找, 可以通过该插件修改行为  \n\n- [pip-on-top](https://extensions.gnome.org/extension/4691/pip-on-top/)\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口  \n\n- [frequency-boost-switch](https://extensions.gnome.org/extension/4792/frequency-boost-switch/)\n在右上角菜单中的 `电池策略` 中添加一个 `Checkox`, 用于切换 `是否允许超频`  \n\n<!-- Deprecated -->\n<!-- - [overview-navigation](https://extensions.gnome.org/extension/1702/overview-navigation/) -->\n<!-- 当按下 `Super` 进入 `Overview` 后, 可以按下 `空格键`, 窗口上会出现字母   -->\n<!-- 输入小写字母就切换到对应窗口, 按下 `Shift` 会使字母颜色变红, 此时输入字母会关闭对应窗口   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![overview-navigation](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n<!-- Deprecated -->\n<!-- - [cleaner-overview](https://extensions.gnome.org/extension/3759/cleaner-overview/) -->\n<!-- 进入 `Overview` 时, 将窗口排列整齐, 简单实用   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![cleaner-overview](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n\n- [user-theme](https://extensions.gnome.org/extension/19/user-themes/)\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)  \n注意: 还需要使用 `gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com` 指定主题  \n但我个人还是喜欢 GNOME 默认的暗色主题, 默认的就已经非常好看了  \n\n- [user-syle-sheet](https://extensions.gnome.org/extension/3414/user-stylesheet-font/)\n读取 `~/.local/share/gnome-shell/gnome-shell.css` 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者  \n\n\n\n- - -\n\n# 美化\n以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等  \n还有很多插件有帮助, 上面 [推荐插件列表](#tui-jian-cha-jian-lie-biao) 里有提到, 比如那个更改css的, 这里不说了  \n\n- 启动暗模式:  \n\n```bash\ngsettings set org.gnome.desktop.interface color-scheme \"prefer-dark\"\n```\n\n- 背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下  \n\n```bash\ngsettings set org.gnome.desktop.background picture-uri 'file:///usr/share/backgrounds/aaa.png'\ngsettings set org.gnome.desktop.background picture-uri-dark 'file:///usr/share/backgrounds/aaa.png'\n```\n\n- 头像: 假设用户名是 `Xyz`, 则需要将图片命名为 `Xyz`, 随后放到 `/var/lib/AccountsService/icons/` 下\n\n```bash\nsudo mv ./Xyz /var/lib/AccountsService/icons/\n\n# 或将图片命名为.face, 放到家目录\n# mv ./Xyz ~/.face  \n```\n\n- 主题: 单用户的放 `~/.themes/` , 多用户的放 `/usr/share/themes/`, 可前往 [gnome-look](https://www.gnome-look.org/) 挑选主题  \n\n```bash\n# 以 Nordic 为例子\nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.git\ngsettings set org.gnome.desktop.interface gtk-theme 'Nordic'\ngsettings set org.gnome.desktop.wm.preferences theme 'Nordic'\n\n# 你也可以使用 `user-theme` 这个插件进行设置:  \nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.gi\ngnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com\n```\n\n- 字体: 将顶栏字体换成 `Fira Code`, 顺便调整下大小  \n\n```bash\ngsettings set org.gnome.desktop.interface font-name 'Fira Code 11.8'\n```\n\n- 隐藏 `Dash` 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了  \n\n```bash\ngsettings set org.gnome.shell favorite-apps \"[]\"\n```\n\n**注意:**  \n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 `Just-perfection` 插件  \n此插件得到官方支持, 可以将桌面 `化简`, 包括Dash  \n如果你只是使用插件, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的[禁用快捷键](#jin-yong-kuai-jie-jian)  \n\n- 去掉左上角的 `Activities`: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装插件: `space-bar`)  \n\n```bash\n# 自定义工作区的名称, 不然就是默认的数字\ngsettings set org.gnome.desktop.wm.preferences workspace-names \"['Browser', 'Terminal', 'Game', 'Box', 'Other']\"\n```\n- 隐藏顶栏: 安装 `just-perfection` && `blur-my-shell`, 配置后就是本文 [成品展示](#cheng-pin-zhan-shi) 中的了, 处于 `Overview` 中才显示顶栏  \n\n- - -\n\n# 快捷键\n这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改  \n\n我个人就不喜欢 `Alt+Fn数字`, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 `I3/Sway` 那样  \n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash  \n\n**注意:**  \n快捷键部分, 还是推荐通过 `gnome-control-center keyboard` 打开设置中心的键盘区, 在其中自定义快捷键  \n(如果图形界面无法满足你的需求, 你可以再捉摸着, 看看下面的命令行部分, 或许可以帮到你)\n\n快捷键之间有冲突的话, 可能无法生效, 请通过 `gnome-control-center keyboard` 查看快捷键冲突并重置快捷键至默认  \n\n\n## 查找快捷键\n首先, 我们得明白如何查找对应的快捷键  \n\n下面的命令会列出极大部分的快捷键:  \n\n```bash\ngsettings list-recursively | grep -E \"Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left\" | cat\n```\n\n你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语  \n如果实在找不到, 一点点看过去也行 :)  \n\n\n## 禁用快捷键\n某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组  \n想要禁用该快捷键, 将对应的数组设置为空就行了  \n\n举个例子, 禁用Dash的快捷键 (见上文的置空 `favorite-apps`):  \n\n```bash\n# Default: Super+\"1..9\"\nfor i in $(seq 9)\ndo\n    gsettings set org.gnome.shell.keybindings switch-to-application-$i \"[]\"  \ndone    \n```\n\n禁用快捷键还可以让你避免冲突, 比如:  \n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次  \n这时就要借助 GUI 的力量了: 输入 `gnome-control-center keyboard`, 然后进入自定义那栏, 会显示冲突的键  \n\n举个例子, 我想修改 `Super+Esc` 变成锁屏, 我就要这样做:  \n\n```bash\ngsettings set org.gnome.settings-daemon.plugins.media-keys screensaver \"['<Super>Escape']\" #Default: Sup+L\ngsettings set org.gnome.mutter.wayland.keybindings restore-shortcuts \"[]\" # Default: Sup+Esc\n```\n\n## 修改快捷键\n修改, 也就是覆写默认的快捷键, 与下文要讲的 [添加快捷键](#tian-jia-kuai-jie-jian) 不是一个概念  \n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考  \n\n- Vim 式的按键, 改变窗口布局, 替代原有的 `Super+方向键`:  \n\n```bash\n# 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......\n\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-left  \"['<Super>h']\" # 放左边\ngsettings set org.gnome.desktop.wm.keybindings  maximize           \"['<Super>j']\" # 最大化\ngsettings set org.gnome.desktop.wm.keybindings  unmaximize         \"['<Super>k']\" # 最小化\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-right \"['<Super>l']\" # 放右边\n```\n\n对了, 如果你追求平铺式的话, 插件可以满足一部分要求, 但肯定比不上专业的窗管...  \n\n- move, resize, kill 一个窗口:  \n\n```bash\n# Move\ngsettings set org.gnome.desktop.wm.keybindings begin-move   \"['<Super>x']\"        #Default: Alt+F7\n\n# Resize\ngsettings set org.gnome.desktop.wm.keybindings begin-resize \"['<Super>r']\"        #Default: Alt+F8\n\n# Kill\ngsettings set org.gnome.desktop.wm.keybindings close        \"['<Super><Shift>q']\" #Default: Alt+F4\n```\n\n- toggle-max, max, min, toggle-fullscreen, show-desktop:  \n\n```bash\n# Toggle max\ngsettings set org.gnome.desktop.wm.keybindings toggle-maximized  \"['<Super>m']\"     #Default: Alt+F10\n\n# Max/Min\ngsettings set org.gnome.desktop.wm.keybindings maximize          \"['<Super>j']\"\ngsettings set org.gnome.desktop.wm.keybindings unmaximize        \"['<Super>k']\"\ngsettings set org.gnome.desktop.wm.keybindings minimize          \"['<Super>comma']\" #Default: Super+H\n\n# Toggle fullscreen\ngsettings set org.gnome.desktop.wm.keybindings toggle-fullscreen \"['<Super>f']\"     #Default: None\n\n# Show desktop\ngsettings set org.gnome.desktop.wm.keybindings show-desktop      \"['<Super>d']\"     #Default: None\n```\n\n- 还有套很重要的快捷键, 就是切换工作区了, 搭配先前提到过的消除过渡动画的插件, 流畅感Max:  \n\n```bash\nfor i in $(seq 9)\ndo\n  gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-$i \"['<Super>$i']\"\n  gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-$i   \"['<Super><Shift>$i']\"\ndone\ngsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-10   \"['<Super>0']\"\ngsettings set org.gnome.desktop.wm.keybindings move-to-workspace-10     \"['<Super><Shift>0']\"\n```\n\n- 再比如, 覆写 `run-dialog` 的快捷键 (默认是按Alt-F2, 但太远了...):  \n\n```bash\ngsettings set org.gnome.desktop.wm.keybindings panel-run-dialog \"['<Super>c']\" #Default: Alt+F2\n```\n\n## 添加快捷键\n此处指的是真正的, 添加自己的快捷键. 不是简单的覆写  \n比如 `Super+Return` 打开一个终端, `Super+B` 打开浏览器, `Super+E` 打开文件管理器...  \n\n废话不多说, 你按下面照猫画虎, 就阔以了:  \n\n```bash\ngp0=\"/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\ngp1=\"org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\\n/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\n\n# Custom Keys\n# 注意!!!!!!!\n# 不要在最后添加逗号\ngsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings \"[             \\\n    '$gp0/custom0/', '$gp0/custom1/', '$gp0/custom2/', '$gp0/custom3/', '$gp0/custom4/'      \\\n]\"\n\n## Terminal\ngsettings set $gp1/custom0/ name     'Terminal'\ngsettings set $gp1/custom0/ command  'alacritty'\ngsettings set $gp1/custom0/ binding  '<Super>Return'\n\n## Files\ngsettings set $gp1/custom1/ name     'Files'\ngsettings set $gp1/custom1/ command  'nautilus'\ngsettings set $gp1/custom1/ binding  '<Super>e'\n\n## Browser\ngsettings set $gp1/custom2/ name     'Browser'\ngsettings set $gp1/custom2/ command  'firefox'\ngsettings set $gp1/custom2/ binding  '<Super>b'\n\n## Logout\ngsettings set $gp1/custom3  name     'Logout'\ngsettings set $gp1/custom3/ command  'gnome-session-quit'\ngsettings set $gp1/custom3/ binding  '<Super><Shift>Escape'\n\n## Fcitx5 Reload\ngsettings set $gp1/custom4/ name     'Fcitx5_Reload'\ngsettings set $gp1/custom4/ command  'fcitx5 -r'\ngsettings set $gp1/custom4/ binding  '<Alt><Shift>space'\n```\n\n上面的一切已经非常非常详细, 但接下来还要解决最后的问题:  \n如果你更换了机器/重装了系统, 如何快速恢复先前的工作环境?  \n\n- - -\n\n# 加载配置\n我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件  \n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上  \n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE  \n\n**注意:**  \n我相信你还没有忘记, 如何把插件下载下来, 将十几个zip文件放在一个文件夹里面, 然后用bash脚本自动下载安装吧?  \n请跳转至上面的 [安装插件/从命令行](#cong-ming-ling-xing) 目录\n\n\n## 对于非Nixos\n对于普通的Linux发行版, 直接按下面的方式  \n\n- 导出当前的dconf数据到某个文件:  \n\n```bash\ndconf dump / > dconf.settings\n```\n\n- 加载/导入某个dconf文件到当前系统:\n\n```bash\ncat dconf.settings | dconf load -f /\n```\n\n对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置  \n同时确认 `dconf.settings` 中的 `picture-uri` / `picture-uri-dark` 指向对应文件  \n\n## 对于Nixos\n\n如果你使用 Nixos, 请先确保已经安装了 [HomeManager](https://github.com/nix-community/home-manager)  \nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具  \n\n虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档  \n请先下载 `dconf2nix`, 这是一个将 dconf文件, 转换为 nix 表达式的工具  \n随后, 在终端输入以下内容, 得到 `dconf.nix` :  \n\n```bash\ndconf dump / > dconf.settings\ndconf2nix -i dconf.settings -o dconf.nix\n```\n\n在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):  \n\n```\nnixpkgs/\n├── gnome\n│   ├── .background\n│   ├── .face\n│   └── dconf.nix\n└── home.nix\n```\n\n这里的 `dconf.nix` 就是刚刚转换得到的nix表达式, 在 `home.nix` 中导入它:  \n\n```nix\nimports = [\n  ./gnome/dconf.nix\n];\n```\n\n\n介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 `$HOME` 下  \n这里将两个图片放在了 `~/.config/nixpkgs/gnome/` 下, 因此要修改下相应文件  \n\n\n- 对于背景图像, 修改 `dconf.nix` 中的 `picture-uri`:  \n\n```nix\n\"org/gnome/desktop/background\" =\nlet picture = ../.background.png; in\n{\n  picture-uri = \"file://${picture}\";\n  picture-uri-dark = \"file://${picture}\";\n};\n```\n\n- 对于人物头像, 在 `home.nix` 添加以下内容:  \n\n```nix\nhome.file.\".face\".source = ./.face;\n```\n\n大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了  \n\n","slug":"desktop-beautify/gnome","published":1,"updated":"2022-07-20T03:22:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ofv0001j1s61n20fmll","content":"<blockquote>\n<p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"kai-pian-shuo-ming\">开篇说明</h1>\n<p><strong>注意:</strong><br>\n本篇文章的配置皆在注重 <strong>简洁</strong>, <strong>美观</strong>, <strong>高效</strong><br>\n想要平铺式, 炫酷效果, 更多功能的, 请自行配置, 或查看我的另外一篇博客: <a href=\"/posts/desktop-beautify/hyprland\">Hyprland 平铺式</a><br>\n请注意 GNOME 版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>\n目前, 该篇文章的适用 GNOME 版本为: <strong>44</strong>  (<strong>于2023年5月21更新本文</strong>)</p>\n<p><strong>注意:</strong><br>\n如果你是在我的博客上阅读本文, 请善用右侧目录功能</p>\n<hr>\n<h1 id=\"geng-xin-shuo-ming\">更新说明</h1>\n<p><strong>每次更新本文时, 一切更改记录都会放在这里, 方便读者进行版本迁移 (比如从 43 -&gt; 44), 或者发现新的有用的插件</strong><br>\n<strong>版本的不同, 在除了插件方面会有所差异, 其他地方是几乎一样的, 就算真有不一样的地方我也会标注的, 请放心</strong><br>\n<strong>一般来说, 每次更新本文时, 主要更新的是 <a href=\"#tui-jian-cha-jian-lie-biao\">推荐插件列表</a> 这部分, 如果你已经看过本文了, 一般只需要跳转至那一部分即可</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2023.5.21<br>\n更新了本文版本以适配 GNOME-44<br>\n更新了推荐插件列表及相应配图<br>\n添加了 “gdm下部分设置无法生效” 的解决方法</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>2023年了, GNOME 又靠谱又好用, 但有些人的界面仍处于是十年前的样子…<br>\n我个人认为 <strong>简洁</strong> + <strong>大气</strong> + <strong>美观</strong> 比较重要, 当然你也可以自行修改进行DIY<br>\n如果真的有需求, 请自己动手, 丰衣足食吧! <s>(虽然我认为本文已经详细地不能再详细了)</s></p>\n<p><img data-src=\"/images/gnome/overview_44.png\" alt=\"44(当前版本的图片)\"><br>\n<img data-src=\"/images/gnome/overview_42.png\" alt=\"42(旧版本的保留图片)\"></p>\n<hr>\n<h1 id=\"shi-yong-gong-ju-shuo-ming\">使用工具说明</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>dconf</code>:<br>\n是一套基于键的配置系统, 十分高效, 你可以将其视作 Windows 下的注册表, 但修改起来非常简单</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>gsettings</code>:<br>\n是 GNOME 下的高级API, 是一个命令行工具, 用来简化对 dconf 的操作</p>\n</li>\n</ul>\n<p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>\n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p>\n<p>接下来的大部分配置, 都会使用 <code>gsettings</code> 在命令行中进行操作</p>\n<p>当然, 你也可以通过图形化界面, 比如 <code>gnome-control-center</code> 进行设置, 但有一些东西是界面里不存在/无法调整的<br>\n同时, 为了方便读者进行复制粘贴, 特此写成命令形式 <s>(快说蟹蟹!!)</s></p>\n<hr>\n<h1 id=\"chang-yong-she-zhi\">常用设置</h1>\n<p>以下是各种方面的设置, 直接复制粘贴, 有些地方进行下修改, 适配自己情况即可</p>\n<h2 id=\"hong-mo-ban\" id=\"触摸板\">触摸板</h2>\n<p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p>\n<p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>\n这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p>\n<p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>\n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>\n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p>\n<p>你可以在终端输入如下命令进行调整:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class=\"literal\">true</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>分别对应:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>轻击模拟鼠标点击, 默认为false</p>\n</li>\n<li class=\"lvl-2\">\n<p>调整触摸板速度, 默认为0</p>\n</li>\n<li class=\"lvl-2\">\n<p>打字时禁用触摸板, 默认为true</p>\n</li>\n</ul>\n<p>常用手势:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单指: 移动鼠标</p>\n</li>\n<li class=\"lvl-2\">\n<p>双指上下: 翻页</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指左右: 切换Workspace</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指上: 打开Overview (不常用, 按Super更快)</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指下: 显示任务栏 (当你隐藏任务栏时)</p>\n</li>\n</ul>\n<p>(安装一些插件后, 相关快捷键可能会发生改变)</p>\n<h2 id=\"chuang-kou-yu-gong-zuo-qu\" id=\"窗口与工作区\">窗口与工作区</h2>\n<p>我个人喜欢将工作区设置为静态, 也就是禁止动态工作区, 防止窗口自由移动, 同时将工作区设置为10个:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter dynamic-workspaces <span class=\"literal\">false</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences num-workspaces 10</span><br></pre></td></tr></table></figure>\n<p>(Mutter 是 GNOME 自己的窗口管理器)</p>\n<p>对于快捷键, 你可以自定义窗口的最大化/最小化/全屏/隐藏/更改大小/移动, 与有关工作区的部分<br>\n鉴于这一部分属于设置快捷键系列, 请您移动至本文后面的 <strong><a href=\"#xiu-gai-kuai-jie-jian\">修改快捷键</a></strong> 目录</p>\n<p>举个例子:<br>\n比如 “move window”, 普通来讲你可能会双击窗口的标题栏, 然后拖动窗口进行移动, 但你完全可以将这个操作绑定在快捷键 “Super+x” 上<br>\n然后按一次该快捷键, 进入 “move mode”, 移动完毕之后再按一次(或者点击一下), 就可以确定窗口位置<br>\n如果你不满意, 可以按一下 <code>Esc</code>, 恢复到初始位置</p>\n<p>还有很多操作, 比如移动某个窗口至指定工作区, 或者切换至某个工作区, 就像是使用着类似 “i3/sway/hyprland” 等 “window manager” 一样的体验</p>\n<hr>\n<h1 id=\"gdm\">GDM</h1>\n<p>稍微说明下, 如果你在登陆之后使用 gsettings 进行的设置, 无法在 GDM 中生效时, 极大概率是用户与权限问题</p>\n<p>比如, 你发现触摸板明明已经设置了轻触模拟点击, 但在 GDM 中无效, 那就指定 <code>gdm</code> 用户, 再设置一遍即可:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">xhost +SI:localuser:gdm</span><br><span class=\"line\">sudo -u gdm gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class=\"literal\">true</span></span><br><span class=\"line\">sudo -u gdm gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class=\"line\">sudo -u gdm gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"cha-jian\">插件</h1>\n<h2 id=\"an-zhuang-cha-jian\" id=\"安装插件\">安装插件</h2>\n<p>GNOME 的插件(Extensions)是其重要的组成, 赋予了随意组合的 <strong>自由</strong> 与 <strong>强大</strong>, 说是 GNOME 一半的 <strong>灵魂</strong> 所在, 也不为过之<br>\n我将先介绍如何安装/使用它们, 因为后面需要用到插件</p>\n<p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>\n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p>\n<h3 id=\"cong-ming-ling-xing\" id=\"从命令行\">从命令行</h3>\n<p><strong>提示</strong><br>\n请确保拥有以下命令: <code>unzip</code>, <code>jq</code>, 有些发行版默认连 <code>unzip</code> 都没有…<br>\n下载成功后, 切记要 logout, 然后再登进来, 运行 <code>gnome-session-quit</code> 即可</p>\n<p>每个GNOME插件都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载插件</p>\n<p>你可以在 <a href=\"https://extensions.gnome.org/\">Extensions-GNOME</a> 这个网站上, 浏览并下载插件<br>\n请将以 .zip 结尾的插件放在同一目录下, 假设该目录叫 <code>exts_list</code></p>\n<p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p>\n<div class=\"tabs\" id=\"install-extensions\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#install-extensions-1\">Bash</a></li><li class=\"tab\"><a href=\"#install-extensions-2\">Fish</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"install-extensions-1\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a UUID_LIST</span><br><span class=\"line\">EXTS_DIR=<span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions</span><br><span class=\"line\">EXTS_LIST=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">str_join</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;$*&quot;</span> | sed <span class=\"string\">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$EXTS_DIR</span></span><br><span class=\"line\">chmod -R 755 <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/</span><br><span class=\"line\"><span class=\"keyword\">for</span> EXT <span class=\"keyword\">in</span> <span class=\"variable\">$EXTS_LIST</span>/*.zip</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  UUID=$(unzip -p <span class=\"variable\">$EXT</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span>)</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$EXT</span> -d <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  UUID_LIST+=<span class=\"string\">&quot;\\&quot;<span class=\"variable\">$UUID</span>\\&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">UUID_LIST=[$(str_join <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"install-extensions-2\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> exts_list <span class=\"variable\">$argv</span>[1]</span><br><span class=\"line\"><span class=\"built_in\">set</span> exts_dir <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$exts_dir</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ext <span class=\"keyword\">in</span> exts_list/*.zip</span><br><span class=\"line\">  <span class=\"built_in\">set</span> uuid ( unzip -p <span class=\"variable\">$ext</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span> )</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$ext</span> -d <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  <span class=\"built_in\">set</span> -a uuid_list \\<span class=\"string\">&#x27;$uuid\\&#x27;</span></span><br><span class=\"line\">end</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list [( string join <span class=\"string\">&quot;,&quot;</span> <span class=\"variable\">$uuid_list</span> )]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div>\n<p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p>\n<p><strong>注意: 先logout, 再登进来</strong></p>\n<p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dbus-send --<span class=\"built_in\">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \\</span><br><span class=\"line\">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class=\"string\">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"cong-liu-lan-qi\" id=\"从浏览器\">从浏览器</h3>\n<p>该方法其实也蛮方便的, 但不适合快速部署<br>\n你需要安装两个玩意, 才能直接从 <a href=\"https://extensions.gnome.org/\">Extension-GNOME</a> 上直接下载</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>chrome-gnome-shell</code>:<br>\n本地软件, 你可以通过包管理器, 直接搜这个名字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>GNOME Shell integration</code>:<br>\n浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>\nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p>\n</li>\n</ul>\n<p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href=\"https://extensions.gnome.org/\">网站</a> 上 直接安装到本地</p>\n<hr>\n<h2 id=\"cha-kan-yu-pei-zhi-cha-jian\" id=\"查看与配置插件\">查看与配置插件</h2>\n<p>此处推荐使用浏览器来设置插件, 在 <a href=\"https://extensions.gnome.org/local/\">https://extensions.gnome.org/local/</a> 页面管理与配置插件</p>\n<p>如果你想通过命令行, 则可以使用 <code>gnome-extensions</code> 这个命令, 来查看并配置插件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取帮助, `Command` 为可选项</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">help</span> [Command]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看插件列表</span></span><br><span class=\"line\">gnome-extensions list --user    <span class=\"comment\"># 查看用户级插件</span></span><br><span class=\"line\">gnome-extensions list --system  <span class=\"comment\"># 查看系统级插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看插件的信息</span></span><br><span class=\"line\">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用/禁用某个插件</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置某个插件 (打开 GUI 界面)</span></span><br><span class=\"line\">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure>\n<p>或者通过 <code>gsettings</code> 来配置某个插件, 但不推荐, 因为麻烦:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看某个插件的所有选项</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 得到/重置/设置 某个插件的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class=\"line\"><span class=\"comment\"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class=\"line\"><span class=\"comment\"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure>\n<p>你可以在已经配置好插件的机器上, 导出 <code>dconf.settings</code> 文件, 并在新机器上加载它, 避免更换机器/重装系统之后再次设置插件<br>\n详情请见 <a href=\"#jia-zai-pei-zhi\"><strong>加载配置</strong></a></p>\n<hr>\n<h1 id=\"tui-jian-cha-jian-lie-biao\">推荐插件列表</h1>\n<p>以下是我目前正在使用且推荐的插件, 适用版本为 <strong>44</strong></p>\n<p><strong>注意:</strong></p>\n<!-- 如果你是通过我的博客 [jedsek.xyz](https://jedsek.xyz) 观看的话, 我默认隐藏了这些图片  -->\n<!-- 你可以展开任意一张图片后, 点击图片, 然后可以通过方向键切换图片 :)  -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3960/transparent-top-bar-adjustable-transparency/\">transparent-top-bar(adjustable-transparency)</a><br>\n让顶栏变透明的插件, 当窗口最大化或者与顶栏重叠时, 为了显示清晰会自动重新变回不透明</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/16/auto-move-windows/\">auto-move-windows</a><br>\n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5473/color-app-menu-icon-for-gnome-40/\">color-app-menu-icon</a><br>\n顶栏左上角会显示你当前所在应用的图标与名称</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4937/draw-on-you-screen-2/\">draw-on-your-screen-2</a><br>\n通过设置的快捷键, 让你可以在屏幕上用画笔画画, 在录制视频, 向他人演示, 标记重点的时候非常有用</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/7/removable-drive-menu/\">removable-drive-menu</a><br>\n当你插入u盘之后, 顶栏会出现显示图标, 让你快速访问文件, u盘拔出之后图标自动消失</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/2986/runcat/\">run-cat</a><br>\n在顶栏出现一只奔跑的小猫与 cpu 的利用率, cpu 利用率越高, 小猫跑得越快</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5292/quick-touchpad-toggle/\">quick-touchpad-toggle</a><br>\n在 quick-settings 中增加一个选项, 让你快速启用/禁用触摸板</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/352/middle-click-to-close-in-overview/\">quick-close-in-overview</a><br>\n在 overview 中, 当你的鼠标移动到对应窗口时, 右上角增加一个叉叉, 让你快速关闭窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5522/just-another-search-bar/\">just-another-search-bar</a><br>\n让你自己设置一个快捷键, 按下之后打开一个搜索框, 然后用你的默认浏览器搜索输入内容, 你可以设置搜索引擎(google/bing)<br>\n这个操作在 overview 中也可以做到, 名字都说了是 just-another, 是为了更美观</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/97/coverflow-alt-tab/\">coverflow-alt-tab</a><br>\n让你在使用 <code>super+tab</code>/<code>alt+tab</code> 切换窗口时, 获得好看美观的特效</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4112/customize-ibus/\">customize-iBus</a><br>\nibus 是 gnome 内置的一个输入法, 已经和 fcitx5 差不多了, 默认情况下就已经非常好看了<br>\n你可以使用这个插件, 深度自定义 ibus 的行为, 比如我现在, 打字时就能够让候选框随着我打字的节奏而抖动, 非常爽<br>\n再比如设置中英文切换时, 指示器的显示时间, 抖动效果, 闪烁特效等</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/ibus.png\" alt=\"ibus默认情况下的外表/系统暗色主题\"></p>\n</details>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1411/quake-mode/\">quake-mode</a><br>\n雷神模式!! 该插件可以让你以雷神模式打开一些与快捷键绑定的应用, 即以下拉式打开任意一个app, 全部工作区共享一个app<br>\nquake-mode 配上你喜欢的任意一个终端, 都会产生非常棒的奇效, 具体效果可以点击链接看动图演示即可</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3396/color-picker/\">color-pciker</a><br>\n采色笔, 用来采集颜色, 有相关需求的话非常有用, 没什么好说的</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5425/battery-time/\">battery-time</a><br>\n在 quick-setting 中显示你的电量还可以撑多久</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3991/bluetooth-battery/\">bluetooth-battery-indicator</a><br>\n当你连接蓝牙设备之后, 会在顶栏显示电量</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/\">bluetooth-quick-connect</a><br>\n在 quick-setting 中, 让你快速连接/断开已经配对过的蓝牙设备, 非常有用</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/2935/control-blur-effect-on-lock-screen/\">control-blur-effect-on-lock-screen</a><br>\n锁屏之后, 背景图片会变得模糊(blur), 这个插件可以修改模糊度, 我个人喜欢背景完全不模糊</p>\n</li>\n</ul>\n<!-- Deprecated -->\n<!-- - [refresh-wifi-connections](https://extensions.gnome.org/extension/905/refresh-wifi-connections/) -->\n<!-- 当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键   -->\n<!--  -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![refresh-wifi-connections](/images/gnome/refresh-wifi-connections.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1446/transparent-window-moving/\">transparent-window-moving</a><br>\n在对窗口进行移动/调整大小时, 使窗口变得透明</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3843/just-perfection/\">just-perfection</a><br>\n我最喜欢的一个插件, 用于对界面进行大量自定义与精简<br>\n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview_44.png\" alt=\"just-perfection\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1113/nothing-to-say/\">nothing-to-say</a><br>\n用于切断/恢复声音的输入, 对我来说蛮有用的:<br>\n当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5090/space-bar/\">space-bar</a><br>\n模仿 I3/Sway/Bspwm 等窗口管理器, 在左上角显示工作区, 有些类似的插件, 但个人认为, 这个插件最好</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/space-bar_name.png\" alt=\"space-bar/名称\"><br>\n<img data-src=\"/images/gnome/space-bar_number.png\" alt=\"space-bar/数字\"></p>\n</details>\n<br>\n<!-- Deprecated -->\n<!-- - [workspace-switcher-manager](https://extensions.gnome.org/extension/4788/workspace-switcher-manager/) -->\n<!-- 美化通过键盘(我配成了 `Super + 1..9`), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![workspace-switcher-manager](/images/gnome/workspace-switcher-manager.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/\">disable-workspace-switch-animation-for-GNOME40+</a><br>\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1319/gsconnect/\">gsconnect</a><br>\nGNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>\n手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href=\"/downloads/gnome/kdeconnect.apk\">kdeconnect</a></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gsconnect.png\" alt=\"gsconnect\"></p>\n</details>\n<br>\n<!-- Deprecated -->\n<!-- - [blur-my-shell](https://extensions.gnome.org/extension/3193/blur-my-shell/) -->\n<!-- 用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的插件   -->\n<!-- 但我并不推荐这个插件, 因为修改的东西太多, 和其他插件一起的话, 有概率发生死机等问题   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![blur-my-shell](/images/gnome/overview.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5506/user-avatar-in-quick-settings/\">user-avatar-in-quick-settings</a><br>\n让右上角菜单出现你的头像, 提升美观而已</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/\">gnome40-ui-improvements</a><br>\n按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区, 与下面的插件 <code>v-shell</code>  不兼容, 二选一, 我推荐下面的 <code>v-shell</code></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gnome40-ui-improvements.png\" alt=\"gnome40-ui-improvements\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5177/vertical-workspaces/\">v-shell</a><br>\n按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在左边显示工作区, 同时附赠了各种非常好用的操作, 与上面的 <code>gnome40-ui-improvements</code> 二选一<br>\n当你进入 <code>Overview</code> 后, 按下 <code>space</code> 后可以查询打开的窗口, <code>alt+space</code> 查询最近修改的文件</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview_44.png\" alt=\"v-shell\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/\">gnome-fuzzy-app-search</a><br>\n出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该插件修改行为</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4691/pip-on-top/\">pip-on-top</a><br>\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4792/frequency-boost-switch/\">frequency-boost-switch</a><br>\n在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p>\n</li>\n</ul>\n<!-- Deprecated -->\n<!-- - [overview-navigation](https://extensions.gnome.org/extension/1702/overview-navigation/) -->\n<!-- 当按下 `Super` 进入 `Overview` 后, 可以按下 `空格键`, 窗口上会出现字母   -->\n<!-- 输入小写字母就切换到对应窗口, 按下 `Shift` 会使字母颜色变红, 此时输入字母会关闭对应窗口   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![overview-navigation](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<!-- Deprecated -->\n<!-- - [cleaner-overview](https://extensions.gnome.org/extension/3759/cleaner-overview/) -->\n<!-- 进入 `Overview` 时, 将窗口排列整齐, 简单实用   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![cleaner-overview](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/19/user-themes/\">user-theme</a><br>\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>\n注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br>\n但我个人还是喜欢 GNOME 默认的暗色主题, 默认的就已经非常好看了</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3414/user-stylesheet-font/\">user-syle-sheet</a><br>\n读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"mei-hua\">美化</h1>\n<p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>\n还有很多插件有帮助, 上面 <a href=\"#tui-jian-cha-jian-lie-biao\">推荐插件列表</a> 里有提到, 比如那个更改css的, 这里不说了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动暗模式:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface color-scheme <span class=\"string\">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri-dark <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或将图片命名为.face, 放到家目录</span></span><br><span class=\"line\"><span class=\"comment\"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href=\"https://www.gnome-look.org/\">gnome-look</a> 挑选主题</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以 Nordic 为例子</span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface gtk-theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你也可以使用 `user-theme` 这个插件进行设置:  </span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class=\"line\">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface font-name <span class=\"string\">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell favorite-apps <span class=\"string\">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong><br>\n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 插件<br>\n此插件得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>\n如果你只是使用插件, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href=\"#jin-yong-kuai-jie-jian\">禁用快捷键</a></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装插件: <code>space-bar</code>)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences workspace-names <span class=\"string\">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href=\"#cheng-pin-zhan-shi\">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"kuai-jie-jian\">快捷键</h1>\n<p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p>\n<p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>\n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p>\n<p><strong>注意:</strong><br>\n快捷键部分, 还是推荐通过 <code>gnome-control-center keyboard</code> 打开设置中心的键盘区, 在其中自定义快捷键<br>\n(如果图形界面无法满足你的需求, 你可以再捉摸着, 看看下面的命令行部分, 或许可以帮到你)</p>\n<p>快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突并重置快捷键至默认</p>\n<h2 id=\"cha-zhao-kuai-jie-jian\" id=\"查找快捷键\">查找快捷键</h2>\n<p>首先, 我们得明白如何查找对应的快捷键</p>\n<p>下面的命令会列出极大部分的快捷键:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings list-recursively | grep -E <span class=\"string\">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure>\n<p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>\n如果实在找不到, 一点点看过去也行 😃</p>\n<h2 id=\"jin-yong-kuai-jie-jian\" id=\"禁用快捷键\">禁用快捷键</h2>\n<p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>\n想要禁用该快捷键, 将对应的数组设置为空就行了</p>\n<p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default: Super+&quot;1..9&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    gsettings <span class=\"built_in\">set</span> org.gnome.shell.keybindings switch-to-application-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[]&quot;</span>  </span><br><span class=\"line\"><span class=\"keyword\">done</span>    </span><br></pre></td></tr></table></figure>\n<p>禁用快捷键还可以让你避免冲突, 比如:<br>\n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>\n这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p>\n<p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class=\"string\">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class=\"comment\">#Default: Sup+L</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class=\"string\">&quot;[]&quot;</span> <span class=\"comment\"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"xiu-gai-kuai-jie-jian\" id=\"修改快捷键\">修改快捷键</h2>\n<p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href=\"#tian-jia-kuai-jie-jian\">添加快捷键</a> 不是一个概念<br>\n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Vim 式的按键, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class=\"line\"></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class=\"comment\"># 放左边</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class=\"comment\"># 最大化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class=\"comment\"># 最小化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class=\"string\">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class=\"comment\"># 放右边</span></span><br></pre></td></tr></table></figure>\n<p>对了, 如果你追求平铺式的话, 插件可以满足一部分要求, 但肯定比不上专业的窗管…</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>move, resize, kill 一个窗口:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Move</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Resize</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class=\"string\">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Kill</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings close        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Toggle max</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class=\"comment\">#Default: Alt+F10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Max/Min</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings maximize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings minimize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class=\"comment\">#Default: Super+H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Toggle fullscreen</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class=\"string\">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Show desktop</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class=\"string\">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还有套很重要的快捷键, 就是切换工作区了, 搭配先前提到过的消除过渡动画的插件, 流畅感Max:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[&#x27;&lt;Super&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class=\"variable\">$i</span>   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class=\"string\">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"tian-jia-kuai-jie-jian\" id=\"添加快捷键\">添加快捷键</h2>\n<p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>\n比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p>\n<p>废话不多说, 你按下面照猫画虎, 就阔以了:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gp0=<span class=\"string\">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\">gp1=<span class=\"string\">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\</span></span><br><span class=\"line\"><span class=\"string\">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Custom Keys</span></span><br><span class=\"line\"><span class=\"comment\"># 注意!!!!!!!</span></span><br><span class=\"line\"><span class=\"comment\"># 不要在最后添加逗号</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class=\"string\">&quot;[             \\</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;<span class=\"variable\">$gp0</span>/custom0/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom1/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom2/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom3/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom4/&#x27;      \\</span></span><br><span class=\"line\"><span class=\"string\">]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Terminal</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ name     <span class=\"string\">&#x27;Terminal&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;alacritty&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ binding  <span class=\"string\">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Files</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ name     <span class=\"string\">&#x27;Files&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;nautilus&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ binding  <span class=\"string\">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Browser</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ name     <span class=\"string\">&#x27;Browser&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;firefox&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ binding  <span class=\"string\">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Logout</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3  name     <span class=\"string\">&#x27;Logout&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;gnome-session-quit&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ binding  <span class=\"string\">&#x27;&lt;Super&gt;&lt;Shift&gt;Escape&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Fcitx5 Reload</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom4/ name     <span class=\"string\">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom4/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;fcitx5 -r&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom4/ binding  <span class=\"string\">&#x27;&lt;Alt&gt;&lt;Shift&gt;space&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>上面的一切已经非常非常详细, 但接下来还要解决最后的问题:<br>\n如果你更换了机器/重装了系统, 如何快速恢复先前的工作环境?</p>\n<hr>\n<h1 id=\"jia-zai-pei-zhi\">加载配置</h1>\n<p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>\n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>\n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p>\n<p><strong>注意:</strong><br>\n我相信你还没有忘记, 如何把插件下载下来, 将十几个zip文件放在一个文件夹里面, 然后用bash脚本自动下载安装吧?<br>\n请跳转至上面的 <a href=\"#cong-ming-ling-xing\">安装插件/从命令行</a> 目录</p>\n<h2 id=\"dui-yu-fei-nixos\" id=\"对于非Nixos\">对于非Nixos</h2>\n<p>对于普通的Linux发行版, 直接按下面的方式</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>导出当前的dconf数据到某个文件:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加载/导入某个dconf文件到当前系统:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure>\n<p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>\n同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p>\n<h2 id=\"dui-yu-nixos\" id=\"对于Nixos\">对于Nixos</h2>\n<p>如果你使用 Nixos, 请先确保已经安装了 <a href=\"https://github.com/nix-community/home-manager\">HomeManager</a><br>\nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p>\n<p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>\n请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>\n随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br><span class=\"line\">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure>\n<p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">nixpkgs/</span><br><span class=\"line\">├── gnome</span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.background</span></span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.face</span></span><br><span class=\"line\">│   └── dconf<span class=\"selector-class\">.nix</span></span><br><span class=\"line\">└── home.nix</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">imports</span> = [</span><br><span class=\"line\">  ./gnome/dconf.nix</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>\n这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">picture</span> = ../.background.png; <span class=\"keyword\">in</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri-dark</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">home.file.<span class=\"string\">&quot;.face&quot;</span>.<span class=\"attr\">source</span> = ./.face;</span><br></pre></td></tr></table></figure>\n<p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>\n","site":{"data":{}},"length":15662,"excerpt":"<blockquote>\n<p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p>\n</blockquote>","more":"<h1 id=\"kai-pian-shuo-ming\">开篇说明</h1>\n<p><strong>注意:</strong><br>\n本篇文章的配置皆在注重 <strong>简洁</strong>, <strong>美观</strong>, <strong>高效</strong><br>\n想要平铺式, 炫酷效果, 更多功能的, 请自行配置, 或查看我的另外一篇博客: <a href=\"/posts/desktop-beautify/hyprland\">Hyprland 平铺式</a><br>\n请注意 GNOME 版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>\n目前, 该篇文章的适用 GNOME 版本为: <strong>44</strong>  (<strong>于2023年5月21更新本文</strong>)</p>\n<p><strong>注意:</strong><br>\n如果你是在我的博客上阅读本文, 请善用右侧目录功能</p>\n<hr>\n<h1 id=\"geng-xin-shuo-ming\">更新说明</h1>\n<p><strong>每次更新本文时, 一切更改记录都会放在这里, 方便读者进行版本迁移 (比如从 43 -&gt; 44), 或者发现新的有用的插件</strong><br>\n<strong>版本的不同, 在除了插件方面会有所差异, 其他地方是几乎一样的, 就算真有不一样的地方我也会标注的, 请放心</strong><br>\n<strong>一般来说, 每次更新本文时, 主要更新的是 <a href=\"#tui-jian-cha-jian-lie-biao\">推荐插件列表</a> 这部分, 如果你已经看过本文了, 一般只需要跳转至那一部分即可</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>2023.5.21<br>\n更新了本文版本以适配 GNOME-44<br>\n更新了推荐插件列表及相应配图<br>\n添加了 “gdm下部分设置无法生效” 的解决方法</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>2023年了, GNOME 又靠谱又好用, 但有些人的界面仍处于是十年前的样子…<br>\n我个人认为 <strong>简洁</strong> + <strong>大气</strong> + <strong>美观</strong> 比较重要, 当然你也可以自行修改进行DIY<br>\n如果真的有需求, 请自己动手, 丰衣足食吧! <s>(虽然我认为本文已经详细地不能再详细了)</s></p>\n<p><img data-src=\"/images/gnome/overview_44.png\" alt=\"44(当前版本的图片)\"><br>\n<img data-src=\"/images/gnome/overview_42.png\" alt=\"42(旧版本的保留图片)\"></p>\n<hr>\n<h1 id=\"shi-yong-gong-ju-shuo-ming\">使用工具说明</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>dconf</code>:<br>\n是一套基于键的配置系统, 十分高效, 你可以将其视作 Windows 下的注册表, 但修改起来非常简单</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>gsettings</code>:<br>\n是 GNOME 下的高级API, 是一个命令行工具, 用来简化对 dconf 的操作</p>\n</li>\n</ul>\n<p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>\n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p>\n<p>接下来的大部分配置, 都会使用 <code>gsettings</code> 在命令行中进行操作</p>\n<p>当然, 你也可以通过图形化界面, 比如 <code>gnome-control-center</code> 进行设置, 但有一些东西是界面里不存在/无法调整的<br>\n同时, 为了方便读者进行复制粘贴, 特此写成命令形式 <s>(快说蟹蟹!!)</s></p>\n<hr>\n<h1 id=\"chang-yong-she-zhi\">常用设置</h1>\n<p>以下是各种方面的设置, 直接复制粘贴, 有些地方进行下修改, 适配自己情况即可</p>\n<h2 id=\"hong-mo-ban\" id=\"触摸板\">触摸板</h2>\n<p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p>\n<p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>\n这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p>\n<p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>\n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>\n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p>\n<p>你可以在终端输入如下命令进行调整:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class=\"literal\">true</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>分别对应:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>轻击模拟鼠标点击, 默认为false</p>\n</li>\n<li class=\"lvl-2\">\n<p>调整触摸板速度, 默认为0</p>\n</li>\n<li class=\"lvl-2\">\n<p>打字时禁用触摸板, 默认为true</p>\n</li>\n</ul>\n<p>常用手势:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单指: 移动鼠标</p>\n</li>\n<li class=\"lvl-2\">\n<p>双指上下: 翻页</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指左右: 切换Workspace</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指上: 打开Overview (不常用, 按Super更快)</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指下: 显示任务栏 (当你隐藏任务栏时)</p>\n</li>\n</ul>\n<p>(安装一些插件后, 相关快捷键可能会发生改变)</p>\n<h2 id=\"chuang-kou-yu-gong-zuo-qu\" id=\"窗口与工作区\">窗口与工作区</h2>\n<p>我个人喜欢将工作区设置为静态, 也就是禁止动态工作区, 防止窗口自由移动, 同时将工作区设置为10个:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter dynamic-workspaces <span class=\"literal\">false</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences num-workspaces 10</span><br></pre></td></tr></table></figure>\n<p>(Mutter 是 GNOME 自己的窗口管理器)</p>\n<p>对于快捷键, 你可以自定义窗口的最大化/最小化/全屏/隐藏/更改大小/移动, 与有关工作区的部分<br>\n鉴于这一部分属于设置快捷键系列, 请您移动至本文后面的 <strong><a href=\"#xiu-gai-kuai-jie-jian\">修改快捷键</a></strong> 目录</p>\n<p>举个例子:<br>\n比如 “move window”, 普通来讲你可能会双击窗口的标题栏, 然后拖动窗口进行移动, 但你完全可以将这个操作绑定在快捷键 “Super+x” 上<br>\n然后按一次该快捷键, 进入 “move mode”, 移动完毕之后再按一次(或者点击一下), 就可以确定窗口位置<br>\n如果你不满意, 可以按一下 <code>Esc</code>, 恢复到初始位置</p>\n<p>还有很多操作, 比如移动某个窗口至指定工作区, 或者切换至某个工作区, 就像是使用着类似 “i3/sway/hyprland” 等 “window manager” 一样的体验</p>\n<hr>\n<h1 id=\"gdm\">GDM</h1>\n<p>稍微说明下, 如果你在登陆之后使用 gsettings 进行的设置, 无法在 GDM 中生效时, 极大概率是用户与权限问题</p>\n<p>比如, 你发现触摸板明明已经设置了轻触模拟点击, 但在 GDM 中无效, 那就指定 <code>gdm</code> 用户, 再设置一遍即可:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">xhost +SI:localuser:gdm</span><br><span class=\"line\">sudo -u gdm gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class=\"literal\">true</span></span><br><span class=\"line\">sudo -u gdm gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class=\"line\">sudo -u gdm gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"cha-jian\">插件</h1>\n<h2 id=\"an-zhuang-cha-jian\" id=\"安装插件\">安装插件</h2>\n<p>GNOME 的插件(Extensions)是其重要的组成, 赋予了随意组合的 <strong>自由</strong> 与 <strong>强大</strong>, 说是 GNOME 一半的 <strong>灵魂</strong> 所在, 也不为过之<br>\n我将先介绍如何安装/使用它们, 因为后面需要用到插件</p>\n<p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>\n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p>\n<h3 id=\"cong-ming-ling-xing\" id=\"从命令行\">从命令行</h3>\n<p><strong>提示</strong><br>\n请确保拥有以下命令: <code>unzip</code>, <code>jq</code>, 有些发行版默认连 <code>unzip</code> 都没有…<br>\n下载成功后, 切记要 logout, 然后再登进来, 运行 <code>gnome-session-quit</code> 即可</p>\n<p>每个GNOME插件都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载插件</p>\n<p>你可以在 <a href=\"https://extensions.gnome.org/\">Extensions-GNOME</a> 这个网站上, 浏览并下载插件<br>\n请将以 .zip 结尾的插件放在同一目录下, 假设该目录叫 <code>exts_list</code></p>\n<p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p>\n<div class=\"tabs\" id=\"install-extensions\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#install-extensions-1\">Bash</a></li><li class=\"tab\"><a href=\"#install-extensions-2\">Fish</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"install-extensions-1\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a UUID_LIST</span><br><span class=\"line\">EXTS_DIR=<span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions</span><br><span class=\"line\">EXTS_LIST=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">str_join</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;$*&quot;</span> | sed <span class=\"string\">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$EXTS_DIR</span></span><br><span class=\"line\">chmod -R 755 <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/</span><br><span class=\"line\"><span class=\"keyword\">for</span> EXT <span class=\"keyword\">in</span> <span class=\"variable\">$EXTS_LIST</span>/*.zip</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  UUID=$(unzip -p <span class=\"variable\">$EXT</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span>)</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$EXT</span> -d <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  UUID_LIST+=<span class=\"string\">&quot;\\&quot;<span class=\"variable\">$UUID</span>\\&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">UUID_LIST=[$(str_join <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"install-extensions-2\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> exts_list <span class=\"variable\">$argv</span>[1]</span><br><span class=\"line\"><span class=\"built_in\">set</span> exts_dir <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$exts_dir</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ext <span class=\"keyword\">in</span> exts_list/*.zip</span><br><span class=\"line\">  <span class=\"built_in\">set</span> uuid ( unzip -p <span class=\"variable\">$ext</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span> )</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$ext</span> -d <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  <span class=\"built_in\">set</span> -a uuid_list \\<span class=\"string\">&#x27;$uuid\\&#x27;</span></span><br><span class=\"line\">end</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list [( string join <span class=\"string\">&quot;,&quot;</span> <span class=\"variable\">$uuid_list</span> )]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div>\n<p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p>\n<p><strong>注意: 先logout, 再登进来</strong></p>\n<p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dbus-send --<span class=\"built_in\">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \\</span><br><span class=\"line\">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class=\"string\">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"cong-liu-lan-qi\" id=\"从浏览器\">从浏览器</h3>\n<p>该方法其实也蛮方便的, 但不适合快速部署<br>\n你需要安装两个玩意, 才能直接从 <a href=\"https://extensions.gnome.org/\">Extension-GNOME</a> 上直接下载</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>chrome-gnome-shell</code>:<br>\n本地软件, 你可以通过包管理器, 直接搜这个名字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>GNOME Shell integration</code>:<br>\n浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>\nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p>\n</li>\n</ul>\n<p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href=\"https://extensions.gnome.org/\">网站</a> 上 直接安装到本地</p>\n<hr>\n<h2 id=\"cha-kan-yu-pei-zhi-cha-jian\" id=\"查看与配置插件\">查看与配置插件</h2>\n<p>此处推荐使用浏览器来设置插件, 在 <a href=\"https://extensions.gnome.org/local/\">https://extensions.gnome.org/local/</a> 页面管理与配置插件</p>\n<p>如果你想通过命令行, 则可以使用 <code>gnome-extensions</code> 这个命令, 来查看并配置插件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取帮助, `Command` 为可选项</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">help</span> [Command]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看插件列表</span></span><br><span class=\"line\">gnome-extensions list --user    <span class=\"comment\"># 查看用户级插件</span></span><br><span class=\"line\">gnome-extensions list --system  <span class=\"comment\"># 查看系统级插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看插件的信息</span></span><br><span class=\"line\">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用/禁用某个插件</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置某个插件 (打开 GUI 界面)</span></span><br><span class=\"line\">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure>\n<p>或者通过 <code>gsettings</code> 来配置某个插件, 但不推荐, 因为麻烦:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看某个插件的所有选项</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 得到/重置/设置 某个插件的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class=\"line\"><span class=\"comment\"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class=\"line\"><span class=\"comment\"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure>\n<p>你可以在已经配置好插件的机器上, 导出 <code>dconf.settings</code> 文件, 并在新机器上加载它, 避免更换机器/重装系统之后再次设置插件<br>\n详情请见 <a href=\"#jia-zai-pei-zhi\"><strong>加载配置</strong></a></p>\n<hr>\n<h1 id=\"tui-jian-cha-jian-lie-biao\">推荐插件列表</h1>\n<p>以下是我目前正在使用且推荐的插件, 适用版本为 <strong>44</strong></p>\n<p><strong>注意:</strong></p>\n<!-- 如果你是通过我的博客 [jedsek.xyz](https://jedsek.xyz) 观看的话, 我默认隐藏了这些图片  -->\n<!-- 你可以展开任意一张图片后, 点击图片, 然后可以通过方向键切换图片 :)  -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3960/transparent-top-bar-adjustable-transparency/\">transparent-top-bar(adjustable-transparency)</a><br>\n让顶栏变透明的插件, 当窗口最大化或者与顶栏重叠时, 为了显示清晰会自动重新变回不透明</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/16/auto-move-windows/\">auto-move-windows</a><br>\n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5473/color-app-menu-icon-for-gnome-40/\">color-app-menu-icon</a><br>\n顶栏左上角会显示你当前所在应用的图标与名称</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4937/draw-on-you-screen-2/\">draw-on-your-screen-2</a><br>\n通过设置的快捷键, 让你可以在屏幕上用画笔画画, 在录制视频, 向他人演示, 标记重点的时候非常有用</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/7/removable-drive-menu/\">removable-drive-menu</a><br>\n当你插入u盘之后, 顶栏会出现显示图标, 让你快速访问文件, u盘拔出之后图标自动消失</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/2986/runcat/\">run-cat</a><br>\n在顶栏出现一只奔跑的小猫与 cpu 的利用率, cpu 利用率越高, 小猫跑得越快</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5292/quick-touchpad-toggle/\">quick-touchpad-toggle</a><br>\n在 quick-settings 中增加一个选项, 让你快速启用/禁用触摸板</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/352/middle-click-to-close-in-overview/\">quick-close-in-overview</a><br>\n在 overview 中, 当你的鼠标移动到对应窗口时, 右上角增加一个叉叉, 让你快速关闭窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5522/just-another-search-bar/\">just-another-search-bar</a><br>\n让你自己设置一个快捷键, 按下之后打开一个搜索框, 然后用你的默认浏览器搜索输入内容, 你可以设置搜索引擎(google/bing)<br>\n这个操作在 overview 中也可以做到, 名字都说了是 just-another, 是为了更美观</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/97/coverflow-alt-tab/\">coverflow-alt-tab</a><br>\n让你在使用 <code>super+tab</code>/<code>alt+tab</code> 切换窗口时, 获得好看美观的特效</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4112/customize-ibus/\">customize-iBus</a><br>\nibus 是 gnome 内置的一个输入法, 已经和 fcitx5 差不多了, 默认情况下就已经非常好看了<br>\n你可以使用这个插件, 深度自定义 ibus 的行为, 比如我现在, 打字时就能够让候选框随着我打字的节奏而抖动, 非常爽<br>\n再比如设置中英文切换时, 指示器的显示时间, 抖动效果, 闪烁特效等</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/ibus.png\" alt=\"ibus默认情况下的外表/系统暗色主题\"></p>\n</details>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1411/quake-mode/\">quake-mode</a><br>\n雷神模式!! 该插件可以让你以雷神模式打开一些与快捷键绑定的应用, 即以下拉式打开任意一个app, 全部工作区共享一个app<br>\nquake-mode 配上你喜欢的任意一个终端, 都会产生非常棒的奇效, 具体效果可以点击链接看动图演示即可</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3396/color-picker/\">color-pciker</a><br>\n采色笔, 用来采集颜色, 有相关需求的话非常有用, 没什么好说的</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5425/battery-time/\">battery-time</a><br>\n在 quick-setting 中显示你的电量还可以撑多久</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3991/bluetooth-battery/\">bluetooth-battery-indicator</a><br>\n当你连接蓝牙设备之后, 会在顶栏显示电量</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1401/bluetooth-quick-connect/\">bluetooth-quick-connect</a><br>\n在 quick-setting 中, 让你快速连接/断开已经配对过的蓝牙设备, 非常有用</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/2935/control-blur-effect-on-lock-screen/\">control-blur-effect-on-lock-screen</a><br>\n锁屏之后, 背景图片会变得模糊(blur), 这个插件可以修改模糊度, 我个人喜欢背景完全不模糊</p>\n</li>\n</ul>\n<!-- Deprecated -->\n<!-- - [refresh-wifi-connections](https://extensions.gnome.org/extension/905/refresh-wifi-connections/) -->\n<!-- 当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键   -->\n<!--  -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![refresh-wifi-connections](/images/gnome/refresh-wifi-connections.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1446/transparent-window-moving/\">transparent-window-moving</a><br>\n在对窗口进行移动/调整大小时, 使窗口变得透明</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3843/just-perfection/\">just-perfection</a><br>\n我最喜欢的一个插件, 用于对界面进行大量自定义与精简<br>\n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview_44.png\" alt=\"just-perfection\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1113/nothing-to-say/\">nothing-to-say</a><br>\n用于切断/恢复声音的输入, 对我来说蛮有用的:<br>\n当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5090/space-bar/\">space-bar</a><br>\n模仿 I3/Sway/Bspwm 等窗口管理器, 在左上角显示工作区, 有些类似的插件, 但个人认为, 这个插件最好</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/space-bar_name.png\" alt=\"space-bar/名称\"><br>\n<img data-src=\"/images/gnome/space-bar_number.png\" alt=\"space-bar/数字\"></p>\n</details>\n<br>\n<!-- Deprecated -->\n<!-- - [workspace-switcher-manager](https://extensions.gnome.org/extension/4788/workspace-switcher-manager/) -->\n<!-- 美化通过键盘(我配成了 `Super + 1..9`), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![workspace-switcher-manager](/images/gnome/workspace-switcher-manager.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/\">disable-workspace-switch-animation-for-GNOME40+</a><br>\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1319/gsconnect/\">gsconnect</a><br>\nGNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>\n手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href=\"/downloads/gnome/kdeconnect.apk\">kdeconnect</a></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gsconnect.png\" alt=\"gsconnect\"></p>\n</details>\n<br>\n<!-- Deprecated -->\n<!-- - [blur-my-shell](https://extensions.gnome.org/extension/3193/blur-my-shell/) -->\n<!-- 用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的插件   -->\n<!-- 但我并不推荐这个插件, 因为修改的东西太多, 和其他插件一起的话, 有概率发生死机等问题   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![blur-my-shell](/images/gnome/overview.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5506/user-avatar-in-quick-settings/\">user-avatar-in-quick-settings</a><br>\n让右上角菜单出现你的头像, 提升美观而已</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/\">gnome40-ui-improvements</a><br>\n按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区, 与下面的插件 <code>v-shell</code>  不兼容, 二选一, 我推荐下面的 <code>v-shell</code></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gnome40-ui-improvements.png\" alt=\"gnome40-ui-improvements\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5177/vertical-workspaces/\">v-shell</a><br>\n按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在左边显示工作区, 同时附赠了各种非常好用的操作, 与上面的 <code>gnome40-ui-improvements</code> 二选一<br>\n当你进入 <code>Overview</code> 后, 按下 <code>space</code> 后可以查询打开的窗口, <code>alt+space</code> 查询最近修改的文件</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview_44.png\" alt=\"v-shell\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/\">gnome-fuzzy-app-search</a><br>\n出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该插件修改行为</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4691/pip-on-top/\">pip-on-top</a><br>\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4792/frequency-boost-switch/\">frequency-boost-switch</a><br>\n在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p>\n</li>\n</ul>\n<!-- Deprecated -->\n<!-- - [overview-navigation](https://extensions.gnome.org/extension/1702/overview-navigation/) -->\n<!-- 当按下 `Super` 进入 `Overview` 后, 可以按下 `空格键`, 窗口上会出现字母   -->\n<!-- 输入小写字母就切换到对应窗口, 按下 `Shift` 会使字母颜色变红, 此时输入字母会关闭对应窗口   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![overview-navigation](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<!-- Deprecated -->\n<!-- - [cleaner-overview](https://extensions.gnome.org/extension/3759/cleaner-overview/) -->\n<!-- 进入 `Overview` 时, 将窗口排列整齐, 简单实用   -->\n<!-- >>> **点击展开/隐藏图片** -->\n<!-- ![cleaner-overview](/images/gnome/overview-navigation.png) -->\n<!-- >>> -->\n<!--  -->\n<!-- <br> -->\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/19/user-themes/\">user-theme</a><br>\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>\n注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br>\n但我个人还是喜欢 GNOME 默认的暗色主题, 默认的就已经非常好看了</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3414/user-stylesheet-font/\">user-syle-sheet</a><br>\n读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"mei-hua\">美化</h1>\n<p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>\n还有很多插件有帮助, 上面 <a href=\"#tui-jian-cha-jian-lie-biao\">推荐插件列表</a> 里有提到, 比如那个更改css的, 这里不说了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动暗模式:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface color-scheme <span class=\"string\">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri-dark <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或将图片命名为.face, 放到家目录</span></span><br><span class=\"line\"><span class=\"comment\"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href=\"https://www.gnome-look.org/\">gnome-look</a> 挑选主题</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以 Nordic 为例子</span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface gtk-theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你也可以使用 `user-theme` 这个插件进行设置:  </span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class=\"line\">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface font-name <span class=\"string\">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell favorite-apps <span class=\"string\">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong><br>\n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 插件<br>\n此插件得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>\n如果你只是使用插件, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href=\"#jin-yong-kuai-jie-jian\">禁用快捷键</a></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装插件: <code>space-bar</code>)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences workspace-names <span class=\"string\">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href=\"#cheng-pin-zhan-shi\">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"kuai-jie-jian\">快捷键</h1>\n<p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p>\n<p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>\n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p>\n<p><strong>注意:</strong><br>\n快捷键部分, 还是推荐通过 <code>gnome-control-center keyboard</code> 打开设置中心的键盘区, 在其中自定义快捷键<br>\n(如果图形界面无法满足你的需求, 你可以再捉摸着, 看看下面的命令行部分, 或许可以帮到你)</p>\n<p>快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突并重置快捷键至默认</p>\n<h2 id=\"cha-zhao-kuai-jie-jian\" id=\"查找快捷键\">查找快捷键</h2>\n<p>首先, 我们得明白如何查找对应的快捷键</p>\n<p>下面的命令会列出极大部分的快捷键:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings list-recursively | grep -E <span class=\"string\">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure>\n<p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>\n如果实在找不到, 一点点看过去也行 😃</p>\n<h2 id=\"jin-yong-kuai-jie-jian\" id=\"禁用快捷键\">禁用快捷键</h2>\n<p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>\n想要禁用该快捷键, 将对应的数组设置为空就行了</p>\n<p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default: Super+&quot;1..9&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    gsettings <span class=\"built_in\">set</span> org.gnome.shell.keybindings switch-to-application-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[]&quot;</span>  </span><br><span class=\"line\"><span class=\"keyword\">done</span>    </span><br></pre></td></tr></table></figure>\n<p>禁用快捷键还可以让你避免冲突, 比如:<br>\n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>\n这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p>\n<p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class=\"string\">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class=\"comment\">#Default: Sup+L</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class=\"string\">&quot;[]&quot;</span> <span class=\"comment\"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"xiu-gai-kuai-jie-jian\" id=\"修改快捷键\">修改快捷键</h2>\n<p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href=\"#tian-jia-kuai-jie-jian\">添加快捷键</a> 不是一个概念<br>\n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Vim 式的按键, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class=\"line\"></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class=\"comment\"># 放左边</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class=\"comment\"># 最大化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class=\"comment\"># 最小化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class=\"string\">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class=\"comment\"># 放右边</span></span><br></pre></td></tr></table></figure>\n<p>对了, 如果你追求平铺式的话, 插件可以满足一部分要求, 但肯定比不上专业的窗管…</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>move, resize, kill 一个窗口:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Move</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Resize</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class=\"string\">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Kill</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings close        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Toggle max</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class=\"comment\">#Default: Alt+F10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Max/Min</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings maximize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings minimize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class=\"comment\">#Default: Super+H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Toggle fullscreen</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class=\"string\">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Show desktop</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class=\"string\">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还有套很重要的快捷键, 就是切换工作区了, 搭配先前提到过的消除过渡动画的插件, 流畅感Max:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[&#x27;&lt;Super&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class=\"variable\">$i</span>   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class=\"string\">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"tian-jia-kuai-jie-jian\" id=\"添加快捷键\">添加快捷键</h2>\n<p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>\n比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p>\n<p>废话不多说, 你按下面照猫画虎, 就阔以了:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gp0=<span class=\"string\">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\">gp1=<span class=\"string\">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\</span></span><br><span class=\"line\"><span class=\"string\">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Custom Keys</span></span><br><span class=\"line\"><span class=\"comment\"># 注意!!!!!!!</span></span><br><span class=\"line\"><span class=\"comment\"># 不要在最后添加逗号</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class=\"string\">&quot;[             \\</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;<span class=\"variable\">$gp0</span>/custom0/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom1/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom2/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom3/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom4/&#x27;      \\</span></span><br><span class=\"line\"><span class=\"string\">]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Terminal</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ name     <span class=\"string\">&#x27;Terminal&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;alacritty&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ binding  <span class=\"string\">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Files</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ name     <span class=\"string\">&#x27;Files&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;nautilus&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ binding  <span class=\"string\">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Browser</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ name     <span class=\"string\">&#x27;Browser&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;firefox&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ binding  <span class=\"string\">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Logout</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3  name     <span class=\"string\">&#x27;Logout&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;gnome-session-quit&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ binding  <span class=\"string\">&#x27;&lt;Super&gt;&lt;Shift&gt;Escape&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Fcitx5 Reload</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom4/ name     <span class=\"string\">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom4/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;fcitx5 -r&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom4/ binding  <span class=\"string\">&#x27;&lt;Alt&gt;&lt;Shift&gt;space&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>上面的一切已经非常非常详细, 但接下来还要解决最后的问题:<br>\n如果你更换了机器/重装了系统, 如何快速恢复先前的工作环境?</p>\n<hr>\n<h1 id=\"jia-zai-pei-zhi\">加载配置</h1>\n<p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>\n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>\n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p>\n<p><strong>注意:</strong><br>\n我相信你还没有忘记, 如何把插件下载下来, 将十几个zip文件放在一个文件夹里面, 然后用bash脚本自动下载安装吧?<br>\n请跳转至上面的 <a href=\"#cong-ming-ling-xing\">安装插件/从命令行</a> 目录</p>\n<h2 id=\"dui-yu-fei-nixos\" id=\"对于非Nixos\">对于非Nixos</h2>\n<p>对于普通的Linux发行版, 直接按下面的方式</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>导出当前的dconf数据到某个文件:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加载/导入某个dconf文件到当前系统:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure>\n<p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>\n同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p>\n<h2 id=\"dui-yu-nixos\" id=\"对于Nixos\">对于Nixos</h2>\n<p>如果你使用 Nixos, 请先确保已经安装了 <a href=\"https://github.com/nix-community/home-manager\">HomeManager</a><br>\nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p>\n<p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>\n请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>\n随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br><span class=\"line\">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure>\n<p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">nixpkgs/</span><br><span class=\"line\">├── gnome</span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.background</span></span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.face</span></span><br><span class=\"line\">│   └── dconf<span class=\"selector-class\">.nix</span></span><br><span class=\"line\">└── home.nix</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">imports</span> = [</span><br><span class=\"line\">  ./gnome/dconf.nix</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>\n这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">picture</span> = ../.background.png; <span class=\"keyword\">in</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri-dark</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">home.file.<span class=\"string\">&quot;.face&quot;</span>.<span class=\"attr\">source</span> = ./.face;</span><br></pre></td></tr></table></figure>\n<p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>"},{"title":"Hyprland 平铺式","abbrlink":"posts/desktop-beautify/hyprland","hidden":false,"date":"2022-12-10T09:46:21.000Z","top":99998,"keywords":["Linux","Hyprland","Waylnad","Desktop"],"is_series":true,"prev_post":["posts/desktop-beautify/gnome","GNOME 入坑指南"],"_content":"> Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户\n<!-- more -->\n","source":"_posts/desktop-beautify/hyprland.md","raw":"---\ntitle: \"Hyprland 平铺式\"\nabbrlink: posts/desktop-beautify/hyprland\nhidden: false\ndate: 2022-12-10 17:46:21\ntop: 99998\ntags: [Linux, Hyprland, Waylnad, Desktop]\nkeywords: [Linux, Hyprland, Waylnad, Desktop]\nis_series: true\nprev_post: [posts/desktop-beautify/gnome, GNOME 入坑指南]\n---\n> Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户\n<!-- more -->\n","slug":"desktop-beautify/hyprland","published":1,"updated":"2022-12-10T09:46:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ofz0003j1s6aacmdbgw","content":"<blockquote>\n<p>Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":58,"excerpt":"<blockquote>\n<p>Wayland/Linux 下的炫酷窗管/混合器: Hyprland, 拥有丰富的特性集, 适合追求高度自由与极致性能的用户</p>\n</blockquote>","more":""},{"title":"high-school-it-p1~> 数据与信息","abbrlink":"posts/high-school-it/p1","hidden":false,"date":"2022-09-10T13:05:57.000Z","top":7999,"keywords":["高中信息技术","python"],"is_series":true,"next_post":["/posts/high-school-it/p2","p2~> 基础科普"],"_content":"> 本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别\n<!-- more -->\n我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念  \n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普  \n\n# 数据的定义\n数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等  \n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等  \n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:  \n\n- 你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解  \n- 你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解  \n\n上面的两种情况中:  \n\n- `记载在纸上的相对论的文字` 就是数据, 属于客观层面\n- `山顶洞人/科学家` 看见相对论的两种态度, 属于主观层面\n\n没有主观层面上的理解, 数据便只是一张废纸, 毫无意义  \n\n- - -\n# 信息的定义\n虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)  \n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义  \n\n信息论之父, 香农, 对此就有一套理解: \"信息是用来消除随机不确定性的东西\", 这通常被看作经典定义  \n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:  \n\n- 这是一台电脑笔记本\n- 这是一台屏幕大小为15.6英寸的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本\n\n你会看到, 信息越多, 越能消除随机不确定性  \n\n- - -\n\n# 信息的特征\n我们通过香农对信息的定义, 与一个例子, 大概懂得了 \"信息是用来消除随机不确定性的东西\"  \n但我们还得了解更多关于\"信息\"的信息, 来完善\"信息\"的定义, 来加速理解  \n\n下面是信息的5个特征, 教科书上搬的:  \n\n- 载体依附性  \n信息不能独立存在, 它是虚的, 必须有载体  \n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失  \n\n- 不损耗性\n信息在传播的过程中, 是不会发生损耗的\n\n- 时效性  \n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变  \n比如 \"太阳亮着\" 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?  \n\n- 共享性  \n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗  \n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的  \n\n- 可加工处理性/真伪性  \n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人  \n在比如 `盲人摸象/管中窥豹`, 都体现了真伪性  \n\n- 价值性  \n比如天气预报让你出门避免被雨淋湿, 这就是价值  \n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值\n\n- - -\n\n# 知识的定义\n不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和\n它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的  \n指的是人们已经掌握的能力\n\n这部分很简单, 简单概述即可, 但请注意不要与下面的 `智慧的定义搞错了`  \n- - -\n\n# 智慧的定义\n一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力\n\n- - -\n\n# 总结\n以下是一个很好的, 对三者进行了区分的例子:\n\n- 数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号\n- 信息: 人们知道圆周率就是3.1415926\n- 知识: 人们知道如何求解圆的面积来解决现实问题\n- 智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术\n\n这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了  \n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新...\n","source":"_posts/high-school-it/p1-数据与信息.md","raw":"---\ntitle: \"high-school-it-p1~> 数据与信息\"\nabbrlink: posts/high-school-it/p1\nhidden: false\ndate: 2022-09-10 21:05:57\ntop: 7999\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\nis_series: true\nnext_post: [/posts/high-school-it/p2, \"p2~> 基础科普\"]\n---\n> 本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别\n<!-- more -->\n我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念  \n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普  \n\n# 数据的定义\n数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等  \n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等  \n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:  \n\n- 你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解  \n- 你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解  \n\n上面的两种情况中:  \n\n- `记载在纸上的相对论的文字` 就是数据, 属于客观层面\n- `山顶洞人/科学家` 看见相对论的两种态度, 属于主观层面\n\n没有主观层面上的理解, 数据便只是一张废纸, 毫无意义  \n\n- - -\n# 信息的定义\n虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)  \n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义  \n\n信息论之父, 香农, 对此就有一套理解: \"信息是用来消除随机不确定性的东西\", 这通常被看作经典定义  \n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:  \n\n- 这是一台电脑笔记本\n- 这是一台屏幕大小为15.6英寸的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本\n\n你会看到, 信息越多, 越能消除随机不确定性  \n\n- - -\n\n# 信息的特征\n我们通过香农对信息的定义, 与一个例子, 大概懂得了 \"信息是用来消除随机不确定性的东西\"  \n但我们还得了解更多关于\"信息\"的信息, 来完善\"信息\"的定义, 来加速理解  \n\n下面是信息的5个特征, 教科书上搬的:  \n\n- 载体依附性  \n信息不能独立存在, 它是虚的, 必须有载体  \n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失  \n\n- 不损耗性\n信息在传播的过程中, 是不会发生损耗的\n\n- 时效性  \n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变  \n比如 \"太阳亮着\" 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?  \n\n- 共享性  \n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗  \n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的  \n\n- 可加工处理性/真伪性  \n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人  \n在比如 `盲人摸象/管中窥豹`, 都体现了真伪性  \n\n- 价值性  \n比如天气预报让你出门避免被雨淋湿, 这就是价值  \n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值\n\n- - -\n\n# 知识的定义\n不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和\n它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的  \n指的是人们已经掌握的能力\n\n这部分很简单, 简单概述即可, 但请注意不要与下面的 `智慧的定义搞错了`  \n- - -\n\n# 智慧的定义\n一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力\n\n- - -\n\n# 总结\n以下是一个很好的, 对三者进行了区分的例子:\n\n- 数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号\n- 信息: 人们知道圆周率就是3.1415926\n- 知识: 人们知道如何求解圆的面积来解决现实问题\n- 智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术\n\n这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了  \n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新...\n","slug":"high-school-it/p1-数据与信息","published":1,"updated":"2022-09-10T13:05:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og20005j1s65beo3uy4","content":"<blockquote>\n<p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>\n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p>\n<h1 id=\"shu-ju-de-ding-yi\">数据的定义</h1>\n<p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>\n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>\n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p>\n</li>\n<li class=\"lvl-2\">\n<p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p>\n</li>\n</ul>\n<p>上面的两种情况中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p>\n</li>\n</ul>\n<p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p>\n<hr>\n<h1 id=\"xin-xi-de-ding-yi\">信息的定义</h1>\n<p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>\n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p>\n<p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>\n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这是一台电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p>\n</li>\n</ul>\n<p>你会看到, 信息越多, 越能消除随机不确定性</p>\n<hr>\n<h1 id=\"xin-xi-de-te-zheng\">信息的特征</h1>\n<p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>\n但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p>\n<p>下面是信息的5个特征, 教科书上搬的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>载体依附性<br>\n信息不能独立存在, 它是虚的, 必须有载体<br>\n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>不损耗性信息在传播的过程中, 是不会发生损耗的</p>\n</li>\n<li class=\"lvl-2\">\n<p>时效性<br>\n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>\n比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p>\n</li>\n<li class=\"lvl-2\">\n<p>共享性<br>\n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>\n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p>\n</li>\n<li class=\"lvl-2\">\n<p>可加工处理性/真伪性<br>\n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>\n在比如 <code>盲人摸象/管中窥豹</code>, 都体现了真伪性</p>\n</li>\n<li class=\"lvl-2\">\n<p>价值性<br>\n比如天气预报让你出门避免被雨淋湿, 这就是价值<br>\n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"zhi-shi-de-ding-yi\">知识的定义</h1>\n<p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的<br>\n指的是人们已经掌握的能力</p>\n<p>这部分很简单, 简单概述即可, 但请注意不要与下面的 <code>智慧的定义搞错了</code></p>\n<hr>\n<h1 id=\"zhi-hui-de-ding-yi\">智慧的定义</h1>\n<p>一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力</p>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<p>以下是一个很好的, 对三者进行了区分的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p>\n</li>\n<li class=\"lvl-2\">\n<p>信息: 人们知道圆周率就是3.1415926</p>\n</li>\n<li class=\"lvl-2\">\n<p>知识: 人们知道如何求解圆的面积来解决现实问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术</p>\n</li>\n</ul>\n<p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>\n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>\n","site":{"data":{}},"length":1556,"excerpt":"<blockquote>\n<p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p>\n</blockquote>","more":"<p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>\n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p>\n<h1 id=\"shu-ju-de-ding-yi\">数据的定义</h1>\n<p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>\n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>\n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p>\n</li>\n<li class=\"lvl-2\">\n<p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p>\n</li>\n</ul>\n<p>上面的两种情况中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p>\n</li>\n</ul>\n<p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p>\n<hr>\n<h1 id=\"xin-xi-de-ding-yi\">信息的定义</h1>\n<p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>\n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p>\n<p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>\n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这是一台电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p>\n</li>\n</ul>\n<p>你会看到, 信息越多, 越能消除随机不确定性</p>\n<hr>\n<h1 id=\"xin-xi-de-te-zheng\">信息的特征</h1>\n<p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>\n但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p>\n<p>下面是信息的5个特征, 教科书上搬的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>载体依附性<br>\n信息不能独立存在, 它是虚的, 必须有载体<br>\n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>不损耗性信息在传播的过程中, 是不会发生损耗的</p>\n</li>\n<li class=\"lvl-2\">\n<p>时效性<br>\n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>\n比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p>\n</li>\n<li class=\"lvl-2\">\n<p>共享性<br>\n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>\n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p>\n</li>\n<li class=\"lvl-2\">\n<p>可加工处理性/真伪性<br>\n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>\n在比如 <code>盲人摸象/管中窥豹</code>, 都体现了真伪性</p>\n</li>\n<li class=\"lvl-2\">\n<p>价值性<br>\n比如天气预报让你出门避免被雨淋湿, 这就是价值<br>\n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"zhi-shi-de-ding-yi\">知识的定义</h1>\n<p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的<br>\n指的是人们已经掌握的能力</p>\n<p>这部分很简单, 简单概述即可, 但请注意不要与下面的 <code>智慧的定义搞错了</code></p>\n<hr>\n<h1 id=\"zhi-hui-de-ding-yi\">智慧的定义</h1>\n<p>一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力</p>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<p>以下是一个很好的, 对三者进行了区分的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p>\n</li>\n<li class=\"lvl-2\">\n<p>信息: 人们知道圆周率就是3.1415926</p>\n</li>\n<li class=\"lvl-2\">\n<p>知识: 人们知道如何求解圆的面积来解决现实问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术</p>\n</li>\n</ul>\n<p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>\n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>"},{"title":"high-school-it-p2~> 基础科普","abbrlink":"posts/high-school-it/p2","hidden":false,"date":"2022-09-11T12:51:16.000Z","top":7998,"keywords":["高中信息技术","python"],"is_series":true,"prev_post":["/posts/high-school-it/p1","p1~> 数据与信息"],"next_post":["/posts/high-school-it/p3","p3~> python基础语法-part1"],"_content":"> 让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!\n<!-- more -->\n\n**注意:**  \n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解  \n\n\n# 编译与解释\n计算机是二进制的, 只认识二进制, 但你不可能手写二进制  \nc/cpp/python 等编程语言, 让你写人类可理解的 \"代码\", 然后将它们 \"转化\" 为二进制后供机器执行  \n\n反正记住一点:  \n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 `.exe` 结尾的文件  \n我们将代码被解析为二进制的过程, 称为 \"编译\", 将解析工具, 称为 \"编译器\"  \n\n当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕  \n我们将分段编译的过程, 称为 \"解释\", 将分段编译的工具, 称为 \"解释器\"  \n\n编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本  \n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码  \n\npy的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑  \n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python :)  \n\n**代码:**  \n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码  \n它仅是段文本, 若没了编译器/解释器, 代码毫无用处  \n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件  \n\n**文件后缀:**\n文件本身的内容, 并不会因修改文件的后缀名而发生更改  \n后缀只不过起到一个进行分辨的作用, 当你看见 \"xxx.jpg\", 就知道它是张图片, 看见 \"xxx.txt\", 就知道它是段文本  \n\n文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性  \nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:  \n\n当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了  \n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 \"文件损坏\" 了\n\n如何显示文件后缀?  \n按住 \"win+e\" (\"win\" 是键盘下面的windows图标, win与e一起按), 打开文件浏览器  \n在上方顶栏, 点击 \"查看\", 随后勾选右侧的 \"文件扩展名\", 然后关闭文件浏览器  \n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了  \n\n- - -\n\n# Python的特点  \n- 是一门 ++高级语言++\n- 是一门 ++面向对象++ 的语言\n- 是一门 ++解释型++ 语言\n- 语法简单, 拥有丰富强大的库, 适合快速开发\n\n**高级语言**  \n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段  \n\n- 机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解  \n- 汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了\n- 高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp  \n\n值得注意的是, 还有一个叫 ++自然语言++, 别和上面的搞混了  \n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语  \n\n\n**面向对象**  \n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木  \n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼  \n(非严谨版, 勿喷, 只是快速了解而已)  \n\n**库:**  \n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂  \n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了  \n\n- - -\n\n# 环境搭建\n你可以选择用家里的电脑练习python, 这时就需要自己安装python了\n~~(以Windows为例, 毕竟你要是用的是linux还需要看这步吗...)~~  \n\npython的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: [安装程序](https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe)  \n至于出现安装界面后点哪里, 你就记住两个地方:\n\n- 先勾选底部的两个框框, 分别是\"install launcher\" 与 \"add path\", 都选上\n- 点击 \"Install Now\" 进行安装, 等待安装成功后直接点击close\n\n如何检验自己是否安装成功?  \n请按住 `win+r` (win键是键盘最下面的window图标, \"win\" 与 \"r\" 要一起按)  \n随后输入 `cmd`, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示  \n\n请输入以下命令, 检验python是否安装成功:  \n\n```\npython  --version\n```\n\n以上的 `python`, 就是安装的python解释器, 是个可执行文件(exe)  \n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本  \n它应该会输出类似下面的文字:  \n\n```\nPython 3.9.0\n```\n\n如果是其他输出, 很可能是安装的时候, 未勾选 `add path` 这个框, 导致路径无法被识别  \n\n:::tips\n**命令与路径**  \n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 \"终端/命令行/cmd\"  \n粗体闪烁的光标前的提示符, 表示你当前处于的路径  \n\n你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)  \n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛  \n比如, 敲下 \"C:\\asdiasdadows\\asdadtem32\\casd.exe\" 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)  \n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 :)  \n\n但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 \"xxx\" 来执行 \"C:\\asdad\\xxx.exe\" 该怎么办呢?  \n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件  \n\n你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 \"add path\" 了吗?  \n就是为了能够直接输入 \"python\" 来执行命令, 而不需要在意它的路径!\n\n同样的道理, 你按 \"win+r\" 后, 输入的 `cmd`, 其实就代表着, 通过 `cmd` 背后对应的路径, 执行了叫 `cmd.exe` 的exe文件  \n因此, 出现了这个黑框框 :)\n\n但请明白一点, 这个黑框框只不过是个 \"外壳\", 只是让你输入命令而已, 能够显示文字而已  \n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行  \n你可以 \"win+r\" 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的  \n:::\n\n- - -\n\n# idle的背后原理\n你现在已经了解了很多基础的概念/常识了, 对吧?!  \n\n在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 \"idle\" 的工具, 编辑代码后, 点击 \"Run\" 开始运行? (或类似工具)  \n实际上, 若你明白了先前讲的 \"编译器/解释器\", 这个图形化的界面实际上也并不神秘  \n\n你编辑代码后点击的 \"Run\", 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行  \n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已  \n\n整个过程如下:  \n\n- 新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 \"xxx.py\"\n- 在 cmd 中输入: `python xxx.py`\n\n\n- - -\n# Hello world!\n来加深印象, 写个非常简单的程序吧, 作用是打印一句话: \"Hello world!\"  \n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码  \n\n:::tips\n**注意:**\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化  \n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明  \n:::\n\n首先, 在桌面右键, 新建一个txt文件, 假设它叫 \"first_app\", 然后右键编辑, 输入下面的内容:  \n\n```python\nprint(\"Hello world!\")\n```\n\n随后打开cmd/终端, 你的当前路径应该是 \"C:\\Users\\用户名\"  \n我们新建的文件, 在桌面中, 桌面对应的文件夹是 \"Desktop\", 因此我们应该进入Desktop文件夹, 然后根据路径执行它:  \n\n```bash\ncd Desktop\npython first_app.txt\n```\n\n这将会打印:  \n\n```\nHello world!\n```\n\n瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行  \n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件  \n\n你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已  \n(如果你不懂怎么修改后缀, 请看上面的 \"常识科普: 文件后缀\")  \n\n当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!  \n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 \"这是段python代码\", 然后去寻找相关的工具了  \n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途\n\n但还是有个问题  \n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 \"python\", 进行执行  \n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入  \n\n这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!  \n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了  \n\n在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 \"输入命令, 得到结果\" 的循环  \n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失  \n\n有没有什么办法来阻止双击后黑框框的消失呢? 当然有  \nwindows中有这么一个命令, 叫做 \"pause\", 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿  \n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的  \n\npython是可以调用外部命令的!  \n\n你可以在 first_app.py 中, 这样改进你的代码:  \n\n```python\nimport os\n\nprint(\"Hello World!\")\nos.system(\"pause\")\n```\n\n上面的 `import`, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事  \n`os.system(\"pause\")` 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令  \n\n好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分","source":"_posts/high-school-it/p2-基础科普.md","raw":"---\ntitle: \"high-school-it-p2~> 基础科普\"\nabbrlink: posts/high-school-it/p2\nhidden: false\ndate: 2022-09-11 20:51:16\ntop: 7998\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\nis_series: true\nprev_post: [/posts/high-school-it/p1, \"p1~> 数据与信息\"]\nnext_post: [/posts/high-school-it/p3, \"p3~> python基础语法-part1\"]\n---\n> 让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!\n<!-- more -->\n\n**注意:**  \n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解  \n\n\n# 编译与解释\n计算机是二进制的, 只认识二进制, 但你不可能手写二进制  \nc/cpp/python 等编程语言, 让你写人类可理解的 \"代码\", 然后将它们 \"转化\" 为二进制后供机器执行  \n\n反正记住一点:  \n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 `.exe` 结尾的文件  \n我们将代码被解析为二进制的过程, 称为 \"编译\", 将解析工具, 称为 \"编译器\"  \n\n当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕  \n我们将分段编译的过程, 称为 \"解释\", 将分段编译的工具, 称为 \"解释器\"  \n\n编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本  \n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码  \n\npy的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑  \n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python :)  \n\n**代码:**  \n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码  \n它仅是段文本, 若没了编译器/解释器, 代码毫无用处  \n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件  \n\n**文件后缀:**\n文件本身的内容, 并不会因修改文件的后缀名而发生更改  \n后缀只不过起到一个进行分辨的作用, 当你看见 \"xxx.jpg\", 就知道它是张图片, 看见 \"xxx.txt\", 就知道它是段文本  \n\n文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性  \nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:  \n\n当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了  \n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 \"文件损坏\" 了\n\n如何显示文件后缀?  \n按住 \"win+e\" (\"win\" 是键盘下面的windows图标, win与e一起按), 打开文件浏览器  \n在上方顶栏, 点击 \"查看\", 随后勾选右侧的 \"文件扩展名\", 然后关闭文件浏览器  \n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了  \n\n- - -\n\n# Python的特点  \n- 是一门 ++高级语言++\n- 是一门 ++面向对象++ 的语言\n- 是一门 ++解释型++ 语言\n- 语法简单, 拥有丰富强大的库, 适合快速开发\n\n**高级语言**  \n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段  \n\n- 机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解  \n- 汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了\n- 高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp  \n\n值得注意的是, 还有一个叫 ++自然语言++, 别和上面的搞混了  \n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语  \n\n\n**面向对象**  \n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木  \n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼  \n(非严谨版, 勿喷, 只是快速了解而已)  \n\n**库:**  \n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂  \n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了  \n\n- - -\n\n# 环境搭建\n你可以选择用家里的电脑练习python, 这时就需要自己安装python了\n~~(以Windows为例, 毕竟你要是用的是linux还需要看这步吗...)~~  \n\npython的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: [安装程序](https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe)  \n至于出现安装界面后点哪里, 你就记住两个地方:\n\n- 先勾选底部的两个框框, 分别是\"install launcher\" 与 \"add path\", 都选上\n- 点击 \"Install Now\" 进行安装, 等待安装成功后直接点击close\n\n如何检验自己是否安装成功?  \n请按住 `win+r` (win键是键盘最下面的window图标, \"win\" 与 \"r\" 要一起按)  \n随后输入 `cmd`, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示  \n\n请输入以下命令, 检验python是否安装成功:  \n\n```\npython  --version\n```\n\n以上的 `python`, 就是安装的python解释器, 是个可执行文件(exe)  \n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本  \n它应该会输出类似下面的文字:  \n\n```\nPython 3.9.0\n```\n\n如果是其他输出, 很可能是安装的时候, 未勾选 `add path` 这个框, 导致路径无法被识别  \n\n:::tips\n**命令与路径**  \n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 \"终端/命令行/cmd\"  \n粗体闪烁的光标前的提示符, 表示你当前处于的路径  \n\n你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)  \n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛  \n比如, 敲下 \"C:\\asdiasdadows\\asdadtem32\\casd.exe\" 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)  \n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 :)  \n\n但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 \"xxx\" 来执行 \"C:\\asdad\\xxx.exe\" 该怎么办呢?  \n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件  \n\n你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 \"add path\" 了吗?  \n就是为了能够直接输入 \"python\" 来执行命令, 而不需要在意它的路径!\n\n同样的道理, 你按 \"win+r\" 后, 输入的 `cmd`, 其实就代表着, 通过 `cmd` 背后对应的路径, 执行了叫 `cmd.exe` 的exe文件  \n因此, 出现了这个黑框框 :)\n\n但请明白一点, 这个黑框框只不过是个 \"外壳\", 只是让你输入命令而已, 能够显示文字而已  \n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行  \n你可以 \"win+r\" 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的  \n:::\n\n- - -\n\n# idle的背后原理\n你现在已经了解了很多基础的概念/常识了, 对吧?!  \n\n在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 \"idle\" 的工具, 编辑代码后, 点击 \"Run\" 开始运行? (或类似工具)  \n实际上, 若你明白了先前讲的 \"编译器/解释器\", 这个图形化的界面实际上也并不神秘  \n\n你编辑代码后点击的 \"Run\", 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行  \n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已  \n\n整个过程如下:  \n\n- 新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 \"xxx.py\"\n- 在 cmd 中输入: `python xxx.py`\n\n\n- - -\n# Hello world!\n来加深印象, 写个非常简单的程序吧, 作用是打印一句话: \"Hello world!\"  \n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码  \n\n:::tips\n**注意:**\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化  \n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明  \n:::\n\n首先, 在桌面右键, 新建一个txt文件, 假设它叫 \"first_app\", 然后右键编辑, 输入下面的内容:  \n\n```python\nprint(\"Hello world!\")\n```\n\n随后打开cmd/终端, 你的当前路径应该是 \"C:\\Users\\用户名\"  \n我们新建的文件, 在桌面中, 桌面对应的文件夹是 \"Desktop\", 因此我们应该进入Desktop文件夹, 然后根据路径执行它:  \n\n```bash\ncd Desktop\npython first_app.txt\n```\n\n这将会打印:  \n\n```\nHello world!\n```\n\n瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行  \n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件  \n\n你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已  \n(如果你不懂怎么修改后缀, 请看上面的 \"常识科普: 文件后缀\")  \n\n当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!  \n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 \"这是段python代码\", 然后去寻找相关的工具了  \n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途\n\n但还是有个问题  \n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 \"python\", 进行执行  \n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入  \n\n这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!  \n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了  \n\n在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 \"输入命令, 得到结果\" 的循环  \n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失  \n\n有没有什么办法来阻止双击后黑框框的消失呢? 当然有  \nwindows中有这么一个命令, 叫做 \"pause\", 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿  \n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的  \n\npython是可以调用外部命令的!  \n\n你可以在 first_app.py 中, 这样改进你的代码:  \n\n```python\nimport os\n\nprint(\"Hello World!\")\nos.system(\"pause\")\n```\n\n上面的 `import`, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事  \n`os.system(\"pause\")` 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令  \n\n好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分","slug":"high-school-it/p2-基础科普","published":1,"updated":"2022-09-11T12:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og30006j1s63gk00au0","content":"<blockquote>\n<p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><strong>注意:</strong><br>\n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p>\n<h1 id=\"bian-yi-yu-jie-shi\">编译与解释</h1>\n<p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>\nc/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p>\n<p>反正记住一点:<br>\n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 <code>.exe</code> 结尾的文件<br>\n我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p>\n<p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>\n我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p>\n<p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>\n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p>\n<p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>\n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p>\n<p><strong>代码:</strong><br>\n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>\n它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>\n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p>\n<p><strong>文件后缀:</strong><br>\n文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>\n后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p>\n<p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>\nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p>\n<p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>\n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p>\n<p>如何显示文件后缀?<br>\n按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>\n在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>\n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p>\n<hr>\n<h1 id=\"python-de-te-dian\">Python的特点</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>是一门 <ins>高级语言</ins></p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>面向对象</ins> 的语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>解释型</ins> 语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法简单, 拥有丰富强大的库, 适合快速开发</p>\n</li>\n</ul>\n<p><strong>高级语言</strong><br>\n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</p>\n</li>\n<li class=\"lvl-2\">\n<p>汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</p>\n</li>\n<li class=\"lvl-2\">\n<p>高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</p>\n</li>\n</ul>\n<p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>\n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p>\n<p><strong>面向对象</strong><br>\n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>\n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>\n(非严谨版, 勿喷, 只是快速了解而已)</p>\n<p><strong>库:</strong><br>\n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>\n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p>\n<hr>\n<h1 id=\"huan-jing-da-jian\">环境搭建</h1>\n<p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br>\n<s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p>\n<p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href=\"https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe\">安装程序</a><br>\n至于出现安装界面后点哪里, 你就记住两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p>\n</li>\n<li class=\"lvl-2\">\n<p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p>\n</li>\n</ul>\n<p>如何检验自己是否安装成功?<br>\n请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>\n随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p>\n<p>请输入以下命令, 检验python是否安装成功:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span>  --<span class=\"keyword\">version</span></span><br></pre></td></tr></table></figure>\n<p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>\n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>\n它应该会输出类似下面的文字:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Python</span> <span class=\"number\">3</span>.<span class=\"number\">9</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p>\n<div class=\"tips\">\n<p><strong>命令与路径</strong><br>\n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>\n粗体闪烁的光标前的提示符, 表示你当前处于的路径</p>\n<p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>\n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>\n比如, 敲下 “C:\\asdiasdadows\\asdadtem32\\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>\n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p>\n<p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\\asdad\\xxx.exe” 该怎么办呢?<br>\n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p>\n<p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>\n就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p>\n<p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>\n因此, 出现了这个黑框框 😃</p>\n<p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>\n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>\n你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p>\n</div>\n<hr>\n<h1 id=\"idle-de-bei-hou-yuan-li\">idle的背后原理</h1>\n<p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p>\n<p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>\n实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p>\n<p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>\n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p>\n<p>整个过程如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href=\"http://xxx.py\">xxx.py</a>”</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 cmd 中输入: <code>python xxx.py</code></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"hello-world\">Hello world!</h1>\n<p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>\n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>\n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p>\n</div>\n<p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>随后打开cmd/终端, 你的当前路径应该是 “C:\\Users\\用户名”<br>\n我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> Desktop</span><br><span class=\"line\">python first_app.txt</span><br></pre></td></tr></table></figure>\n<p>这将会打印:</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello world!</span><br></pre></td></tr></table></figure>\n<p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>\n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p>\n<p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>\n(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p>\n<p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>\n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>\n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p>\n<p>但还是有个问题<br>\n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>\n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p>\n<p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>\n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p>\n<p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>\n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p>\n<p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>\nwindows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>\n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p>\n<p>python是可以调用外部命令的!</p>\n<p>你可以在 first_app.py 中, 这样改进你的代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br>\n<code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p>\n<p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>\n","site":{"data":{}},"length":4249,"excerpt":"<blockquote>\n<p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p>\n</blockquote>","more":"<p><strong>注意:</strong><br>\n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p>\n<h1 id=\"bian-yi-yu-jie-shi\">编译与解释</h1>\n<p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>\nc/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p>\n<p>反正记住一点:<br>\n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 <code>.exe</code> 结尾的文件<br>\n我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p>\n<p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>\n我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p>\n<p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>\n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p>\n<p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>\n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p>\n<p><strong>代码:</strong><br>\n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>\n它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>\n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p>\n<p><strong>文件后缀:</strong><br>\n文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>\n后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p>\n<p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>\nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p>\n<p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>\n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p>\n<p>如何显示文件后缀?<br>\n按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>\n在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>\n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p>\n<hr>\n<h1 id=\"python-de-te-dian\">Python的特点</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>是一门 <ins>高级语言</ins></p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>面向对象</ins> 的语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>解释型</ins> 语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法简单, 拥有丰富强大的库, 适合快速开发</p>\n</li>\n</ul>\n<p><strong>高级语言</strong><br>\n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</p>\n</li>\n<li class=\"lvl-2\">\n<p>汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</p>\n</li>\n<li class=\"lvl-2\">\n<p>高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</p>\n</li>\n</ul>\n<p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>\n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p>\n<p><strong>面向对象</strong><br>\n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>\n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>\n(非严谨版, 勿喷, 只是快速了解而已)</p>\n<p><strong>库:</strong><br>\n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>\n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p>\n<hr>\n<h1 id=\"huan-jing-da-jian\">环境搭建</h1>\n<p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br>\n<s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p>\n<p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href=\"https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe\">安装程序</a><br>\n至于出现安装界面后点哪里, 你就记住两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p>\n</li>\n<li class=\"lvl-2\">\n<p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p>\n</li>\n</ul>\n<p>如何检验自己是否安装成功?<br>\n请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>\n随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p>\n<p>请输入以下命令, 检验python是否安装成功:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span>  --<span class=\"keyword\">version</span></span><br></pre></td></tr></table></figure>\n<p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>\n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>\n它应该会输出类似下面的文字:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Python</span> <span class=\"number\">3</span>.<span class=\"number\">9</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p>\n<div class=\"tips\">\n<p><strong>命令与路径</strong><br>\n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>\n粗体闪烁的光标前的提示符, 表示你当前处于的路径</p>\n<p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>\n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>\n比如, 敲下 “C:\\asdiasdadows\\asdadtem32\\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>\n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p>\n<p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\\asdad\\xxx.exe” 该怎么办呢?<br>\n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p>\n<p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>\n就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p>\n<p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>\n因此, 出现了这个黑框框 😃</p>\n<p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>\n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>\n你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p>\n</div>\n<hr>\n<h1 id=\"idle-de-bei-hou-yuan-li\">idle的背后原理</h1>\n<p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p>\n<p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>\n实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p>\n<p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>\n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p>\n<p>整个过程如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href=\"http://xxx.py\">xxx.py</a>”</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 cmd 中输入: <code>python xxx.py</code></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"hello-world\">Hello world!</h1>\n<p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>\n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>\n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p>\n</div>\n<p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>随后打开cmd/终端, 你的当前路径应该是 “C:\\Users\\用户名”<br>\n我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> Desktop</span><br><span class=\"line\">python first_app.txt</span><br></pre></td></tr></table></figure>\n<p>这将会打印:</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello world!</span><br></pre></td></tr></table></figure>\n<p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>\n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p>\n<p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>\n(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p>\n<p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>\n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>\n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p>\n<p>但还是有个问题<br>\n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>\n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p>\n<p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>\n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p>\n<p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>\n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p>\n<p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>\nwindows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>\n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p>\n<p>python是可以调用外部命令的!</p>\n<p>你可以在 first_app.py 中, 这样改进你的代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br>\n<code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p>\n<p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>"},{"title":"high-school-it-p3~> python基础语法-part1","abbrlink":"posts/high-school-it/p3","hidden":false,"date":"2022-09-12T03:45:45.000Z","top":7997,"keywords":["高中信息技术","python"],"is_series":true,"prev_post":["/posts/high-school-it/p2","p2~> 基础科普"],"next_post":["/posts/high-school-it/p4","p4~> python基础语法-part2"],"_content":"> 正式的对python语法的学习, 包含常见库函数的使用\n<!-- more -->\n\n有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 [p2: 基础科普与环境搭建](/posts/high-school-it/p2)  \n**感谢:**  \n本文的切片部分来源于 [python切片完全指南(语法篇)](https://zhuanlan.zhihu.com/p/79541418), 已经过原作者准许\n\n# 变量与赋值  \n编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么? \n需要数据, 还需要存放数据的地方, ++变量++, 就是这么一个存放数据的地方  \n\n变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)  \n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实  \n\n有两个概念:\n- 声明变量:  创建变量 (声明一个变量出现了)  \n- 赋值: 把一个值装到箱子(变量)里\n\n比如, 一个很简单的例子:  \n\n```python\na = 1\n```\n\n这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值  \n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量  \n\n变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同  \n\n你也可以这样:  \n\n```python\na = 1\nb = a\n```\n\n我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b  \n第二行表示, 把a里面的数值取出来, 传给了b  \n\npython支持也支持这样的赋值操作, 甚至可以继续长下去\n\n```python\na = b = c = 1\nd = e = f = 2\n\na,b,c = d,e,f\n```\n\n上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2\n\n\n你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:  \n\n```python\na = 1\nb = 2\na,b = b,a\n```\n\n你可能会疑惑:  \n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?  \n该想法对应的代码是这样的:  \n\n```python\na = 1\nb = 2\n\na = b\nb = a\n```\n\n但在交换数值的代码中, 你应该这样理解:  \n\n```python\na = 1\nb = 2\n\n_t1 = b\n_t2 = a\na = _t1\nb = _t2\n```\n\n这表示, 进行 `a,b = b,a` 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b  \n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了  \n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 :)  \n\n另外 选择题会出现这样的常见选项:  \n\n```python\nA.  a = 1, b = 2, c = 3\nB.  a, b, c = 1, 2, 3\nC.  a = 1; b = 2; c = 3\n```\n其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已\n\n- - -\n\n# 变量命名规范\npython中, 变量的命名必须符合规范, 不然直接报错  \n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a  \n\n命名规范如下:  \n- 变量名由字母, 数字, 下划线组成\n- 不能由数字开头\n- 中间不能有空格分割  \n- 不能与python中的关键字重名  \n\n以下都是合法的变量名  \n\n```python\na\nabada\nasd111231\nad190123kkad\nasd_asd1_asd2\n_123daa\n_as11\n```\n\n以下是不合法的变量名:  \n\n```python\ndef\nnot\nin\nlambda\n\n1123\n123adad\nsad;;-``\n``?/\n',\n```\n\n**关键字:**  \n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in  \n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果  \n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用  \n\n你怎么知道哪些是关键字呢? 慢慢看吧, 像 `def/import/for/if/break` 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字\n\n- - -\n# 注释\n\n## 作用\n注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码  \n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么\n\n举个例子:\n\n```python\na = 1  此时 a 的值为 1\n```\n\n```python\na = 1  # 此时 a 的值为 1\n```\n\n前者会报错, 因为 \"此时 a 的值为 1\" 也被解释器当作代码而进行解析, 自然就会报错了  \n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释  \n\n再举个例子:\n\n```python\n# 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出\n\na = 1\nb = 2\nc = 3\nmax = -1\nif a > b > c:\n  max = a\nelif b > c:\n  max = b\nelse:\n  max = c\nprint(max)\n```\n\n瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了  \n\n## 单/多行注释\npython 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了  \n\n```python\n# 12345\n# 上山打老虎\n# 老虎打不着\n# 打到小松鼠\n\n''' \n12345\n上山打老虎\n老虎打不着\n打到小松鼠\n'''\n```\n\n以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候  \n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)\n\n- - -\n# 基本数据类型\n前面说了, 求解问题时, 你需要数据, 还有存放数据的地方  \n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了  \n\n为了模拟现实, py将数据进行了抽象与分类:  \n\n\n- int: 对应整数  \n- float: 对应实数  \n- string: 对应文字\n- bool: 对应真与假\n\n有了这些 ++基本数据类型++, 我们就能够模拟世界了, 进行抽象, 求解问题了  \n\n举些例子:  \n- 我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃  \n- 我的年龄是16岁: 用int来表示 16 这个数字\n- 我的名字叫做: 用string来表示 \"赵二狗\", \"Anasdpa\" 这样的文字  \n\n同时, 我们还可以用这些 ++基本数据类型++, 构建出 ++复杂数据类型++, 比如, 我想创建一个类型, 叫 student, 表示学生  \n你可以这样抽象:  \n\n```python\nstudent {\n  age:  int,\n  height: float,\n  name: string,\n  fat_or_not: bool\n}\n```\n\npy中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已\n\n\n- - -\n\n# 运算符与优先级\npython 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作  \n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个  \n在以下的图表中, 优先级1是最高, 数字越大优先级越低  \n\n## 算术运算符  \n算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字  \n\n|运算符|描述|例子|优先级|\n|--|--|--|--|\n|**|x的y次方|x**y|1|\n|*|x乘以y|x*y|2|\n|/|x除以y, 产生实数值|x/y|2|\n|//|x除以y, 产生整数值|x//y|2|\n|%|x除以y, 取余数|x%y|2|\n|+|x加y|x+y|3|\n|-|x减y|x-y|3|\n\n瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 :)\n\n算术运算符, 可以与赋值运算符相互结合:\n\n```python\na = a + 1\n\na += 1  # 是上面的等价物\n```\n\n类似的, 还有 `-=`, `*=`, `%=`\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍\n\n## 关系运算符\n关系运算符, 若关系成立则返回 True, 不然返回 False, 如 `1 < 2` 是 True, 因此又称为 比较运算符  \n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)\n\n|运算符|描述|例子\n|--|--|--|\n|>| x 大于 y| x > y|\n|<| x 小于 y| x < y|\n|>=| x 大于等于 y| x >= y|\n|<=| x 小于等于 y| x <= y|\n|==| x 等于 y| x == y|\n|!=| x 不等于 y| x != y|\n\n**注:**  \n本博客使用了连体字特性, 因此你看见的>=其实是>号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=\n\n- - -\n\n# 基本数据结构\n数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构  \n\n举个例子, 有种数据结构, 叫做 `队列 (Queue)`, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:  \n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解  \n此时的队列, 就是一个 `单向队列`, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)  \n\n根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构  \n当然, 我们此处仅学习基本数据结构  \n\n## 列表\n列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素  \n\n### 单索引  \n我们可以通过单个索引, 访问对应的单个元素  \n\n举个例子:  \n\n```python\n# 有着 3 个元素的列表\nlist = [300, 400, 500]\n\n# 通过索引, 访问元素 (索引从 0 开始)\nlist[0]  # 300\nlist[1]  # 400\nlist[2]  # 500\n```\n\n**扩展: 为何 index 从 0 开始?**  \n因为, 所谓的index, 代表的概念, 其实是 `偏移量`  \n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素  \n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?  \n\n你可以这样理解:  \n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间  \n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子\n\n列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子  \n如何访问第 1 个格子? 第一个格子向右跳 0 格  \n如何访问第 2 个格子? 第二个格子向右跳 1 格  \n如何访问第 3 个格子? 第三个格子向右跳 2 格  \n\n\n现在懂了吧? 下标其实就是偏移量, 代表的是 `相对于第 1 个格子偏移了多少格`  \n要访问第几个格子, 直接加上偏移量即可 (比如 `list[0]` 偏移了0, 是第一个元素)\n\n如果你非要把下标从 1 开始, 那就得这样:  \nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0  \n于是在根据下标1, 求第一个元素时, 偏移量就是 `1 - 1 = 0`  \n同理, 根据下标2, 求第二个元素时, 偏移量就是 `2 - 1 = 1`  \n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 `index - 1`  \n\n如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?  \n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了  \n~~(好吧, 原因其实真的只是因为习俗)~~\n\n而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 :)  \n\npy 中还存在 `负索引` 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减  \n比如 `ls[-1]`, 就代表倒数第一个元素, `ls[-2]` 就代表倒数第二个元素  \n\n举个例子, 已知 `a = [10, 20, 30, 40, 50]` 让我们将其与图表进行对立:  \n\n| | | | | | |\n|--|--|--|--|--|--|\n|元素|10|20|30|40|50|\n|正索引|0|1|2|3|4|\n|负索引|-5|-4|-3|-2|-1|\n\n显而易见的, `ls[-1]`, 就相当于 `ls[len(ls) - 1]` ( len(ls) 表示得到列表ls的长度 )  \n\n### 索引越界\n\n于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:  \n\n```python demo.py\na = [10, 20, 30, 40, 50]\na[5]\n```\n\n当我们在命令行中执行 `python demo.py` (见 [p2: 基础科普#环境搭建](/posts/high-school-it/p2#huan-jing-da-jian) ) 或直接使用图形化工具, 点击运行按钮  \n\n脑子想一想都知道肯定编译不过, 我们将得到以下报错:  \n\n```\nTraceback (most recent call last):\n  File \"/home/jedsek/a.py\", line 2, in <module>\n    a[5]\n    ~^^^\nIndexError: list index out of range\n```\n\n看不懂的直接像做玩英语完形一样当作 \"哔(屏蔽词)\" 跳过就好, index 是 \"索引/下标的意思\", 这条报错表示, 下标越界了!  \n因为 a 是个长度为 5 的列表, 所以只能用 `n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)` 来当下标, 即 0 到 4, 因此 5 是非法的  \n负索引也是一样的道理, 不能越界哟~~\n\n### 切片\n切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素  \n\n举个例子:  \n\n```python\nnumbers = [201, 202, 203, 204]  # 定义列表\nnumbers[0:4]  # [201, 202, 203, 204]\nnumbers[0:2]  # [201, 202]\nnumbers[0:1]  # [201]\n```\n\n在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素  \n我们通过 `list[m:n]`, 得到了一个子列表, 只要索引在 `[m, n) (左开右闭区间)` 内, 就会被放入这个子列表  \n\n图表依然会较为直观:  \n\n`numbers = [201, 202, 203, 204]`\n||||\n|--|--|--|\n|切片|对应索引|取出的子列表|\n|0:4|[0, 1, 2, 3]|[201, 202, 203, 204]|\n|0:2|[0, 1]|[201, 202]|\n|0:1|[0]|[201]|\n|-3:-1|[-3, -2]|[202, 203]|\n\n默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 `numbers[0:4:1]` 就相当于 `numbers[0:4]`  \n而 `numbers[0:4:2]` 则相当于从 `[0, 1, 2, 3]` 中的第一个元素 `0` 开始, 作为下标取 numbers 的元素, 然后走两步到 `2`, 依次类推  \n步长不能设置为 0, 不然会报错  \n\n有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 `[]`  \n举个例子: `numbers[3:2]` 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分  \n\n### 省略与默认值\n关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 :)  \n \n已知 `a = [10, 20, 30, 40, 50]`, 你可以使用 `a[start:stop:step]` 来表示 a 的切片, 其中 start/stop/step 都是可以省略的  \n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 `a[start:stop]`/`a[start:stop:]` 的形式时, 步长会使用默认值1  \n\n而对于 `start/stop` 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取  \n举些例子, 已知 `a = [10, 20, 30, 40, 50, 60, 70]`:  \n\n- `a[2:5:1]` 中, `2:4` 对应的下标是 `[2, 3, 4]`, 索引对应的元素是 `[30, 40, 50]`, 因为步长为1, 所以结果直接就是 `[30, 40, 50]`  \n- `a[2::1]` 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 `[30, 40, 50, 60, 70]`  \n- `a[:2:1]` 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 `[10, 20]`  \n- `a[2::-1]` 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 `[30, 20, 10]`  \n- `a[:2:-1]` 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 `[70, 60, 50, 40]`  \n\n什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:  \n- `start` 代表列表中某个元素的下标, 这个元素是切片的起头\n- `stop` 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)  \n- `step` 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取  \n\n要开始了哦, 超级直观的方法:  \n\n以 `a[2:5:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `5`, 所以箭头的终点是 `50` (箭头从 60 逆方向缩一格): [10, 20, ~~30, 40, 50~~>, 60, 70]\n\n以 `a[2::1]` 为例:\n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: [10, 20, ~~30, 40, 50, 60, 70]~~>\n\n以 `a[:2:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 被省略, 所以箭头的起点在左边的无限远处, 不用动: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `20` (箭头从 30 逆方向缩一格): ~~[10, 20~~>, 30, 40, 50, 60, 70]\n\n以 `a[2::-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: <~~[10, 20, 30~~, 40, 50, 60, 70]  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: <~~[10, 20, 30~~, 40, 50, 60, 70]\n \n以 `a[:2:-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 被省略, 所以箭头的起点在右边的无限远处, 不用动: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `40` (箭头从 30 逆方向缩一格): [10, 20, 30, <~~40, 50, 60, 70]~~\n\n对于负索引也是一样的道理, 先确定好 `start` 与 `stop` 的位置, 然后根据步长画对应方向的箭头  \n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行  \n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可  \n\n- - -\n\n## 字典\npython 中的字典, 实际上就是一些键值对组成的集合  \n键值对, 指的就是根据某个键值, 获取其对应的另外一个值  \n\n举个例子:  \n- 名字: \"小明\"  \n- 年龄(year): 16\n- 身高(cm): 178\n\n名字 -> \"小明\", 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了  \n\n在 python 中, 你可以用一对花括号来定义字典:  \n\n```python\na = {'Shadd': 10, 'Lasd': 111, 'PPqwea': 899}\n```\n\n冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  `a['Shadd']` 将得到 `10`","source":"_posts/high-school-it/p3-python基础语法-part1.md","raw":"---\ntitle: \"high-school-it-p3~> python基础语法-part1\"\nabbrlink: posts/high-school-it/p3\nhidden: false\ndate: 2022-09-12 11:45:45\ntop: 7997\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\nis_series: true\nprev_post: [/posts/high-school-it/p2, \"p2~> 基础科普\"]\nnext_post: [/posts/high-school-it/p4, \"p4~> python基础语法-part2\"]\n---\n> 正式的对python语法的学习, 包含常见库函数的使用\n<!-- more -->\n\n有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 [p2: 基础科普与环境搭建](/posts/high-school-it/p2)  \n**感谢:**  \n本文的切片部分来源于 [python切片完全指南(语法篇)](https://zhuanlan.zhihu.com/p/79541418), 已经过原作者准许\n\n# 变量与赋值  \n编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么? \n需要数据, 还需要存放数据的地方, ++变量++, 就是这么一个存放数据的地方  \n\n变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)  \n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实  \n\n有两个概念:\n- 声明变量:  创建变量 (声明一个变量出现了)  \n- 赋值: 把一个值装到箱子(变量)里\n\n比如, 一个很简单的例子:  \n\n```python\na = 1\n```\n\n这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值  \n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量  \n\n变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同  \n\n你也可以这样:  \n\n```python\na = 1\nb = a\n```\n\n我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b  \n第二行表示, 把a里面的数值取出来, 传给了b  \n\npython支持也支持这样的赋值操作, 甚至可以继续长下去\n\n```python\na = b = c = 1\nd = e = f = 2\n\na,b,c = d,e,f\n```\n\n上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2\n\n\n你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:  \n\n```python\na = 1\nb = 2\na,b = b,a\n```\n\n你可能会疑惑:  \n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?  \n该想法对应的代码是这样的:  \n\n```python\na = 1\nb = 2\n\na = b\nb = a\n```\n\n但在交换数值的代码中, 你应该这样理解:  \n\n```python\na = 1\nb = 2\n\n_t1 = b\n_t2 = a\na = _t1\nb = _t2\n```\n\n这表示, 进行 `a,b = b,a` 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b  \n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了  \n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 :)  \n\n另外 选择题会出现这样的常见选项:  \n\n```python\nA.  a = 1, b = 2, c = 3\nB.  a, b, c = 1, 2, 3\nC.  a = 1; b = 2; c = 3\n```\n其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已\n\n- - -\n\n# 变量命名规范\npython中, 变量的命名必须符合规范, 不然直接报错  \n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a  \n\n命名规范如下:  \n- 变量名由字母, 数字, 下划线组成\n- 不能由数字开头\n- 中间不能有空格分割  \n- 不能与python中的关键字重名  \n\n以下都是合法的变量名  \n\n```python\na\nabada\nasd111231\nad190123kkad\nasd_asd1_asd2\n_123daa\n_as11\n```\n\n以下是不合法的变量名:  \n\n```python\ndef\nnot\nin\nlambda\n\n1123\n123adad\nsad;;-``\n``?/\n',\n```\n\n**关键字:**  \n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in  \n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果  \n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用  \n\n你怎么知道哪些是关键字呢? 慢慢看吧, 像 `def/import/for/if/break` 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字\n\n- - -\n# 注释\n\n## 作用\n注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码  \n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么\n\n举个例子:\n\n```python\na = 1  此时 a 的值为 1\n```\n\n```python\na = 1  # 此时 a 的值为 1\n```\n\n前者会报错, 因为 \"此时 a 的值为 1\" 也被解释器当作代码而进行解析, 自然就会报错了  \n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释  \n\n再举个例子:\n\n```python\n# 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出\n\na = 1\nb = 2\nc = 3\nmax = -1\nif a > b > c:\n  max = a\nelif b > c:\n  max = b\nelse:\n  max = c\nprint(max)\n```\n\n瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了  \n\n## 单/多行注释\npython 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了  \n\n```python\n# 12345\n# 上山打老虎\n# 老虎打不着\n# 打到小松鼠\n\n''' \n12345\n上山打老虎\n老虎打不着\n打到小松鼠\n'''\n```\n\n以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候  \n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)\n\n- - -\n# 基本数据类型\n前面说了, 求解问题时, 你需要数据, 还有存放数据的地方  \n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了  \n\n为了模拟现实, py将数据进行了抽象与分类:  \n\n\n- int: 对应整数  \n- float: 对应实数  \n- string: 对应文字\n- bool: 对应真与假\n\n有了这些 ++基本数据类型++, 我们就能够模拟世界了, 进行抽象, 求解问题了  \n\n举些例子:  \n- 我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃  \n- 我的年龄是16岁: 用int来表示 16 这个数字\n- 我的名字叫做: 用string来表示 \"赵二狗\", \"Anasdpa\" 这样的文字  \n\n同时, 我们还可以用这些 ++基本数据类型++, 构建出 ++复杂数据类型++, 比如, 我想创建一个类型, 叫 student, 表示学生  \n你可以这样抽象:  \n\n```python\nstudent {\n  age:  int,\n  height: float,\n  name: string,\n  fat_or_not: bool\n}\n```\n\npy中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已\n\n\n- - -\n\n# 运算符与优先级\npython 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作  \n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个  \n在以下的图表中, 优先级1是最高, 数字越大优先级越低  \n\n## 算术运算符  \n算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字  \n\n|运算符|描述|例子|优先级|\n|--|--|--|--|\n|**|x的y次方|x**y|1|\n|*|x乘以y|x*y|2|\n|/|x除以y, 产生实数值|x/y|2|\n|//|x除以y, 产生整数值|x//y|2|\n|%|x除以y, 取余数|x%y|2|\n|+|x加y|x+y|3|\n|-|x减y|x-y|3|\n\n瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 :)\n\n算术运算符, 可以与赋值运算符相互结合:\n\n```python\na = a + 1\n\na += 1  # 是上面的等价物\n```\n\n类似的, 还有 `-=`, `*=`, `%=`\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍\n\n## 关系运算符\n关系运算符, 若关系成立则返回 True, 不然返回 False, 如 `1 < 2` 是 True, 因此又称为 比较运算符  \n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)\n\n|运算符|描述|例子\n|--|--|--|\n|>| x 大于 y| x > y|\n|<| x 小于 y| x < y|\n|>=| x 大于等于 y| x >= y|\n|<=| x 小于等于 y| x <= y|\n|==| x 等于 y| x == y|\n|!=| x 不等于 y| x != y|\n\n**注:**  \n本博客使用了连体字特性, 因此你看见的>=其实是>号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=\n\n- - -\n\n# 基本数据结构\n数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构  \n\n举个例子, 有种数据结构, 叫做 `队列 (Queue)`, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:  \n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解  \n此时的队列, 就是一个 `单向队列`, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)  \n\n根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构  \n当然, 我们此处仅学习基本数据结构  \n\n## 列表\n列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素  \n\n### 单索引  \n我们可以通过单个索引, 访问对应的单个元素  \n\n举个例子:  \n\n```python\n# 有着 3 个元素的列表\nlist = [300, 400, 500]\n\n# 通过索引, 访问元素 (索引从 0 开始)\nlist[0]  # 300\nlist[1]  # 400\nlist[2]  # 500\n```\n\n**扩展: 为何 index 从 0 开始?**  \n因为, 所谓的index, 代表的概念, 其实是 `偏移量`  \n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素  \n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?  \n\n你可以这样理解:  \n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间  \n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子\n\n列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子  \n如何访问第 1 个格子? 第一个格子向右跳 0 格  \n如何访问第 2 个格子? 第二个格子向右跳 1 格  \n如何访问第 3 个格子? 第三个格子向右跳 2 格  \n\n\n现在懂了吧? 下标其实就是偏移量, 代表的是 `相对于第 1 个格子偏移了多少格`  \n要访问第几个格子, 直接加上偏移量即可 (比如 `list[0]` 偏移了0, 是第一个元素)\n\n如果你非要把下标从 1 开始, 那就得这样:  \nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0  \n于是在根据下标1, 求第一个元素时, 偏移量就是 `1 - 1 = 0`  \n同理, 根据下标2, 求第二个元素时, 偏移量就是 `2 - 1 = 1`  \n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 `index - 1`  \n\n如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?  \n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了  \n~~(好吧, 原因其实真的只是因为习俗)~~\n\n而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 :)  \n\npy 中还存在 `负索引` 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减  \n比如 `ls[-1]`, 就代表倒数第一个元素, `ls[-2]` 就代表倒数第二个元素  \n\n举个例子, 已知 `a = [10, 20, 30, 40, 50]` 让我们将其与图表进行对立:  \n\n| | | | | | |\n|--|--|--|--|--|--|\n|元素|10|20|30|40|50|\n|正索引|0|1|2|3|4|\n|负索引|-5|-4|-3|-2|-1|\n\n显而易见的, `ls[-1]`, 就相当于 `ls[len(ls) - 1]` ( len(ls) 表示得到列表ls的长度 )  \n\n### 索引越界\n\n于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:  \n\n```python demo.py\na = [10, 20, 30, 40, 50]\na[5]\n```\n\n当我们在命令行中执行 `python demo.py` (见 [p2: 基础科普#环境搭建](/posts/high-school-it/p2#huan-jing-da-jian) ) 或直接使用图形化工具, 点击运行按钮  \n\n脑子想一想都知道肯定编译不过, 我们将得到以下报错:  \n\n```\nTraceback (most recent call last):\n  File \"/home/jedsek/a.py\", line 2, in <module>\n    a[5]\n    ~^^^\nIndexError: list index out of range\n```\n\n看不懂的直接像做玩英语完形一样当作 \"哔(屏蔽词)\" 跳过就好, index 是 \"索引/下标的意思\", 这条报错表示, 下标越界了!  \n因为 a 是个长度为 5 的列表, 所以只能用 `n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)` 来当下标, 即 0 到 4, 因此 5 是非法的  \n负索引也是一样的道理, 不能越界哟~~\n\n### 切片\n切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素  \n\n举个例子:  \n\n```python\nnumbers = [201, 202, 203, 204]  # 定义列表\nnumbers[0:4]  # [201, 202, 203, 204]\nnumbers[0:2]  # [201, 202]\nnumbers[0:1]  # [201]\n```\n\n在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素  \n我们通过 `list[m:n]`, 得到了一个子列表, 只要索引在 `[m, n) (左开右闭区间)` 内, 就会被放入这个子列表  \n\n图表依然会较为直观:  \n\n`numbers = [201, 202, 203, 204]`\n||||\n|--|--|--|\n|切片|对应索引|取出的子列表|\n|0:4|[0, 1, 2, 3]|[201, 202, 203, 204]|\n|0:2|[0, 1]|[201, 202]|\n|0:1|[0]|[201]|\n|-3:-1|[-3, -2]|[202, 203]|\n\n默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 `numbers[0:4:1]` 就相当于 `numbers[0:4]`  \n而 `numbers[0:4:2]` 则相当于从 `[0, 1, 2, 3]` 中的第一个元素 `0` 开始, 作为下标取 numbers 的元素, 然后走两步到 `2`, 依次类推  \n步长不能设置为 0, 不然会报错  \n\n有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 `[]`  \n举个例子: `numbers[3:2]` 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分  \n\n### 省略与默认值\n关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 :)  \n \n已知 `a = [10, 20, 30, 40, 50]`, 你可以使用 `a[start:stop:step]` 来表示 a 的切片, 其中 start/stop/step 都是可以省略的  \n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 `a[start:stop]`/`a[start:stop:]` 的形式时, 步长会使用默认值1  \n\n而对于 `start/stop` 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取  \n举些例子, 已知 `a = [10, 20, 30, 40, 50, 60, 70]`:  \n\n- `a[2:5:1]` 中, `2:4` 对应的下标是 `[2, 3, 4]`, 索引对应的元素是 `[30, 40, 50]`, 因为步长为1, 所以结果直接就是 `[30, 40, 50]`  \n- `a[2::1]` 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 `[30, 40, 50, 60, 70]`  \n- `a[:2:1]` 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 `[10, 20]`  \n- `a[2::-1]` 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 `[30, 20, 10]`  \n- `a[:2:-1]` 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 `[70, 60, 50, 40]`  \n\n什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:  \n- `start` 代表列表中某个元素的下标, 这个元素是切片的起头\n- `stop` 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)  \n- `step` 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取  \n\n要开始了哦, 超级直观的方法:  \n\n以 `a[2:5:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `5`, 所以箭头的终点是 `50` (箭头从 60 逆方向缩一格): [10, 20, ~~30, 40, 50~~>, 60, 70]\n\n以 `a[2::1]` 为例:\n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: [10, 20, ~~30, 40, 50, 60, 70]~~>\n\n以 `a[:2:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 被省略, 所以箭头的起点在左边的无限远处, 不用动: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `20` (箭头从 30 逆方向缩一格): ~~[10, 20~~>, 30, 40, 50, 60, 70]\n\n以 `a[2::-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: <~~[10, 20, 30~~, 40, 50, 60, 70]  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: <~~[10, 20, 30~~, 40, 50, 60, 70]\n \n以 `a[:2:-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 被省略, 所以箭头的起点在右边的无限远处, 不用动: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `40` (箭头从 30 逆方向缩一格): [10, 20, 30, <~~40, 50, 60, 70]~~\n\n对于负索引也是一样的道理, 先确定好 `start` 与 `stop` 的位置, 然后根据步长画对应方向的箭头  \n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行  \n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可  \n\n- - -\n\n## 字典\npython 中的字典, 实际上就是一些键值对组成的集合  \n键值对, 指的就是根据某个键值, 获取其对应的另外一个值  \n\n举个例子:  \n- 名字: \"小明\"  \n- 年龄(year): 16\n- 身高(cm): 178\n\n名字 -> \"小明\", 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了  \n\n在 python 中, 你可以用一对花括号来定义字典:  \n\n```python\na = {'Shadd': 10, 'Lasd': 111, 'PPqwea': 899}\n```\n\n冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  `a['Shadd']` 将得到 `10`","slug":"high-school-it/p3-python基础语法-part1","published":1,"updated":"2022-09-12T03:45:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og40007j1s6b8jq34ua","content":"<blockquote>\n<p>正式的对python语法的学习, 包含常见库函数的使用</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href=\"/posts/high-school-it/p2\">p2: 基础科普与环境搭建</a><br>\n<strong>感谢:</strong><br>\n本文的切片部分来源于 <a href=\"https://zhuanlan.zhihu.com/p/79541418\">python切片完全指南(语法篇)</a>, 已经过原作者准许</p>\n<h1 id=\"bian-liang-yu-fu-zhi\">变量与赋值</h1>\n<p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>\n需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p>\n<p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>\n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p>\n<p>有两个概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>声明变量:  创建变量 (声明一个变量出现了)</p>\n</li>\n<li class=\"lvl-2\">\n<p>赋值: 把一个值装到箱子(变量)里</p>\n</li>\n</ul>\n<p>比如, 一个很简单的例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>\n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p>\n<p>变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同</p>\n<p>你也可以这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>\n第二行表示, 把a里面的数值取出来, 传给了b</p>\n<p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = b = c = <span class=\"number\">1</span></span><br><span class=\"line\">d = e = f = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a,b,c = d,e,f</span><br></pre></td></tr></table></figure>\n<p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p>\n<p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">a,b = b,a</span><br></pre></td></tr></table></figure>\n<p>你可能会疑惑:<br>\n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>\n该想法对应的代码是这样的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = b</span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>但在交换数值的代码中, 你应该这样理解:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">_t1 = b</span><br><span class=\"line\">_t2 = a</span><br><span class=\"line\">a = _t1</span><br><span class=\"line\">b = _t2</span><br></pre></td></tr></table></figure>\n<p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>\n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了<br>\n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p>\n<p>另外 选择题会出现这样的常见选项:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.  a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, c = <span class=\"number\">3</span></span><br><span class=\"line\">B.  a, b, c = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\">C.  a = <span class=\"number\">1</span>; b = <span class=\"number\">2</span>; c = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已</p>\n<hr>\n<h1 id=\"bian-liang-ming-ming-gui-fan\">变量命名规范</h1>\n<p>python中, 变量的命名必须符合规范, 不然直接报错<br>\n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p>\n<p>命名规范如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>变量名由字母, 数字, 下划线组成</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能由数字开头</p>\n</li>\n<li class=\"lvl-2\">\n<p>中间不能有空格分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能与python中的关键字重名</p>\n</li>\n</ul>\n<p>以下都是合法的变量名</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">abada</span><br><span class=\"line\">asd111231</span><br><span class=\"line\">ad190123kkad</span><br><span class=\"line\">asd_asd1_asd2</span><br><span class=\"line\">_123daa</span><br><span class=\"line\">_as11</span><br></pre></td></tr></table></figure>\n<p>以下是不合法的变量名:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">not</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">in</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lambda</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">1123</span></span><br><span class=\"line\"><span class=\"function\">123<span class=\"title\">adad</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sad</span>;;-``</span></span><br><span class=\"line\"><span class=\"function\">``?/</span></span><br><span class=\"line\"><span class=\"function\">&#x27;,</span></span><br></pre></td></tr></table></figure>\n<p><strong>关键字:</strong><br>\n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>\n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>\n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p>\n<p>你怎么知道哪些是关键字呢? 慢慢看吧, 像 <code>def/import/for/if/break</code> 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字</p>\n<hr>\n<h1 id=\"zhu-shi\">注释</h1>\n<h2 id=\"zuo-yong\" id=\"作用\">作用</h2>\n<p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>\n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  此时 a 的值为 <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  <span class=\"comment\"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure>\n<p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>\n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p>\n<p>再举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">c = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">max</span> = -<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> a &gt; b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = a</span><br><span class=\"line\"><span class=\"keyword\">elif</span> b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = b</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">max</span>)</span><br></pre></td></tr></table></figure>\n<p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p>\n<h2 id=\"dan-duo-xing-zhu-shi\" id=\"单-多行注释\">单/多行注释</h2>\n<p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 12345</span></span><br><span class=\"line\"><span class=\"comment\"># 上山打老虎</span></span><br><span class=\"line\"><span class=\"comment\"># 老虎打不着</span></span><br><span class=\"line\"><span class=\"comment\"># 打到小松鼠</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27; </span></span><br><span class=\"line\"><span class=\"string\">12345</span></span><br><span class=\"line\"><span class=\"string\">上山打老虎</span></span><br><span class=\"line\"><span class=\"string\">老虎打不着</span></span><br><span class=\"line\"><span class=\"string\">打到小松鼠</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>\n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-lei-xing\">基本数据类型</h1>\n<p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>\n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p>\n<p>为了模拟现实, py将数据进行了抽象与分类:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>int: 对应整数</p>\n</li>\n<li class=\"lvl-2\">\n<p>float: 对应实数</p>\n</li>\n<li class=\"lvl-2\">\n<p>string: 对应文字</p>\n</li>\n<li class=\"lvl-2\">\n<p>bool: 对应真与假</p>\n</li>\n</ul>\n<p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p>\n<p>举些例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的年龄是16岁: 用int来表示 16 这个数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p>\n</li>\n</ul>\n<p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>\n你可以这样抽象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">student &#123;</span><br><span class=\"line\">  age:  <span class=\"built_in\">int</span>,</span><br><span class=\"line\">  height: <span class=\"built_in\">float</span>,</span><br><span class=\"line\">  name: string,</span><br><span class=\"line\">  fat_or_not: <span class=\"built_in\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p>\n<hr>\n<h1 id=\"yun-suan-fu-yu-you-xian-ji\">运算符与优先级</h1>\n<p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>\n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>\n在以下的图表中, 优先级1是最高, 数字越大优先级越低</p>\n<h2 id=\"suan-zhu-yun-suan-fu\" id=\"算术运算符\">算术运算符</h2>\n<p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n<th>优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>x的y次方</td>\n<td>x**y</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>x乘以y</td>\n<td>x*y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>/</td>\n<td>x除以y, 产生实数值</td>\n<td>x/y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>x除以y, 产生整数值</td>\n<td>x//y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>x除以y, 取余数</td>\n<td>x%y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>+</td>\n<td>x加y</td>\n<td>x+y</td>\n<td>3</td>\n</tr>\n<tr>\n<td>-</td>\n<td>x减y</td>\n<td>x-y</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p>\n<p>算术运算符, 可以与赋值运算符相互结合:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a += <span class=\"number\">1</span>  <span class=\"comment\"># 是上面的等价物</span></span><br></pre></td></tr></table></figure>\n<p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p>\n<h2 id=\"guan-xi-yun-suan-fu\" id=\"关系运算符\">关系运算符</h2>\n<p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>\n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>x 大于 y</td>\n<td>x &gt; y</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>x 小于 y</td>\n<td>x &lt; y</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>x 大于等于 y</td>\n<td>x &gt;= y</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>x 小于等于 y</td>\n<td>x &lt;= y</td>\n</tr>\n<tr>\n<td>==</td>\n<td>x 等于 y</td>\n<td>x == y</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>x 不等于 y</td>\n<td>x != y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:</strong><br>\n本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-jie-gou\">基本数据结构</h1>\n<p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p>\n<p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>\n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>\n此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p>\n<p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>\n当然, 我们此处仅学习基本数据结构</p>\n<h2 id=\"lie-biao\" id=\"列表\">列表</h2>\n<p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p>\n<h3 id=\"dan-suo-yin\" id=\"单索引\">单索引</h3>\n<p>我们可以通过单个索引, 访问对应的单个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 有着 3 个元素的列表</span></span><br><span class=\"line\"><span class=\"built_in\">list</span> = [<span class=\"number\">300</span>, <span class=\"number\">400</span>, <span class=\"number\">500</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">0</span>]  <span class=\"comment\"># 300</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">1</span>]  <span class=\"comment\"># 400</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">2</span>]  <span class=\"comment\"># 500</span></span><br></pre></td></tr></table></figure>\n<p><strong>扩展: 为何 index 从 0 开始?</strong><br>\n因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>\n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>\n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p>\n<p>你可以这样理解:<br>\n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>\n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p>\n<p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>\n如何访问第 1 个格子? 第一个格子向右跳 0 格<br>\n如何访问第 2 个格子? 第二个格子向右跳 1 格<br>\n如何访问第 3 个格子? 第三个格子向右跳 2 格</p>\n<p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>\n要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p>\n<p>如果你非要把下标从 1 开始, 那就得这样:<br>\nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>\n于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>\n同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>\n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p>\n<p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>\n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br>\n<s>(好吧, 原因其实真的只是因为习俗)</s></p>\n<p>而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 😃</p>\n<p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>\n比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p>\n<p>举个例子, 已知 <code>a = [10, 20, 30, 40, 50]</code> 让我们将其与图表进行对立:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>元素</td>\n<td>10</td>\n<td>20</td>\n<td>30</td>\n<td>40</td>\n<td>50</td>\n</tr>\n<tr>\n<td>正索引</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>负索引</td>\n<td>-5</td>\n<td>-4</td>\n<td>-3</td>\n<td>-2</td>\n<td>-1</td>\n</tr>\n</tbody>\n</table>\n<p>显而易见的, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p>\n<h3 id=\"suo-yin-yue-jie\" id=\"索引越界\">索引越界</h3>\n<p>于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:</p>\n<figure class=\"highlight python\"><figcaption><span>demo.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">a[<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>当我们在命令行中执行 <code>python demo.py</code> (见 <a href=\"/posts/high-school-it/p2#huan-jing-da-jian\">p2: 基础科普#环境搭建</a> ) 或直接使用图形化工具, 点击运行按钮</p>\n<p>脑子想一想都知道肯定编译不过, 我们将得到以下报错:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent <span class=\"keyword\">call</span> <span class=\"keyword\">last</span>):</span><br><span class=\"line\">  File <span class=\"string\">&quot;/home/jedsek/a.py&quot;</span>, <span class=\"built_in\">line</span> <span class=\"number\">2</span>, in <span class=\"symbol\">&lt;module&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">a</span>[<span class=\"number\">5</span>]</span><br><span class=\"line\">    ~^^^</span><br><span class=\"line\">IndexError: <span class=\"keyword\">list</span> <span class=\"built_in\">index</span> out of <span class=\"built_in\">range</span></span><br></pre></td></tr></table></figure>\n<p>看不懂的直接像做玩英语完形一样当作 “哔(屏蔽词)” 跳过就好, index 是 “索引/下标的意思”, 这条报错表示, 下标越界了!<br>\n因为 a 是个长度为 5 的列表, 所以只能用 <code>n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)</code> 来当下标, 即 0 到 4, 因此 5 是非法的<br>\n负索引也是一样的道理, 不能越界哟~~</p>\n<h3 id=\"qie-pian\" id=\"切片\">切片</h3>\n<p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">numbers = [<span class=\"number\">201</span>, <span class=\"number\">202</span>, <span class=\"number\">203</span>, <span class=\"number\">204</span>]  <span class=\"comment\"># 定义列表</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">4</span>]  <span class=\"comment\"># [201, 202, 203, 204]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">2</span>]  <span class=\"comment\"># [201, 202]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">1</span>]  <span class=\"comment\"># [201]</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>\n我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p>\n<p>图表依然会较为直观:</p>\n<p><code>numbers = [201, 202, 203, 204]</code></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>切片</td>\n<td>对应索引</td>\n<td>取出的子列表</td>\n</tr>\n<tr>\n<td>0:4</td>\n<td>[0, 1, 2, 3]</td>\n<td>[201, 202, 203, 204]</td>\n</tr>\n<tr>\n<td>0:2</td>\n<td>[0, 1]</td>\n<td>[201, 202]</td>\n</tr>\n<tr>\n<td>0:1</td>\n<td>[0]</td>\n<td>[201]</td>\n</tr>\n<tr>\n<td>-3:-1</td>\n<td>[-3, -2]</td>\n<td>[202, 203]</td>\n</tr>\n</tbody>\n</table>\n<p>默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 <code>numbers[0:4:1]</code> 就相当于 <code>numbers[0:4]</code><br>\n而 <code>numbers[0:4:2]</code> 则相当于从 <code>[0, 1, 2, 3]</code> 中的第一个元素 <code>0</code> 开始, 作为下标取 numbers 的元素, 然后走两步到 <code>2</code>, 依次类推<br>\n步长不能设置为 0, 不然会报错</p>\n<p>有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 <code>[]</code><br>\n举个例子: <code>numbers[3:2]</code> 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分</p>\n<h3 id=\"sheng-lue-yu-mo-ren-zhi\" id=\"省略与默认值\">省略与默认值</h3>\n<p>关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 😃</p>\n<p>已知 <code>a = [10, 20, 30, 40, 50]</code>, 你可以使用 <code>a[start:stop:step]</code> 来表示 a 的切片, 其中 start/stop/step 都是可以省略的<br>\n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 <code>a[start:stop]</code>/<code>a[start:stop:]</code> 的形式时, 步长会使用默认值1</p>\n<p>而对于 <code>start/stop</code> 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取<br>\n举些例子, 已知 <code>a = [10, 20, 30, 40, 50, 60, 70]</code>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>a[2:5:1]</code> 中, <code>2:4</code> 对应的下标是 <code>[2, 3, 4]</code>, 索引对应的元素是 <code>[30, 40, 50]</code>, 因为步长为1, 所以结果直接就是 <code>[30, 40, 50]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::1]</code> 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 <code>[30, 40, 50, 60, 70]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:1]</code> 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 <code>[10, 20]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::-1]</code> 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 <code>[30, 20, 10]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:-1]</code> 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 <code>[70, 60, 50, 40]</code></p>\n</li>\n</ul>\n<p>什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>start</code> 代表列表中某个元素的下标, 这个元素是切片的起头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>stop</code> 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>step</code> 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取</p>\n</li>\n</ul>\n<p>要开始了哦, 超级直观的方法:</p>\n<p>以 <code>a[2:5:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>5</code>, 所以箭头的终点是 <code>50</code> (箭头从 60 逆方向缩一格): [10, 20, <s>30, 40, 50</s>&gt;, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n</ul>\n<p>以 <code>a[:2:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在左边的无限远处, 不用动: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>20</code> (箭头从 30 逆方向缩一格): <s>[10, 20</s>&gt;, 30, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[:2:-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在右边的无限远处, 不用动: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>40</code> (箭头从 30 逆方向缩一格): [10, 20, 30, &lt;<s>40, 50, 60, 70]</s></p>\n</li>\n</ul>\n<p>对于负索引也是一样的道理, 先确定好 <code>start</code> 与 <code>stop</code> 的位置, 然后根据步长画对应方向的箭头<br>\n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行<br>\n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可</p>\n<hr>\n<h2 id=\"zi-dian\" id=\"字典\">字典</h2>\n<p>python 中的字典, 实际上就是一些键值对组成的集合<br>\n键值对, 指的就是根据某个键值, 获取其对应的另外一个值</p>\n<p>举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>名字: “小明”</p>\n</li>\n<li class=\"lvl-2\">\n<p>年龄(year): 16</p>\n</li>\n<li class=\"lvl-2\">\n<p>身高(cm): 178</p>\n</li>\n</ul>\n<p>名字 -&gt; “小明”, 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了</p>\n<p>在 python 中, 你可以用一对花括号来定义字典:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"string\">&#x27;Shadd&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;Lasd&#x27;</span>: <span class=\"number\">111</span>, <span class=\"string\">&#x27;PPqwea&#x27;</span>: <span class=\"number\">899</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  <code>a['Shadd']</code> 将得到 <code>10</code></p>\n","site":{"data":{}},"length":7235,"excerpt":"<blockquote>\n<p>正式的对python语法的学习, 包含常见库函数的使用</p>\n</blockquote>","more":"<p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href=\"/posts/high-school-it/p2\">p2: 基础科普与环境搭建</a><br>\n<strong>感谢:</strong><br>\n本文的切片部分来源于 <a href=\"https://zhuanlan.zhihu.com/p/79541418\">python切片完全指南(语法篇)</a>, 已经过原作者准许</p>\n<h1 id=\"bian-liang-yu-fu-zhi\">变量与赋值</h1>\n<p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>\n需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p>\n<p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>\n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p>\n<p>有两个概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>声明变量:  创建变量 (声明一个变量出现了)</p>\n</li>\n<li class=\"lvl-2\">\n<p>赋值: 把一个值装到箱子(变量)里</p>\n</li>\n</ul>\n<p>比如, 一个很简单的例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>\n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p>\n<p>变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同</p>\n<p>你也可以这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>\n第二行表示, 把a里面的数值取出来, 传给了b</p>\n<p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = b = c = <span class=\"number\">1</span></span><br><span class=\"line\">d = e = f = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a,b,c = d,e,f</span><br></pre></td></tr></table></figure>\n<p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p>\n<p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">a,b = b,a</span><br></pre></td></tr></table></figure>\n<p>你可能会疑惑:<br>\n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>\n该想法对应的代码是这样的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = b</span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>但在交换数值的代码中, 你应该这样理解:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">_t1 = b</span><br><span class=\"line\">_t2 = a</span><br><span class=\"line\">a = _t1</span><br><span class=\"line\">b = _t2</span><br></pre></td></tr></table></figure>\n<p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>\n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了<br>\n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p>\n<p>另外 选择题会出现这样的常见选项:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.  a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, c = <span class=\"number\">3</span></span><br><span class=\"line\">B.  a, b, c = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\">C.  a = <span class=\"number\">1</span>; b = <span class=\"number\">2</span>; c = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已</p>\n<hr>\n<h1 id=\"bian-liang-ming-ming-gui-fan\">变量命名规范</h1>\n<p>python中, 变量的命名必须符合规范, 不然直接报错<br>\n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p>\n<p>命名规范如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>变量名由字母, 数字, 下划线组成</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能由数字开头</p>\n</li>\n<li class=\"lvl-2\">\n<p>中间不能有空格分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能与python中的关键字重名</p>\n</li>\n</ul>\n<p>以下都是合法的变量名</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">abada</span><br><span class=\"line\">asd111231</span><br><span class=\"line\">ad190123kkad</span><br><span class=\"line\">asd_asd1_asd2</span><br><span class=\"line\">_123daa</span><br><span class=\"line\">_as11</span><br></pre></td></tr></table></figure>\n<p>以下是不合法的变量名:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">not</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">in</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lambda</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">1123</span></span><br><span class=\"line\"><span class=\"function\">123<span class=\"title\">adad</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sad</span>;;-``</span></span><br><span class=\"line\"><span class=\"function\">``?/</span></span><br><span class=\"line\"><span class=\"function\">&#x27;,</span></span><br></pre></td></tr></table></figure>\n<p><strong>关键字:</strong><br>\n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>\n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>\n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p>\n<p>你怎么知道哪些是关键字呢? 慢慢看吧, 像 <code>def/import/for/if/break</code> 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字</p>\n<hr>\n<h1 id=\"zhu-shi\">注释</h1>\n<h2 id=\"zuo-yong\" id=\"作用\">作用</h2>\n<p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>\n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  此时 a 的值为 <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  <span class=\"comment\"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure>\n<p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>\n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p>\n<p>再举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">c = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">max</span> = -<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> a &gt; b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = a</span><br><span class=\"line\"><span class=\"keyword\">elif</span> b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = b</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">max</span>)</span><br></pre></td></tr></table></figure>\n<p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p>\n<h2 id=\"dan-duo-xing-zhu-shi\" id=\"单-多行注释\">单/多行注释</h2>\n<p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 12345</span></span><br><span class=\"line\"><span class=\"comment\"># 上山打老虎</span></span><br><span class=\"line\"><span class=\"comment\"># 老虎打不着</span></span><br><span class=\"line\"><span class=\"comment\"># 打到小松鼠</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27; </span></span><br><span class=\"line\"><span class=\"string\">12345</span></span><br><span class=\"line\"><span class=\"string\">上山打老虎</span></span><br><span class=\"line\"><span class=\"string\">老虎打不着</span></span><br><span class=\"line\"><span class=\"string\">打到小松鼠</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>\n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-lei-xing\">基本数据类型</h1>\n<p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>\n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p>\n<p>为了模拟现实, py将数据进行了抽象与分类:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>int: 对应整数</p>\n</li>\n<li class=\"lvl-2\">\n<p>float: 对应实数</p>\n</li>\n<li class=\"lvl-2\">\n<p>string: 对应文字</p>\n</li>\n<li class=\"lvl-2\">\n<p>bool: 对应真与假</p>\n</li>\n</ul>\n<p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p>\n<p>举些例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的年龄是16岁: 用int来表示 16 这个数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p>\n</li>\n</ul>\n<p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>\n你可以这样抽象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">student &#123;</span><br><span class=\"line\">  age:  <span class=\"built_in\">int</span>,</span><br><span class=\"line\">  height: <span class=\"built_in\">float</span>,</span><br><span class=\"line\">  name: string,</span><br><span class=\"line\">  fat_or_not: <span class=\"built_in\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p>\n<hr>\n<h1 id=\"yun-suan-fu-yu-you-xian-ji\">运算符与优先级</h1>\n<p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>\n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>\n在以下的图表中, 优先级1是最高, 数字越大优先级越低</p>\n<h2 id=\"suan-zhu-yun-suan-fu\" id=\"算术运算符\">算术运算符</h2>\n<p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n<th>优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>x的y次方</td>\n<td>x**y</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>x乘以y</td>\n<td>x*y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>/</td>\n<td>x除以y, 产生实数值</td>\n<td>x/y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>x除以y, 产生整数值</td>\n<td>x//y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>x除以y, 取余数</td>\n<td>x%y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>+</td>\n<td>x加y</td>\n<td>x+y</td>\n<td>3</td>\n</tr>\n<tr>\n<td>-</td>\n<td>x减y</td>\n<td>x-y</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p>\n<p>算术运算符, 可以与赋值运算符相互结合:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a += <span class=\"number\">1</span>  <span class=\"comment\"># 是上面的等价物</span></span><br></pre></td></tr></table></figure>\n<p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p>\n<h2 id=\"guan-xi-yun-suan-fu\" id=\"关系运算符\">关系运算符</h2>\n<p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>\n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>x 大于 y</td>\n<td>x &gt; y</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>x 小于 y</td>\n<td>x &lt; y</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>x 大于等于 y</td>\n<td>x &gt;= y</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>x 小于等于 y</td>\n<td>x &lt;= y</td>\n</tr>\n<tr>\n<td>==</td>\n<td>x 等于 y</td>\n<td>x == y</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>x 不等于 y</td>\n<td>x != y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:</strong><br>\n本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-jie-gou\">基本数据结构</h1>\n<p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p>\n<p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>\n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>\n此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p>\n<p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>\n当然, 我们此处仅学习基本数据结构</p>\n<h2 id=\"lie-biao\" id=\"列表\">列表</h2>\n<p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p>\n<h3 id=\"dan-suo-yin\" id=\"单索引\">单索引</h3>\n<p>我们可以通过单个索引, 访问对应的单个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 有着 3 个元素的列表</span></span><br><span class=\"line\"><span class=\"built_in\">list</span> = [<span class=\"number\">300</span>, <span class=\"number\">400</span>, <span class=\"number\">500</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">0</span>]  <span class=\"comment\"># 300</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">1</span>]  <span class=\"comment\"># 400</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">2</span>]  <span class=\"comment\"># 500</span></span><br></pre></td></tr></table></figure>\n<p><strong>扩展: 为何 index 从 0 开始?</strong><br>\n因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>\n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>\n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p>\n<p>你可以这样理解:<br>\n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>\n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p>\n<p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>\n如何访问第 1 个格子? 第一个格子向右跳 0 格<br>\n如何访问第 2 个格子? 第二个格子向右跳 1 格<br>\n如何访问第 3 个格子? 第三个格子向右跳 2 格</p>\n<p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>\n要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p>\n<p>如果你非要把下标从 1 开始, 那就得这样:<br>\nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>\n于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>\n同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>\n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p>\n<p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>\n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br>\n<s>(好吧, 原因其实真的只是因为习俗)</s></p>\n<p>而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 😃</p>\n<p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>\n比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p>\n<p>举个例子, 已知 <code>a = [10, 20, 30, 40, 50]</code> 让我们将其与图表进行对立:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>元素</td>\n<td>10</td>\n<td>20</td>\n<td>30</td>\n<td>40</td>\n<td>50</td>\n</tr>\n<tr>\n<td>正索引</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>负索引</td>\n<td>-5</td>\n<td>-4</td>\n<td>-3</td>\n<td>-2</td>\n<td>-1</td>\n</tr>\n</tbody>\n</table>\n<p>显而易见的, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p>\n<h3 id=\"suo-yin-yue-jie\" id=\"索引越界\">索引越界</h3>\n<p>于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:</p>\n<figure class=\"highlight python\"><figcaption><span>demo.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">a[<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>当我们在命令行中执行 <code>python demo.py</code> (见 <a href=\"/posts/high-school-it/p2#huan-jing-da-jian\">p2: 基础科普#环境搭建</a> ) 或直接使用图形化工具, 点击运行按钮</p>\n<p>脑子想一想都知道肯定编译不过, 我们将得到以下报错:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent <span class=\"keyword\">call</span> <span class=\"keyword\">last</span>):</span><br><span class=\"line\">  File <span class=\"string\">&quot;/home/jedsek/a.py&quot;</span>, <span class=\"built_in\">line</span> <span class=\"number\">2</span>, in <span class=\"symbol\">&lt;module&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">a</span>[<span class=\"number\">5</span>]</span><br><span class=\"line\">    ~^^^</span><br><span class=\"line\">IndexError: <span class=\"keyword\">list</span> <span class=\"built_in\">index</span> out of <span class=\"built_in\">range</span></span><br></pre></td></tr></table></figure>\n<p>看不懂的直接像做玩英语完形一样当作 “哔(屏蔽词)” 跳过就好, index 是 “索引/下标的意思”, 这条报错表示, 下标越界了!<br>\n因为 a 是个长度为 5 的列表, 所以只能用 <code>n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)</code> 来当下标, 即 0 到 4, 因此 5 是非法的<br>\n负索引也是一样的道理, 不能越界哟~~</p>\n<h3 id=\"qie-pian\" id=\"切片\">切片</h3>\n<p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">numbers = [<span class=\"number\">201</span>, <span class=\"number\">202</span>, <span class=\"number\">203</span>, <span class=\"number\">204</span>]  <span class=\"comment\"># 定义列表</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">4</span>]  <span class=\"comment\"># [201, 202, 203, 204]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">2</span>]  <span class=\"comment\"># [201, 202]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">1</span>]  <span class=\"comment\"># [201]</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>\n我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p>\n<p>图表依然会较为直观:</p>\n<p><code>numbers = [201, 202, 203, 204]</code></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>切片</td>\n<td>对应索引</td>\n<td>取出的子列表</td>\n</tr>\n<tr>\n<td>0:4</td>\n<td>[0, 1, 2, 3]</td>\n<td>[201, 202, 203, 204]</td>\n</tr>\n<tr>\n<td>0:2</td>\n<td>[0, 1]</td>\n<td>[201, 202]</td>\n</tr>\n<tr>\n<td>0:1</td>\n<td>[0]</td>\n<td>[201]</td>\n</tr>\n<tr>\n<td>-3:-1</td>\n<td>[-3, -2]</td>\n<td>[202, 203]</td>\n</tr>\n</tbody>\n</table>\n<p>默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 <code>numbers[0:4:1]</code> 就相当于 <code>numbers[0:4]</code><br>\n而 <code>numbers[0:4:2]</code> 则相当于从 <code>[0, 1, 2, 3]</code> 中的第一个元素 <code>0</code> 开始, 作为下标取 numbers 的元素, 然后走两步到 <code>2</code>, 依次类推<br>\n步长不能设置为 0, 不然会报错</p>\n<p>有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 <code>[]</code><br>\n举个例子: <code>numbers[3:2]</code> 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分</p>\n<h3 id=\"sheng-lue-yu-mo-ren-zhi\" id=\"省略与默认值\">省略与默认值</h3>\n<p>关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 😃</p>\n<p>已知 <code>a = [10, 20, 30, 40, 50]</code>, 你可以使用 <code>a[start:stop:step]</code> 来表示 a 的切片, 其中 start/stop/step 都是可以省略的<br>\n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 <code>a[start:stop]</code>/<code>a[start:stop:]</code> 的形式时, 步长会使用默认值1</p>\n<p>而对于 <code>start/stop</code> 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取<br>\n举些例子, 已知 <code>a = [10, 20, 30, 40, 50, 60, 70]</code>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>a[2:5:1]</code> 中, <code>2:4</code> 对应的下标是 <code>[2, 3, 4]</code>, 索引对应的元素是 <code>[30, 40, 50]</code>, 因为步长为1, 所以结果直接就是 <code>[30, 40, 50]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::1]</code> 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 <code>[30, 40, 50, 60, 70]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:1]</code> 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 <code>[10, 20]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::-1]</code> 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 <code>[30, 20, 10]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:-1]</code> 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 <code>[70, 60, 50, 40]</code></p>\n</li>\n</ul>\n<p>什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>start</code> 代表列表中某个元素的下标, 这个元素是切片的起头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>stop</code> 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>step</code> 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取</p>\n</li>\n</ul>\n<p>要开始了哦, 超级直观的方法:</p>\n<p>以 <code>a[2:5:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>5</code>, 所以箭头的终点是 <code>50</code> (箭头从 60 逆方向缩一格): [10, 20, <s>30, 40, 50</s>&gt;, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n</ul>\n<p>以 <code>a[:2:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在左边的无限远处, 不用动: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>20</code> (箭头从 30 逆方向缩一格): <s>[10, 20</s>&gt;, 30, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[:2:-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在右边的无限远处, 不用动: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>40</code> (箭头从 30 逆方向缩一格): [10, 20, 30, &lt;<s>40, 50, 60, 70]</s></p>\n</li>\n</ul>\n<p>对于负索引也是一样的道理, 先确定好 <code>start</code> 与 <code>stop</code> 的位置, 然后根据步长画对应方向的箭头<br>\n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行<br>\n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可</p>\n<hr>\n<h2 id=\"zi-dian\" id=\"字典\">字典</h2>\n<p>python 中的字典, 实际上就是一些键值对组成的集合<br>\n键值对, 指的就是根据某个键值, 获取其对应的另外一个值</p>\n<p>举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>名字: “小明”</p>\n</li>\n<li class=\"lvl-2\">\n<p>年龄(year): 16</p>\n</li>\n<li class=\"lvl-2\">\n<p>身高(cm): 178</p>\n</li>\n</ul>\n<p>名字 -&gt; “小明”, 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了</p>\n<p>在 python 中, 你可以用一对花括号来定义字典:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"string\">&#x27;Shadd&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;Lasd&#x27;</span>: <span class=\"number\">111</span>, <span class=\"string\">&#x27;PPqwea&#x27;</span>: <span class=\"number\">899</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  <code>a['Shadd']</code> 将得到 <code>10</code></p>"},{"title":"high-school-it-p4~> python基础语法-part2","abbrlink":"posts/high-school-it/p4","hidden":false,"date":"2022-11-10T14:59:39.000Z","top":7996,"keywords":["高中信息技术","python"],"is_series":true,"prev_post":["/posts/high-school-it/p3","p3~> python基础语法-part1.md"],"next_post":["/posts/high-school-it/p5","p5~> 进制的转换与应用"],"_content":"","source":"_posts/high-school-it/p4-python基础语法-part2-md.md","raw":"---\ntitle: \"high-school-it-p4~> python基础语法-part2\" \nabbrlink: posts/high-school-it/p4\nhidden: false\ndate: 2022-11-10 22:59:39\ntop: 7996\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\nis_series: true\nprev_post: [/posts/high-school-it/p3, \"p3~> python基础语法-part1.md\"]\nnext_post: [/posts/high-school-it/p5, \"p5~> 进制的转换与应用\"]\n---\n","slug":"high-school-it/p4-python基础语法-part2-md","published":1,"updated":"2022-11-10T14:59:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og50009j1s6gr13brw8","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"high-school-it-p5~> 进制的转换与应用","abbrlink":"posts/high-school-it/p5","hidden":false,"date":"2022-11-23T15:51:02.000Z","top":7995,"keywords":["高中信息技术","python"],"is_series":true,"prev_post":["/posts/high-school-it/p4","p4~> python基础语法-part2"],"_content":"> 关于任意进制间的互相转换与应用\n<!-- more -->\n\n","source":"_posts/high-school-it/p5-进制的转换与应用.md","raw":"---\ntitle: \"high-school-it-p5~> 进制的转换与应用\"\nabbrlink: posts/high-school-it/p5\nhidden: false\ndate: 2022-11-23 23:51:02\ntop: 7995\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\nis_series: true\nprev_post: [/posts/high-school-it/p4, \"p4~> python基础语法-part2\"]\n---\n> 关于任意进制间的互相转换与应用\n<!-- more -->\n\n","slug":"high-school-it/p5-进制的转换与应用","published":1,"updated":"2022-11-23T15:51:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og6000aj1s662xvgwi2","content":"<blockquote>\n<p>关于任意进制间的互相转换与应用</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":15,"excerpt":"<blockquote>\n<p>关于任意进制间的互相转换与应用</p>\n</blockquote>","more":""},{"title":"光栅化-对直线的dda与bresenham算法","abbrlink":"posts/other/rasterization-dda-bresenham","hidden":false,"date":"2022-12-26T09:35:10.000Z","top":null,"keywords":null,"mathjax":true,"_content":"关于 光栅化(rasterrization) 中的 DDA 与 Bresenham 两种算法\n<!-- more -->\n\n# 光栅化\n\n首先我们要明白一些常识:  计算机是如何显示图像的?  \n答案很简单, 用电子枪发射电子, 通过电磁场偏转来控制其方向, 打在屏幕上, 进行高速扫描(scan), 即电子束从左往右, 从上往下发射  \n只要在短时间内多次进行扫描, 利用人眼的视觉暂留效果, 让图像, 即上色的像素集合 \"显示\" 出来  \n\nRGB 三原色, 位深分别为 8bit, 即 1byte, 就能构成 (2^8^ * 2^8^ * 2^8^) 种组合, 是爆表多的颜色种类啊  \n只要将一束电子, 变为三束电子, 分别掌管 RGB, 瞄准显示屏上的特定一小块, 就有绚丽多彩的颜色了, 我们称其为, 像素(pixel)  \n\n同时, 这里有两个概念要区分一下:  \n- 片元(fragment): 物理层次上的显示屏上的一小块/一小单元, 概念上更加客观些\n- 像素(pxiel): 已经被染色的图片单元, 概念上更高级更抽象些, 以片元为载体\n\n光栅(Raster), 德语中 \"屏幕\" 的意思, 光栅化自然就是指把什么东西渲染到屏幕上的过程咯  \n可以简单理解为, 光栅化就是在研究, 在屏幕上绘制像素的过程\n\n下面将介绍两种将直线给光栅化的算法, 不要担心, 难度不大, 只需要初中级别的数学水平即可  \n并且假设你已经知道for循环, function, 赋值等编程中的基本概念\n\n- - -\n \n# DDA算法\nDDA(Digital Differential Analyzer), 数字微分分析法, 可别被这名字给吓到了, 实际上这是很容易理解的  \n假设每个像素方块, 其左下角为该像素的坐标, 已知起点与终点的坐标 $\\begin{cases}(x_1, y_1)\\\\\\\\(x_2, y_2)\\end{cases}$, 可求出其斜率k  \n当k<1时, 如图所示, x每增加1时, y需要增加m, 随后将y向下取整得到yy, 然后渲染(x, yy):  \n\n![dda-图1](/images/others/dda_1.png)\n\n用伪代码表示的话, 就是这样:  \n\n```rust\nfor x in x1..=x2 step=1.0\n  y1 += k\n  yy = floor(y1)    // 关键, 但可以不是floor\n  write_pixel(x, yy, BLUE)\n```\n\n结合图片, 相信你应该能够看懂\n\n当然, 我们还可以选择不用 floor, 而是 round, 这叫做圆整处理, 可以尽量做到直线平滑  \n此处, 可以将四舍五入理解为圆整处理, 伪代码如下:  \n\n```rust\nfor x in x1..=x2 step=1.0\n  y1 += k\n  yy = round(y1)  // 圆整处理\n  write_pixel(x, yy, BLUE)\n```\n\n但还有一些问题, 那就是当斜率k > 1时, 即倾斜角大于 45 度时, 如果按照 \"x不断+1, y不断+k\" 的套路, 将无法连续, 如下左图所示  \n此时, 我们就应该反转一下, 按照 \"y不断+1, x不断+1/k\" 的套路, 才能做到尽量连续, 即反转了x与y轴, 如下右图所示  \n\n![dda-图2](/images/others/dda_2.png)\n\n我们将沿着x轴的方向, 或沿着y轴的方向, 移动幅度大的那一个方向, 称作 主位移方向  \n如上面的图1, x轴为主位移方向, 而在图2中, y轴是主位移方向  \n\n当斜率k为负数时, 也可以按照以上两种思路进行处理, 要同时处理正负, 避免if分情况判断的话, 用 abs 计算绝对值即可  \n\n完整处理的伪代码如下:  \n\n```rust\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\n// 确定主位移方向是x轴还是y轴, 记得要用绝对值来避免对正负讨论\nd = max(dx, dy)\n\n// 当主位移方向为x轴, 则按照 \"x不断+1, y不断+k\", 不然按照 \"y不断+1, x不断+1/k\"\ndxx = dx / d\ndyy = dy / d\n\n// 从x1遍历到x2\n// 当主位移方向为x轴时, dxx=1,   dyy=k\n// 当主位移方向为y轴时, dxx=1/k, dyy=1\nfor x in x1..=x2 step=dxx\n  y1 += dyy\n  yy = round(y1)  // 圆整处理\n  write_pixel(x, yy, COLOR)\n```\n\n但还是不够高效, 因为涉及了大量浮点数计算, 比如 `y1 += dyy`  \n同时, for 循环那里可能因为浮点计算不够精准, 次数不够准确, 可以改写为遍历 step 次, 然后在循环体内 `x += dxx`, 但为了美观我懒得改了\n\n- - -\n\n# Bresenham算法","source":"_posts/other/光栅化-dda与bresenham算法.md","raw":"---\ntitle: 光栅化-对直线的dda与bresenham算法\nabbrlink: posts/other/rasterization-dda-bresenham\nhidden: false\ndate: 2022-12-26 17:35:10\ntop:\ntags:\nkeywords:\nmathjax: true\n---\n关于 光栅化(rasterrization) 中的 DDA 与 Bresenham 两种算法\n<!-- more -->\n\n# 光栅化\n\n首先我们要明白一些常识:  计算机是如何显示图像的?  \n答案很简单, 用电子枪发射电子, 通过电磁场偏转来控制其方向, 打在屏幕上, 进行高速扫描(scan), 即电子束从左往右, 从上往下发射  \n只要在短时间内多次进行扫描, 利用人眼的视觉暂留效果, 让图像, 即上色的像素集合 \"显示\" 出来  \n\nRGB 三原色, 位深分别为 8bit, 即 1byte, 就能构成 (2^8^ * 2^8^ * 2^8^) 种组合, 是爆表多的颜色种类啊  \n只要将一束电子, 变为三束电子, 分别掌管 RGB, 瞄准显示屏上的特定一小块, 就有绚丽多彩的颜色了, 我们称其为, 像素(pixel)  \n\n同时, 这里有两个概念要区分一下:  \n- 片元(fragment): 物理层次上的显示屏上的一小块/一小单元, 概念上更加客观些\n- 像素(pxiel): 已经被染色的图片单元, 概念上更高级更抽象些, 以片元为载体\n\n光栅(Raster), 德语中 \"屏幕\" 的意思, 光栅化自然就是指把什么东西渲染到屏幕上的过程咯  \n可以简单理解为, 光栅化就是在研究, 在屏幕上绘制像素的过程\n\n下面将介绍两种将直线给光栅化的算法, 不要担心, 难度不大, 只需要初中级别的数学水平即可  \n并且假设你已经知道for循环, function, 赋值等编程中的基本概念\n\n- - -\n \n# DDA算法\nDDA(Digital Differential Analyzer), 数字微分分析法, 可别被这名字给吓到了, 实际上这是很容易理解的  \n假设每个像素方块, 其左下角为该像素的坐标, 已知起点与终点的坐标 $\\begin{cases}(x_1, y_1)\\\\\\\\(x_2, y_2)\\end{cases}$, 可求出其斜率k  \n当k<1时, 如图所示, x每增加1时, y需要增加m, 随后将y向下取整得到yy, 然后渲染(x, yy):  \n\n![dda-图1](/images/others/dda_1.png)\n\n用伪代码表示的话, 就是这样:  \n\n```rust\nfor x in x1..=x2 step=1.0\n  y1 += k\n  yy = floor(y1)    // 关键, 但可以不是floor\n  write_pixel(x, yy, BLUE)\n```\n\n结合图片, 相信你应该能够看懂\n\n当然, 我们还可以选择不用 floor, 而是 round, 这叫做圆整处理, 可以尽量做到直线平滑  \n此处, 可以将四舍五入理解为圆整处理, 伪代码如下:  \n\n```rust\nfor x in x1..=x2 step=1.0\n  y1 += k\n  yy = round(y1)  // 圆整处理\n  write_pixel(x, yy, BLUE)\n```\n\n但还有一些问题, 那就是当斜率k > 1时, 即倾斜角大于 45 度时, 如果按照 \"x不断+1, y不断+k\" 的套路, 将无法连续, 如下左图所示  \n此时, 我们就应该反转一下, 按照 \"y不断+1, x不断+1/k\" 的套路, 才能做到尽量连续, 即反转了x与y轴, 如下右图所示  \n\n![dda-图2](/images/others/dda_2.png)\n\n我们将沿着x轴的方向, 或沿着y轴的方向, 移动幅度大的那一个方向, 称作 主位移方向  \n如上面的图1, x轴为主位移方向, 而在图2中, y轴是主位移方向  \n\n当斜率k为负数时, 也可以按照以上两种思路进行处理, 要同时处理正负, 避免if分情况判断的话, 用 abs 计算绝对值即可  \n\n完整处理的伪代码如下:  \n\n```rust\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\n// 确定主位移方向是x轴还是y轴, 记得要用绝对值来避免对正负讨论\nd = max(dx, dy)\n\n// 当主位移方向为x轴, 则按照 \"x不断+1, y不断+k\", 不然按照 \"y不断+1, x不断+1/k\"\ndxx = dx / d\ndyy = dy / d\n\n// 从x1遍历到x2\n// 当主位移方向为x轴时, dxx=1,   dyy=k\n// 当主位移方向为y轴时, dxx=1/k, dyy=1\nfor x in x1..=x2 step=dxx\n  y1 += dyy\n  yy = round(y1)  // 圆整处理\n  write_pixel(x, yy, COLOR)\n```\n\n但还是不够高效, 因为涉及了大量浮点数计算, 比如 `y1 += dyy`  \n同时, for 循环那里可能因为浮点计算不够精准, 次数不够准确, 可以改写为遍历 step 次, 然后在循环体内 `x += dxx`, 但为了美观我懒得改了\n\n- - -\n\n# Bresenham算法","slug":"other/光栅化-dda与bresenham算法","published":1,"updated":"2022-12-26T09:35:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og8000cj1s66u1p5uyz","content":"<p>关于 光栅化(rasterrization) 中的 DDA 与 Bresenham 两种算法</p>\n<span id=\"more\"></span>\n<h1 id=\"guang-zha-hua\">光栅化</h1>\n<p>首先我们要明白一些常识:  计算机是如何显示图像的?<br>\n答案很简单, 用电子枪发射电子, 通过电磁场偏转来控制其方向, 打在屏幕上, 进行高速扫描(scan), 即电子束从左往右, 从上往下发射<br>\n只要在短时间内多次进行扫描, 利用人眼的视觉暂留效果, 让图像, 即上色的像素集合 “显示” 出来</p>\n<p>RGB 三原色, 位深分别为 8bit, 即 1byte, 就能构成 (2<sup>8</sup> * 2<sup>8</sup> * 2<sup>8</sup>) 种组合, 是爆表多的颜色种类啊<br>\n只要将一束电子, 变为三束电子, 分别掌管 RGB, 瞄准显示屏上的特定一小块, 就有绚丽多彩的颜色了, 我们称其为, 像素(pixel)</p>\n<p>同时, 这里有两个概念要区分一下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>片元(fragment): 物理层次上的显示屏上的一小块/一小单元, 概念上更加客观些</p>\n</li>\n<li class=\"lvl-2\">\n<p>像素(pxiel): 已经被染色的图片单元, 概念上更高级更抽象些, 以片元为载体</p>\n</li>\n</ul>\n<p>光栅(Raster), 德语中 “屏幕” 的意思, 光栅化自然就是指把什么东西渲染到屏幕上的过程咯<br>\n可以简单理解为, 光栅化就是在研究, 在屏幕上绘制像素的过程</p>\n<p>下面将介绍两种将直线给光栅化的算法, 不要担心, 难度不大, 只需要初中级别的数学水平即可<br>\n并且假设你已经知道for循环, function, 赋值等编程中的基本概念</p>\n<hr>\n<h1 id=\"dda-suan-fa\">DDA算法</h1>\n<p>DDA(Digital Differential Analyzer), 数字微分分析法, 可别被这名字给吓到了, 实际上这是很容易理解的<br>\n假设每个像素方块, 其左下角为该像素的坐标, 已知起点与终点的坐标 $\\begin{cases}(x_1, y_1)\\\\(x_2, y_2)\\end{cases}$, 可求出其斜率k<br>\n当k&lt;1时, 如图所示, x每增加1时, y需要增加m, 随后将y向下取整得到yy, 然后渲染(x, yy):</p>\n<p><img data-src=\"/images/others/dda_1.png\" alt=\"dda-图1\"></p>\n<p>用伪代码表示的话, 就是这样:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x1..=x2 step=<span class=\"number\">1.0</span></span><br><span class=\"line\">  y1 += k</span><br><span class=\"line\">  yy = floor(y1)    <span class=\"comment\">// 关键, 但可以不是floor</span></span><br><span class=\"line\">  write_pixel(x, yy, BLUE)</span><br></pre></td></tr></table></figure>\n<p>结合图片, 相信你应该能够看懂</p>\n<p>当然, 我们还可以选择不用 floor, 而是 round, 这叫做圆整处理, 可以尽量做到直线平滑<br>\n此处, 可以将四舍五入理解为圆整处理, 伪代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x1..=x2 step=<span class=\"number\">1.0</span></span><br><span class=\"line\">  y1 += k</span><br><span class=\"line\">  yy = round(y1)  <span class=\"comment\">// 圆整处理</span></span><br><span class=\"line\">  write_pixel(x, yy, BLUE)</span><br></pre></td></tr></table></figure>\n<p>但还有一些问题, 那就是当斜率k &gt; 1时, 即倾斜角大于 45 度时, 如果按照 “x不断+1, y不断+k” 的套路, 将无法连续, 如下左图所示<br>\n此时, 我们就应该反转一下, 按照 “y不断+1, x不断+1/k” 的套路, 才能做到尽量连续, 即反转了x与y轴, 如下右图所示</p>\n<p><img data-src=\"/images/others/dda_2.png\" alt=\"dda-图2\"></p>\n<p>我们将沿着x轴的方向, 或沿着y轴的方向, 移动幅度大的那一个方向, 称作 主位移方向<br>\n如上面的图1, x轴为主位移方向, 而在图2中, y轴是主位移方向</p>\n<p>当斜率k为负数时, 也可以按照以上两种思路进行处理, 要同时处理正负, 避免if分情况判断的话, 用 abs 计算绝对值即可</p>\n<p>完整处理的伪代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">dx = abs(x2 - x1)</span><br><span class=\"line\">dy = abs(y2 - y1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确定主位移方向是x轴还是y轴, 记得要用绝对值来避免对正负讨论</span></span><br><span class=\"line\">d = max(dx, dy)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当主位移方向为x轴, 则按照 &quot;x不断+1, y不断+k&quot;, 不然按照 &quot;y不断+1, x不断+1/k&quot;</span></span><br><span class=\"line\">dxx = dx / d</span><br><span class=\"line\">dyy = dy / d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从x1遍历到x2</span></span><br><span class=\"line\"><span class=\"comment\">// 当主位移方向为x轴时, dxx=1,   dyy=k</span></span><br><span class=\"line\"><span class=\"comment\">// 当主位移方向为y轴时, dxx=1/k, dyy=1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x1..=x2 step=dxx</span><br><span class=\"line\">  y1 += dyy</span><br><span class=\"line\">  yy = round(y1)  <span class=\"comment\">// 圆整处理</span></span><br><span class=\"line\">  write_pixel(x, yy, COLOR)</span><br></pre></td></tr></table></figure>\n<p>但还是不够高效, 因为涉及了大量浮点数计算, 比如 <code>y1 += dyy</code><br>\n同时, for 循环那里可能因为浮点计算不够精准, 次数不够准确, 可以改写为遍历 step 次, 然后在循环体内 <code>x += dxx</code>, 但为了美观我懒得改了</p>\n<hr>\n<h1 id=\"bresenham-suan-fa\">Bresenham算法</h1>\n","site":{"data":{}},"length":1626,"excerpt":"<p>关于 光栅化(rasterrization) 中的 DDA 与 Bresenham 两种算法</p>","more":"<h1 id=\"guang-zha-hua\">光栅化</h1>\n<p>首先我们要明白一些常识:  计算机是如何显示图像的?<br>\n答案很简单, 用电子枪发射电子, 通过电磁场偏转来控制其方向, 打在屏幕上, 进行高速扫描(scan), 即电子束从左往右, 从上往下发射<br>\n只要在短时间内多次进行扫描, 利用人眼的视觉暂留效果, 让图像, 即上色的像素集合 “显示” 出来</p>\n<p>RGB 三原色, 位深分别为 8bit, 即 1byte, 就能构成 (2<sup>8</sup> * 2<sup>8</sup> * 2<sup>8</sup>) 种组合, 是爆表多的颜色种类啊<br>\n只要将一束电子, 变为三束电子, 分别掌管 RGB, 瞄准显示屏上的特定一小块, 就有绚丽多彩的颜色了, 我们称其为, 像素(pixel)</p>\n<p>同时, 这里有两个概念要区分一下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>片元(fragment): 物理层次上的显示屏上的一小块/一小单元, 概念上更加客观些</p>\n</li>\n<li class=\"lvl-2\">\n<p>像素(pxiel): 已经被染色的图片单元, 概念上更高级更抽象些, 以片元为载体</p>\n</li>\n</ul>\n<p>光栅(Raster), 德语中 “屏幕” 的意思, 光栅化自然就是指把什么东西渲染到屏幕上的过程咯<br>\n可以简单理解为, 光栅化就是在研究, 在屏幕上绘制像素的过程</p>\n<p>下面将介绍两种将直线给光栅化的算法, 不要担心, 难度不大, 只需要初中级别的数学水平即可<br>\n并且假设你已经知道for循环, function, 赋值等编程中的基本概念</p>\n<hr>\n<h1 id=\"dda-suan-fa\">DDA算法</h1>\n<p>DDA(Digital Differential Analyzer), 数字微分分析法, 可别被这名字给吓到了, 实际上这是很容易理解的<br>\n假设每个像素方块, 其左下角为该像素的坐标, 已知起点与终点的坐标 $\\begin{cases}(x_1, y_1)\\\\(x_2, y_2)\\end{cases}$, 可求出其斜率k<br>\n当k&lt;1时, 如图所示, x每增加1时, y需要增加m, 随后将y向下取整得到yy, 然后渲染(x, yy):</p>\n<p><img data-src=\"/images/others/dda_1.png\" alt=\"dda-图1\"></p>\n<p>用伪代码表示的话, 就是这样:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x1..=x2 step=<span class=\"number\">1.0</span></span><br><span class=\"line\">  y1 += k</span><br><span class=\"line\">  yy = floor(y1)    <span class=\"comment\">// 关键, 但可以不是floor</span></span><br><span class=\"line\">  write_pixel(x, yy, BLUE)</span><br></pre></td></tr></table></figure>\n<p>结合图片, 相信你应该能够看懂</p>\n<p>当然, 我们还可以选择不用 floor, 而是 round, 这叫做圆整处理, 可以尽量做到直线平滑<br>\n此处, 可以将四舍五入理解为圆整处理, 伪代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x1..=x2 step=<span class=\"number\">1.0</span></span><br><span class=\"line\">  y1 += k</span><br><span class=\"line\">  yy = round(y1)  <span class=\"comment\">// 圆整处理</span></span><br><span class=\"line\">  write_pixel(x, yy, BLUE)</span><br></pre></td></tr></table></figure>\n<p>但还有一些问题, 那就是当斜率k &gt; 1时, 即倾斜角大于 45 度时, 如果按照 “x不断+1, y不断+k” 的套路, 将无法连续, 如下左图所示<br>\n此时, 我们就应该反转一下, 按照 “y不断+1, x不断+1/k” 的套路, 才能做到尽量连续, 即反转了x与y轴, 如下右图所示</p>\n<p><img data-src=\"/images/others/dda_2.png\" alt=\"dda-图2\"></p>\n<p>我们将沿着x轴的方向, 或沿着y轴的方向, 移动幅度大的那一个方向, 称作 主位移方向<br>\n如上面的图1, x轴为主位移方向, 而在图2中, y轴是主位移方向</p>\n<p>当斜率k为负数时, 也可以按照以上两种思路进行处理, 要同时处理正负, 避免if分情况判断的话, 用 abs 计算绝对值即可</p>\n<p>完整处理的伪代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">dx = abs(x2 - x1)</span><br><span class=\"line\">dy = abs(y2 - y1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确定主位移方向是x轴还是y轴, 记得要用绝对值来避免对正负讨论</span></span><br><span class=\"line\">d = max(dx, dy)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当主位移方向为x轴, 则按照 &quot;x不断+1, y不断+k&quot;, 不然按照 &quot;y不断+1, x不断+1/k&quot;</span></span><br><span class=\"line\">dxx = dx / d</span><br><span class=\"line\">dyy = dy / d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从x1遍历到x2</span></span><br><span class=\"line\"><span class=\"comment\">// 当主位移方向为x轴时, dxx=1,   dyy=k</span></span><br><span class=\"line\"><span class=\"comment\">// 当主位移方向为y轴时, dxx=1/k, dyy=1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> x1..=x2 step=dxx</span><br><span class=\"line\">  y1 += dyy</span><br><span class=\"line\">  yy = round(y1)  <span class=\"comment\">// 圆整处理</span></span><br><span class=\"line\">  write_pixel(x, yy, COLOR)</span><br></pre></td></tr></table></figure>\n<p>但还是不够高效, 因为涉及了大量浮点数计算, 比如 <code>y1 += dyy</code><br>\n同时, for 循环那里可能因为浮点计算不够精准, 次数不够准确, 可以改写为遍历 step 次, 然后在循环体内 <code>x += dxx</code>, 但为了美观我懒得改了</p>\n<hr>\n<h1 id=\"bresenham-suan-fa\">Bresenham算法</h1>"},{"title":"墨染樱下幽魂","abbrlink":"posts/novel/墨染樱下幽魂","hidden":false,"date":"2023-05-22T14:47:44.000Z","top":null,"keywords":["Novel","东方Project"],"_content":"\n<!-- more -->\n","source":"_posts/novel/墨染樱下幽魂.md","raw":"---\ntitle: 墨染樱下幽魂\nabbrlink: posts/novel/墨染樱下幽魂\nhidden: false\ndate: 2023-05-22 22:47:44\ntop:\ntags: [Novel, 东方Project]\nkeywords: [Novel, 东方Project]\n---\n\n<!-- more -->\n","slug":"novel/墨染樱下幽魂","published":1,"updated":"2023-05-22T14:47:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8og9000dj1s6dta9ezgu","content":"<span id=\"more\"></span>\n","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"浪潮涌没的终焉与永恒之爱","abbrlink":"posts/novel/浪潮涌没的终焉与永恒之爱","hidden":false,"date":"2023-05-21T14:48:31.000Z","top":null,"keywords":["Novel","明日方舟"],"_content":"\n> 本文为《明日方舟》二创同人原创作品, 灵感来源于B站上的手书: 《无光同葬》  \n> 你可以通过观看以下视频, 即B站上的《无光同葬》, 来迅速了解斯卡蒂的形象与本文中博士对斯卡蒂的情感 (背景为海嗣if灭世线)   \n<!-- more -->\n<video controls=\"\" src=\"http://rueg9tnqd.hd-bkt.clouddn.com/videos/%E6%97%A0%E5%85%89%E5%90%8C%E8%91%AC.mp4\" type=\"video/mp4\" poster=\"http://rueg9tnqd.hd-bkt.clouddn.com/posters/无光同葬.jpg\" width=\"700\" height=\"400\" style=\"display: inline;\"> </video>\n\n\n<style>\n  * {\n    // font-weight: 500\n  }\n\n</style>\n\n- - -\n\n一望无际的海, 淡淡倾洒的月光  \n浪潮涌动, 船舰缓行, 带着些许海洋潮湿的风轻轻拂过, 轻柔而平静, 天真烂漫, 走过来, 又走过去  \n\n男子站在船面上, 靠着栏杆, 默然地望着远方的水天交接之线, 眼神溃散, 一切的情绪彷佛在他身上消失了一般, 就像是一具空壳  \n他只是这样静悄悄地望着远方, 亦或是, 望着更远更远的地方, 望着已经不存在的那个地方  \n\n**[是啊, 一具空壳而已]** 他默然地想着  \n他早就失去了曾经他所拥有一切, 海浪翻涌, 浪潮早已吞没了泰拉, 曾经倾尽一切的付出毫无意义  \n\n<span style=\"font-weight: 900\">[The Age of Silence]<span/>  \n**[静谧时代]**  \n\n再次的静谧  \n最后的静谧  \n永恒的静谧  \n\n男子倚靠在栏杆旁, 仍然只是呆呆地望着翻涌的海浪  \n男子想到了那位卡西米尔最后的骑士, 那位骑士, 就算无数的海嗣已经爬到了他的身上, 其每寸血肉都被啃食殆尽, 但骑士却仍然在奋力挥动着他的长矛  \n卡西米尔家喻户晓的, 最后的骑士啊, 直到彻底被毁灭之前, 仍在与大海作着斗争, 发起了最后的冲锋  \n男子闭上了双眼, 努力地不让内心的悲伤浮现出来  \n\n海嗣, 那群怪物, 进化得太快了, 因为那位海嗣的神明, 代表着 **\"迁徙\"** 的 **神明** 回到了 **大群**  \n在那么短的时间里面, 海嗣们便已经进化出了适应陆地的身躯, 快速爬行的四肢, 无视铳与源石子弹的鳞片...  \n\n**卡西米尔, 叙拉古, 伊比利亚, 维多利亚, 卡兹戴尔, 莱塔尼亚, 哥伦比亚, 萨米, 萨尔贡, 米诺斯, 谢拉格, 乌萨斯, 大炎...**  \n乌萨斯帝国的皇帝, 他命令手下全部的利刃们自爆, 释放出了最恐怖的 \"国度\", 一座城市大小的空间被扭曲了维度, 陷入了永恒之黑暗  \n\"坍塌恐惧\" 杀死了一切处于 \"国度\" 范围内的生命体, 阻挡着海嗣们的前行  \n可海嗣们仍然在不断的进化着, 不断死亡, 不断繁殖, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化...  \n\n几个月之后, 海嗣们适应了乌萨斯皇帝的利刃们集体自爆所释放出来的 \"国度\", 适应了其扭曲的维度空间, 适应了永恒的黑暗, 适应了恐惧与死亡, 适应了混沌与消逝  \n那位神明, 带领着海嗣们不断的迁徙  \n\n泰拉大陆上的一切国家, 抛弃了意识形态的斗争, 抛弃了一切曾经自身的利益  \n哥伦比亚的军队, 卡西米尔的征战骑士团, 莱塔尼亚的巫师, 拉特兰的铳与子弹...  \n哥伦比亚的创想，萨米的坚韧，大炎的沧桑...  \n根本无法阻挡那群怪物  \n\n大群意识吞噬了一切, 同化了一切, 无数人为之失去生命, 或者成为了大群的一员  \n陆上数万年文明的传承, 最终葬送于浪潮之中, 海嗣们吞噬了文明, 将其化为既有  \n\n可是啊, 现在正处于海洋上, 处于海嗣故乡的他, 却又为什么没有死呢?  \n他抬头, 看向了从一旁走进的红裙女子, 原本溃散的眼神终于第一次有了波动  \n是厌恶? 是不甘? 是悲伤? 是憎恨? 是恐惧? 是愤怒? 是绝望?  \n亦或着...  \n是一抹被狠狠埋在眼底下的, 说不清道不明的, \"爱\" 与 \"恨\" 交织在一起的复杂情感?  \n对眼前的红裙少女, 对海嗣们的神明  \n呐, 你到底是谁啊?  \n到底是我喜欢的那个斯卡蒂, 还是我憎恨的那个伊莎玛拉呢?  \n一想到就变得好痛苦, 这份痛苦又有谁可以理解呢?  \n\n**[博士...]**, 一道温柔的声音响起, 被称做 \"博士\" 的男子却转过了头, 不想看那欢快着眨着眼睛走过来的她  \n但红裙的少女却不肯罢休, 快步向前走了几步, 雪白的藕臂从一旁袭来, 手指温柔地抚摸着男子僵硬的脸庞, 将他扭到一旁的脑袋转了过来  \n\n映入 \"博士\" 眼帘的, 是一位白发红瞳的少女, 穿着一身有着许多皱褶与花边的红裙  \n她的袖口与腰部戴着作为装饰的黑色花边, 右腿绑着许多交织错杂的黑色绑带  \n此时的她, 眼中暗含着秋波, 带着如同这片大海般足以溺死人的深深爱意, 正看着低过头不想与她对视的男子, 嘴角带着一抹轻笑  \n\n但眼前温柔的少女, 却是那群海嗣们的神明, 那让大地迎来了终焉, 被浪潮彻底吞噬的, 掌握着 \"迁徙\" 权能的四大海嗣神明之一  \n腐化之心, 伊莎玛拉, 摧毁了博士曾经拥有的一切的怪物  \n却, 也是博士最爱的那个人, 那个曾经为了阿戈尔的荣耀, 而与海嗣不断战斗的深海猎人...  \n斯卡蒂\n\n他绝望地再次闭上了双眼, 向后退了一步  \n红裙少女却不以为意, 上前了一步  \n\n一进一退之间, 博士已经被逼到退无可退, 被死死地抵在栏杆上  \n斯卡蒂用血红的双眸温柔地望着他, 眼中的倒影唯他一人  \n唇与唇之间的距离越来越近  \n博士能听到她轻轻的呼吸声, 能闻到她身上宛若蔷薇般的幽香, 能感受到她那跳动着的心跳声  \n距离越来越近, 越来越近, 靠近, 即将碰在一起...  \n\n就在即将吻到时, 博士却爆发出全身的力气, 一把推开了眼前的少女, 她银白色的长发随着自身的踉跄而晃动, 反射着淡淡的月光  \n她并不在意, 只是仍然用那温柔的眸子静静地看着博士, 好像仅是如此, 她就已经感受到了莫大的幸福一般  \n\n博士的喉结艰难地滚动了一番  \n**[嗯?]**, 她疑惑地歪了歪头  \n\n**[为什么?]**, 博士开口道  \n直到开口说话之前, 他都未曾预想到自己的声音会颤成这样一幅狼狈的模样\n\n话没有说完, 但斯卡蒂却已经理解了博士的质问, 随后不以为然地用手指把玩着自己的长发, 微笑着对着博士说道:  \n**[这不是, 理所当然的嘛?]**  \n**[要是那些人, 可以乖乖去死, 成为大群养分的话, 或许我的同胞可以少死一些吧?]**  \n理所当然的语气, 不以为然的神情, 美丽灿烂的微笑  \n\n博士的脑袋昏得要死, 血液逆流而上, 直冲脑门, 名为 \"理智\" 的一根弦瞬间崩断  \n以连他自己都没反应过来, 他便已然将斯卡蒂扑倒, 骑在了她的身上, 双手死死地掐住她纤细的脖颈  \n\n**[博士?]**, 她感受着博士在她脖子上的力度, 体会着他内心的悲怆与愤怒, 呼吸变得越发急促  \n**[啊... 如果, 这样, 能让你开心的话...]**, 在一瞬间释然, 她幸福而温柔地对博士笑着, 就像是脖颈上的青痕不存在一样  \n明明是海嗣的神明  \n\n仅仅是这样一句话, 便让博士无法忍受, 松开了手上的力道, 痛哭了起来, 他根本无法杀死眼前这个少女  \n因为, 因为她是斯卡蒂啊, 哪怕被腐化, 被同化, 成为了披着人皮的海嗣怪物, 与伊莎玛拉合为一体, 成为海嗣的神明  \n哪怕她亲手带领海嗣, 杀死了泰拉上的一切, 让他曾经拥有的一切都不复存在  \n\n但斯卡蒂是这个世界上最爱自己的人啊!  \n即使斯卡蒂体内的伊莎玛拉之血逐渐同化了她, 侵蚀并改变了她的意志, 人性被磨灭, 内心变得冷血残酷  \n即使她不再是人, 一切为了种群的延续与发展而思考, 她对博士的爱却仍始终如初, 至死不渝, 战胜了世间的一切  \n这份爱, 早已被刻入灵魂, 成为了本能, 在她的眼中, 博士永远是最为特别的存在, 是她所挚爱之人, 是愿意厮守一生之人  \n\n博士趴在她的身上痛哭着, 斯卡蒂不断地抚摸着他的头, 低声安慰着他  \n斯卡蒂明白他所憎之事情, 所憎恨之物, 理解却又无法理解, 就如同人类进食时不会思考生物被杀死时对屠夫的憎恨, 海嗣们也只是为了活下去吸收养分而已  \n大群的意志在呼唤她, 千万海嗣同胞为了生存, 为了繁衍, 为了迁徙, 为了进化, 为了斗争, 而战胜了一切苦难, 用无数死亡堆积起后来者活下去的可能  \n她是海嗣的神明, 是大群意识的指挥之人  \n\n渐渐地, 博士的哭声渐微, 低吼着, 从口中喃喃着道出一个又一个已经离他而去的人  \n他怎么也无法忘怀, 那一天, 罗德岛的船舰上, 到处都是血, 到处都是肉块  \n那是即使历经无数次战争洗礼的老兵也忍不住胆颤的场景, 令人作呕  \n命运用遍地废墟, 嘲笑着泰拉文明的终焉, 浪潮翻涌, 嗤笑着这片已经走向末路的大地  \n\n在斯卡蒂的眼中, 或许全泰拉也只有他一人是特殊的吧?  \n这个世界太怪了点...  \n他或许是在做梦, 但梦却也太真实了点...  \n\n在这她为他所打造的囚笼之中, 两人将共同度过往后余生, 永远, 永远, 永远...  \n即使他现在因为特殊的基因无法被同化成海嗣, 但已经进化出智慧的海嗣们早已吸收了泰拉所有的科研成果  \n斯卡蒂已经下达了命令, 无数的海嗣正为了攻克他的基因而进行研究  \n那一天不远了...\n他也将被斯卡蒂同化, 共享那无穷的寿命, 在静谧的时代逐渐失去人性, 冷眼注视着曾经的回忆与现在痛苦的自己  \n忘却他曾经所珍视的一切, 最后坠入斯卡蒂那足以溺死人的温柔之中  \n\n大地被浪潮淹没, 此后再无人类  \n海嗣将永远地生存下去  \n海嗣将永远地繁殖下去  \n海嗣将永远地迁徙下去  \n海嗣将永远地进化下去  \n博士与斯卡蒂, 将在无限的进化之中成为全知全能的存在  \n博士与斯卡蒂, 将在新的种群抛弃作为人时的人性  \n\n正因如此, 博士才更加恐惧, 更加厌恶, 大群的意志在他的耳边低语, 斯卡蒂血红的双眸正注视着他  \n博士哭着, 哭着, 随后又笑了  \n\n**[没关系的哟...]**  \n斯卡蒂轻轻拭去他脸颊上的泪水, 温柔地抱着博士, 轻轻地哼唱起了一首歌  \n\n那是斯卡蒂还是深海猎人时, 经常哼唱的一首阿戈尔歌谣  \n她经常在深夜靠着罗德岛的栏杆, 俯瞰着远方的湖泊, 轻轻哼唱着那哀伤的歌  \n旋律哀伤而婉转, 她总是唱着唱着, 然后就不自觉地出神, 望着远方那波光粼粼的湖面  \n她总是那么哀伤  \n\n博士总是会在她哼唱之时出现, 作为一名听众而沉默地听着, 直到歌声结束  \n最开始, 在歌声结束后, 斯卡蒂会沉默着看着对她微笑的博士, 然后轻声道, 她只会给周围的人带来不幸, 希望博士离她远点:  \n\n<br>  \n\n`......`  \n**[为了你的安全着想, 最好离我两米以上, 也不要和我说话...我不想你被冲我而来的危险伤到]**  \n`......`  \n**[看过我过去的简历了? 我的过去可是很糟糕的, 嗯, 让我待在身边, 不仅你会被卷入麻烦的漩涡, 我也会很难办的]**  \n`......`  \n**[这把剑的过去可是很恐怖的喔]**  \n`......`  \n**[这种程度的不幸, 也只是开始罢了]**  \n`......`  \n\n<br/>  \n\n\n有一天, 博士照常撑着脑袋听斯卡蒂唱完歌, 看着斯卡蒂为了把自己撵走而继续装作凶狠的样子, 进行每天的恐吓威胁时, 终于忍不住笑了起来  \n**[喂, 有什么好笑的?]**  \n**[啊, 抱歉, 但你这幅为了把我吓走而故意装作很冷漠很恐怖的样子实在是太太太可爱了~]**  \n...斯卡蒂沉默着转过身去, 不想让博士看到自己微微发烫的脸颊  \n\n要离开的时候, 博士叫停了她, 微笑着跟她说了两句话, 无视了她为了让博士离自己远点而做的一切努力:  \n**[你说你只会给他人带来不幸...但是啊, 有这回事吗?]**  \n**[你给我带来的, 可是满满的幸福哦~]**  \n...斯卡蒂逃一样地离开了  \n\n自那以后, 那位沉默寡言, 背着巨剑的阿戈尔少女, 对着博士的话也逐渐多了起来, 对他的信赖也逐渐多了起来  \n**[你这人, 怎么这么执着, 这样我不就只能老老实实保护你了吗?]**  \n**[远方浩瀚蓝色之下, 埋葬着我原本所在乎的一切, 我害怕, 怕厄运会再次夺走我珍视之人, 所以我才会逃...不希望所珍视之人, 因我而再次受伤...]**  \n**[好! 又度过了轻松的一天, 没有会卷走队友的巨大触须, 也没有蹲在角落满手是血的疯狂敌人...光是上上战场什么的, 对, 已经很轻松了!]**  \n**[根据传说, 我的族裔已经和那些灾祸战斗了无数年, 说不定我们也帮助了你们这些陆地人呢...所以说, 是不是该请我喝一杯?]**  \n**[当你历经漫长黑夜, 终于付出海面, 睁开双眼的那一刹那, 灿烂星空滴落眼眶, 无垠波浪抚过脸颊...]**\n**[眼泪与家的味道, 都是咸的, 相比之下, 罗德岛的浴缸真是又宅又浅...我一定得带你试试去才行]**  \n**[睡着了? 博士, 做个干燥的好梦吧]**  \n**[呼呼地冲过去, 咚地打到敌人, 啪地解决, 原来你们是这么战斗的, 我记住啦!]**  \n**[这个就是那个, 罗德岛干员经常说的晋升嘛? 感觉不错, 好像自己真的变强了呢? 大概?]**  \n**[这么渴求我的力量, 真让我很困扰...如果你真的无所畏惧, 那么做好准备吧, 和我一起直面无边无际的黑暗吧]**  \n**[我倒也挺擅长团队合作啦! 只是...]**  \n**[对手是人类的话, 终归还是没什么手感]**  \n**[听你的]**  \n**[啊...帽子!]**  \n**[离我那么近! 我, 我可没有能完全保护你的自信!]**  \n**[注意安全, 博士]**  \n\n博士眼前的少女, 与曾经的斯卡蒂重叠在了一起, 她对博士的爱一点也未曾改变过  \n依旧是那首他不知听少女哼唱过多少遍的阿戈尔歌谣  \n幽幽的歌声从少女的口中轻轻传出, 哀伤与安详交织, 化为一抹特别的韵味  \n\n浪潮涌沒的终焉之上, 是存于此时此地的永恒之爱  \n\n**[很快, 我们就可以在一起了...]**\n她轻笑  \n\n<span style=\"font-size: 40px\">End<span/>\n","source":"_posts/novel/浪潮涌没的终焉与永恒之爱.md","raw":"---\ntitle: 浪潮涌没的终焉与永恒之爱\nabbrlink: posts/novel/浪潮涌没的终焉与永恒之爱\nhidden: false\ndate: 2023-05-21 22:48:31\ntop:\ntags: [Novel, 明日方舟]\nkeywords: [Novel, 明日方舟]\n---\n\n> 本文为《明日方舟》二创同人原创作品, 灵感来源于B站上的手书: 《无光同葬》  \n> 你可以通过观看以下视频, 即B站上的《无光同葬》, 来迅速了解斯卡蒂的形象与本文中博士对斯卡蒂的情感 (背景为海嗣if灭世线)   \n<!-- more -->\n<video controls=\"\" src=\"http://rueg9tnqd.hd-bkt.clouddn.com/videos/%E6%97%A0%E5%85%89%E5%90%8C%E8%91%AC.mp4\" type=\"video/mp4\" poster=\"http://rueg9tnqd.hd-bkt.clouddn.com/posters/无光同葬.jpg\" width=\"700\" height=\"400\" style=\"display: inline;\"> </video>\n\n\n<style>\n  * {\n    // font-weight: 500\n  }\n\n</style>\n\n- - -\n\n一望无际的海, 淡淡倾洒的月光  \n浪潮涌动, 船舰缓行, 带着些许海洋潮湿的风轻轻拂过, 轻柔而平静, 天真烂漫, 走过来, 又走过去  \n\n男子站在船面上, 靠着栏杆, 默然地望着远方的水天交接之线, 眼神溃散, 一切的情绪彷佛在他身上消失了一般, 就像是一具空壳  \n他只是这样静悄悄地望着远方, 亦或是, 望着更远更远的地方, 望着已经不存在的那个地方  \n\n**[是啊, 一具空壳而已]** 他默然地想着  \n他早就失去了曾经他所拥有一切, 海浪翻涌, 浪潮早已吞没了泰拉, 曾经倾尽一切的付出毫无意义  \n\n<span style=\"font-weight: 900\">[The Age of Silence]<span/>  \n**[静谧时代]**  \n\n再次的静谧  \n最后的静谧  \n永恒的静谧  \n\n男子倚靠在栏杆旁, 仍然只是呆呆地望着翻涌的海浪  \n男子想到了那位卡西米尔最后的骑士, 那位骑士, 就算无数的海嗣已经爬到了他的身上, 其每寸血肉都被啃食殆尽, 但骑士却仍然在奋力挥动着他的长矛  \n卡西米尔家喻户晓的, 最后的骑士啊, 直到彻底被毁灭之前, 仍在与大海作着斗争, 发起了最后的冲锋  \n男子闭上了双眼, 努力地不让内心的悲伤浮现出来  \n\n海嗣, 那群怪物, 进化得太快了, 因为那位海嗣的神明, 代表着 **\"迁徙\"** 的 **神明** 回到了 **大群**  \n在那么短的时间里面, 海嗣们便已经进化出了适应陆地的身躯, 快速爬行的四肢, 无视铳与源石子弹的鳞片...  \n\n**卡西米尔, 叙拉古, 伊比利亚, 维多利亚, 卡兹戴尔, 莱塔尼亚, 哥伦比亚, 萨米, 萨尔贡, 米诺斯, 谢拉格, 乌萨斯, 大炎...**  \n乌萨斯帝国的皇帝, 他命令手下全部的利刃们自爆, 释放出了最恐怖的 \"国度\", 一座城市大小的空间被扭曲了维度, 陷入了永恒之黑暗  \n\"坍塌恐惧\" 杀死了一切处于 \"国度\" 范围内的生命体, 阻挡着海嗣们的前行  \n可海嗣们仍然在不断的进化着, 不断死亡, 不断繁殖, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化...  \n\n几个月之后, 海嗣们适应了乌萨斯皇帝的利刃们集体自爆所释放出来的 \"国度\", 适应了其扭曲的维度空间, 适应了永恒的黑暗, 适应了恐惧与死亡, 适应了混沌与消逝  \n那位神明, 带领着海嗣们不断的迁徙  \n\n泰拉大陆上的一切国家, 抛弃了意识形态的斗争, 抛弃了一切曾经自身的利益  \n哥伦比亚的军队, 卡西米尔的征战骑士团, 莱塔尼亚的巫师, 拉特兰的铳与子弹...  \n哥伦比亚的创想，萨米的坚韧，大炎的沧桑...  \n根本无法阻挡那群怪物  \n\n大群意识吞噬了一切, 同化了一切, 无数人为之失去生命, 或者成为了大群的一员  \n陆上数万年文明的传承, 最终葬送于浪潮之中, 海嗣们吞噬了文明, 将其化为既有  \n\n可是啊, 现在正处于海洋上, 处于海嗣故乡的他, 却又为什么没有死呢?  \n他抬头, 看向了从一旁走进的红裙女子, 原本溃散的眼神终于第一次有了波动  \n是厌恶? 是不甘? 是悲伤? 是憎恨? 是恐惧? 是愤怒? 是绝望?  \n亦或着...  \n是一抹被狠狠埋在眼底下的, 说不清道不明的, \"爱\" 与 \"恨\" 交织在一起的复杂情感?  \n对眼前的红裙少女, 对海嗣们的神明  \n呐, 你到底是谁啊?  \n到底是我喜欢的那个斯卡蒂, 还是我憎恨的那个伊莎玛拉呢?  \n一想到就变得好痛苦, 这份痛苦又有谁可以理解呢?  \n\n**[博士...]**, 一道温柔的声音响起, 被称做 \"博士\" 的男子却转过了头, 不想看那欢快着眨着眼睛走过来的她  \n但红裙的少女却不肯罢休, 快步向前走了几步, 雪白的藕臂从一旁袭来, 手指温柔地抚摸着男子僵硬的脸庞, 将他扭到一旁的脑袋转了过来  \n\n映入 \"博士\" 眼帘的, 是一位白发红瞳的少女, 穿着一身有着许多皱褶与花边的红裙  \n她的袖口与腰部戴着作为装饰的黑色花边, 右腿绑着许多交织错杂的黑色绑带  \n此时的她, 眼中暗含着秋波, 带着如同这片大海般足以溺死人的深深爱意, 正看着低过头不想与她对视的男子, 嘴角带着一抹轻笑  \n\n但眼前温柔的少女, 却是那群海嗣们的神明, 那让大地迎来了终焉, 被浪潮彻底吞噬的, 掌握着 \"迁徙\" 权能的四大海嗣神明之一  \n腐化之心, 伊莎玛拉, 摧毁了博士曾经拥有的一切的怪物  \n却, 也是博士最爱的那个人, 那个曾经为了阿戈尔的荣耀, 而与海嗣不断战斗的深海猎人...  \n斯卡蒂\n\n他绝望地再次闭上了双眼, 向后退了一步  \n红裙少女却不以为意, 上前了一步  \n\n一进一退之间, 博士已经被逼到退无可退, 被死死地抵在栏杆上  \n斯卡蒂用血红的双眸温柔地望着他, 眼中的倒影唯他一人  \n唇与唇之间的距离越来越近  \n博士能听到她轻轻的呼吸声, 能闻到她身上宛若蔷薇般的幽香, 能感受到她那跳动着的心跳声  \n距离越来越近, 越来越近, 靠近, 即将碰在一起...  \n\n就在即将吻到时, 博士却爆发出全身的力气, 一把推开了眼前的少女, 她银白色的长发随着自身的踉跄而晃动, 反射着淡淡的月光  \n她并不在意, 只是仍然用那温柔的眸子静静地看着博士, 好像仅是如此, 她就已经感受到了莫大的幸福一般  \n\n博士的喉结艰难地滚动了一番  \n**[嗯?]**, 她疑惑地歪了歪头  \n\n**[为什么?]**, 博士开口道  \n直到开口说话之前, 他都未曾预想到自己的声音会颤成这样一幅狼狈的模样\n\n话没有说完, 但斯卡蒂却已经理解了博士的质问, 随后不以为然地用手指把玩着自己的长发, 微笑着对着博士说道:  \n**[这不是, 理所当然的嘛?]**  \n**[要是那些人, 可以乖乖去死, 成为大群养分的话, 或许我的同胞可以少死一些吧?]**  \n理所当然的语气, 不以为然的神情, 美丽灿烂的微笑  \n\n博士的脑袋昏得要死, 血液逆流而上, 直冲脑门, 名为 \"理智\" 的一根弦瞬间崩断  \n以连他自己都没反应过来, 他便已然将斯卡蒂扑倒, 骑在了她的身上, 双手死死地掐住她纤细的脖颈  \n\n**[博士?]**, 她感受着博士在她脖子上的力度, 体会着他内心的悲怆与愤怒, 呼吸变得越发急促  \n**[啊... 如果, 这样, 能让你开心的话...]**, 在一瞬间释然, 她幸福而温柔地对博士笑着, 就像是脖颈上的青痕不存在一样  \n明明是海嗣的神明  \n\n仅仅是这样一句话, 便让博士无法忍受, 松开了手上的力道, 痛哭了起来, 他根本无法杀死眼前这个少女  \n因为, 因为她是斯卡蒂啊, 哪怕被腐化, 被同化, 成为了披着人皮的海嗣怪物, 与伊莎玛拉合为一体, 成为海嗣的神明  \n哪怕她亲手带领海嗣, 杀死了泰拉上的一切, 让他曾经拥有的一切都不复存在  \n\n但斯卡蒂是这个世界上最爱自己的人啊!  \n即使斯卡蒂体内的伊莎玛拉之血逐渐同化了她, 侵蚀并改变了她的意志, 人性被磨灭, 内心变得冷血残酷  \n即使她不再是人, 一切为了种群的延续与发展而思考, 她对博士的爱却仍始终如初, 至死不渝, 战胜了世间的一切  \n这份爱, 早已被刻入灵魂, 成为了本能, 在她的眼中, 博士永远是最为特别的存在, 是她所挚爱之人, 是愿意厮守一生之人  \n\n博士趴在她的身上痛哭着, 斯卡蒂不断地抚摸着他的头, 低声安慰着他  \n斯卡蒂明白他所憎之事情, 所憎恨之物, 理解却又无法理解, 就如同人类进食时不会思考生物被杀死时对屠夫的憎恨, 海嗣们也只是为了活下去吸收养分而已  \n大群的意志在呼唤她, 千万海嗣同胞为了生存, 为了繁衍, 为了迁徙, 为了进化, 为了斗争, 而战胜了一切苦难, 用无数死亡堆积起后来者活下去的可能  \n她是海嗣的神明, 是大群意识的指挥之人  \n\n渐渐地, 博士的哭声渐微, 低吼着, 从口中喃喃着道出一个又一个已经离他而去的人  \n他怎么也无法忘怀, 那一天, 罗德岛的船舰上, 到处都是血, 到处都是肉块  \n那是即使历经无数次战争洗礼的老兵也忍不住胆颤的场景, 令人作呕  \n命运用遍地废墟, 嘲笑着泰拉文明的终焉, 浪潮翻涌, 嗤笑着这片已经走向末路的大地  \n\n在斯卡蒂的眼中, 或许全泰拉也只有他一人是特殊的吧?  \n这个世界太怪了点...  \n他或许是在做梦, 但梦却也太真实了点...  \n\n在这她为他所打造的囚笼之中, 两人将共同度过往后余生, 永远, 永远, 永远...  \n即使他现在因为特殊的基因无法被同化成海嗣, 但已经进化出智慧的海嗣们早已吸收了泰拉所有的科研成果  \n斯卡蒂已经下达了命令, 无数的海嗣正为了攻克他的基因而进行研究  \n那一天不远了...\n他也将被斯卡蒂同化, 共享那无穷的寿命, 在静谧的时代逐渐失去人性, 冷眼注视着曾经的回忆与现在痛苦的自己  \n忘却他曾经所珍视的一切, 最后坠入斯卡蒂那足以溺死人的温柔之中  \n\n大地被浪潮淹没, 此后再无人类  \n海嗣将永远地生存下去  \n海嗣将永远地繁殖下去  \n海嗣将永远地迁徙下去  \n海嗣将永远地进化下去  \n博士与斯卡蒂, 将在无限的进化之中成为全知全能的存在  \n博士与斯卡蒂, 将在新的种群抛弃作为人时的人性  \n\n正因如此, 博士才更加恐惧, 更加厌恶, 大群的意志在他的耳边低语, 斯卡蒂血红的双眸正注视着他  \n博士哭着, 哭着, 随后又笑了  \n\n**[没关系的哟...]**  \n斯卡蒂轻轻拭去他脸颊上的泪水, 温柔地抱着博士, 轻轻地哼唱起了一首歌  \n\n那是斯卡蒂还是深海猎人时, 经常哼唱的一首阿戈尔歌谣  \n她经常在深夜靠着罗德岛的栏杆, 俯瞰着远方的湖泊, 轻轻哼唱着那哀伤的歌  \n旋律哀伤而婉转, 她总是唱着唱着, 然后就不自觉地出神, 望着远方那波光粼粼的湖面  \n她总是那么哀伤  \n\n博士总是会在她哼唱之时出现, 作为一名听众而沉默地听着, 直到歌声结束  \n最开始, 在歌声结束后, 斯卡蒂会沉默着看着对她微笑的博士, 然后轻声道, 她只会给周围的人带来不幸, 希望博士离她远点:  \n\n<br>  \n\n`......`  \n**[为了你的安全着想, 最好离我两米以上, 也不要和我说话...我不想你被冲我而来的危险伤到]**  \n`......`  \n**[看过我过去的简历了? 我的过去可是很糟糕的, 嗯, 让我待在身边, 不仅你会被卷入麻烦的漩涡, 我也会很难办的]**  \n`......`  \n**[这把剑的过去可是很恐怖的喔]**  \n`......`  \n**[这种程度的不幸, 也只是开始罢了]**  \n`......`  \n\n<br/>  \n\n\n有一天, 博士照常撑着脑袋听斯卡蒂唱完歌, 看着斯卡蒂为了把自己撵走而继续装作凶狠的样子, 进行每天的恐吓威胁时, 终于忍不住笑了起来  \n**[喂, 有什么好笑的?]**  \n**[啊, 抱歉, 但你这幅为了把我吓走而故意装作很冷漠很恐怖的样子实在是太太太可爱了~]**  \n...斯卡蒂沉默着转过身去, 不想让博士看到自己微微发烫的脸颊  \n\n要离开的时候, 博士叫停了她, 微笑着跟她说了两句话, 无视了她为了让博士离自己远点而做的一切努力:  \n**[你说你只会给他人带来不幸...但是啊, 有这回事吗?]**  \n**[你给我带来的, 可是满满的幸福哦~]**  \n...斯卡蒂逃一样地离开了  \n\n自那以后, 那位沉默寡言, 背着巨剑的阿戈尔少女, 对着博士的话也逐渐多了起来, 对他的信赖也逐渐多了起来  \n**[你这人, 怎么这么执着, 这样我不就只能老老实实保护你了吗?]**  \n**[远方浩瀚蓝色之下, 埋葬着我原本所在乎的一切, 我害怕, 怕厄运会再次夺走我珍视之人, 所以我才会逃...不希望所珍视之人, 因我而再次受伤...]**  \n**[好! 又度过了轻松的一天, 没有会卷走队友的巨大触须, 也没有蹲在角落满手是血的疯狂敌人...光是上上战场什么的, 对, 已经很轻松了!]**  \n**[根据传说, 我的族裔已经和那些灾祸战斗了无数年, 说不定我们也帮助了你们这些陆地人呢...所以说, 是不是该请我喝一杯?]**  \n**[当你历经漫长黑夜, 终于付出海面, 睁开双眼的那一刹那, 灿烂星空滴落眼眶, 无垠波浪抚过脸颊...]**\n**[眼泪与家的味道, 都是咸的, 相比之下, 罗德岛的浴缸真是又宅又浅...我一定得带你试试去才行]**  \n**[睡着了? 博士, 做个干燥的好梦吧]**  \n**[呼呼地冲过去, 咚地打到敌人, 啪地解决, 原来你们是这么战斗的, 我记住啦!]**  \n**[这个就是那个, 罗德岛干员经常说的晋升嘛? 感觉不错, 好像自己真的变强了呢? 大概?]**  \n**[这么渴求我的力量, 真让我很困扰...如果你真的无所畏惧, 那么做好准备吧, 和我一起直面无边无际的黑暗吧]**  \n**[我倒也挺擅长团队合作啦! 只是...]**  \n**[对手是人类的话, 终归还是没什么手感]**  \n**[听你的]**  \n**[啊...帽子!]**  \n**[离我那么近! 我, 我可没有能完全保护你的自信!]**  \n**[注意安全, 博士]**  \n\n博士眼前的少女, 与曾经的斯卡蒂重叠在了一起, 她对博士的爱一点也未曾改变过  \n依旧是那首他不知听少女哼唱过多少遍的阿戈尔歌谣  \n幽幽的歌声从少女的口中轻轻传出, 哀伤与安详交织, 化为一抹特别的韵味  \n\n浪潮涌沒的终焉之上, 是存于此时此地的永恒之爱  \n\n**[很快, 我们就可以在一起了...]**\n她轻笑  \n\n<span style=\"font-size: 40px\">End<span/>\n","slug":"novel/浪潮涌没的终焉与永恒之爱","published":1,"updated":"2023-05-21T14:48:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogb000fj1s6327het0t","content":"<blockquote>\n<p>本文为《明日方舟》二创同人原创作品, 灵感来源于B站上的手书: 《无光同葬》<br>\n你可以通过观看以下视频, 即B站上的《无光同葬》, 来迅速了解斯卡蒂的形象与本文中博士对斯卡蒂的情感 (背景为海嗣if灭世线)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><video controls=\"\" src=\"http://rueg9tnqd.hd-bkt.clouddn.com/videos/%E6%97%A0%E5%85%89%E5%90%8C%E8%91%AC.mp4\" type=\"video/mp4\" poster=\"http://rueg9tnqd.hd-bkt.clouddn.com/posters/无光同葬.jpg\" width=\"700\" height=\"400\" style=\"display: inline;\"> </video></p>\n<style>\n  * {\n    // font-weight: 500\n  }\n\n</style>\n<hr>\n<p>一望无际的海, 淡淡倾洒的月光<br>\n浪潮涌动, 船舰缓行, 带着些许海洋潮湿的风轻轻拂过, 轻柔而平静, 天真烂漫, 走过来, 又走过去</p>\n<p>男子站在船面上, 靠着栏杆, 默然地望着远方的水天交接之线, 眼神溃散, 一切的情绪彷佛在他身上消失了一般, 就像是一具空壳<br>\n他只是这样静悄悄地望着远方, 亦或是, 望着更远更远的地方, 望着已经不存在的那个地方</p>\n<p><strong>[是啊, 一具空壳而已]</strong> 他默然地想着<br>\n他早就失去了曾经他所拥有一切, 海浪翻涌, 浪潮早已吞没了泰拉, 曾经倾尽一切的付出毫无意义</p>\n<p><span style=\"font-weight: 900\">[The Age of Silence]<span/><br>\n<strong>[静谧时代]</strong></p>\n<p>再次的静谧<br>\n最后的静谧<br>\n永恒的静谧</p>\n<p>男子倚靠在栏杆旁, 仍然只是呆呆地望着翻涌的海浪<br>\n男子想到了那位卡西米尔最后的骑士, 那位骑士, 就算无数的海嗣已经爬到了他的身上, 其每寸血肉都被啃食殆尽, 但骑士却仍然在奋力挥动着他的长矛<br>\n卡西米尔家喻户晓的, 最后的骑士啊, 直到彻底被毁灭之前, 仍在与大海作着斗争, 发起了最后的冲锋<br>\n男子闭上了双眼, 努力地不让内心的悲伤浮现出来</p>\n<p>海嗣, 那群怪物, 进化得太快了, 因为那位海嗣的神明, 代表着 <strong>“迁徙”</strong> 的 <strong>神明</strong> 回到了 <strong>大群</strong><br>\n在那么短的时间里面, 海嗣们便已经进化出了适应陆地的身躯, 快速爬行的四肢, 无视铳与源石子弹的鳞片…</p>\n<p><strong>卡西米尔, 叙拉古, 伊比利亚, 维多利亚, 卡兹戴尔, 莱塔尼亚, 哥伦比亚, 萨米, 萨尔贡, 米诺斯, 谢拉格, 乌萨斯, 大炎…</strong><br>\n乌萨斯帝国的皇帝, 他命令手下全部的利刃们自爆, 释放出了最恐怖的 “国度”, 一座城市大小的空间被扭曲了维度, 陷入了永恒之黑暗<br>\n“坍塌恐惧” 杀死了一切处于 “国度” 范围内的生命体, 阻挡着海嗣们的前行<br>\n可海嗣们仍然在不断的进化着, 不断死亡, 不断繁殖, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化…</p>\n<p>几个月之后, 海嗣们适应了乌萨斯皇帝的利刃们集体自爆所释放出来的 “国度”, 适应了其扭曲的维度空间, 适应了永恒的黑暗, 适应了恐惧与死亡, 适应了混沌与消逝<br>\n那位神明, 带领着海嗣们不断的迁徙</p>\n<p>泰拉大陆上的一切国家, 抛弃了意识形态的斗争, 抛弃了一切曾经自身的利益<br>\n哥伦比亚的军队, 卡西米尔的征战骑士团, 莱塔尼亚的巫师, 拉特兰的铳与子弹…<br>\n哥伦比亚的创想，萨米的坚韧，大炎的沧桑…<br>\n根本无法阻挡那群怪物</p>\n<p>大群意识吞噬了一切, 同化了一切, 无数人为之失去生命, 或者成为了大群的一员<br>\n陆上数万年文明的传承, 最终葬送于浪潮之中, 海嗣们吞噬了文明, 将其化为既有</p>\n<p>可是啊, 现在正处于海洋上, 处于海嗣故乡的他, 却又为什么没有死呢?<br>\n他抬头, 看向了从一旁走进的红裙女子, 原本溃散的眼神终于第一次有了波动<br>\n是厌恶? 是不甘? 是悲伤? 是憎恨? 是恐惧? 是愤怒? 是绝望?<br>\n亦或着…<br>\n是一抹被狠狠埋在眼底下的, 说不清道不明的, “爱” 与 “恨” 交织在一起的复杂情感?<br>\n对眼前的红裙少女, 对海嗣们的神明<br>\n呐, 你到底是谁啊?<br>\n到底是我喜欢的那个斯卡蒂, 还是我憎恨的那个伊莎玛拉呢?<br>\n一想到就变得好痛苦, 这份痛苦又有谁可以理解呢?</p>\n<p><strong>[博士…]</strong>, 一道温柔的声音响起, 被称做 “博士” 的男子却转过了头, 不想看那欢快着眨着眼睛走过来的她<br>\n但红裙的少女却不肯罢休, 快步向前走了几步, 雪白的藕臂从一旁袭来, 手指温柔地抚摸着男子僵硬的脸庞, 将他扭到一旁的脑袋转了过来</p>\n<p>映入 “博士” 眼帘的, 是一位白发红瞳的少女, 穿着一身有着许多皱褶与花边的红裙<br>\n她的袖口与腰部戴着作为装饰的黑色花边, 右腿绑着许多交织错杂的黑色绑带<br>\n此时的她, 眼中暗含着秋波, 带着如同这片大海般足以溺死人的深深爱意, 正看着低过头不想与她对视的男子, 嘴角带着一抹轻笑</p>\n<p>但眼前温柔的少女, 却是那群海嗣们的神明, 那让大地迎来了终焉, 被浪潮彻底吞噬的, 掌握着 “迁徙” 权能的四大海嗣神明之一<br>\n腐化之心, 伊莎玛拉, 摧毁了博士曾经拥有的一切的怪物<br>\n却, 也是博士最爱的那个人, 那个曾经为了阿戈尔的荣耀, 而与海嗣不断战斗的深海猎人…<br>\n斯卡蒂</p>\n<p>他绝望地再次闭上了双眼, 向后退了一步<br>\n红裙少女却不以为意, 上前了一步</p>\n<p>一进一退之间, 博士已经被逼到退无可退, 被死死地抵在栏杆上<br>\n斯卡蒂用血红的双眸温柔地望着他, 眼中的倒影唯他一人<br>\n唇与唇之间的距离越来越近<br>\n博士能听到她轻轻的呼吸声, 能闻到她身上宛若蔷薇般的幽香, 能感受到她那跳动着的心跳声<br>\n距离越来越近, 越来越近, 靠近, 即将碰在一起…</p>\n<p>就在即将吻到时, 博士却爆发出全身的力气, 一把推开了眼前的少女, 她银白色的长发随着自身的踉跄而晃动, 反射着淡淡的月光<br>\n她并不在意, 只是仍然用那温柔的眸子静静地看着博士, 好像仅是如此, 她就已经感受到了莫大的幸福一般</p>\n<p>博士的喉结艰难地滚动了一番<br>\n<strong>[嗯?]</strong>, 她疑惑地歪了歪头</p>\n<p><strong>[为什么?]</strong>, 博士开口道<br>\n直到开口说话之前, 他都未曾预想到自己的声音会颤成这样一幅狼狈的模样</p>\n<p>话没有说完, 但斯卡蒂却已经理解了博士的质问, 随后不以为然地用手指把玩着自己的长发, 微笑着对着博士说道:<br>\n<strong>[这不是, 理所当然的嘛?]</strong><br>\n<strong>[要是那些人, 可以乖乖去死, 成为大群养分的话, 或许我的同胞可以少死一些吧?]</strong><br>\n理所当然的语气, 不以为然的神情, 美丽灿烂的微笑</p>\n<p>博士的脑袋昏得要死, 血液逆流而上, 直冲脑门, 名为 “理智” 的一根弦瞬间崩断<br>\n以连他自己都没反应过来, 他便已然将斯卡蒂扑倒, 骑在了她的身上, 双手死死地掐住她纤细的脖颈</p>\n<p><strong>[博士?]</strong>, 她感受着博士在她脖子上的力度, 体会着他内心的悲怆与愤怒, 呼吸变得越发急促<br>\n<strong>[啊… 如果, 这样, 能让你开心的话…]</strong>, 在一瞬间释然, 她幸福而温柔地对博士笑着, 就像是脖颈上的青痕不存在一样<br>\n明明是海嗣的神明</p>\n<p>仅仅是这样一句话, 便让博士无法忍受, 松开了手上的力道, 痛哭了起来, 他根本无法杀死眼前这个少女<br>\n因为, 因为她是斯卡蒂啊, 哪怕被腐化, 被同化, 成为了披着人皮的海嗣怪物, 与伊莎玛拉合为一体, 成为海嗣的神明<br>\n哪怕她亲手带领海嗣, 杀死了泰拉上的一切, 让他曾经拥有的一切都不复存在</p>\n<p>但斯卡蒂是这个世界上最爱自己的人啊!<br>\n即使斯卡蒂体内的伊莎玛拉之血逐渐同化了她, 侵蚀并改变了她的意志, 人性被磨灭, 内心变得冷血残酷<br>\n即使她不再是人, 一切为了种群的延续与发展而思考, 她对博士的爱却仍始终如初, 至死不渝, 战胜了世间的一切<br>\n这份爱, 早已被刻入灵魂, 成为了本能, 在她的眼中, 博士永远是最为特别的存在, 是她所挚爱之人, 是愿意厮守一生之人</p>\n<p>博士趴在她的身上痛哭着, 斯卡蒂不断地抚摸着他的头, 低声安慰着他<br>\n斯卡蒂明白他所憎之事情, 所憎恨之物, 理解却又无法理解, 就如同人类进食时不会思考生物被杀死时对屠夫的憎恨, 海嗣们也只是为了活下去吸收养分而已<br>\n大群的意志在呼唤她, 千万海嗣同胞为了生存, 为了繁衍, 为了迁徙, 为了进化, 为了斗争, 而战胜了一切苦难, 用无数死亡堆积起后来者活下去的可能<br>\n她是海嗣的神明, 是大群意识的指挥之人</p>\n<p>渐渐地, 博士的哭声渐微, 低吼着, 从口中喃喃着道出一个又一个已经离他而去的人<br>\n他怎么也无法忘怀, 那一天, 罗德岛的船舰上, 到处都是血, 到处都是肉块<br>\n那是即使历经无数次战争洗礼的老兵也忍不住胆颤的场景, 令人作呕<br>\n命运用遍地废墟, 嘲笑着泰拉文明的终焉, 浪潮翻涌, 嗤笑着这片已经走向末路的大地</p>\n<p>在斯卡蒂的眼中, 或许全泰拉也只有他一人是特殊的吧?<br>\n这个世界太怪了点…<br>\n他或许是在做梦, 但梦却也太真实了点…</p>\n<p>在这她为他所打造的囚笼之中, 两人将共同度过往后余生, 永远, 永远, 永远…<br>\n即使他现在因为特殊的基因无法被同化成海嗣, 但已经进化出智慧的海嗣们早已吸收了泰拉所有的科研成果<br>\n斯卡蒂已经下达了命令, 无数的海嗣正为了攻克他的基因而进行研究<br>\n那一天不远了…<br>\n他也将被斯卡蒂同化, 共享那无穷的寿命, 在静谧的时代逐渐失去人性, 冷眼注视着曾经的回忆与现在痛苦的自己<br>\n忘却他曾经所珍视的一切, 最后坠入斯卡蒂那足以溺死人的温柔之中</p>\n<p>大地被浪潮淹没, 此后再无人类<br>\n海嗣将永远地生存下去<br>\n海嗣将永远地繁殖下去<br>\n海嗣将永远地迁徙下去<br>\n海嗣将永远地进化下去<br>\n博士与斯卡蒂, 将在无限的进化之中成为全知全能的存在<br>\n博士与斯卡蒂, 将在新的种群抛弃作为人时的人性</p>\n<p>正因如此, 博士才更加恐惧, 更加厌恶, 大群的意志在他的耳边低语, 斯卡蒂血红的双眸正注视着他<br>\n博士哭着, 哭着, 随后又笑了</p>\n<p><strong>[没关系的哟…]</strong><br>\n斯卡蒂轻轻拭去他脸颊上的泪水, 温柔地抱着博士, 轻轻地哼唱起了一首歌</p>\n<p>那是斯卡蒂还是深海猎人时, 经常哼唱的一首阿戈尔歌谣<br>\n她经常在深夜靠着罗德岛的栏杆, 俯瞰着远方的湖泊, 轻轻哼唱着那哀伤的歌<br>\n旋律哀伤而婉转, 她总是唱着唱着, 然后就不自觉地出神, 望着远方那波光粼粼的湖面<br>\n她总是那么哀伤</p>\n<p>博士总是会在她哼唱之时出现, 作为一名听众而沉默地听着, 直到歌声结束<br>\n最开始, 在歌声结束后, 斯卡蒂会沉默着看着对她微笑的博士, 然后轻声道, 她只会给周围的人带来不幸, 希望博士离她远点:</p>\n<br>  \n<p><code>......</code><br>\n<strong>[为了你的安全着想, 最好离我两米以上, 也不要和我说话…我不想你被冲我而来的危险伤到]</strong><br>\n<code>......</code><br>\n<strong>[看过我过去的简历了? 我的过去可是很糟糕的, 嗯, 让我待在身边, 不仅你会被卷入麻烦的漩涡, 我也会很难办的]</strong><br>\n<code>......</code><br>\n<strong>[这把剑的过去可是很恐怖的喔]</strong><br>\n<code>......</code><br>\n<strong>[这种程度的不幸, 也只是开始罢了]</strong><br>\n<code>......</code></p>\n<br/>  \n<p>有一天, 博士照常撑着脑袋听斯卡蒂唱完歌, 看着斯卡蒂为了把自己撵走而继续装作凶狠的样子, 进行每天的恐吓威胁时, 终于忍不住笑了起来<br>\n<strong>[喂, 有什么好笑的?]</strong><br>\n<strong>[啊, 抱歉, 但你这幅为了把我吓走而故意装作很冷漠很恐怖的样子实在是太太太可爱了~]</strong><br>\n…斯卡蒂沉默着转过身去, 不想让博士看到自己微微发烫的脸颊</p>\n<p>要离开的时候, 博士叫停了她, 微笑着跟她说了两句话, 无视了她为了让博士离自己远点而做的一切努力:<br>\n<strong>[你说你只会给他人带来不幸…但是啊, 有这回事吗?]</strong><br>\n<strong>[你给我带来的, 可是满满的幸福哦~]</strong><br>\n…斯卡蒂逃一样地离开了</p>\n<p>自那以后, 那位沉默寡言, 背着巨剑的阿戈尔少女, 对着博士的话也逐渐多了起来, 对他的信赖也逐渐多了起来<br>\n<strong>[你这人, 怎么这么执着, 这样我不就只能老老实实保护你了吗?]</strong><br>\n<strong>[远方浩瀚蓝色之下, 埋葬着我原本所在乎的一切, 我害怕, 怕厄运会再次夺走我珍视之人, 所以我才会逃…不希望所珍视之人, 因我而再次受伤…]</strong><br>\n<strong>[好! 又度过了轻松的一天, 没有会卷走队友的巨大触须, 也没有蹲在角落满手是血的疯狂敌人…光是上上战场什么的, 对, 已经很轻松了!]</strong><br>\n<strong>[根据传说, 我的族裔已经和那些灾祸战斗了无数年, 说不定我们也帮助了你们这些陆地人呢…所以说, 是不是该请我喝一杯?]</strong><br>\n<strong>[当你历经漫长黑夜, 终于付出海面, 睁开双眼的那一刹那, 灿烂星空滴落眼眶, 无垠波浪抚过脸颊…]</strong><br>\n<strong>[眼泪与家的味道, 都是咸的, 相比之下, 罗德岛的浴缸真是又宅又浅…我一定得带你试试去才行]</strong><br>\n<strong>[睡着了? 博士, 做个干燥的好梦吧]</strong><br>\n<strong>[呼呼地冲过去, 咚地打到敌人, 啪地解决, 原来你们是这么战斗的, 我记住啦!]</strong><br>\n<strong>[这个就是那个, 罗德岛干员经常说的晋升嘛? 感觉不错, 好像自己真的变强了呢? 大概?]</strong><br>\n<strong>[这么渴求我的力量, 真让我很困扰…如果你真的无所畏惧, 那么做好准备吧, 和我一起直面无边无际的黑暗吧]</strong><br>\n<strong>[我倒也挺擅长团队合作啦! 只是…]</strong><br>\n<strong>[对手是人类的话, 终归还是没什么手感]</strong><br>\n<strong>[听你的]</strong><br>\n<strong>[啊…帽子!]</strong><br>\n<strong>[离我那么近! 我, 我可没有能完全保护你的自信!]</strong><br>\n<strong>[注意安全, 博士]</strong></p>\n<p>博士眼前的少女, 与曾经的斯卡蒂重叠在了一起, 她对博士的爱一点也未曾改变过<br>\n依旧是那首他不知听少女哼唱过多少遍的阿戈尔歌谣<br>\n幽幽的歌声从少女的口中轻轻传出, 哀伤与安详交织, 化为一抹特别的韵味</p>\n<p>浪潮涌沒的终焉之上, 是存于此时此地的永恒之爱</p>\n<p><strong>[很快, 我们就可以在一起了…]</strong><br>\n她轻笑</p>\n<p><span style=\"font-size: 40px\">End<span/></p>\n","site":{"data":{}},"length":4686,"excerpt":"<blockquote>\n<p>本文为《明日方舟》二创同人原创作品, 灵感来源于B站上的手书: 《无光同葬》<br>\n你可以通过观看以下视频, 即B站上的《无光同葬》, 来迅速了解斯卡蒂的形象与本文中博士对斯卡蒂的情感 (背景为海嗣if灭世线)</p>\n</blockquote>","more":"<p><video controls=\"\" src=\"http://rueg9tnqd.hd-bkt.clouddn.com/videos/%E6%97%A0%E5%85%89%E5%90%8C%E8%91%AC.mp4\" type=\"video/mp4\" poster=\"http://rueg9tnqd.hd-bkt.clouddn.com/posters/无光同葬.jpg\" width=\"700\" height=\"400\" style=\"display: inline;\"> </video></p>\n<style>\n  * {\n    // font-weight: 500\n  }\n\n</style>\n<hr>\n<p>一望无际的海, 淡淡倾洒的月光<br>\n浪潮涌动, 船舰缓行, 带着些许海洋潮湿的风轻轻拂过, 轻柔而平静, 天真烂漫, 走过来, 又走过去</p>\n<p>男子站在船面上, 靠着栏杆, 默然地望着远方的水天交接之线, 眼神溃散, 一切的情绪彷佛在他身上消失了一般, 就像是一具空壳<br>\n他只是这样静悄悄地望着远方, 亦或是, 望着更远更远的地方, 望着已经不存在的那个地方</p>\n<p><strong>[是啊, 一具空壳而已]</strong> 他默然地想着<br>\n他早就失去了曾经他所拥有一切, 海浪翻涌, 浪潮早已吞没了泰拉, 曾经倾尽一切的付出毫无意义</p>\n<p><span style=\"font-weight: 900\">[The Age of Silence]<span/><br>\n<strong>[静谧时代]</strong></p>\n<p>再次的静谧<br>\n最后的静谧<br>\n永恒的静谧</p>\n<p>男子倚靠在栏杆旁, 仍然只是呆呆地望着翻涌的海浪<br>\n男子想到了那位卡西米尔最后的骑士, 那位骑士, 就算无数的海嗣已经爬到了他的身上, 其每寸血肉都被啃食殆尽, 但骑士却仍然在奋力挥动着他的长矛<br>\n卡西米尔家喻户晓的, 最后的骑士啊, 直到彻底被毁灭之前, 仍在与大海作着斗争, 发起了最后的冲锋<br>\n男子闭上了双眼, 努力地不让内心的悲伤浮现出来</p>\n<p>海嗣, 那群怪物, 进化得太快了, 因为那位海嗣的神明, 代表着 <strong>“迁徙”</strong> 的 <strong>神明</strong> 回到了 <strong>大群</strong><br>\n在那么短的时间里面, 海嗣们便已经进化出了适应陆地的身躯, 快速爬行的四肢, 无视铳与源石子弹的鳞片…</p>\n<p><strong>卡西米尔, 叙拉古, 伊比利亚, 维多利亚, 卡兹戴尔, 莱塔尼亚, 哥伦比亚, 萨米, 萨尔贡, 米诺斯, 谢拉格, 乌萨斯, 大炎…</strong><br>\n乌萨斯帝国的皇帝, 他命令手下全部的利刃们自爆, 释放出了最恐怖的 “国度”, 一座城市大小的空间被扭曲了维度, 陷入了永恒之黑暗<br>\n“坍塌恐惧” 杀死了一切处于 “国度” 范围内的生命体, 阻挡着海嗣们的前行<br>\n可海嗣们仍然在不断的进化着, 不断死亡, 不断繁殖, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化, 死亡, 繁殖, 适应, 进化…</p>\n<p>几个月之后, 海嗣们适应了乌萨斯皇帝的利刃们集体自爆所释放出来的 “国度”, 适应了其扭曲的维度空间, 适应了永恒的黑暗, 适应了恐惧与死亡, 适应了混沌与消逝<br>\n那位神明, 带领着海嗣们不断的迁徙</p>\n<p>泰拉大陆上的一切国家, 抛弃了意识形态的斗争, 抛弃了一切曾经自身的利益<br>\n哥伦比亚的军队, 卡西米尔的征战骑士团, 莱塔尼亚的巫师, 拉特兰的铳与子弹…<br>\n哥伦比亚的创想，萨米的坚韧，大炎的沧桑…<br>\n根本无法阻挡那群怪物</p>\n<p>大群意识吞噬了一切, 同化了一切, 无数人为之失去生命, 或者成为了大群的一员<br>\n陆上数万年文明的传承, 最终葬送于浪潮之中, 海嗣们吞噬了文明, 将其化为既有</p>\n<p>可是啊, 现在正处于海洋上, 处于海嗣故乡的他, 却又为什么没有死呢?<br>\n他抬头, 看向了从一旁走进的红裙女子, 原本溃散的眼神终于第一次有了波动<br>\n是厌恶? 是不甘? 是悲伤? 是憎恨? 是恐惧? 是愤怒? 是绝望?<br>\n亦或着…<br>\n是一抹被狠狠埋在眼底下的, 说不清道不明的, “爱” 与 “恨” 交织在一起的复杂情感?<br>\n对眼前的红裙少女, 对海嗣们的神明<br>\n呐, 你到底是谁啊?<br>\n到底是我喜欢的那个斯卡蒂, 还是我憎恨的那个伊莎玛拉呢?<br>\n一想到就变得好痛苦, 这份痛苦又有谁可以理解呢?</p>\n<p><strong>[博士…]</strong>, 一道温柔的声音响起, 被称做 “博士” 的男子却转过了头, 不想看那欢快着眨着眼睛走过来的她<br>\n但红裙的少女却不肯罢休, 快步向前走了几步, 雪白的藕臂从一旁袭来, 手指温柔地抚摸着男子僵硬的脸庞, 将他扭到一旁的脑袋转了过来</p>\n<p>映入 “博士” 眼帘的, 是一位白发红瞳的少女, 穿着一身有着许多皱褶与花边的红裙<br>\n她的袖口与腰部戴着作为装饰的黑色花边, 右腿绑着许多交织错杂的黑色绑带<br>\n此时的她, 眼中暗含着秋波, 带着如同这片大海般足以溺死人的深深爱意, 正看着低过头不想与她对视的男子, 嘴角带着一抹轻笑</p>\n<p>但眼前温柔的少女, 却是那群海嗣们的神明, 那让大地迎来了终焉, 被浪潮彻底吞噬的, 掌握着 “迁徙” 权能的四大海嗣神明之一<br>\n腐化之心, 伊莎玛拉, 摧毁了博士曾经拥有的一切的怪物<br>\n却, 也是博士最爱的那个人, 那个曾经为了阿戈尔的荣耀, 而与海嗣不断战斗的深海猎人…<br>\n斯卡蒂</p>\n<p>他绝望地再次闭上了双眼, 向后退了一步<br>\n红裙少女却不以为意, 上前了一步</p>\n<p>一进一退之间, 博士已经被逼到退无可退, 被死死地抵在栏杆上<br>\n斯卡蒂用血红的双眸温柔地望着他, 眼中的倒影唯他一人<br>\n唇与唇之间的距离越来越近<br>\n博士能听到她轻轻的呼吸声, 能闻到她身上宛若蔷薇般的幽香, 能感受到她那跳动着的心跳声<br>\n距离越来越近, 越来越近, 靠近, 即将碰在一起…</p>\n<p>就在即将吻到时, 博士却爆发出全身的力气, 一把推开了眼前的少女, 她银白色的长发随着自身的踉跄而晃动, 反射着淡淡的月光<br>\n她并不在意, 只是仍然用那温柔的眸子静静地看着博士, 好像仅是如此, 她就已经感受到了莫大的幸福一般</p>\n<p>博士的喉结艰难地滚动了一番<br>\n<strong>[嗯?]</strong>, 她疑惑地歪了歪头</p>\n<p><strong>[为什么?]</strong>, 博士开口道<br>\n直到开口说话之前, 他都未曾预想到自己的声音会颤成这样一幅狼狈的模样</p>\n<p>话没有说完, 但斯卡蒂却已经理解了博士的质问, 随后不以为然地用手指把玩着自己的长发, 微笑着对着博士说道:<br>\n<strong>[这不是, 理所当然的嘛?]</strong><br>\n<strong>[要是那些人, 可以乖乖去死, 成为大群养分的话, 或许我的同胞可以少死一些吧?]</strong><br>\n理所当然的语气, 不以为然的神情, 美丽灿烂的微笑</p>\n<p>博士的脑袋昏得要死, 血液逆流而上, 直冲脑门, 名为 “理智” 的一根弦瞬间崩断<br>\n以连他自己都没反应过来, 他便已然将斯卡蒂扑倒, 骑在了她的身上, 双手死死地掐住她纤细的脖颈</p>\n<p><strong>[博士?]</strong>, 她感受着博士在她脖子上的力度, 体会着他内心的悲怆与愤怒, 呼吸变得越发急促<br>\n<strong>[啊… 如果, 这样, 能让你开心的话…]</strong>, 在一瞬间释然, 她幸福而温柔地对博士笑着, 就像是脖颈上的青痕不存在一样<br>\n明明是海嗣的神明</p>\n<p>仅仅是这样一句话, 便让博士无法忍受, 松开了手上的力道, 痛哭了起来, 他根本无法杀死眼前这个少女<br>\n因为, 因为她是斯卡蒂啊, 哪怕被腐化, 被同化, 成为了披着人皮的海嗣怪物, 与伊莎玛拉合为一体, 成为海嗣的神明<br>\n哪怕她亲手带领海嗣, 杀死了泰拉上的一切, 让他曾经拥有的一切都不复存在</p>\n<p>但斯卡蒂是这个世界上最爱自己的人啊!<br>\n即使斯卡蒂体内的伊莎玛拉之血逐渐同化了她, 侵蚀并改变了她的意志, 人性被磨灭, 内心变得冷血残酷<br>\n即使她不再是人, 一切为了种群的延续与发展而思考, 她对博士的爱却仍始终如初, 至死不渝, 战胜了世间的一切<br>\n这份爱, 早已被刻入灵魂, 成为了本能, 在她的眼中, 博士永远是最为特别的存在, 是她所挚爱之人, 是愿意厮守一生之人</p>\n<p>博士趴在她的身上痛哭着, 斯卡蒂不断地抚摸着他的头, 低声安慰着他<br>\n斯卡蒂明白他所憎之事情, 所憎恨之物, 理解却又无法理解, 就如同人类进食时不会思考生物被杀死时对屠夫的憎恨, 海嗣们也只是为了活下去吸收养分而已<br>\n大群的意志在呼唤她, 千万海嗣同胞为了生存, 为了繁衍, 为了迁徙, 为了进化, 为了斗争, 而战胜了一切苦难, 用无数死亡堆积起后来者活下去的可能<br>\n她是海嗣的神明, 是大群意识的指挥之人</p>\n<p>渐渐地, 博士的哭声渐微, 低吼着, 从口中喃喃着道出一个又一个已经离他而去的人<br>\n他怎么也无法忘怀, 那一天, 罗德岛的船舰上, 到处都是血, 到处都是肉块<br>\n那是即使历经无数次战争洗礼的老兵也忍不住胆颤的场景, 令人作呕<br>\n命运用遍地废墟, 嘲笑着泰拉文明的终焉, 浪潮翻涌, 嗤笑着这片已经走向末路的大地</p>\n<p>在斯卡蒂的眼中, 或许全泰拉也只有他一人是特殊的吧?<br>\n这个世界太怪了点…<br>\n他或许是在做梦, 但梦却也太真实了点…</p>\n<p>在这她为他所打造的囚笼之中, 两人将共同度过往后余生, 永远, 永远, 永远…<br>\n即使他现在因为特殊的基因无法被同化成海嗣, 但已经进化出智慧的海嗣们早已吸收了泰拉所有的科研成果<br>\n斯卡蒂已经下达了命令, 无数的海嗣正为了攻克他的基因而进行研究<br>\n那一天不远了…<br>\n他也将被斯卡蒂同化, 共享那无穷的寿命, 在静谧的时代逐渐失去人性, 冷眼注视着曾经的回忆与现在痛苦的自己<br>\n忘却他曾经所珍视的一切, 最后坠入斯卡蒂那足以溺死人的温柔之中</p>\n<p>大地被浪潮淹没, 此后再无人类<br>\n海嗣将永远地生存下去<br>\n海嗣将永远地繁殖下去<br>\n海嗣将永远地迁徙下去<br>\n海嗣将永远地进化下去<br>\n博士与斯卡蒂, 将在无限的进化之中成为全知全能的存在<br>\n博士与斯卡蒂, 将在新的种群抛弃作为人时的人性</p>\n<p>正因如此, 博士才更加恐惧, 更加厌恶, 大群的意志在他的耳边低语, 斯卡蒂血红的双眸正注视着他<br>\n博士哭着, 哭着, 随后又笑了</p>\n<p><strong>[没关系的哟…]</strong><br>\n斯卡蒂轻轻拭去他脸颊上的泪水, 温柔地抱着博士, 轻轻地哼唱起了一首歌</p>\n<p>那是斯卡蒂还是深海猎人时, 经常哼唱的一首阿戈尔歌谣<br>\n她经常在深夜靠着罗德岛的栏杆, 俯瞰着远方的湖泊, 轻轻哼唱着那哀伤的歌<br>\n旋律哀伤而婉转, 她总是唱着唱着, 然后就不自觉地出神, 望着远方那波光粼粼的湖面<br>\n她总是那么哀伤</p>\n<p>博士总是会在她哼唱之时出现, 作为一名听众而沉默地听着, 直到歌声结束<br>\n最开始, 在歌声结束后, 斯卡蒂会沉默着看着对她微笑的博士, 然后轻声道, 她只会给周围的人带来不幸, 希望博士离她远点:</p>\n<br>  \n<p><code>......</code><br>\n<strong>[为了你的安全着想, 最好离我两米以上, 也不要和我说话…我不想你被冲我而来的危险伤到]</strong><br>\n<code>......</code><br>\n<strong>[看过我过去的简历了? 我的过去可是很糟糕的, 嗯, 让我待在身边, 不仅你会被卷入麻烦的漩涡, 我也会很难办的]</strong><br>\n<code>......</code><br>\n<strong>[这把剑的过去可是很恐怖的喔]</strong><br>\n<code>......</code><br>\n<strong>[这种程度的不幸, 也只是开始罢了]</strong><br>\n<code>......</code></p>\n<br/>  \n<p>有一天, 博士照常撑着脑袋听斯卡蒂唱完歌, 看着斯卡蒂为了把自己撵走而继续装作凶狠的样子, 进行每天的恐吓威胁时, 终于忍不住笑了起来<br>\n<strong>[喂, 有什么好笑的?]</strong><br>\n<strong>[啊, 抱歉, 但你这幅为了把我吓走而故意装作很冷漠很恐怖的样子实在是太太太可爱了~]</strong><br>\n…斯卡蒂沉默着转过身去, 不想让博士看到自己微微发烫的脸颊</p>\n<p>要离开的时候, 博士叫停了她, 微笑着跟她说了两句话, 无视了她为了让博士离自己远点而做的一切努力:<br>\n<strong>[你说你只会给他人带来不幸…但是啊, 有这回事吗?]</strong><br>\n<strong>[你给我带来的, 可是满满的幸福哦~]</strong><br>\n…斯卡蒂逃一样地离开了</p>\n<p>自那以后, 那位沉默寡言, 背着巨剑的阿戈尔少女, 对着博士的话也逐渐多了起来, 对他的信赖也逐渐多了起来<br>\n<strong>[你这人, 怎么这么执着, 这样我不就只能老老实实保护你了吗?]</strong><br>\n<strong>[远方浩瀚蓝色之下, 埋葬着我原本所在乎的一切, 我害怕, 怕厄运会再次夺走我珍视之人, 所以我才会逃…不希望所珍视之人, 因我而再次受伤…]</strong><br>\n<strong>[好! 又度过了轻松的一天, 没有会卷走队友的巨大触须, 也没有蹲在角落满手是血的疯狂敌人…光是上上战场什么的, 对, 已经很轻松了!]</strong><br>\n<strong>[根据传说, 我的族裔已经和那些灾祸战斗了无数年, 说不定我们也帮助了你们这些陆地人呢…所以说, 是不是该请我喝一杯?]</strong><br>\n<strong>[当你历经漫长黑夜, 终于付出海面, 睁开双眼的那一刹那, 灿烂星空滴落眼眶, 无垠波浪抚过脸颊…]</strong><br>\n<strong>[眼泪与家的味道, 都是咸的, 相比之下, 罗德岛的浴缸真是又宅又浅…我一定得带你试试去才行]</strong><br>\n<strong>[睡着了? 博士, 做个干燥的好梦吧]</strong><br>\n<strong>[呼呼地冲过去, 咚地打到敌人, 啪地解决, 原来你们是这么战斗的, 我记住啦!]</strong><br>\n<strong>[这个就是那个, 罗德岛干员经常说的晋升嘛? 感觉不错, 好像自己真的变强了呢? 大概?]</strong><br>\n<strong>[这么渴求我的力量, 真让我很困扰…如果你真的无所畏惧, 那么做好准备吧, 和我一起直面无边无际的黑暗吧]</strong><br>\n<strong>[我倒也挺擅长团队合作啦! 只是…]</strong><br>\n<strong>[对手是人类的话, 终归还是没什么手感]</strong><br>\n<strong>[听你的]</strong><br>\n<strong>[啊…帽子!]</strong><br>\n<strong>[离我那么近! 我, 我可没有能完全保护你的自信!]</strong><br>\n<strong>[注意安全, 博士]</strong></p>\n<p>博士眼前的少女, 与曾经的斯卡蒂重叠在了一起, 她对博士的爱一点也未曾改变过<br>\n依旧是那首他不知听少女哼唱过多少遍的阿戈尔歌谣<br>\n幽幽的歌声从少女的口中轻轻传出, 哀伤与安详交织, 化为一抹特别的韵味</p>\n<p>浪潮涌沒的终焉之上, 是存于此时此地的永恒之爱</p>\n<p><strong>[很快, 我们就可以在一起了…]</strong><br>\n她轻笑</p>\n<p><span style=\"font-size: 40px\">End<span/></p>"},{"layout":"page","abbrlink":"categories/desktop-beautify","title":"desktop-beautify","hidden":true,"date":"2022-12-10T10:46:29.000Z","quicklink":true,"top":null,"keywords":null,"_content":"\n下面是一些桌面美化的文章, GNOME 与 Hyprland 分别代表了 \"简洁稳定\" 与 \"炫酷自由\" 两种不同的理念  \n当然, 这不是说 GNOME 不能炫酷, 也不是说 Hyprland 不能简洁, 想配置当然还是可以配置的\n\n[x]  [GNOME 入坑指南](/posts/desktop-beautify/gnome)\n[ ]  [Hyprland 平铺式](/posts/desktop-beautify/hyprland)\n\n","source":"_posts/categories/desktop-beautify.md","raw":"---\nlayout: page\nabbrlink: categories/desktop-beautify\ntitle: desktop-beautify\nhidden: true\ndate: 2022-12-10 18:46:29\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n下面是一些桌面美化的文章, GNOME 与 Hyprland 分别代表了 \"简洁稳定\" 与 \"炫酷自由\" 两种不同的理念  \n当然, 这不是说 GNOME 不能炫酷, 也不是说 Hyprland 不能简洁, 想配置当然还是可以配置的\n\n[x]  [GNOME 入坑指南](/posts/desktop-beautify/gnome)\n[ ]  [Hyprland 平铺式](/posts/desktop-beautify/hyprland)\n\n","slug":"categories/desktop-beautify","published":1,"updated":"2022-12-10T10:46:29.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogd000gj1s65ttl8yxo","content":"<p>下面是一些桌面美化的文章, GNOME 与 Hyprland 分别代表了 “简洁稳定” 与 “炫酷自由” 两种不同的理念<br>\n当然, 这不是说 GNOME 不能炫酷, 也不是说 Hyprland 不能简洁, 想配置当然还是可以配置的</p>\n<p><input type=\"checkbox\" id=\"checkbox1\" checked=\"true\"><label for=\"checkbox1\"> </label><a href=\"/posts/desktop-beautify/gnome\">GNOME 入坑指南</a><br>\n<input type=\"checkbox\" id=\"checkbox0\"><label for=\"checkbox0\"> </label><a href=\"/posts/desktop-beautify/hyprland\">Hyprland 平铺式</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":118,"excerpt":"","more":"<p>下面是一些桌面美化的文章, GNOME 与 Hyprland 分别代表了 “简洁稳定” 与 “炫酷自由” 两种不同的理念<br>\n当然, 这不是说 GNOME 不能炫酷, 也不是说 Hyprland 不能简洁, 想配置当然还是可以配置的</p>\n<p><input type=\"checkbox\" id=\"checkbox1\" checked=\"true\"><label for=\"checkbox1\"> </label><a href=\"/posts/desktop-beautify/gnome\">GNOME 入坑指南</a><br>\n<input type=\"checkbox\" id=\"checkbox0\"><label for=\"checkbox0\"> </label><a href=\"/posts/desktop-beautify/hyprland\">Hyprland 平铺式</a></p>\n"},{"title":"haskell-basic-p2~> 环境搭建","abbrlink":"posts/haskell-basic/p2","hidden":false,"date":"2022-06-25T13:57:14.000Z","top":6998,"keywords":["Haskell","函数式"],"is_series":true,"prev_post":["/posts/haskell-basic/p1","p1~> 系列说明"],"next_post":["/posts/haskell-basic/p3","p3~> 函数式介绍"],"_content":"> 本节将介绍如何搭建 Haskell 的环境\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 编译器 && 包管理\n本文假设你使用的是Linux系统  \n\n通过Linux发行版自带的包管理器, 下载 `haskell-platform` 来直接配置环境  \n随后, 你会获得 `ghc`, `ghci`, `cabal`  \n\n- `ghc`: Haskell 的编译器  \n- `ghci`: 一个REPL, 即用于新手学习的交互式解释器  \n- `cabal`: Hsakell的包管理器  \n\n(注, 你也可以选择下载另一个叫 `stack` 的包管理器, 不过我选择了 `cabal (官方的)`, 仅此而已)  \n\n请确保都能正确显示版本:  \n\n```bash\nghc -V\nghci -V\ncabal -V\n```\n\n本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 `ghci`, 因此 `cabal-install (即上面的 cabal)` 这东西不太会用到  \n\n - - -\n\n# 代码编辑\n\n推荐的代码编辑器:\n- Helix (强推)\n- Nvim/Vim\n- Emacs\n- Vscode\n\n如果你使用的是Vscode, 直接下载对应的Haskell插件  \n如果你使用的是 `Helix/Vim/Emacs`, 要下载对应的LSP: `haskell-language-server`  \n\n比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:  \n\n```bash\nsudo dnf copr enable -y petersen/haskell-language-server\nsudo dnf install -y haskell-language-server\n```\n\n如果你使用的是 [Helix](https://helix-editor.com/), LSP将会直接启用  \n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP  \n\n- - -\n\n# 换源\nHaskell的包都放在 [hackage](https://hackage.haskell.org/), 下载依赖时, 速度可能极慢  \n这时, 我们应该进行将其换成镜像源  \n\n若你使用cabal, 可以按照下面的做:\n\n```bash\ncabal user-config init\nsed -i 's/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g' ~/.cabal/config\nsed -i 's/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g' ~/.cabal/config\nsed -i 's/-- secure: True/secure: True/g' ~/.cabal/config\ncabal update\n```\n\n这会生成cabal的配置文件, 并且将url替换为中科大的源  \n\n至此, 环境准备工作已全部完成  \n下一节, 我们将正式开始学习 Haskell  \n\n- - -\n\n# 更改ghci提示符\n第一次执行 `ghci` 时, 你会发现前置的提示符为 `Prelude>`, 这是默认样式  \n但它会随着你引入的模块的增多, 而变得冗杂, 比如:  \n\n当你输入 `:m Data.Time` (表示引入一个模块, 后面会学), 前置提示符变成了 `Prelude Data.Time>`  \n\n为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:  \n\n```bash\necho ':set prompt \"ghci> \"' > ~/.ghci\nchmod go-w ~/.ghci\n```\n\n第一行更改提示符  \n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改  ","source":"_posts/haskell/basic/p2-环境搭建.md","raw":"---\ntitle: \"haskell-basic-p2~> 环境搭建\"\nabbrlink: posts/haskell-basic/p2\nhidden: false\ndate: 2022-06-25 21:57:14\ntop: 6998\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\nis_series: true\nprev_post: [\"/posts/haskell-basic/p1\", \"p1~> 系列说明\"]\nnext_post: [\"/posts/haskell-basic/p3\", \"p3~> 函数式介绍\"]\n---\n> 本节将介绍如何搭建 Haskell 的环境\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 编译器 && 包管理\n本文假设你使用的是Linux系统  \n\n通过Linux发行版自带的包管理器, 下载 `haskell-platform` 来直接配置环境  \n随后, 你会获得 `ghc`, `ghci`, `cabal`  \n\n- `ghc`: Haskell 的编译器  \n- `ghci`: 一个REPL, 即用于新手学习的交互式解释器  \n- `cabal`: Hsakell的包管理器  \n\n(注, 你也可以选择下载另一个叫 `stack` 的包管理器, 不过我选择了 `cabal (官方的)`, 仅此而已)  \n\n请确保都能正确显示版本:  \n\n```bash\nghc -V\nghci -V\ncabal -V\n```\n\n本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 `ghci`, 因此 `cabal-install (即上面的 cabal)` 这东西不太会用到  \n\n - - -\n\n# 代码编辑\n\n推荐的代码编辑器:\n- Helix (强推)\n- Nvim/Vim\n- Emacs\n- Vscode\n\n如果你使用的是Vscode, 直接下载对应的Haskell插件  \n如果你使用的是 `Helix/Vim/Emacs`, 要下载对应的LSP: `haskell-language-server`  \n\n比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:  \n\n```bash\nsudo dnf copr enable -y petersen/haskell-language-server\nsudo dnf install -y haskell-language-server\n```\n\n如果你使用的是 [Helix](https://helix-editor.com/), LSP将会直接启用  \n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP  \n\n- - -\n\n# 换源\nHaskell的包都放在 [hackage](https://hackage.haskell.org/), 下载依赖时, 速度可能极慢  \n这时, 我们应该进行将其换成镜像源  \n\n若你使用cabal, 可以按照下面的做:\n\n```bash\ncabal user-config init\nsed -i 's/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g' ~/.cabal/config\nsed -i 's/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g' ~/.cabal/config\nsed -i 's/-- secure: True/secure: True/g' ~/.cabal/config\ncabal update\n```\n\n这会生成cabal的配置文件, 并且将url替换为中科大的源  \n\n至此, 环境准备工作已全部完成  \n下一节, 我们将正式开始学习 Haskell  \n\n- - -\n\n# 更改ghci提示符\n第一次执行 `ghci` 时, 你会发现前置的提示符为 `Prelude>`, 这是默认样式  \n但它会随着你引入的模块的增多, 而变得冗杂, 比如:  \n\n当你输入 `:m Data.Time` (表示引入一个模块, 后面会学), 前置提示符变成了 `Prelude Data.Time>`  \n\n为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:  \n\n```bash\necho ':set prompt \"ghci> \"' > ~/.ghci\nchmod go-w ~/.ghci\n```\n\n第一行更改提示符  \n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改  ","slug":"haskell/basic/p2-环境搭建","published":1,"updated":"2022-06-25T13:57:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oge000ij1s6a1jxf9ev","content":"<blockquote>\n<p>本节将介绍如何搭建 Haskell 的环境</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"bian-yi-qi-amp-amp-bao-guan-li\">编译器 &amp;&amp; 包管理</h1>\n<p>本文假设你使用的是Linux系统</p>\n<p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>\n随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ghc</code>: Haskell 的编译器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>cabal</code>: Hsakell的包管理器</p>\n</li>\n</ul>\n<p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p>\n<p>请确保都能正确显示版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ghc -V</span><br><span class=\"line\">ghci -V</span><br><span class=\"line\">cabal -V</span><br></pre></td></tr></table></figure>\n<p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p>\n<hr>\n<h1 id=\"dai-ma-bian-ji\">代码编辑</h1>\n<p>推荐的代码编辑器:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Helix (强推)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nvim/Vim</p>\n</li>\n<li class=\"lvl-2\">\n<p>Emacs</p>\n</li>\n<li class=\"lvl-2\">\n<p>Vscode</p>\n</li>\n</ul>\n<p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>\n如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p>\n<p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf copr <span class=\"built_in\">enable</span> -y petersen/haskell-language-server</span><br><span class=\"line\">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure>\n<p>如果你使用的是 <a href=\"https://helix-editor.com/\">Helix</a>, LSP将会直接启用<br>\n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p>\n<hr>\n<h1 id=\"huan-yuan\">换源</h1>\n<p>Haskell的包都放在 <a href=\"https://hackage.haskell.org/\">hackage</a>, 下载依赖时, 速度可能极慢<br>\n这时, 我们应该进行将其换成镜像源</p>\n<p>若你使用cabal, 可以按照下面的做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cabal user-config init</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">cabal update</span><br></pre></td></tr></table></figure>\n<p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p>\n<p>至此, 环境准备工作已全部完成<br>\n下一节, 我们将正式开始学习 Haskell</p>\n<hr>\n<h1 id=\"geng-gai-ghci-ti-shi-fu\">更改ghci提示符</h1>\n<p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>\n但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p>\n<p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p>\n<p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class=\"line\">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure>\n<p>第一行更改提示符<br>\n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>\n","site":{"data":{}},"length":1350,"excerpt":"<blockquote>\n<p>本节将介绍如何搭建 Haskell 的环境</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"bian-yi-qi-amp-amp-bao-guan-li\">编译器 &amp;&amp; 包管理</h1>\n<p>本文假设你使用的是Linux系统</p>\n<p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>\n随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ghc</code>: Haskell 的编译器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>cabal</code>: Hsakell的包管理器</p>\n</li>\n</ul>\n<p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p>\n<p>请确保都能正确显示版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ghc -V</span><br><span class=\"line\">ghci -V</span><br><span class=\"line\">cabal -V</span><br></pre></td></tr></table></figure>\n<p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p>\n<hr>\n<h1 id=\"dai-ma-bian-ji\">代码编辑</h1>\n<p>推荐的代码编辑器:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Helix (强推)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nvim/Vim</p>\n</li>\n<li class=\"lvl-2\">\n<p>Emacs</p>\n</li>\n<li class=\"lvl-2\">\n<p>Vscode</p>\n</li>\n</ul>\n<p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>\n如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p>\n<p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf copr <span class=\"built_in\">enable</span> -y petersen/haskell-language-server</span><br><span class=\"line\">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure>\n<p>如果你使用的是 <a href=\"https://helix-editor.com/\">Helix</a>, LSP将会直接启用<br>\n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p>\n<hr>\n<h1 id=\"huan-yuan\">换源</h1>\n<p>Haskell的包都放在 <a href=\"https://hackage.haskell.org/\">hackage</a>, 下载依赖时, 速度可能极慢<br>\n这时, 我们应该进行将其换成镜像源</p>\n<p>若你使用cabal, 可以按照下面的做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cabal user-config init</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">cabal update</span><br></pre></td></tr></table></figure>\n<p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p>\n<p>至此, 环境准备工作已全部完成<br>\n下一节, 我们将正式开始学习 Haskell</p>\n<hr>\n<h1 id=\"geng-gai-ghci-ti-shi-fu\">更改ghci提示符</h1>\n<p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>\n但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p>\n<p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p>\n<p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class=\"line\">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure>\n<p>第一行更改提示符<br>\n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>"},{"title":"haskell-basic-p3~> 函数式介绍","abbrlink":"posts/haskell-basic/p3","hidden":false,"date":"2022-06-26T08:16:10.000Z","top":6997,"keywords":["Haskell","函数式"],"is_series":true,"prev_post":["/posts/haskell-basic/p2","p2~> 环境搭建"],"next_post":["/posts/haskell-basic/p4","p4~> 基础语法"],"_content":"> 何为函数式编程(FP, 即Functional Programming) ?\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西  \n那么, 开始吧!  \n\n# 编程范式\n## 概览\nFP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式  \n\n编程范式是一种思考方式, 技术, 语言范式, 编程模型  \n在世界上, 有许多编程范式, 最主要的有:  \n\n|简称|中文名|英文名|\n|--|--|--|\n|FP|函数式编程|Functional Programming|\n|OOP|面向对象编程|Object-Oriented Programming|\n|POP|面向过程编程|Procedure-Oriented Programming|\n|LP |逻辑式编程|Logic Programming|\n|DP |声明式编程|Declarative Programming|\n|IP |命令式编程|Imperative Programming|\n\n\n编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西  \n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆  \n\n\n\n编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响  \n下面是一些编程范式的例子:  \n\n**提示**\n如果你已经了解过以下范式, 直接跳到 [**总结**](#zong-jie) 吧  \n\n- 面向过程:  \n优点:  \n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉  \n缺点:  \n代码复用能力差, 扩展性差, 繁琐  \n\n- 面向对象:  \n优点:  \n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍  \n缺点:  \n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐  \n\n- 逻辑式:\n优点:  \n通过建立 `事实`, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇  \n缺点:\n玄学编程, 可能想象不到怎么样建立出 `能正确求解的前提条件/定义`, 也可能因推理过于复杂, 导致性能低下  \n\n- 函数式:\n优点:\n通过以数学中的 `函数` 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性  \n缺点:  \n学习难度较大, 性能因不可变数据, 不可避免地会低下一些  \n\n- 命令式:  \n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已  \n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可  \n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了  \n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等  \n\n- 声明式:  \n指你编程依靠描述, 而非面向过程地去思考  \n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发  \nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库  \n特点是一旦脱离相关领域, 语法就不再便利  \n\n\n## 总结\n各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式  \n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集  \n\n比如:\n- 面向过程/面向对象 && 命令式 \n- 函数式/逻辑式 && 声明式\n- 混合一种, 两种, 甚至各种范式\n\n再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想  \n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力  \n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子  \n\n相信经过本小节, 你对什么是编程范式有了一个初步的认知  \n接下来, 我们就要专注于本节的主角, 函数式  \n\n简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中  \n让我们开始对函数式的正式介绍吧!\n\n- - -\n\n# 高阶函数\n高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数  \n\n你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民  \n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较  \n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)  \n~~(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)~~  \n\n一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民  \n\n- - -\n\n# 不可变数据\n不可变数据(Immutable Data), 指你无法修改已经存在的数据  \n\n换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它  \n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 `变量` 感到困惑  \n\n这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身  \n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费  \n\n而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制  \n但不可变的数据能够有效降低并发的难度  \n\n而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊  \n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值  \n- - -\n\n# 副作用\n副作用(Side Effects), 指与外界发生的交互  \n\n假设有这么一个函数:  \n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出  \n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出  \n\n因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情  \n这种超脱于语言, 来自更真实世界的交互, 我们称之为 `副作用`  \n\n副作用包括, 但不限于:  \n- 发送网络请求  \n- 访问系统状态\n- 操作数据库\n- 操作DOM\n- IO操作\n- 修改函数外部的变量  \n- 使用具有副作用的函数 (传播性)\n\n你会注意到 `修改函数外部的变量`, 它也可以看作 `与外界的交互`  \n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值  \n那么这将无法保证相同输入, 能得到相同输出  \n\n但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互  \n绝对的没有副作用, 意味着这个程序绝对的没用  \n\n- - -\n\n# 引用透明\n引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价  \n\n引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等  \n以下是数学中的 RT, 简单来讲, 就是等式推导:  \n\nf(x) = (x+1)^2^\nf(2) = (2+1)^2^ = (3)^2^ = 9\n\n可以看到, `2+1`可以被`3`代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 `等式推导`:  \n某个 `父表达式` 由许多 `子表达式` 组成, 如果可以将这些 `子表达式` 替换为它们计算得到的对应值, 就能简化这个 `父表达式`    \n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT  \n\n总而言之, 就是替换, 替换, 还是替换  \n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等  \n\nRT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:  \n若有这么个函数:  \n\n```haskell\ndouble_x(x: Int): Int {\n    println(x);\n    return x+x;\n}\n```\n\n那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)  \n此时进行替换的话, 比如 `double_x(10) -> 20`, 因为后者少了次打印, 语义不一致  \n假设你将其中10次对 `double_x(x)` 的调用, 都用 `x+x` 来替换, 那你将缺少10次打印  \n\n这只是个简单的例子, 你完全能将函数中的 `println(x)`, 换成其他具有副作用, 而非单纯数运算的表达式  \n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难  \n你将需要额外使用复杂的工具, 去分析一段复杂的代码  \n这通常是一些 BUG 的来源  \n\nRT, 即引用透明, 注定与副作用互斥  \n\n- - -\n\n# 纯函数\n纯函数(Pure Functions), 表示引用透明的函数  \n\n引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已  \n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好  \n\n因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已  \n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系  \n\n一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:  \n有三个纯函数: `f(x), h(x), g(x)`, 那么 `f(x) + h(x) + g(x)` 中, 三个函数直接并行计算即可  \n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性  \n\n但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来  \n\n- - -\n\n# 其他\n以上是对函数式的小小概括  \n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解  \n\n为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码  \n\n- 埃氏筛求素数:\n\n```haskell\nprimes = filterPrime [2..]\n  where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0]\n```\n\n\n\n- 斐波那契数列:\n\n```haskell\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n- 快速排列:\n\n```haskell\nqsort [] = []\nqsort (x : xs) = qsort sList ++ [x] ++ qsort bList\n  where (sList, bList) = partition (< x) xs\n```\n\n- 辗转相除法求最大公约数:\n\n```haskell\ngcd' x y\n  | y == 0 = x\n  | otherwise = gcd' y (x `mod` y)\n```\n\n感谢你的观看, 咋们下期见!!  \n先让我鸽几天 :)\n","source":"_posts/haskell/basic/p3-函数式编程.md","raw":"---\ntitle: \"haskell-basic-p3~> 函数式介绍\"\nabbrlink: posts/haskell-basic/p3\nhidden: false\ndate: 2022-06-26 16:16:10\ntop: 6997\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\nis_series: true\nprev_post: [\"/posts/haskell-basic/p2\", \"p2~> 环境搭建\"]\nnext_post: [\"/posts/haskell-basic/p4\", \"p4~> 基础语法\"]\n---\n> 何为函数式编程(FP, 即Functional Programming) ?\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西  \n那么, 开始吧!  \n\n# 编程范式\n## 概览\nFP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式  \n\n编程范式是一种思考方式, 技术, 语言范式, 编程模型  \n在世界上, 有许多编程范式, 最主要的有:  \n\n|简称|中文名|英文名|\n|--|--|--|\n|FP|函数式编程|Functional Programming|\n|OOP|面向对象编程|Object-Oriented Programming|\n|POP|面向过程编程|Procedure-Oriented Programming|\n|LP |逻辑式编程|Logic Programming|\n|DP |声明式编程|Declarative Programming|\n|IP |命令式编程|Imperative Programming|\n\n\n编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西  \n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆  \n\n\n\n编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响  \n下面是一些编程范式的例子:  \n\n**提示**\n如果你已经了解过以下范式, 直接跳到 [**总结**](#zong-jie) 吧  \n\n- 面向过程:  \n优点:  \n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉  \n缺点:  \n代码复用能力差, 扩展性差, 繁琐  \n\n- 面向对象:  \n优点:  \n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍  \n缺点:  \n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐  \n\n- 逻辑式:\n优点:  \n通过建立 `事实`, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇  \n缺点:\n玄学编程, 可能想象不到怎么样建立出 `能正确求解的前提条件/定义`, 也可能因推理过于复杂, 导致性能低下  \n\n- 函数式:\n优点:\n通过以数学中的 `函数` 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性  \n缺点:  \n学习难度较大, 性能因不可变数据, 不可避免地会低下一些  \n\n- 命令式:  \n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已  \n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可  \n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了  \n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等  \n\n- 声明式:  \n指你编程依靠描述, 而非面向过程地去思考  \n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发  \nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库  \n特点是一旦脱离相关领域, 语法就不再便利  \n\n\n## 总结\n各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式  \n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集  \n\n比如:\n- 面向过程/面向对象 && 命令式 \n- 函数式/逻辑式 && 声明式\n- 混合一种, 两种, 甚至各种范式\n\n再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想  \n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力  \n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子  \n\n相信经过本小节, 你对什么是编程范式有了一个初步的认知  \n接下来, 我们就要专注于本节的主角, 函数式  \n\n简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中  \n让我们开始对函数式的正式介绍吧!\n\n- - -\n\n# 高阶函数\n高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数  \n\n你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民  \n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较  \n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)  \n~~(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)~~  \n\n一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民  \n\n- - -\n\n# 不可变数据\n不可变数据(Immutable Data), 指你无法修改已经存在的数据  \n\n换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它  \n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 `变量` 感到困惑  \n\n这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身  \n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费  \n\n而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制  \n但不可变的数据能够有效降低并发的难度  \n\n而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊  \n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值  \n- - -\n\n# 副作用\n副作用(Side Effects), 指与外界发生的交互  \n\n假设有这么一个函数:  \n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出  \n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出  \n\n因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情  \n这种超脱于语言, 来自更真实世界的交互, 我们称之为 `副作用`  \n\n副作用包括, 但不限于:  \n- 发送网络请求  \n- 访问系统状态\n- 操作数据库\n- 操作DOM\n- IO操作\n- 修改函数外部的变量  \n- 使用具有副作用的函数 (传播性)\n\n你会注意到 `修改函数外部的变量`, 它也可以看作 `与外界的交互`  \n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值  \n那么这将无法保证相同输入, 能得到相同输出  \n\n但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互  \n绝对的没有副作用, 意味着这个程序绝对的没用  \n\n- - -\n\n# 引用透明\n引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价  \n\n引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等  \n以下是数学中的 RT, 简单来讲, 就是等式推导:  \n\nf(x) = (x+1)^2^\nf(2) = (2+1)^2^ = (3)^2^ = 9\n\n可以看到, `2+1`可以被`3`代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 `等式推导`:  \n某个 `父表达式` 由许多 `子表达式` 组成, 如果可以将这些 `子表达式` 替换为它们计算得到的对应值, 就能简化这个 `父表达式`    \n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT  \n\n总而言之, 就是替换, 替换, 还是替换  \n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等  \n\nRT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:  \n若有这么个函数:  \n\n```haskell\ndouble_x(x: Int): Int {\n    println(x);\n    return x+x;\n}\n```\n\n那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)  \n此时进行替换的话, 比如 `double_x(10) -> 20`, 因为后者少了次打印, 语义不一致  \n假设你将其中10次对 `double_x(x)` 的调用, 都用 `x+x` 来替换, 那你将缺少10次打印  \n\n这只是个简单的例子, 你完全能将函数中的 `println(x)`, 换成其他具有副作用, 而非单纯数运算的表达式  \n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难  \n你将需要额外使用复杂的工具, 去分析一段复杂的代码  \n这通常是一些 BUG 的来源  \n\nRT, 即引用透明, 注定与副作用互斥  \n\n- - -\n\n# 纯函数\n纯函数(Pure Functions), 表示引用透明的函数  \n\n引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已  \n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好  \n\n因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已  \n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系  \n\n一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:  \n有三个纯函数: `f(x), h(x), g(x)`, 那么 `f(x) + h(x) + g(x)` 中, 三个函数直接并行计算即可  \n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性  \n\n但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来  \n\n- - -\n\n# 其他\n以上是对函数式的小小概括  \n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解  \n\n为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码  \n\n- 埃氏筛求素数:\n\n```haskell\nprimes = filterPrime [2..]\n  where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0]\n```\n\n\n\n- 斐波那契数列:\n\n```haskell\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n- 快速排列:\n\n```haskell\nqsort [] = []\nqsort (x : xs) = qsort sList ++ [x] ++ qsort bList\n  where (sList, bList) = partition (< x) xs\n```\n\n- 辗转相除法求最大公约数:\n\n```haskell\ngcd' x y\n  | y == 0 = x\n  | otherwise = gcd' y (x `mod` y)\n```\n\n感谢你的观看, 咋们下期见!!  \n先让我鸽几天 :)\n","slug":"haskell/basic/p3-函数式编程","published":1,"updated":"2022-06-26T08:16:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogg000kj1s6fpho05dd","content":"<blockquote>\n<p>何为函数式编程(FP, 即Functional Programming) ?</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>\n那么, 开始吧!</p>\n<h1 id=\"bian-cheng-fan-shi\">编程范式</h1>\n<h2 id=\"gai-lan\" id=\"概览\">概览</h2>\n<p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p>\n<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>\n在世界上, 有许多编程范式, 最主要的有:</p>\n<table>\n<thead>\n<tr>\n<th>简称</th>\n<th>中文名</th>\n<th>英文名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FP</td>\n<td>函数式编程</td>\n<td>Functional Programming</td>\n</tr>\n<tr>\n<td>OOP</td>\n<td>面向对象编程</td>\n<td>Object-Oriented Programming</td>\n</tr>\n<tr>\n<td>POP</td>\n<td>面向过程编程</td>\n<td>Procedure-Oriented Programming</td>\n</tr>\n<tr>\n<td>LP</td>\n<td>逻辑式编程</td>\n<td>Logic Programming</td>\n</tr>\n<tr>\n<td>DP</td>\n<td>声明式编程</td>\n<td>Declarative Programming</td>\n</tr>\n<tr>\n<td>IP</td>\n<td>命令式编程</td>\n<td>Imperative Programming</td>\n</tr>\n</tbody>\n</table>\n<p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>\n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p>\n<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>\n下面是一些编程范式的例子:</p>\n<p><strong>提示</strong><br>\n如果你已经了解过以下范式, 直接跳到 <a href=\"#zong-jie\"><strong>总结</strong></a> 吧</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程:<br>\n优点:<br>\n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>\n缺点:<br>\n代码复用能力差, 扩展性差, 繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>面向对象:<br>\n优点:<br>\n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>\n缺点:<br>\n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>逻辑式:<br>\n优点:<br>\n通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>\n缺点:<br>\n玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式:<br>\n优点:<br>\n通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>\n缺点:<br>\n学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令式:<br>\n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>\n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>\n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>\n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>声明式:<br>\n指你编程依靠描述, 而非面向过程地去思考<br>\n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>\nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>\n特点是一旦脱离相关领域, 语法就不再便利</p>\n</li>\n</ul>\n<h2 id=\"zong-jie\" id=\"总结\">总结</h2>\n<p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>\n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p>\n<p>比如:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程/面向对象 &amp;&amp; 命令式</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式/逻辑式 &amp;&amp; 声明式</p>\n</li>\n<li class=\"lvl-2\">\n<p>混合一种, 两种, 甚至各种范式</p>\n</li>\n</ul>\n<p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>\n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>\n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p>\n<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>\n接下来, 我们就要专注于本节的主角, 函数式</p>\n<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>\n让我们开始对函数式的正式介绍吧!</p>\n<hr>\n<h1 id=\"gao-jie-han-shu\">高阶函数</h1>\n<p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p>\n<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>\n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>\n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br>\n<s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p>\n<p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p>\n<hr>\n<h1 id=\"bu-ke-bian-shu-ju\">不可变数据</h1>\n<p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p>\n<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>\n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p>\n<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>\n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p>\n<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>\n但不可变的数据能够有效降低并发的难度</p>\n<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>\n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p>\n<hr>\n<h1 id=\"fu-zuo-yong\">副作用</h1>\n<p>副作用(Side Effects), 指与外界发生的交互</p>\n<p>假设有这么一个函数:<br>\n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>\n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p>\n<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>\n这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p>\n<p>副作用包括, 但不限于:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>发送网络请求</p>\n</li>\n<li class=\"lvl-2\">\n<p>访问系统状态</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作数据库</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作DOM</p>\n</li>\n<li class=\"lvl-2\">\n<p>IO操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>修改函数外部的变量</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用具有副作用的函数 (传播性)</p>\n</li>\n</ul>\n<p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>\n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>\n那么这将无法保证相同输入, 能得到相同输出</p>\n<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>\n绝对的没有副作用, 意味着这个程序绝对的没用</p>\n<hr>\n<h1 id=\"yin-yong-tou-ming\">引用透明</h1>\n<p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p>\n<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>\n以下是数学中的 RT, 简单来讲, 就是等式推导:</p>\n<p>f(x) = (x+1)<sup>2</sup><br>\nf(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p>\n<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>\n某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>\n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p>\n<p>总而言之, 就是替换, 替换, 还是替换<br>\n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p>\n<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>\n若有这么个函数:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">double_x</span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    println(x);</span><br><span class=\"line\">    return x+x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>\n此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>\n假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p>\n<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>\n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>\n你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>\n这通常是一些 BUG 的来源</p>\n<p>RT, 即引用透明, 注定与副作用互斥</p>\n<hr>\n<h1 id=\"chun-han-shu\">纯函数</h1>\n<p>纯函数(Pure Functions), 表示引用透明的函数</p>\n<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>\n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p>\n<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>\n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p>\n<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>\n有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>\n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p>\n<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p>\n<hr>\n<h1 id=\"qi-ta\">其他</h1>\n<p>以上是对函数式的小小概括<br>\n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p>\n<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>埃氏筛求素数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">primes</span> = filterPrime [<span class=\"number\">2.</span>.]</span><br><span class=\"line\">  <span class=\"keyword\">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>斐波那契数列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fibs</span> = <span class=\"number\">0</span> : <span class=\"number\">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>快速排列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> [] = []</span><br><span class=\"line\"><span class=\"title\">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class=\"line\">  <span class=\"keyword\">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>辗转相除法求最大公约数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">gcd&#x27;</span> x y</span><br><span class=\"line\">  | y == <span class=\"number\">0</span> = x</span><br><span class=\"line\">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure>\n<p>感谢你的观看, 咋们下期见!!<br>\n先让我鸽几天 😃</p>\n","site":{"data":{}},"length":3837,"excerpt":"<blockquote>\n<p>何为函数式编程(FP, 即Functional Programming) ?</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>\n那么, 开始吧!</p>\n<h1 id=\"bian-cheng-fan-shi\">编程范式</h1>\n<h2 id=\"gai-lan\" id=\"概览\">概览</h2>\n<p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p>\n<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>\n在世界上, 有许多编程范式, 最主要的有:</p>\n<table>\n<thead>\n<tr>\n<th>简称</th>\n<th>中文名</th>\n<th>英文名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FP</td>\n<td>函数式编程</td>\n<td>Functional Programming</td>\n</tr>\n<tr>\n<td>OOP</td>\n<td>面向对象编程</td>\n<td>Object-Oriented Programming</td>\n</tr>\n<tr>\n<td>POP</td>\n<td>面向过程编程</td>\n<td>Procedure-Oriented Programming</td>\n</tr>\n<tr>\n<td>LP</td>\n<td>逻辑式编程</td>\n<td>Logic Programming</td>\n</tr>\n<tr>\n<td>DP</td>\n<td>声明式编程</td>\n<td>Declarative Programming</td>\n</tr>\n<tr>\n<td>IP</td>\n<td>命令式编程</td>\n<td>Imperative Programming</td>\n</tr>\n</tbody>\n</table>\n<p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>\n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p>\n<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>\n下面是一些编程范式的例子:</p>\n<p><strong>提示</strong><br>\n如果你已经了解过以下范式, 直接跳到 <a href=\"#zong-jie\"><strong>总结</strong></a> 吧</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程:<br>\n优点:<br>\n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>\n缺点:<br>\n代码复用能力差, 扩展性差, 繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>面向对象:<br>\n优点:<br>\n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>\n缺点:<br>\n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>逻辑式:<br>\n优点:<br>\n通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>\n缺点:<br>\n玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式:<br>\n优点:<br>\n通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>\n缺点:<br>\n学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令式:<br>\n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>\n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>\n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>\n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>声明式:<br>\n指你编程依靠描述, 而非面向过程地去思考<br>\n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>\nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>\n特点是一旦脱离相关领域, 语法就不再便利</p>\n</li>\n</ul>\n<h2 id=\"zong-jie\" id=\"总结\">总结</h2>\n<p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>\n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p>\n<p>比如:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程/面向对象 &amp;&amp; 命令式</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式/逻辑式 &amp;&amp; 声明式</p>\n</li>\n<li class=\"lvl-2\">\n<p>混合一种, 两种, 甚至各种范式</p>\n</li>\n</ul>\n<p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>\n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>\n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p>\n<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>\n接下来, 我们就要专注于本节的主角, 函数式</p>\n<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>\n让我们开始对函数式的正式介绍吧!</p>\n<hr>\n<h1 id=\"gao-jie-han-shu\">高阶函数</h1>\n<p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p>\n<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>\n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>\n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br>\n<s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p>\n<p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p>\n<hr>\n<h1 id=\"bu-ke-bian-shu-ju\">不可变数据</h1>\n<p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p>\n<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>\n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p>\n<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>\n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p>\n<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>\n但不可变的数据能够有效降低并发的难度</p>\n<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>\n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p>\n<hr>\n<h1 id=\"fu-zuo-yong\">副作用</h1>\n<p>副作用(Side Effects), 指与外界发生的交互</p>\n<p>假设有这么一个函数:<br>\n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>\n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p>\n<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>\n这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p>\n<p>副作用包括, 但不限于:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>发送网络请求</p>\n</li>\n<li class=\"lvl-2\">\n<p>访问系统状态</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作数据库</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作DOM</p>\n</li>\n<li class=\"lvl-2\">\n<p>IO操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>修改函数外部的变量</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用具有副作用的函数 (传播性)</p>\n</li>\n</ul>\n<p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>\n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>\n那么这将无法保证相同输入, 能得到相同输出</p>\n<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>\n绝对的没有副作用, 意味着这个程序绝对的没用</p>\n<hr>\n<h1 id=\"yin-yong-tou-ming\">引用透明</h1>\n<p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p>\n<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>\n以下是数学中的 RT, 简单来讲, 就是等式推导:</p>\n<p>f(x) = (x+1)<sup>2</sup><br>\nf(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p>\n<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>\n某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>\n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p>\n<p>总而言之, 就是替换, 替换, 还是替换<br>\n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p>\n<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>\n若有这么个函数:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">double_x</span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    println(x);</span><br><span class=\"line\">    return x+x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>\n此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>\n假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p>\n<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>\n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>\n你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>\n这通常是一些 BUG 的来源</p>\n<p>RT, 即引用透明, 注定与副作用互斥</p>\n<hr>\n<h1 id=\"chun-han-shu\">纯函数</h1>\n<p>纯函数(Pure Functions), 表示引用透明的函数</p>\n<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>\n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p>\n<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>\n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p>\n<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>\n有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>\n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p>\n<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p>\n<hr>\n<h1 id=\"qi-ta\">其他</h1>\n<p>以上是对函数式的小小概括<br>\n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p>\n<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>埃氏筛求素数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">primes</span> = filterPrime [<span class=\"number\">2.</span>.]</span><br><span class=\"line\">  <span class=\"keyword\">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>斐波那契数列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fibs</span> = <span class=\"number\">0</span> : <span class=\"number\">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>快速排列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> [] = []</span><br><span class=\"line\"><span class=\"title\">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class=\"line\">  <span class=\"keyword\">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>辗转相除法求最大公约数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">gcd&#x27;</span> x y</span><br><span class=\"line\">  | y == <span class=\"number\">0</span> = x</span><br><span class=\"line\">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure>\n<p>感谢你的观看, 咋们下期见!!<br>\n先让我鸽几天 😃</p>"},{"title":"haskell-basic-p5~> 类型与类型类","abbrlink":"posts/haskell-basic/p5","hidden":false,"date":"2022-07-18T08:24:44.000Z","top":6995,"keywords":["Haskell","函数式"],"is_series":true,"prev_post":["/posts/haskell-basic/p4","p4~> 基础语法"],"_content":"> 关于 Haskell 中的类型(Type), 与类型类(Typeclass)  \n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 开篇","source":"_posts/haskell/basic/p5-类型与类型类.md","raw":"---\ntitle: \"haskell-basic-p5~> 类型与类型类\"\nabbrlink: posts/haskell-basic/p5\nhidden: false\ndate: 2022-07-18 16:24:44\ntop: 6995\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\nis_series: true\nprev_post: [\"/posts/haskell-basic/p4\", \"p4~> 基础语法\"]\n---\n> 关于 Haskell 中的类型(Type), 与类型类(Typeclass)  \n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 开篇","slug":"haskell/basic/p5-类型与类型类","published":1,"updated":"2022-07-18T08:24:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogh000nj1s63479dgt0","content":"<blockquote>\n<p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n","site":{"data":{}},"length":57,"excerpt":"<blockquote>\n<p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"kai-pian\">开篇</h1>"},{"title":"haskell-basic-p4~> 基础语法","abbrlink":"posts/haskell-basic/p4","hidden":false,"date":"2022-07-12T13:46:05.000Z","top":6996,"keywords":["Haskell","函数式"],"is_series":true,"prev_post":["/posts/haskell-basic/p3","p3~> 函数式介绍"],"next_post":["/posts/haskell-basic/p5","p5~> 类型与类型类"],"_content":"> 关于 Haskell 的数字, Bool, List, If语句\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\nHaskell 是一门静态强类型语言, 我们接下来将学习一些基础类型  \n你可以在终端敲下 `ghci` 进入交互解释器, 去执行接下来的代码  \n\n# 数字  \n\n```haskell\n(2 + 8) * 9 - 10   -- 80\n5 / 2              -- 2.5\n5 ^ 2              -- 25\n5 ^  (2.0)         -- error\n5 ** (2.0)         -- 25.0 \n```\n\n加减乘除就不说了, 对于 `^` 与 `**` 都是幂函数, 底数的类型随意  \n但 `^` 接受的指数是个整数, `**` 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)  \n以上的运算符号, 实际上都是函数  \n\n比如, 你可以键入 `:t (+)`, 来得到 `+` 这个函数的类型:  \n\n```haskell\n(+) :: Num a => a -> a -> a\n```\n\n`=>` 后面的表示参数与返回值的类型  \n`=>` 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface  \n\n看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 `ghci` 中, 如何查看类型而已  \n以上的东西, 实际上类似于:  \n\n```\nfunction (+)<a: Num> (a, a, a) -> a { }\n```\n\nHaskell 中的小写字母相当于无约束的泛型, 啥都能匹配  \nNum 这个类型类了, 便起到一个约束的作用  \n\n同时, 由于加法函数的定义, `\"ABC\" + 123` 这样的表达式, 会直接报错  \n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a  \n\n- - -\n\n# Bool \n\n```haskell\nTrue && False      -- False\nTrue || False      -- True\nnot True           -- False\n```\n\n你还可以用 `==` 或 `/=` 来得到一个Bool值:  \n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)\n\n```haskell\n1 == 0             -- False\n2 + 3 == 1 + 4     -- True\n\"ABC\" /= \"AB\"      -- True\n```\n\n值得注意的是, 等号与不等号的左右, 两个值的类型必须相等  \n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型  \n可以键入 `:t (==)` 查看其类型:  \n\n```haskell\n(==) :: Eq a => a -> a -> Bool\n```\n\n表示接受的两个参数, 其类型相同, 都是a  \n并且a类型必须具有相等性, 返回值是Bool类型  \n\n注意:  \n由于其定义, `\"ABC\" == 123` 这样的表达式, 会直接报错  \n原因与先前的加法函数同理\n\n等到后面, 我们可以自己动手, 实现 `&&`, `||`, `not` 这三个函数  \n甚至连 If语句, 我们都可以自己写个函数来代替  \n\nIf语句在 Haskell 中仅仅是个语法糖而已  \n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 `if-else` 这样的语法糖  \n感兴趣的话, 可以自己去看下: [传送门](https://wiki.haskell.org/If-then-else)  \n\n- - -\n\n# List\nList(列表), 在 Haskell 中扮演着一个非常重要的角色  \n就像是其他语言的数组一样, 但却更加强大  \n\n## 省略右端\n像下面, 就创建了一个有十个元素的List:  \n\n```haskell\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n上面的List, 类型为 `Num a => [a]`  \na 实际上就是元素的类型, [a] 表示装着这种类型元素的List  \n\n虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: `take`  \n你可以查看它的类型:\n\n```haskell\ntake :: Int -> [a] -> [a]\n```\n\n这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List  \n比如:\n\n```haskell\ntake 5 [1,2,3,4,5,6,7,8,9,10]      -- [1,2,3,4,5]\n```\n\n这个函数你马上就会用到, 在处理无限元素的List时非常好用  \n\n回到刚才, 你可以一个个地输入元素, 创建List  \n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样  \n\n```haskell\n[1..10]\n[1..100]\n[1..1000]\n```\n\n诸如 `[m..n]` 这样的形式, 会创建一个闭区间, 从m遍历到n  \n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 `Enum` 这个类型类的成员  \n从 Rust, Scala, Java 等语言出发, 相当于实现了 `Enum` 这个 Trait/Interface  \n\n你甚至可以舍去右端, 写下 `[1..]` 这样的式子来表达1到无穷  \n你还可以生成 [Char], 比如 `['a'..'z']` 将会生成 `\"abcdefghijklmnopqrstuvwxyz\"`, 因为String类型等价于 [Char]  \n\n值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a  \n当a也是 `Bounded` 类型类的成员时, 说明这种类型一定有边界, 比如 `Int`, `Char` 等  \n不然的话, a将无界, 比如 `[1..]` 便是一个真正的, 从1到正无穷的List, 类型为 `Num a => [a]`  \n\n当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 `Num a => a` 呢?  \n\n事实上, 这是 Haskell 中为数不多的隐式行为  \n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型  \n\n举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:  \n\n```haskell\na = 100::Integer      -- 100\na + 1                 -- 101\na + 1::Int            -- error\n```\n\n我们先声明了a, 分别与整数字面量, Int类型数字相加  \n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的  \n根据 [(+)函数](#shu-zi) 的定义, 同时也因为Integer是Num这个Typeclass的成员  \n\n回到先前的 `[1..]`, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求  \n\n## 设置步长\n先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点  \n同时, 取决于元素的类型, 会产生无限或有界的List  \n\n但是, 比如 [1..5] 会生成 `[1,2,3,4,5]`, 默认情况下的步长是1  \n如果你想调整步长的话, 可以像下面这样:  \n\n```haskell\n[1,3..]          -- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]\n[5,10..]         -- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]\n```\n\n你还可以设置小数的步长, 比如:\n\n```haskell\n[1.0, 1.5..]     -- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]\n```\n\n哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 :)\n\n## 列表推导\nHaskell 中的 List, 还有一个强大的地方, 那就是 `List Comprehension (列表推导)`  \n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数  \n  \n```haskell\n[x | x <- [1..], mod x 2 == 0]  -- [2,4,6,8,10,12,14,16,18, 20..]\n```\n\n你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 ~~(因为就是这样抄来的啊)~~  \n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: `{x | n ∈ Z, x = 2n}` , 表示了偶数集  \n\nHaskell 中的 `List Comprehension` 也有这么个杠:  \n\n```haskell\n[ x | x <- xs, bool_expr1, bool_expr2 ]   \n```\n\n- 用 `|` 分割组成的表达式, 与后面的推导  \n- xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个  \n- `bool_expr` 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个  \n\n可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了  \n\n```haskell\n[x + y | x <- [1..3], y <- [1..3]]                   -- [2,3,4,3,4,5,4,5,6]\n[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]  -- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]\n```\n\n其实, 就相当于 `多重for循环` + `最后一重for循环中的零个或多个if语句`  \n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:  \n\n- 第一个式子 `[x + y | x <- [1..3], y <- [1..3]]`, 相当于:  \n\n```Rust\nlet new_array\nfor x in [1..3]\n  for y in [1..3]\n    (x + y) -> new_array\n```\n\n- 第二个式子 `[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]`, 相当于:\n\n```Rust\nlet new_array\nfor x in [1..100]\n  if x `mod` 2 == 0 && x `mod` 3 == 0\n    (x) -> new_array\n```\n\n因此, 你可以对比下下面两种式子:  \n\n```haskell\n[ x * y | x <- [1..10], y <- [1..x]  ]\n[ x * y | x <- [1..y],  y <- [1..10] ]\n```\n\n第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过  \n\n好了, 关于List, 暂时先到这吧  \n其实后面还有很多关于List的, 毕竟它太重要了  \n\n- - -\n\n# If语句\n先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的  \n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci  \n\n毕竟 Haskell 比较特殊, 为了函数的 [纯度](/posts/haskell-basic/p3/#chun-han-shu) , 特意搞了一堆东西  \n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)\n\n开始吧!\n\n## 单if\n首先, 让我们新建一个文件, 命名为 `demo.hs`  \n\nBMI, Body Mass Index (身体质量指数)  \n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康  \n\n让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧  \n\n**你可以这样运行以 .hs 结尾的文件:**  \n- 在 `demo.hs` 所在的目录下, 输入 `runghc demo.hs`, 不会留下目标文件  \n- 输入 `ghc demo.hs`, 留下目标文件 `./demo`  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if  bmi > 25\n    then putStrLn \"Fat!!!\"\n  else putStrLn \"Thin!!!\"\n```\n\n先别在意那个 `do` 与 `<-` 是啥, 无视即可, 反正这段代码你应该也看得懂:  \n程序会读取输入, 作为 `bmi` 的值, 随后根据大小, 判断是胖是瘦  \n\n当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi > 25\n    then putStrLn \"Fat!!!\"\n    else putStrLn \"Thin!!!\"\n```\n\n也蛮美观的, 但我更喜欢压行 :)\n\n\n\n## 多If\n其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂...\n\n先前的 单If 实在不够, 没有区分输入不对劲的情况  \n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi < 0\n    then putStrLn \"What?\"\n  else if bmi > 25 \n    then putStrLn \"Fat!!!\"\n  else if bmi <= 25 && bmi <= 18.5 \n    then putStrLn \"Healthy!!!\"\n  else \n    putStrLn \"Thin!!!\"\n```\n\n哇, 看着好美, 好熟悉!  \n所以你为什么说没有多重If呢?  \n\n别急, 格式化之后:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n  if bmi < 0\n    then putStrLn \"What?\"\n    else\n      if bmi > 25\n        then putStrLn \"Fat!!!\"\n        else\n          if bmi <= 25 && bmi < 18.5\n            then putStrLn \"12\"\n            else putStrLn \"Thin!!!\"\n```\n\n懂了吧? 它只是 else 中再套一个 if-else 而已  \n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)  \n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)  \n\n这节就到这, 看辉夜3的最后一集去了~~\n","source":"_posts/haskell/basic/p4-基础语法.md","raw":"---\ntitle: \"haskell-basic-p4~> 基础语法\"\nabbrlink: posts/haskell-basic/p4\nhidden: false\ndate: 2022-07-12 21:46:05\ntop: 6996\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\nis_series: true\nprev_post: [\"/posts/haskell-basic/p3\", \"p3~> 函数式介绍\"]\nnext_post: [\"/posts/haskell-basic/p5\", \"p5~> 类型与类型类\"]\n---\n> 关于 Haskell 的数字, Bool, List, If语句\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\nHaskell 是一门静态强类型语言, 我们接下来将学习一些基础类型  \n你可以在终端敲下 `ghci` 进入交互解释器, 去执行接下来的代码  \n\n# 数字  \n\n```haskell\n(2 + 8) * 9 - 10   -- 80\n5 / 2              -- 2.5\n5 ^ 2              -- 25\n5 ^  (2.0)         -- error\n5 ** (2.0)         -- 25.0 \n```\n\n加减乘除就不说了, 对于 `^` 与 `**` 都是幂函数, 底数的类型随意  \n但 `^` 接受的指数是个整数, `**` 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)  \n以上的运算符号, 实际上都是函数  \n\n比如, 你可以键入 `:t (+)`, 来得到 `+` 这个函数的类型:  \n\n```haskell\n(+) :: Num a => a -> a -> a\n```\n\n`=>` 后面的表示参数与返回值的类型  \n`=>` 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface  \n\n看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 `ghci` 中, 如何查看类型而已  \n以上的东西, 实际上类似于:  \n\n```\nfunction (+)<a: Num> (a, a, a) -> a { }\n```\n\nHaskell 中的小写字母相当于无约束的泛型, 啥都能匹配  \nNum 这个类型类了, 便起到一个约束的作用  \n\n同时, 由于加法函数的定义, `\"ABC\" + 123` 这样的表达式, 会直接报错  \n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a  \n\n- - -\n\n# Bool \n\n```haskell\nTrue && False      -- False\nTrue || False      -- True\nnot True           -- False\n```\n\n你还可以用 `==` 或 `/=` 来得到一个Bool值:  \n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)\n\n```haskell\n1 == 0             -- False\n2 + 3 == 1 + 4     -- True\n\"ABC\" /= \"AB\"      -- True\n```\n\n值得注意的是, 等号与不等号的左右, 两个值的类型必须相等  \n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型  \n可以键入 `:t (==)` 查看其类型:  \n\n```haskell\n(==) :: Eq a => a -> a -> Bool\n```\n\n表示接受的两个参数, 其类型相同, 都是a  \n并且a类型必须具有相等性, 返回值是Bool类型  \n\n注意:  \n由于其定义, `\"ABC\" == 123` 这样的表达式, 会直接报错  \n原因与先前的加法函数同理\n\n等到后面, 我们可以自己动手, 实现 `&&`, `||`, `not` 这三个函数  \n甚至连 If语句, 我们都可以自己写个函数来代替  \n\nIf语句在 Haskell 中仅仅是个语法糖而已  \n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 `if-else` 这样的语法糖  \n感兴趣的话, 可以自己去看下: [传送门](https://wiki.haskell.org/If-then-else)  \n\n- - -\n\n# List\nList(列表), 在 Haskell 中扮演着一个非常重要的角色  \n就像是其他语言的数组一样, 但却更加强大  \n\n## 省略右端\n像下面, 就创建了一个有十个元素的List:  \n\n```haskell\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n上面的List, 类型为 `Num a => [a]`  \na 实际上就是元素的类型, [a] 表示装着这种类型元素的List  \n\n虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: `take`  \n你可以查看它的类型:\n\n```haskell\ntake :: Int -> [a] -> [a]\n```\n\n这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List  \n比如:\n\n```haskell\ntake 5 [1,2,3,4,5,6,7,8,9,10]      -- [1,2,3,4,5]\n```\n\n这个函数你马上就会用到, 在处理无限元素的List时非常好用  \n\n回到刚才, 你可以一个个地输入元素, 创建List  \n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样  \n\n```haskell\n[1..10]\n[1..100]\n[1..1000]\n```\n\n诸如 `[m..n]` 这样的形式, 会创建一个闭区间, 从m遍历到n  \n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 `Enum` 这个类型类的成员  \n从 Rust, Scala, Java 等语言出发, 相当于实现了 `Enum` 这个 Trait/Interface  \n\n你甚至可以舍去右端, 写下 `[1..]` 这样的式子来表达1到无穷  \n你还可以生成 [Char], 比如 `['a'..'z']` 将会生成 `\"abcdefghijklmnopqrstuvwxyz\"`, 因为String类型等价于 [Char]  \n\n值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a  \n当a也是 `Bounded` 类型类的成员时, 说明这种类型一定有边界, 比如 `Int`, `Char` 等  \n不然的话, a将无界, 比如 `[1..]` 便是一个真正的, 从1到正无穷的List, 类型为 `Num a => [a]`  \n\n当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 `Num a => a` 呢?  \n\n事实上, 这是 Haskell 中为数不多的隐式行为  \n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型  \n\n举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:  \n\n```haskell\na = 100::Integer      -- 100\na + 1                 -- 101\na + 1::Int            -- error\n```\n\n我们先声明了a, 分别与整数字面量, Int类型数字相加  \n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的  \n根据 [(+)函数](#shu-zi) 的定义, 同时也因为Integer是Num这个Typeclass的成员  \n\n回到先前的 `[1..]`, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求  \n\n## 设置步长\n先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点  \n同时, 取决于元素的类型, 会产生无限或有界的List  \n\n但是, 比如 [1..5] 会生成 `[1,2,3,4,5]`, 默认情况下的步长是1  \n如果你想调整步长的话, 可以像下面这样:  \n\n```haskell\n[1,3..]          -- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]\n[5,10..]         -- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]\n```\n\n你还可以设置小数的步长, 比如:\n\n```haskell\n[1.0, 1.5..]     -- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]\n```\n\n哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 :)\n\n## 列表推导\nHaskell 中的 List, 还有一个强大的地方, 那就是 `List Comprehension (列表推导)`  \n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数  \n  \n```haskell\n[x | x <- [1..], mod x 2 == 0]  -- [2,4,6,8,10,12,14,16,18, 20..]\n```\n\n你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 ~~(因为就是这样抄来的啊)~~  \n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: `{x | n ∈ Z, x = 2n}` , 表示了偶数集  \n\nHaskell 中的 `List Comprehension` 也有这么个杠:  \n\n```haskell\n[ x | x <- xs, bool_expr1, bool_expr2 ]   \n```\n\n- 用 `|` 分割组成的表达式, 与后面的推导  \n- xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个  \n- `bool_expr` 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个  \n\n可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了  \n\n```haskell\n[x + y | x <- [1..3], y <- [1..3]]                   -- [2,3,4,3,4,5,4,5,6]\n[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]  -- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]\n```\n\n其实, 就相当于 `多重for循环` + `最后一重for循环中的零个或多个if语句`  \n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:  \n\n- 第一个式子 `[x + y | x <- [1..3], y <- [1..3]]`, 相当于:  \n\n```Rust\nlet new_array\nfor x in [1..3]\n  for y in [1..3]\n    (x + y) -> new_array\n```\n\n- 第二个式子 `[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]`, 相当于:\n\n```Rust\nlet new_array\nfor x in [1..100]\n  if x `mod` 2 == 0 && x `mod` 3 == 0\n    (x) -> new_array\n```\n\n因此, 你可以对比下下面两种式子:  \n\n```haskell\n[ x * y | x <- [1..10], y <- [1..x]  ]\n[ x * y | x <- [1..y],  y <- [1..10] ]\n```\n\n第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过  \n\n好了, 关于List, 暂时先到这吧  \n其实后面还有很多关于List的, 毕竟它太重要了  \n\n- - -\n\n# If语句\n先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的  \n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci  \n\n毕竟 Haskell 比较特殊, 为了函数的 [纯度](/posts/haskell-basic/p3/#chun-han-shu) , 特意搞了一堆东西  \n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)\n\n开始吧!\n\n## 单if\n首先, 让我们新建一个文件, 命名为 `demo.hs`  \n\nBMI, Body Mass Index (身体质量指数)  \n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康  \n\n让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧  \n\n**你可以这样运行以 .hs 结尾的文件:**  \n- 在 `demo.hs` 所在的目录下, 输入 `runghc demo.hs`, 不会留下目标文件  \n- 输入 `ghc demo.hs`, 留下目标文件 `./demo`  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if  bmi > 25\n    then putStrLn \"Fat!!!\"\n  else putStrLn \"Thin!!!\"\n```\n\n先别在意那个 `do` 与 `<-` 是啥, 无视即可, 反正这段代码你应该也看得懂:  \n程序会读取输入, 作为 `bmi` 的值, 随后根据大小, 判断是胖是瘦  \n\n当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi > 25\n    then putStrLn \"Fat!!!\"\n    else putStrLn \"Thin!!!\"\n```\n\n也蛮美观的, 但我更喜欢压行 :)\n\n\n\n## 多If\n其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂...\n\n先前的 单If 实在不够, 没有区分输入不对劲的情况  \n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi < 0\n    then putStrLn \"What?\"\n  else if bmi > 25 \n    then putStrLn \"Fat!!!\"\n  else if bmi <= 25 && bmi <= 18.5 \n    then putStrLn \"Healthy!!!\"\n  else \n    putStrLn \"Thin!!!\"\n```\n\n哇, 看着好美, 好熟悉!  \n所以你为什么说没有多重If呢?  \n\n别急, 格式化之后:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n  if bmi < 0\n    then putStrLn \"What?\"\n    else\n      if bmi > 25\n        then putStrLn \"Fat!!!\"\n        else\n          if bmi <= 25 && bmi < 18.5\n            then putStrLn \"12\"\n            else putStrLn \"Thin!!!\"\n```\n\n懂了吧? 它只是 else 中再套一个 if-else 而已  \n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)  \n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)  \n\n这节就到这, 看辉夜3的最后一集去了~~\n","slug":"haskell/basic/p4-基础语法","published":1,"updated":"2022-07-12T13:46:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogi000pj1s6esdt2oav","content":"<blockquote>\n<p>关于 Haskell 的数字, Bool, List, If语句</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>\n你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p>\n<h1 id=\"shu-zi\">数字</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">2</span> + <span class=\"number\">8</span>) * <span class=\"number\">9</span> - <span class=\"number\">10</span>   <span class=\"comment\">-- 80</span></span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span>              <span class=\"comment\">-- 2.5</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^ <span class=\"number\">2</span>              <span class=\"comment\">-- 25</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^  (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- error</span></span><br><span class=\"line\"><span class=\"number\">5</span> ** (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- 25.0 </span></span><br></pre></td></tr></table></figure>\n<p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>\n但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>\n以上的运算符号, 实际上都是函数</p>\n<p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(+) :: <span class=\"type\">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>\n<p><code>=&gt;</code> 后面的表示参数与返回值的类型<br>\n<code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p>\n<p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>\n以上的东西, 实际上类似于:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"params\">(+)</span>&lt;<span class=\"title\">a</span>: <span class=\"title\">Num</span>&gt; <span class=\"params\">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>\nNum 这个类型类了, 便起到一个约束的作用</p>\n<p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>\n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p>\n<hr>\n<h1 id=\"bool\">Bool</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">True</span> &amp;&amp; <span class=\"type\">False</span>      <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"type\">True</span> || <span class=\"type\">False</span>      <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"title\">not</span> <span class=\"type\">True</span>           <span class=\"comment\">-- False</span></span><br></pre></td></tr></table></figure>\n<p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>\n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> == <span class=\"number\">0</span>             <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"number\">2</span> + <span class=\"number\">3</span> == <span class=\"number\">1</span> + <span class=\"number\">4</span>     <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"string\">&quot;ABC&quot;</span> /= <span class=\"string\">&quot;AB&quot;</span>      <span class=\"comment\">-- True</span></span><br></pre></td></tr></table></figure>\n<p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>\n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>\n可以键入 <code>:t (==)</code> 查看其类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(==) :: <span class=\"type\">Eq</span> a =&gt; a -&gt; a -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>表示接受的两个参数, 其类型相同, 都是a<br>\n并且a类型必须具有相等性, 返回值是Bool类型</p>\n<p>注意:<br>\n由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>\n原因与先前的加法函数同理</p>\n<p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>\n甚至连 If语句, 我们都可以自己写个函数来代替</p>\n<p>If语句在 Haskell 中仅仅是个语法糖而已<br>\n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>\n感兴趣的话, 可以自己去看下: <a href=\"https://wiki.haskell.org/If-then-else\">传送门</a></p>\n<hr>\n<h1 id=\"list\">List</h1>\n<p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>\n就像是其他语言的数组一样, 但却更加强大</p>\n<h2 id=\"sheng-lue-you-duan\" id=\"省略右端\">省略右端</h2>\n<p>像下面, 就创建了一个有十个元素的List:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>\na 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p>\n<p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>\n你可以查看它的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> :: <span class=\"type\">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>\n<p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>\n比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> <span class=\"number\">5</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]      <span class=\"comment\">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p>\n<p>回到刚才, 你可以一个个地输入元素, 创建List<br>\n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.10</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.100</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.1000</span>]</span><br></pre></td></tr></table></figure>\n<p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>\n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>\n从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p>\n<p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>\n你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p>\n<p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>\n当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>\n不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p>\n<p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p>\n<p>事实上, 这是 Haskell 中为数不多的隐式行为<br>\n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p>\n<p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">a</span> = <span class=\"number\">100</span>::<span class=\"type\">Integer</span>      <span class=\"comment\">-- 100</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>                 <span class=\"comment\">-- 101</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>::<span class=\"type\">Int</span>            <span class=\"comment\">-- error</span></span><br></pre></td></tr></table></figure>\n<p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>\n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>\n根据 <a href=\"#shu-zi\">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p>\n<p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p>\n<h2 id=\"she-zhi-bu-chang\" id=\"设置步长\">设置步长</h2>\n<p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>\n同时, 取决于元素的类型, 会产生无限或有界的List</p>\n<p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>\n如果你想调整步长的话, 可以像下面这样:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3.</span>.]          <span class=\"comment\">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">10.</span>.]         <span class=\"comment\">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure>\n<p>你还可以设置小数的步长, 比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.0</span>, <span class=\"number\">1.5</span>..]     <span class=\"comment\">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure>\n<p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p>\n<h2 id=\"lie-biao-tui-dao\" id=\"列表推导\">列表推导</h2>\n<p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>\n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span>.], mod x <span class=\"number\">2</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure>\n<p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>\n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p>\n<p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p>\n</li>\n<li class=\"lvl-2\">\n<p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p>\n</li>\n</ul>\n<p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x + y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>], y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>]]                   <span class=\"comment\">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.100</span>], x `mod` <span class=\"number\">2</span> == <span class=\"number\">0</span>, x `mod` <span class=\"number\">3</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure>\n<p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>\n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">100</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x `<span class=\"keyword\">mod</span>` <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; x `<span class=\"keyword\">mod</span>` <span class=\"number\">3</span> == <span class=\"number\">0</span></span><br><span class=\"line\">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<p>因此, 你可以对比下下面两种式子:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>], y &lt;- [<span class=\"number\">1.</span>.x]  ]</span><br><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span>.y],  y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>] ]</span><br></pre></td></tr></table></figure>\n<p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p>\n<p>好了, 关于List, 暂时先到这吧<br>\n其实后面还有很多关于List的, 毕竟它太重要了</p>\n<hr>\n<h1 id=\"if-yu-ju\">If语句</h1>\n<p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>\n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p>\n<p>毕竟 Haskell 比较特殊, 为了函数的 <a href=\"/posts/haskell-basic/p3/#chun-han-shu\">纯度</a> , 特意搞了一堆东西<br>\n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p>\n<p>开始吧!</p>\n<h2 id=\"dan-if\" id=\"单if\">单if</h2>\n<p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p>\n<p>BMI, Body Mass Index (身体质量指数)<br>\n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p>\n<p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p>\n<p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</p>\n</li>\n<li class=\"lvl-2\">\n<p>输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>  bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>\n程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p>\n<p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>也蛮美观的, 但我更喜欢压行 😃</p>\n<h2 id=\"duo-if\" id=\"多If\">多If</h2>\n<p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p>\n<p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>\n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt;= <span class=\"number\">18.5</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Healthy!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">    putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>哇, 看着好美, 好熟悉!<br>\n所以你为什么说没有多重If呢?</p>\n<p>别急, 格式化之后:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">        <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt; <span class=\"number\">18.5</span></span><br><span class=\"line\">            <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;12&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>\n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>\n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p>\n<p>这节就到这, 看辉夜3的最后一集去了~~</p>\n","site":{"data":{}},"length":5117,"excerpt":"<blockquote>\n<p>关于 Haskell 的数字, Bool, List, If语句</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>\n你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p>\n<h1 id=\"shu-zi\">数字</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">2</span> + <span class=\"number\">8</span>) * <span class=\"number\">9</span> - <span class=\"number\">10</span>   <span class=\"comment\">-- 80</span></span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span>              <span class=\"comment\">-- 2.5</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^ <span class=\"number\">2</span>              <span class=\"comment\">-- 25</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^  (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- error</span></span><br><span class=\"line\"><span class=\"number\">5</span> ** (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- 25.0 </span></span><br></pre></td></tr></table></figure>\n<p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>\n但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>\n以上的运算符号, 实际上都是函数</p>\n<p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(+) :: <span class=\"type\">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>\n<p><code>=&gt;</code> 后面的表示参数与返回值的类型<br>\n<code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p>\n<p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>\n以上的东西, 实际上类似于:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"params\">(+)</span>&lt;<span class=\"title\">a</span>: <span class=\"title\">Num</span>&gt; <span class=\"params\">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>\nNum 这个类型类了, 便起到一个约束的作用</p>\n<p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>\n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p>\n<hr>\n<h1 id=\"bool\">Bool</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">True</span> &amp;&amp; <span class=\"type\">False</span>      <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"type\">True</span> || <span class=\"type\">False</span>      <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"title\">not</span> <span class=\"type\">True</span>           <span class=\"comment\">-- False</span></span><br></pre></td></tr></table></figure>\n<p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>\n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> == <span class=\"number\">0</span>             <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"number\">2</span> + <span class=\"number\">3</span> == <span class=\"number\">1</span> + <span class=\"number\">4</span>     <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"string\">&quot;ABC&quot;</span> /= <span class=\"string\">&quot;AB&quot;</span>      <span class=\"comment\">-- True</span></span><br></pre></td></tr></table></figure>\n<p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>\n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>\n可以键入 <code>:t (==)</code> 查看其类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(==) :: <span class=\"type\">Eq</span> a =&gt; a -&gt; a -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>表示接受的两个参数, 其类型相同, 都是a<br>\n并且a类型必须具有相等性, 返回值是Bool类型</p>\n<p>注意:<br>\n由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>\n原因与先前的加法函数同理</p>\n<p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>\n甚至连 If语句, 我们都可以自己写个函数来代替</p>\n<p>If语句在 Haskell 中仅仅是个语法糖而已<br>\n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>\n感兴趣的话, 可以自己去看下: <a href=\"https://wiki.haskell.org/If-then-else\">传送门</a></p>\n<hr>\n<h1 id=\"list\">List</h1>\n<p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>\n就像是其他语言的数组一样, 但却更加强大</p>\n<h2 id=\"sheng-lue-you-duan\" id=\"省略右端\">省略右端</h2>\n<p>像下面, 就创建了一个有十个元素的List:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>\na 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p>\n<p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>\n你可以查看它的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> :: <span class=\"type\">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>\n<p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>\n比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> <span class=\"number\">5</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]      <span class=\"comment\">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p>\n<p>回到刚才, 你可以一个个地输入元素, 创建List<br>\n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.10</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.100</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.1000</span>]</span><br></pre></td></tr></table></figure>\n<p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>\n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>\n从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p>\n<p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>\n你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p>\n<p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>\n当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>\n不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p>\n<p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p>\n<p>事实上, 这是 Haskell 中为数不多的隐式行为<br>\n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p>\n<p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">a</span> = <span class=\"number\">100</span>::<span class=\"type\">Integer</span>      <span class=\"comment\">-- 100</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>                 <span class=\"comment\">-- 101</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>::<span class=\"type\">Int</span>            <span class=\"comment\">-- error</span></span><br></pre></td></tr></table></figure>\n<p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>\n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>\n根据 <a href=\"#shu-zi\">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p>\n<p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p>\n<h2 id=\"she-zhi-bu-chang\" id=\"设置步长\">设置步长</h2>\n<p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>\n同时, 取决于元素的类型, 会产生无限或有界的List</p>\n<p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>\n如果你想调整步长的话, 可以像下面这样:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3.</span>.]          <span class=\"comment\">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">10.</span>.]         <span class=\"comment\">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure>\n<p>你还可以设置小数的步长, 比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.0</span>, <span class=\"number\">1.5</span>..]     <span class=\"comment\">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure>\n<p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p>\n<h2 id=\"lie-biao-tui-dao\" id=\"列表推导\">列表推导</h2>\n<p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>\n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span>.], mod x <span class=\"number\">2</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure>\n<p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>\n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p>\n<p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p>\n</li>\n<li class=\"lvl-2\">\n<p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p>\n</li>\n</ul>\n<p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x + y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>], y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>]]                   <span class=\"comment\">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.100</span>], x `mod` <span class=\"number\">2</span> == <span class=\"number\">0</span>, x `mod` <span class=\"number\">3</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure>\n<p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>\n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">100</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x `<span class=\"keyword\">mod</span>` <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; x `<span class=\"keyword\">mod</span>` <span class=\"number\">3</span> == <span class=\"number\">0</span></span><br><span class=\"line\">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<p>因此, 你可以对比下下面两种式子:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>], y &lt;- [<span class=\"number\">1.</span>.x]  ]</span><br><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span>.y],  y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>] ]</span><br></pre></td></tr></table></figure>\n<p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p>\n<p>好了, 关于List, 暂时先到这吧<br>\n其实后面还有很多关于List的, 毕竟它太重要了</p>\n<hr>\n<h1 id=\"if-yu-ju\">If语句</h1>\n<p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>\n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p>\n<p>毕竟 Haskell 比较特殊, 为了函数的 <a href=\"/posts/haskell-basic/p3/#chun-han-shu\">纯度</a> , 特意搞了一堆东西<br>\n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p>\n<p>开始吧!</p>\n<h2 id=\"dan-if\" id=\"单if\">单if</h2>\n<p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p>\n<p>BMI, Body Mass Index (身体质量指数)<br>\n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p>\n<p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p>\n<p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</p>\n</li>\n<li class=\"lvl-2\">\n<p>输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>  bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>\n程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p>\n<p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>也蛮美观的, 但我更喜欢压行 😃</p>\n<h2 id=\"duo-if\" id=\"多If\">多If</h2>\n<p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p>\n<p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>\n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt;= <span class=\"number\">18.5</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Healthy!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">    putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>哇, 看着好美, 好熟悉!<br>\n所以你为什么说没有多重If呢?</p>\n<p>别急, 格式化之后:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">        <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt; <span class=\"number\">18.5</span></span><br><span class=\"line\">            <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;12&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>\n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>\n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p>\n<p>这节就到这, 看辉夜3的最后一集去了~~</p>"},{"title":"haskell-basic-p1~> 系列说明","abbrlink":"posts/haskell-basic/p1","hidden":false,"date":"2022-06-25T13:22:14.000Z","top":6999,"keywords":["Haskell","函数式"],"is_series":true,"next_post":["/posts/haskell-basic/p2","p2~> 环境搭建"],"_content":"> 欢迎大家来到 Haskell 的学习系列\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 系列说明\n本系列会介绍下Haskell, 同时学习它的语法与思想  \n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 :)  \n~~(毕竟是Haskell)~~\n\n- - -\n\n# 参考资料\n1. 书籍\n- [Learn You a Haskell for Great Good! (趣学指南)](http://learnyouahaskell.com/chapters)\n- [A Gentle Introduction to Haskell, Version 98](https://www.haskell.org/tutorial/)\n\n2. 论坛\n- [Haskell Discourse](https://discourse.haskell.org/)\n\n3. 博客\n- [Lambda Calculus (Lambda演算)](http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97)  \n- [Functors In Pictures (图解函子)](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n\n4. Wiki\n- [Haskell Wiki](https://wiki.haskell.org/)\n\n- - -\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","source":"_posts/haskell/basic/p1-系列说明.md","raw":"---\ntitle: \"haskell-basic-p1~> 系列说明\"\nabbrlink: posts/haskell-basic/p1\nhidden: false\ndate: 2022-06-25 21:22:14\ntop: 6999\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\nis_series: true\nnext_post: [\"/posts/haskell-basic/p2\", \"p2~> 环境搭建\"]\n---\n> 欢迎大家来到 Haskell 的学习系列\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 系列说明\n本系列会介绍下Haskell, 同时学习它的语法与思想  \n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 :)  \n~~(毕竟是Haskell)~~\n\n- - -\n\n# 参考资料\n1. 书籍\n- [Learn You a Haskell for Great Good! (趣学指南)](http://learnyouahaskell.com/chapters)\n- [A Gentle Introduction to Haskell, Version 98](https://www.haskell.org/tutorial/)\n\n2. 论坛\n- [Haskell Discourse](https://discourse.haskell.org/)\n\n3. 博客\n- [Lambda Calculus (Lambda演算)](http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97)  \n- [Functors In Pictures (图解函子)](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n\n4. Wiki\n- [Haskell Wiki](https://wiki.haskell.org/)\n\n- - -\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","slug":"haskell/basic/p1-系列说明","published":1,"updated":"2022-06-25T13:22:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogi000rj1s62qxb2i6k","content":"<blockquote>\n<p>欢迎大家来到 Haskell 的学习系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>\n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br>\n<s>(毕竟是Haskell)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://learnyouahaskell.com/chapters\">Learn You a Haskell for Great Good! (趣学指南)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.haskell.org/tutorial/\">A Gentle Introduction to Haskell, Version 98</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>论坛</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://discourse.haskell.org/\">Haskell Discourse</a></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\">Lambda Calculus (Lambda演算)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors In Pictures (图解函子)</a></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>Wiki</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://wiki.haskell.org/\">Haskell Wiki</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>\n","site":{"data":{}},"length":330,"excerpt":"<blockquote>\n<p>欢迎大家来到 Haskell 的学习系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>\n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br>\n<s>(毕竟是Haskell)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://learnyouahaskell.com/chapters\">Learn You a Haskell for Great Good! (趣学指南)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.haskell.org/tutorial/\">A Gentle Introduction to Haskell, Version 98</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>论坛</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://discourse.haskell.org/\">Haskell Discourse</a></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\">Lambda Calculus (Lambda演算)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors In Pictures (图解函子)</a></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>Wiki</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://wiki.haskell.org/\">Haskell Wiki</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>"},{"title":"p2-环境搭建","abbrlink":"posts/scala3-basic/p2","hidden":false,"date":"2022-12-17T09:29:14.000Z","top":39998,"keywords":["Scala3","函数式"],"is_series":true,"post_post":["/posts/scala3-basic/p1","p1~> 系列说明"],"next_post":["/posts/scala3-basic/p2","p2~> 环境搭建"],"_content":"> 本节将介绍如何搭建 scala3 的环境\n<!-- more -->\n\n同系列传送门: [scala3-basic](/categories/scala3-basic)\n","source":"_posts/scala3/basic/p2-环境搭建.md","raw":"---\ntitle: p2-环境搭建\nabbrlink: posts/scala3-basic/p2\nhidden: false\ndate: 2022-12-17 17:29:14\ntop: 39998\ntags: [Scala3]\nkeywords: [Scala3, 函数式]\nis_series: true\npost_post: [\"/posts/scala3-basic/p1\", \"p1~> 系列说明\"]\nnext_post: [\"/posts/scala3-basic/p2\", \"p2~> 环境搭建\"]\n---\n> 本节将介绍如何搭建 scala3 的环境\n<!-- more -->\n\n同系列传送门: [scala3-basic](/categories/scala3-basic)\n","slug":"scala3/basic/p2-环境搭建","published":1,"updated":"2022-12-17T09:29:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogk000tj1s6g4dk81ce","content":"<blockquote>\n<p>本节将介绍如何搭建 scala3 的环境</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/scala3-basic\">scala3-basic</a></p>\n","site":{"data":{}},"length":37,"excerpt":"<blockquote>\n<p>本节将介绍如何搭建 scala3 的环境</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/scala3-basic\">scala3-basic</a></p>"},{"title":"scala3-basic-p1~> 系列说明","abbrlink":"posts/scala3-basic/p1","hidden":false,"date":"2022-12-17T07:13:04.000Z","top":39999,"keywords":["Scala3","函数式"],"is_series":true,"next_post":["/posts/scala3-basic/p2","p2~> 环境搭建"],"_content":"> 欢迎大家来到 scala3 的学习系列\n<!-- more -->\n\n同系列传送门: [scala3-basic](/categories/scala3-basic)\n","source":"_posts/scala3/basic/p1-系列说明.md","raw":"---\ntitle: \"scala3-basic-p1~> 系列说明\"\nabbrlink: posts/scala3-basic/p1\nhidden: false\ndate: 2022-12-17 15:13:04\ntop: 39999\ntags: [Scala3]\nkeywords: [Scala3, 函数式]\nis_series: true\nnext_post: [\"/posts/scala3-basic/p2\", \"p2~> 环境搭建\"]\n---\n> 欢迎大家来到 scala3 的学习系列\n<!-- more -->\n\n同系列传送门: [scala3-basic](/categories/scala3-basic)\n","slug":"scala3/basic/p1-系列说明","published":1,"updated":"2022-12-17T07:13:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogk000uj1s667yi1deq","content":"<blockquote>\n<p>欢迎大家来到 scala3 的学习系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/scala3-basic\">scala3-basic</a></p>\n","site":{"data":{}},"length":36,"excerpt":"<blockquote>\n<p>欢迎大家来到 scala3 的学习系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/scala3-basic\">scala3-basic</a></p>"},{"abbrlink":"categories/scala3-basic","hidden":true,"layout":"page","quicklink":true,"date":"2022-12-17T09:25:21.000Z","title":"scala3-basic","top":null,"keywords":null,"_content":"\n[ ]  [p1~> 系列说明](/posts/scala3-basic/p1)\n[ ]  [p2~> 环境搭建](/posts/scala3-basic/p2)\n","source":"_posts/categories/scala3/basic.md","raw":"---\nabbrlink: categories/scala3-basic\nhidden: true\nlayout: page\nquicklink: true\ndate: 2022-12-17 17:25:21\ntitle: scala3-basic\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[ ]  [p1~> 系列说明](/posts/scala3-basic/p1)\n[ ]  [p2~> 环境搭建](/posts/scala3-basic/p2)\n","slug":"categories/scala3/basic","published":1,"updated":"2022-12-17T09:25:21.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogl000wj1s6c0oq4tyg","content":"<p><input type=\"checkbox\" id=\"checkbox3\"><label for=\"checkbox3\"> </label><a href=\"/posts/scala3-basic/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox2\"><label for=\"checkbox2\"> </label><a href=\"/posts/scala3-basic/p2\">p2~&gt; 环境搭建</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":22,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox3\"><label for=\"checkbox3\"> </label><a href=\"/posts/scala3-basic/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox2\"><label for=\"checkbox2\"> </label><a href=\"/posts/scala3-basic/p2\">p2~&gt; 环境搭建</a></p>\n"},{"abbrlink":"categories/haskell-basic","hidden":true,"date":"2022-06-25T13:12:38.000Z","title":"haskell-basic","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1~> 系列说明](/posts/haskell-basic/p1)\n[x]  [p2~> 环境搭建](/posts/haskell-basic/p2)\n[x]  [p3~> 函数式介绍](/posts/haskell-basic/p3)\n[x]  [p4~> 基础语法](/posts/haskell-basic/p4)\n[ ]  [p5~> 类型与类型类](/posts/haskell-basic/p5)","source":"_posts/categories/haskell/basic.md","raw":"---\nabbrlink: categories/haskell-basic\nhidden: true\ndate: 2022-06-25 21:12:38\ntitle: haskell-basic\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1~> 系列说明](/posts/haskell-basic/p1)\n[x]  [p2~> 环境搭建](/posts/haskell-basic/p2)\n[x]  [p3~> 函数式介绍](/posts/haskell-basic/p3)\n[x]  [p4~> 基础语法](/posts/haskell-basic/p4)\n[ ]  [p5~> 类型与类型类](/posts/haskell-basic/p5)","slug":"categories/haskell/basic","published":1,"updated":"2022-06-25T13:12:38.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogm000xj1s6440o2x8s","content":"<p><input type=\"checkbox\" id=\"checkbox8\" checked=\"true\"><label for=\"checkbox8\"> </label><a href=\"/posts/haskell-basic/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox7\" checked=\"true\"><label for=\"checkbox7\"> </label><a href=\"/posts/haskell-basic/p2\">p2~&gt; 环境搭建</a><br>\n<input type=\"checkbox\" id=\"checkbox6\" checked=\"true\"><label for=\"checkbox6\"> </label><a href=\"/posts/haskell-basic/p3\">p3~&gt; 函数式介绍</a><br>\n<input type=\"checkbox\" id=\"checkbox5\" checked=\"true\"><label for=\"checkbox5\"> </label><a href=\"/posts/haskell-basic/p4\">p4~&gt; 基础语法</a><br>\n<input type=\"checkbox\" id=\"checkbox4\"><label for=\"checkbox4\"> </label><a href=\"/posts/haskell-basic/p5\">p5~&gt; 类型与类型类</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":58,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox8\" checked=\"true\"><label for=\"checkbox8\"> </label><a href=\"/posts/haskell-basic/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox7\" checked=\"true\"><label for=\"checkbox7\"> </label><a href=\"/posts/haskell-basic/p2\">p2~&gt; 环境搭建</a><br>\n<input type=\"checkbox\" id=\"checkbox6\" checked=\"true\"><label for=\"checkbox6\"> </label><a href=\"/posts/haskell-basic/p3\">p3~&gt; 函数式介绍</a><br>\n<input type=\"checkbox\" id=\"checkbox5\" checked=\"true\"><label for=\"checkbox5\"> </label><a href=\"/posts/haskell-basic/p4\">p4~&gt; 基础语法</a><br>\n<input type=\"checkbox\" id=\"checkbox4\"><label for=\"checkbox4\"> </label><a href=\"/posts/haskell-basic/p5\">p5~&gt; 类型与类型类</a></p>\n"},{"abbrlink":"categories/high-school-it","hidden":true,"layout":"page","quicklink":true,"date":"2022-09-14T10:45:37.000Z","title":"","top":null,"keywords":null,"_content":"高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题  \n\n# 高一\n[x]  [p1~> 数据与信息](/posts/high-school-it/p1)\n[x]  [p2~> 基础科普](/posts/high-school-it/p2)\n[x]  [p3~> python基础语法-part1](/posts/high-school-it/p3)\n[ ]  [p4~> python基础语法-part2](/posts/high-school-it/p4)\n[ ]  [p5~> 进制的转换与应用](/posts/high-school-it/p5)\n","source":"_posts/categories/high-chool-it/index.md","raw":"---\nabbrlink: categories/high-school-it\nhidden: true\nlayout: page\nquicklink: true\ndate: 2022-09-14 18:45:37\ntitle:\ntop:\ntags:\ncategories:\nkeywords:\n---\n高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题  \n\n# 高一\n[x]  [p1~> 数据与信息](/posts/high-school-it/p1)\n[x]  [p2~> 基础科普](/posts/high-school-it/p2)\n[x]  [p3~> python基础语法-part1](/posts/high-school-it/p3)\n[ ]  [p4~> python基础语法-part2](/posts/high-school-it/p4)\n[ ]  [p5~> 进制的转换与应用](/posts/high-school-it/p5)\n","slug":"categories/high-chool-it/index","published":1,"updated":"2022-09-14T10:45:37.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogn0010j1s67zm3gdr3","content":"<p>高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题</p>\n<h1 id=\"gao-yi\">高一</h1>\n<p><input type=\"checkbox\" id=\"checkbox13\" checked=\"true\"><label for=\"checkbox13\"> </label><a href=\"/posts/high-school-it/p1\">p1~&gt; 数据与信息</a><br>\n<input type=\"checkbox\" id=\"checkbox12\" checked=\"true\"><label for=\"checkbox12\"> </label><a href=\"/posts/high-school-it/p2\">p2~&gt; 基础科普</a><br>\n<input type=\"checkbox\" id=\"checkbox11\" checked=\"true\"><label for=\"checkbox11\"> </label><a href=\"/posts/high-school-it/p3\">p3~&gt; python基础语法-part1</a><br>\n<input type=\"checkbox\" id=\"checkbox10\"><label for=\"checkbox10\"> </label><a href=\"/posts/high-school-it/p4\">p4~&gt; python基础语法-part2</a><br>\n<input type=\"checkbox\" id=\"checkbox9\"><label for=\"checkbox9\"> </label><a href=\"/posts/high-school-it/p5\">p5~&gt; 进制的转换与应用</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":117,"excerpt":"","more":"<p>高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题</p>\n<h1 id=\"gao-yi\">高一</h1>\n<p><input type=\"checkbox\" id=\"checkbox13\" checked=\"true\"><label for=\"checkbox13\"> </label><a href=\"/posts/high-school-it/p1\">p1~&gt; 数据与信息</a><br>\n<input type=\"checkbox\" id=\"checkbox12\" checked=\"true\"><label for=\"checkbox12\"> </label><a href=\"/posts/high-school-it/p2\">p2~&gt; 基础科普</a><br>\n<input type=\"checkbox\" id=\"checkbox11\" checked=\"true\"><label for=\"checkbox11\"> </label><a href=\"/posts/high-school-it/p3\">p3~&gt; python基础语法-part1</a><br>\n<input type=\"checkbox\" id=\"checkbox10\"><label for=\"checkbox10\"> </label><a href=\"/posts/high-school-it/p4\">p4~&gt; python基础语法-part2</a><br>\n<input type=\"checkbox\" id=\"checkbox9\"><label for=\"checkbox9\"> </label><a href=\"/posts/high-school-it/p5\">p5~&gt; 进制的转换与应用</a></p>\n"},{"title":"rust-async","abbrlink":"categories/rust-async","hidden":true,"date":"2021-12-04T13:23:28.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1~> 系列说明](/posts/rust-async/p1)\n[x]  [p2~> 异步简介](/posts/rust-async/p2)\n[x]  [p3~> Future](/posts/rust-async/p3)\n[x]  [p4~> 状态的保存与变换](/posts/rust-async/p4)\n","source":"_posts/categories/rust/async.md","raw":"---\ntitle: rust-async\nabbrlink: categories/rust-async\nhidden: true\ndate: 2021-12-04 21:23:28\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1~> 系列说明](/posts/rust-async/p1)\n[x]  [p2~> 异步简介](/posts/rust-async/p2)\n[x]  [p3~> Future](/posts/rust-async/p3)\n[x]  [p4~> 状态的保存与变换](/posts/rust-async/p4)\n","slug":"categories/rust/async","published":1,"updated":"2021-12-04T13:23:28.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogo0012j1s62nec365f","content":"<p><input type=\"checkbox\" id=\"checkbox17\" checked=\"true\"><label for=\"checkbox17\"> </label><a href=\"/posts/rust-async/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox16\" checked=\"true\"><label for=\"checkbox16\"> </label><a href=\"/posts/rust-async/p2\">p2~&gt; 异步简介</a><br>\n<input type=\"checkbox\" id=\"checkbox15\" checked=\"true\"><label for=\"checkbox15\"> </label><a href=\"/posts/rust-async/p3\">p3~&gt; Future</a><br>\n<input type=\"checkbox\" id=\"checkbox14\" checked=\"true\"><label for=\"checkbox14\"> </label><a href=\"/posts/rust-async/p4\">p4~&gt; 状态的保存与变换</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":50,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox17\" checked=\"true\"><label for=\"checkbox17\"> </label><a href=\"/posts/rust-async/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox16\" checked=\"true\"><label for=\"checkbox16\"> </label><a href=\"/posts/rust-async/p2\">p2~&gt; 异步简介</a><br>\n<input type=\"checkbox\" id=\"checkbox15\" checked=\"true\"><label for=\"checkbox15\"> </label><a href=\"/posts/rust-async/p3\">p3~&gt; Future</a><br>\n<input type=\"checkbox\" id=\"checkbox14\" checked=\"true\"><label for=\"checkbox14\"> </label><a href=\"/posts/rust-async/p4\">p4~&gt; 状态的保存与变换</a></p>\n"},{"title":"rust-decl-macro","abbrlink":"categories/rust-decl-macro","hidden":true,"date":"2021-12-04T14:30:59.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n呜呜呜呜呜呜呜呜呜呜呜呜...\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业...  \n\n您可以去看我在B站的相关视频: [传送门](https://www.bilibili.com/video/BV1Wv411W7FH/)  \n我迟早有一天会更完的 :)\n\n[x]  [p1~> 系列说明](/posts/rust-decl-macro/p1)\n[x]  [p2~> 从println!开始](/posts/rust-decl-macro/p2)\n[x]  [p3~> 声明与使用](/posts/rust-decl-macro/p3)\n[x]  [p4~> 重复](/posts/rust-decl-macro/p4)\n[ ]  [p5~> 卫生性](/posts/rust-decl-macro/p5)\n[ ]  [p6~> 实战: 递推序列生成器](/posts/rust-decl-macro/p6)\n[ ]  [p7~> 作用域的导入与导出](/posts/rust-decl-macro/p7)\n[ ]  [p8~> 模式: TT-Muncher](/posts/rust-decl-macro/p8)\n[ ]  [p9~> 模式: 内用规则与尾部分隔符](/posts/rust-decl-macro/p9)\n","source":"_posts/categories/rust/decl-macro.md","raw":"---\ntitle: rust-decl-macro\nabbrlink: categories/rust-decl-macro\nhidden: true\ndate: 2021-12-04 22:30:59\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n呜呜呜呜呜呜呜呜呜呜呜呜...\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业...  \n\n您可以去看我在B站的相关视频: [传送门](https://www.bilibili.com/video/BV1Wv411W7FH/)  \n我迟早有一天会更完的 :)\n\n[x]  [p1~> 系列说明](/posts/rust-decl-macro/p1)\n[x]  [p2~> 从println!开始](/posts/rust-decl-macro/p2)\n[x]  [p3~> 声明与使用](/posts/rust-decl-macro/p3)\n[x]  [p4~> 重复](/posts/rust-decl-macro/p4)\n[ ]  [p5~> 卫生性](/posts/rust-decl-macro/p5)\n[ ]  [p6~> 实战: 递推序列生成器](/posts/rust-decl-macro/p6)\n[ ]  [p7~> 作用域的导入与导出](/posts/rust-decl-macro/p7)\n[ ]  [p8~> 模式: TT-Muncher](/posts/rust-decl-macro/p8)\n[ ]  [p9~> 模式: 内用规则与尾部分隔符](/posts/rust-decl-macro/p9)\n","slug":"categories/rust/decl-macro","published":1,"updated":"2021-12-04T14:30:59.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogp0015j1s6e5fc9lpm","content":"<p>呜呜呜呜呜呜呜呜呜呜呜呜…<br>\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业…</p>\n<p>您可以去看我在B站的相关视频: <a href=\"https://www.bilibili.com/video/BV1Wv411W7FH/\">传送门</a><br>\n我迟早有一天会更完的 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox26\" checked=\"true\"><label for=\"checkbox26\"> </label><a href=\"/posts/rust-decl-macro/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox25\" checked=\"true\"><label for=\"checkbox25\"> </label><a href=\"/posts/rust-decl-macro/p2\">p2~&gt; 从println!开始</a><br>\n<input type=\"checkbox\" id=\"checkbox24\" checked=\"true\"><label for=\"checkbox24\"> </label><a href=\"/posts/rust-decl-macro/p3\">p3~&gt; 声明与使用</a><br>\n<input type=\"checkbox\" id=\"checkbox23\" checked=\"true\"><label for=\"checkbox23\"> </label><a href=\"/posts/rust-decl-macro/p4\">p4~&gt; 重复</a><br>\n<input type=\"checkbox\" id=\"checkbox22\"><label for=\"checkbox22\"> </label><a href=\"/posts/rust-decl-macro/p5\">p5~&gt; 卫生性</a><br>\n<input type=\"checkbox\" id=\"checkbox21\"><label for=\"checkbox21\"> </label><a href=\"/posts/rust-decl-macro/p6\">p6~&gt; 实战: 递推序列生成器</a><br>\n<input type=\"checkbox\" id=\"checkbox20\"><label for=\"checkbox20\"> </label><a href=\"/posts/rust-decl-macro/p7\">p7~&gt; 作用域的导入与导出</a><br>\n<input type=\"checkbox\" id=\"checkbox19\"><label for=\"checkbox19\"> </label><a href=\"/posts/rust-decl-macro/p8\">p8~&gt; 模式: TT-Muncher</a><br>\n<input type=\"checkbox\" id=\"checkbox18\"><label for=\"checkbox18\"> </label><a href=\"/posts/rust-decl-macro/p9\">p9~&gt; 模式: 内用规则与尾部分隔符</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":211,"excerpt":"","more":"<p>呜呜呜呜呜呜呜呜呜呜呜呜…<br>\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业…</p>\n<p>您可以去看我在B站的相关视频: <a href=\"https://www.bilibili.com/video/BV1Wv411W7FH/\">传送门</a><br>\n我迟早有一天会更完的 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox26\" checked=\"true\"><label for=\"checkbox26\"> </label><a href=\"/posts/rust-decl-macro/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox25\" checked=\"true\"><label for=\"checkbox25\"> </label><a href=\"/posts/rust-decl-macro/p2\">p2~&gt; 从println!开始</a><br>\n<input type=\"checkbox\" id=\"checkbox24\" checked=\"true\"><label for=\"checkbox24\"> </label><a href=\"/posts/rust-decl-macro/p3\">p3~&gt; 声明与使用</a><br>\n<input type=\"checkbox\" id=\"checkbox23\" checked=\"true\"><label for=\"checkbox23\"> </label><a href=\"/posts/rust-decl-macro/p4\">p4~&gt; 重复</a><br>\n<input type=\"checkbox\" id=\"checkbox22\"><label for=\"checkbox22\"> </label><a href=\"/posts/rust-decl-macro/p5\">p5~&gt; 卫生性</a><br>\n<input type=\"checkbox\" id=\"checkbox21\"><label for=\"checkbox21\"> </label><a href=\"/posts/rust-decl-macro/p6\">p6~&gt; 实战: 递推序列生成器</a><br>\n<input type=\"checkbox\" id=\"checkbox20\"><label for=\"checkbox20\"> </label><a href=\"/posts/rust-decl-macro/p7\">p7~&gt; 作用域的导入与导出</a><br>\n<input type=\"checkbox\" id=\"checkbox19\"><label for=\"checkbox19\"> </label><a href=\"/posts/rust-decl-macro/p8\">p8~&gt; 模式: TT-Muncher</a><br>\n<input type=\"checkbox\" id=\"checkbox18\"><label for=\"checkbox18\"> </label><a href=\"/posts/rust-decl-macro/p9\">p9~&gt; 模式: 内用规则与尾部分隔符</a></p>\n"},{"abbrlink":"categories/rust-gstreamer","hidden":true,"layout":"page","quicklink":true,"date":"2022-10-22T14:25:49.000Z","title":"rust-gstreamer","top":null,"keywords":null,"_content":"\n这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust  \n可以看作是官网教程的翻译, 但把 C 语言换成 Rust, 而且会尽量增加解释, 让教程变得更加简单易懂  \n\n值得注意的是, 这些一个都还没开始写 (悲  \n下面的目录, 作用是提醒自己不要忘记, 仅此而已, 有空再写, 愉快鸽鸽鸽啦! :)\n\n[ ]  [p1~> 系列说明](/posts/rust-gstreamer/p1)\n[ ]  [p2~> 管道的基础概念](/posts/rust-gstreamer/p2)\n[ ]  [p3~> 管道的动态构建](/posts/rust-gstreamer/p3)\n[ ]  [p4~> 时间管理](/posts/rust-gstreamer/p4)\n[ ]  [p5~> 与GUI集成](/posts/rust-gstreamer/p5)\n","source":"_posts/categories/rust/gstreamer.md","raw":"---\nabbrlink: categories/rust-gstreamer\nhidden: true\nlayout: page\nquicklink: true\ndate: 2022-10-22 22:25:49\ntitle: rust-gstreamer\ntop: \ntags:\ncategories:\nkeywords:\n---\n\n这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust  \n可以看作是官网教程的翻译, 但把 C 语言换成 Rust, 而且会尽量增加解释, 让教程变得更加简单易懂  \n\n值得注意的是, 这些一个都还没开始写 (悲  \n下面的目录, 作用是提醒自己不要忘记, 仅此而已, 有空再写, 愉快鸽鸽鸽啦! :)\n\n[ ]  [p1~> 系列说明](/posts/rust-gstreamer/p1)\n[ ]  [p2~> 管道的基础概念](/posts/rust-gstreamer/p2)\n[ ]  [p3~> 管道的动态构建](/posts/rust-gstreamer/p3)\n[ ]  [p4~> 时间管理](/posts/rust-gstreamer/p4)\n[ ]  [p5~> 与GUI集成](/posts/rust-gstreamer/p5)\n","slug":"categories/rust/gstreamer","published":1,"updated":"2022-10-22T14:25:49.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogp0017j1s6c5u32v8z","content":"<p>这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust<br>\n可以看作是官网教程的翻译, 但把 C 语言换成 Rust, 而且会尽量增加解释, 让教程变得更加简单易懂</p>\n<p>值得注意的是, 这些一个都还没开始写 (悲<br>\n下面的目录, 作用是提醒自己不要忘记, 仅此而已, 有空再写, 愉快鸽鸽鸽啦! 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox31\"><label for=\"checkbox31\"> </label><a href=\"/posts/rust-gstreamer/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox30\"><label for=\"checkbox30\"> </label><a href=\"/posts/rust-gstreamer/p2\">p2~&gt; 管道的基础概念</a><br>\n<input type=\"checkbox\" id=\"checkbox29\"><label for=\"checkbox29\"> </label><a href=\"/posts/rust-gstreamer/p3\">p3~&gt; 管道的动态构建</a><br>\n<input type=\"checkbox\" id=\"checkbox28\"><label for=\"checkbox28\"> </label><a href=\"/posts/rust-gstreamer/p4\">p4~&gt; 时间管理</a><br>\n<input type=\"checkbox\" id=\"checkbox27\"><label for=\"checkbox27\"> </label><a href=\"/posts/rust-gstreamer/p5\">p5~&gt; 与GUI集成</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":203,"excerpt":"","more":"<p>这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust<br>\n可以看作是官网教程的翻译, 但把 C 语言换成 Rust, 而且会尽量增加解释, 让教程变得更加简单易懂</p>\n<p>值得注意的是, 这些一个都还没开始写 (悲<br>\n下面的目录, 作用是提醒自己不要忘记, 仅此而已, 有空再写, 愉快鸽鸽鸽啦! 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox31\"><label for=\"checkbox31\"> </label><a href=\"/posts/rust-gstreamer/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox30\"><label for=\"checkbox30\"> </label><a href=\"/posts/rust-gstreamer/p2\">p2~&gt; 管道的基础概念</a><br>\n<input type=\"checkbox\" id=\"checkbox29\"><label for=\"checkbox29\"> </label><a href=\"/posts/rust-gstreamer/p3\">p3~&gt; 管道的动态构建</a><br>\n<input type=\"checkbox\" id=\"checkbox28\"><label for=\"checkbox28\"> </label><a href=\"/posts/rust-gstreamer/p4\">p4~&gt; 时间管理</a><br>\n<input type=\"checkbox\" id=\"checkbox27\"><label for=\"checkbox27\"> </label><a href=\"/posts/rust-gstreamer/p5\">p5~&gt; 与GUI集成</a></p>\n"},{"title":"rust-atomics-and-locks","abbrlink":"categories/rust-atomics-and-locks","hidden":true,"date":"2023-06-23T11:16:57.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1~> 系列说明](/posts/rust-atomics-and-locks/p1)\n[ ]  [p2~> 基础概念](/posts/rust-atomics-and-locks/p2)\n","source":"_posts/categories/rust/atomics-and-locks.md","raw":"---\ntitle: rust-atomics-and-locks\nabbrlink: categories/rust-atomics-and-locks\nhidden: true\ndate: 2023-06-23 19:16:57\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1~> 系列说明](/posts/rust-atomics-and-locks/p1)\n[ ]  [p2~> 基础概念](/posts/rust-atomics-and-locks/p2)\n","slug":"categories/rust/atomics-and-locks","published":1,"updated":"2023-06-23T11:16:57.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogq001aj1s60ld725ro","content":"<p><input type=\"checkbox\" id=\"checkbox33\" checked=\"true\"><label for=\"checkbox33\"> </label><a href=\"/posts/rust-atomics-and-locks/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox32\"><label for=\"checkbox32\"> </label><a href=\"/posts/rust-atomics-and-locks/p2\">p2~&gt; 基础概念</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":22,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox33\" checked=\"true\"><label for=\"checkbox33\"> </label><a href=\"/posts/rust-atomics-and-locks/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox32\"><label for=\"checkbox32\"> </label><a href=\"/posts/rust-atomics-and-locks/p2\">p2~&gt; 基础概念</a></p>\n"},{"title":"rust-gui","abbrlink":"categories/rust-gui","hidden":true,"date":"2021-12-04T14:34:41.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n这里是关于用 rust 写 GUI 程序的索引  \n\n# GTK4\nGTK4 是 Linux 平台上推荐的选项, 说简单肯定不至于, 但说稳是肯定稳的  \n而且 GTK4 近年开始发力, 已经达成现代化的目标了, 不要因为是 C 语言写的, 就抱有太大偏见, 有些人只是讨厌 C 语言的繁琐而已  \n可以看看 vala 语言 (可以看作是专门为 gtk 设计的语言了) 来写 GTK 程序, 很简洁很美, 表达力并不差  \n\n[x]  [p1~> 系列说明](/posts/rust-gtk4/p1)\n[x]  [p2~> 创建窗口](/posts/rust-gtk4/p2)\n[x]  [p3~> GObject: 内存管理](/posts/rust-gtk4/p3)\n[x]  [p4~> GObject: 子类化](/posts/rust-gtk4/p4)\n[x]  [p5~> GObject: 通用类型](/posts/rust-gtk4/p5)\n[x]  [p6~> GObject: 属性](/posts/rust-gtk4/p6)\n[x]  [p7~> GObject: 信号](/posts/rust-gtk4/p7)\n[ ]  [p8~> 主事件循环](/posts/rust-gtk4/p8)\n[ ]  [p9~> 设置持久化](/posts/rust-gtk4/p9)\n\n- - -\n\n# Iced\nIced 使用 Elm 语言的模型, 很有趣也非常简单易学, 加上跨平台与能轻松编译到 web 端的特性, 很是推荐  \n[ ]  [p1~> 系列说明](/posts/rust-iced/p1)\n[ ]  [p2~> Elm式架构](/posts/rust-iced/p2)\n[ ]  [p3~> 布局](/posts/rust-iced/p3)\n[ ]  [p4~> 样式](/posts/rust-iced/p4)\n\n\n- - -\n\n# Relm4\n基于 GTK4, 加上了 Elm 语言的模型, 可以看作是 gtk-rs 的语法糖版本 ~~(应该?)~~, 一般推荐  ","source":"_posts/categories/rust/gui.md","raw":"---\ntitle: rust-gui\nabbrlink: categories/rust-gui\nhidden: true\ndate: 2021-12-04 22:34:41\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n这里是关于用 rust 写 GUI 程序的索引  \n\n# GTK4\nGTK4 是 Linux 平台上推荐的选项, 说简单肯定不至于, 但说稳是肯定稳的  \n而且 GTK4 近年开始发力, 已经达成现代化的目标了, 不要因为是 C 语言写的, 就抱有太大偏见, 有些人只是讨厌 C 语言的繁琐而已  \n可以看看 vala 语言 (可以看作是专门为 gtk 设计的语言了) 来写 GTK 程序, 很简洁很美, 表达力并不差  \n\n[x]  [p1~> 系列说明](/posts/rust-gtk4/p1)\n[x]  [p2~> 创建窗口](/posts/rust-gtk4/p2)\n[x]  [p3~> GObject: 内存管理](/posts/rust-gtk4/p3)\n[x]  [p4~> GObject: 子类化](/posts/rust-gtk4/p4)\n[x]  [p5~> GObject: 通用类型](/posts/rust-gtk4/p5)\n[x]  [p6~> GObject: 属性](/posts/rust-gtk4/p6)\n[x]  [p7~> GObject: 信号](/posts/rust-gtk4/p7)\n[ ]  [p8~> 主事件循环](/posts/rust-gtk4/p8)\n[ ]  [p9~> 设置持久化](/posts/rust-gtk4/p9)\n\n- - -\n\n# Iced\nIced 使用 Elm 语言的模型, 很有趣也非常简单易学, 加上跨平台与能轻松编译到 web 端的特性, 很是推荐  \n[ ]  [p1~> 系列说明](/posts/rust-iced/p1)\n[ ]  [p2~> Elm式架构](/posts/rust-iced/p2)\n[ ]  [p3~> 布局](/posts/rust-iced/p3)\n[ ]  [p4~> 样式](/posts/rust-iced/p4)\n\n\n- - -\n\n# Relm4\n基于 GTK4, 加上了 Elm 语言的模型, 可以看作是 gtk-rs 的语法糖版本 ~~(应该?)~~, 一般推荐  ","slug":"categories/rust/gui","published":1,"updated":"2021-12-04T14:34:41.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogr001cj1s699x70gql","content":"<p>这里是关于用 rust 写 GUI 程序的索引</p>\n<h1 id=\"gtk-4\">GTK4</h1>\n<p>GTK4 是 Linux 平台上推荐的选项, 说简单肯定不至于, 但说稳是肯定稳的<br>\n而且 GTK4 近年开始发力, 已经达成现代化的目标了, 不要因为是 C 语言写的, 就抱有太大偏见, 有些人只是讨厌 C 语言的繁琐而已<br>\n可以看看 vala 语言 (可以看作是专门为 gtk 设计的语言了) 来写 GTK 程序, 很简洁很美, 表达力并不差</p>\n<p><input type=\"checkbox\" id=\"checkbox42\" checked=\"true\"><label for=\"checkbox42\"> </label><a href=\"/posts/rust-gtk4/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox41\" checked=\"true\"><label for=\"checkbox41\"> </label><a href=\"/posts/rust-gtk4/p2\">p2~&gt; 创建窗口</a><br>\n<input type=\"checkbox\" id=\"checkbox40\" checked=\"true\"><label for=\"checkbox40\"> </label><a href=\"/posts/rust-gtk4/p3\">p3~&gt; GObject: 内存管理</a><br>\n<input type=\"checkbox\" id=\"checkbox39\" checked=\"true\"><label for=\"checkbox39\"> </label><a href=\"/posts/rust-gtk4/p4\">p4~&gt; GObject: 子类化</a><br>\n<input type=\"checkbox\" id=\"checkbox38\" checked=\"true\"><label for=\"checkbox38\"> </label><a href=\"/posts/rust-gtk4/p5\">p5~&gt; GObject: 通用类型</a><br>\n<input type=\"checkbox\" id=\"checkbox37\" checked=\"true\"><label for=\"checkbox37\"> </label><a href=\"/posts/rust-gtk4/p6\">p6~&gt; GObject: 属性</a><br>\n<input type=\"checkbox\" id=\"checkbox36\" checked=\"true\"><label for=\"checkbox36\"> </label><a href=\"/posts/rust-gtk4/p7\">p7~&gt; GObject: 信号</a><br>\n<input type=\"checkbox\" id=\"checkbox35\"><label for=\"checkbox35\"> </label><a href=\"/posts/rust-gtk4/p8\">p8~&gt; 主事件循环</a><br>\n<input type=\"checkbox\" id=\"checkbox34\"><label for=\"checkbox34\"> </label><a href=\"/posts/rust-gtk4/p9\">p9~&gt; 设置持久化</a></p>\n<hr>\n<h1 id=\"iced\">Iced</h1>\n<p>Iced 使用 Elm 语言的模型, 很有趣也非常简单易学, 加上跨平台与能轻松编译到 web 端的特性, 很是推荐<br>\n<input type=\"checkbox\" id=\"checkbox46\"><label for=\"checkbox46\"> </label><a href=\"/posts/rust-iced/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox45\"><label for=\"checkbox45\"> </label><a href=\"/posts/rust-iced/p2\">p2~&gt; Elm式架构</a><br>\n<input type=\"checkbox\" id=\"checkbox44\"><label for=\"checkbox44\"> </label><a href=\"/posts/rust-iced/p3\">p3~&gt; 布局</a><br>\n<input type=\"checkbox\" id=\"checkbox43\"><label for=\"checkbox43\"> </label><a href=\"/posts/rust-iced/p4\">p4~&gt; 样式</a></p>\n<hr>\n<h1 id=\"relm-4\">Relm4</h1>\n<p>基于 GTK4, 加上了 Elm 语言的模型, 可以看作是 gtk-rs 的语法糖版本 <s>(应该?)</s>, 一般推荐</p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":450,"excerpt":"","more":"<p>这里是关于用 rust 写 GUI 程序的索引</p>\n<h1 id=\"gtk-4\">GTK4</h1>\n<p>GTK4 是 Linux 平台上推荐的选项, 说简单肯定不至于, 但说稳是肯定稳的<br>\n而且 GTK4 近年开始发力, 已经达成现代化的目标了, 不要因为是 C 语言写的, 就抱有太大偏见, 有些人只是讨厌 C 语言的繁琐而已<br>\n可以看看 vala 语言 (可以看作是专门为 gtk 设计的语言了) 来写 GTK 程序, 很简洁很美, 表达力并不差</p>\n<p><input type=\"checkbox\" id=\"checkbox42\" checked=\"true\"><label for=\"checkbox42\"> </label><a href=\"/posts/rust-gtk4/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox41\" checked=\"true\"><label for=\"checkbox41\"> </label><a href=\"/posts/rust-gtk4/p2\">p2~&gt; 创建窗口</a><br>\n<input type=\"checkbox\" id=\"checkbox40\" checked=\"true\"><label for=\"checkbox40\"> </label><a href=\"/posts/rust-gtk4/p3\">p3~&gt; GObject: 内存管理</a><br>\n<input type=\"checkbox\" id=\"checkbox39\" checked=\"true\"><label for=\"checkbox39\"> </label><a href=\"/posts/rust-gtk4/p4\">p4~&gt; GObject: 子类化</a><br>\n<input type=\"checkbox\" id=\"checkbox38\" checked=\"true\"><label for=\"checkbox38\"> </label><a href=\"/posts/rust-gtk4/p5\">p5~&gt; GObject: 通用类型</a><br>\n<input type=\"checkbox\" id=\"checkbox37\" checked=\"true\"><label for=\"checkbox37\"> </label><a href=\"/posts/rust-gtk4/p6\">p6~&gt; GObject: 属性</a><br>\n<input type=\"checkbox\" id=\"checkbox36\" checked=\"true\"><label for=\"checkbox36\"> </label><a href=\"/posts/rust-gtk4/p7\">p7~&gt; GObject: 信号</a><br>\n<input type=\"checkbox\" id=\"checkbox35\"><label for=\"checkbox35\"> </label><a href=\"/posts/rust-gtk4/p8\">p8~&gt; 主事件循环</a><br>\n<input type=\"checkbox\" id=\"checkbox34\"><label for=\"checkbox34\"> </label><a href=\"/posts/rust-gtk4/p9\">p9~&gt; 设置持久化</a></p>\n<hr>\n<h1 id=\"iced\">Iced</h1>\n<p>Iced 使用 Elm 语言的模型, 很有趣也非常简单易学, 加上跨平台与能轻松编译到 web 端的特性, 很是推荐<br>\n<input type=\"checkbox\" id=\"checkbox46\"><label for=\"checkbox46\"> </label><a href=\"/posts/rust-iced/p1\">p1~&gt; 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox45\"><label for=\"checkbox45\"> </label><a href=\"/posts/rust-iced/p2\">p2~&gt; Elm式架构</a><br>\n<input type=\"checkbox\" id=\"checkbox44\"><label for=\"checkbox44\"> </label><a href=\"/posts/rust-iced/p3\">p3~&gt; 布局</a><br>\n<input type=\"checkbox\" id=\"checkbox43\"><label for=\"checkbox43\"> </label><a href=\"/posts/rust-iced/p4\">p4~&gt; 样式</a></p>\n<hr>\n<h1 id=\"relm-4\">Relm4</h1>\n<p>基于 GTK4, 加上了 Elm 语言的模型, 可以看作是 gtk-rs 的语法糖版本 <s>(应该?)</s>, 一般推荐</p>\n"},{"abbrlink":"categories/rust-tui","hidden":true,"date":"2022-06-19T05:05:06.000Z","layout":"page","title":"rust-tui","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1-系列说明](/posts/rust-tui/p1)\n[ ]  [p2-基础架构](/posts/rust-tui/p2)","source":"_posts/categories/rust/tui.md","raw":"---\nabbrlink: categories/rust-tui\nhidden: true\ndate: 2022-06-19 13:05:06\nlayout: page\ntitle: rust-tui \nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1-系列说明](/posts/rust-tui/p1)\n[ ]  [p2-基础架构](/posts/rust-tui/p2)","slug":"categories/rust/tui","published":1,"updated":"2022-06-19T05:05:06.000Z","comments":1,"photos":[],"link":"","_id":"cljoa8ogs001ej1s684h0c6jv","content":"<p><input type=\"checkbox\" id=\"checkbox48\" checked=\"true\"><label for=\"checkbox48\"> </label><a href=\"/posts/rust-tui/p1\">p1-系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox47\"><label for=\"checkbox47\"> </label><a href=\"/posts/rust-tui/p2\">p2-基础架构</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":14,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox48\" checked=\"true\"><label for=\"checkbox48\"> </label><a href=\"/posts/rust-tui/p1\">p1-系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox47\"><label for=\"checkbox47\"> </label><a href=\"/posts/rust-tui/p2\">p2-基础架构</a></p>\n"},{"title":"rust-async-p1~> 系列说明","abbrlink":"posts/rust-async/p1","date":"2021-09-12T03:43:19.000Z","top":9899,"keywords":["Async","异步","Rust"],"is_series":true,"next_post":["posts/rust-async/p2","异步简介"],"_content":"> 欢迎大家来到 Rust 的 异步(async) 系列  \n<!-- more -->\n\n同系列传送门: [rust-async](/categories/rust-async) \n\n# 系列说明\n此系列,我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n- - - \n# 资料来源\n1. 书籍  \n- [async-book](https://rust-lang.github.io/async-book/**)\n- [async_std/tutorials](https://book.async.rs/overview/async-std)\n- [tokio/tutorials](https://tokio.rs/tokio/tutorial)\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n2. 博客\n- [Withoutboats's blogs](https://without.boats/blog/)  \n\n- - -\n\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","source":"_posts/rust/async/p1-系列说明.md","raw":"---\ntitle: \"rust-async-p1~> 系列说明\"\nabbrlink: posts/rust-async/p1\ndate: 2021-09-12 11:43:19\ntop: 9899\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\nis_series: true\nnext_post: [posts/rust-async/p2, 异步简介]\n---\n> 欢迎大家来到 Rust 的 异步(async) 系列  \n<!-- more -->\n\n同系列传送门: [rust-async](/categories/rust-async) \n\n# 系列说明\n此系列,我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n- - - \n# 资料来源\n1. 书籍  \n- [async-book](https://rust-lang.github.io/async-book/**)\n- [async_std/tutorials](https://book.async.rs/overview/async-std)\n- [tokio/tutorials](https://tokio.rs/tokio/tutorial)\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n2. 博客\n- [Withoutboats's blogs](https://without.boats/blog/)  \n\n- - -\n\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","slug":"rust/async/p1-系列说明","published":1,"updated":"2021-09-12T03:43:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogt001gj1s6c9o261f0","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>\n当然也会介绍异步方面的相关概念咯</p>\n<hr>\n<h1 id=\"zi-liao-lai-yuan\">资料来源</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rust-lang.github.io/async-book/**\">async-book</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://book.async.rs/overview/async-std\">async_std/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://tokio.rs/tokio/tutorial\">tokio/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>\n","site":{"data":{}},"length":245,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>\n当然也会介绍异步方面的相关概念咯</p>\n<hr>\n<h1 id=\"zi-liao-lai-yuan\">资料来源</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rust-lang.github.io/async-book/**\">async-book</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://book.async.rs/overview/async-std\">async_std/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://tokio.rs/tokio/tutorial\">tokio/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>"},{"title":"rust-async-p2~> 异步简介","abbrlink":"posts/rust-async/p2","date":"2021-09-12T04:04:09.000Z","top":9898,"keywords":["Async","异步","Rust"],"is_series":true,"prev_post":["posts/rust-async/p1","系列说明"],"next_post":["posts/rust-async/p3","Future"],"_content":"> 来简单介绍一下异步吧  \n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n\n**异步编程 (Asynchronous programming)**, 是一种**并发编程模型** \n特点是通过少量`OS_thread(系统线程)`, 即可运行大量`并发任务`, 在某些场景下,可以疯狂压榨cpu的性能\n\n- - -\n\n# 模型对比\n为何选择异步,它的优势有哪些? 让我们对比下 **异步** 与其他 **并发模型**:  \n\n1.`系统线程 (OS Thread)`  \n由操作系统提供线程,进行并发,如 `std::thread`  \n- 简单易使用, 建模能力强, 足够传统  \n- 操作系统就是运行时, 与C语言交互方便 \n- 数据同步困难, 易发生数据竞争  \n- 小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n\n\n2.`绿色线程 (Green Thread)`  \n它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身, 由程序本身进行模拟  \nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库  \n- 程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长  \n- 创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  \n- 由程序本身实现模拟出来, Runtime 较大  \n- 如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互\n- 绿色线程在不同平台上,其实现可能不同  \n- 对多平台的支持/维护/改进得靠实现者保证  \n\n- - -\n# 异步\n我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:  \n\n```rust\nlet file = /*  */\nlet content = read(file);\ncompute()\n```\n\n读取 `file`, 获取 `content`, 在此期间, 我们做不了任何其他事, 得等待`IO操作(Input/Output, 输入/输出)` 完毕, 才能进行接下来的 `compute`  \n`读取文件`, 属于`IO操作`, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速: \n\n```rust\nlet file = /*  */\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n// 使用 join 阻塞调用线程, 确保句柄线程执行结束\nlet content = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n两个任务 `read` 与 `compute` 是独立无依赖的, 所以我们`spawn`了两个线程  \n- 第一个用于读取文件,获取数据\n- 第二个用于执行 `compute`    \n\n速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作  \n单线程中的异步(伪)代码如下:\n\n```rust\nlet file = /*  */\nlet content = read_async(file);\ncompute_async()\n```\n\n你会注意到:  \n- `read` -> `read_async`  \n- `compute` -> `compute_async`  \n\n伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:  \n\n- `read`:  \n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 `compute`  \n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时,会运行 `compute_async`, 线程由 `read_async` 接管, 变为由 `compute_async` 接管  \n当阻塞时间结束,则程序继续变为运行`read_async`\n\n瞧, `read_async` 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程  \n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨  \n异步操作, 就像是可以随意 `start/stop` 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待  \n\n即使是单线程, 也能做到同时运行多个 `Task(异步任务)`, 而异步结合多线程也是可以的, 只要存在耗时的IO操作  \n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步\n\n- - -\n\n# 尾声\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了  \n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!  \n\n","source":"_posts/rust/async/p2-异步简介.md","raw":"---\ntitle: \"rust-async-p2~> 异步简介\"\nabbrlink: posts/rust-async/p2\ndate: 2021-09-12 12:04:09\ntop: 9898\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\nis_series: true\nprev_post: [posts/rust-async/p1, 系列说明]\nnext_post: [posts/rust-async/p3, Future]\n---\n> 来简单介绍一下异步吧  \n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n\n**异步编程 (Asynchronous programming)**, 是一种**并发编程模型** \n特点是通过少量`OS_thread(系统线程)`, 即可运行大量`并发任务`, 在某些场景下,可以疯狂压榨cpu的性能\n\n- - -\n\n# 模型对比\n为何选择异步,它的优势有哪些? 让我们对比下 **异步** 与其他 **并发模型**:  \n\n1.`系统线程 (OS Thread)`  \n由操作系统提供线程,进行并发,如 `std::thread`  \n- 简单易使用, 建模能力强, 足够传统  \n- 操作系统就是运行时, 与C语言交互方便 \n- 数据同步困难, 易发生数据竞争  \n- 小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n\n\n2.`绿色线程 (Green Thread)`  \n它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身, 由程序本身进行模拟  \nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库  \n- 程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长  \n- 创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  \n- 由程序本身实现模拟出来, Runtime 较大  \n- 如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互\n- 绿色线程在不同平台上,其实现可能不同  \n- 对多平台的支持/维护/改进得靠实现者保证  \n\n- - -\n# 异步\n我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:  \n\n```rust\nlet file = /*  */\nlet content = read(file);\ncompute()\n```\n\n读取 `file`, 获取 `content`, 在此期间, 我们做不了任何其他事, 得等待`IO操作(Input/Output, 输入/输出)` 完毕, 才能进行接下来的 `compute`  \n`读取文件`, 属于`IO操作`, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速: \n\n```rust\nlet file = /*  */\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n// 使用 join 阻塞调用线程, 确保句柄线程执行结束\nlet content = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n两个任务 `read` 与 `compute` 是独立无依赖的, 所以我们`spawn`了两个线程  \n- 第一个用于读取文件,获取数据\n- 第二个用于执行 `compute`    \n\n速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作  \n单线程中的异步(伪)代码如下:\n\n```rust\nlet file = /*  */\nlet content = read_async(file);\ncompute_async()\n```\n\n你会注意到:  \n- `read` -> `read_async`  \n- `compute` -> `compute_async`  \n\n伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:  \n\n- `read`:  \n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 `compute`  \n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时,会运行 `compute_async`, 线程由 `read_async` 接管, 变为由 `compute_async` 接管  \n当阻塞时间结束,则程序继续变为运行`read_async`\n\n瞧, `read_async` 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程  \n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨  \n异步操作, 就像是可以随意 `start/stop` 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待  \n\n即使是单线程, 也能做到同时运行多个 `Task(异步任务)`, 而异步结合多线程也是可以的, 只要存在耗时的IO操作  \n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步\n\n- - -\n\n# 尾声\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了  \n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!  \n\n","slug":"rust/async/p2-异步简介","published":1,"updated":"2021-09-12T04:04:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogu001ij1s6e9rvhpqx","content":"<blockquote>\n<p>来简单介绍一下异步吧</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>异步编程 (Asynchronous programming)</strong>, 是一种<strong>并发编程模型</strong><br>\n特点是通过少量<code>OS_thread(系统线程)</code>, 即可运行大量<code>并发任务</code>, 在某些场景下,可以疯狂压榨cpu的性能</p>\n<hr>\n<h1 id=\"mo-xing-dui-bi\">模型对比</h1>\n<p>为何选择异步,它的优势有哪些? 让我们对比下 <strong>异步</strong> 与其他 <strong>并发模型</strong>:</p>\n<p>1.<code>系统线程 (OS Thread)</code><br>\n由操作系统提供线程,进行并发,如 <code>std::thread</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>简单易使用, 建模能力强, 足够传统</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作系统就是运行时, 与C语言交互方便</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据同步困难, 易发生数据竞争</p>\n</li>\n<li class=\"lvl-2\">\n<p>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>\n</li>\n</ul>\n<p>2.<code>绿色线程 (Green Thread)</code><br>\n它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身, 由程序本身进行模拟<br>\nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>由程序本身实现模拟出来, Runtime 较大</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互</p>\n</li>\n<li class=\"lvl-2\">\n<p>绿色线程在不同平台上,其实现可能不同</p>\n</li>\n<li class=\"lvl-2\">\n<p>对多平台的支持/维护/改进得靠实现者保证</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"yi-bu\">异步</h1>\n<p>我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read(file);</span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>读取 <code>file</code>, 获取 <code>content</code>, 在此期间, 我们做不了任何其他事, 得等待<code>IO操作(Input/Output, 输入/输出)</code> 完毕, 才能进行接下来的 <code>compute</code><br>\n<code>读取文件</code>, 属于<code>IO操作</code>, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"><span class=\"comment\">// 使用 join 阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n<p>两个任务 <code>read</code> 与 <code>compute</code> 是独立无依赖的, 所以我们<code>spawn</code>了两个线程</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个用于读取文件,获取数据</p>\n</li>\n<li class=\"lvl-2\">\n<p>第二个用于执行 <code>compute</code></p>\n</li>\n</ul>\n<p>速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作<br>\n单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read_async(file);</span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n<p>你会注意到:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code> -&gt; <code>read_async</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>compute</code> -&gt; <code>compute_async</code></p>\n</li>\n</ul>\n<p>伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code>:<br>\n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 <code>compute</code><br>\n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>read_async</code>:<br>\n它处于阻塞时,会运行 <code>compute_async</code>, 线程由 <code>read_async</code> 接管, 变为由 <code>compute_async</code> 接管<br>\n当阻塞时间结束,则程序继续变为运行<code>read_async</code></p>\n</li>\n</ul>\n<p>瞧, <code>read_async</code> 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程<br>\n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨<br>\n异步操作, 就像是可以随意 <code>start/stop</code> 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待</p>\n<p>即使是单线程, 也能做到同时运行多个 <code>Task(异步任务)</code>, 而异步结合多线程也是可以的, 只要存在耗时的IO操作<br>\n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步</p>\n<hr>\n<h1 id=\"wei-sheng\">尾声</h1>\n<p>Q:<br>\n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>\nA:<br>\n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了<br>\n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!</p>\n","site":{"data":{}},"length":1849,"excerpt":"<blockquote>\n<p>来简单介绍一下异步吧</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>异步编程 (Asynchronous programming)</strong>, 是一种<strong>并发编程模型</strong><br>\n特点是通过少量<code>OS_thread(系统线程)</code>, 即可运行大量<code>并发任务</code>, 在某些场景下,可以疯狂压榨cpu的性能</p>\n<hr>\n<h1 id=\"mo-xing-dui-bi\">模型对比</h1>\n<p>为何选择异步,它的优势有哪些? 让我们对比下 <strong>异步</strong> 与其他 <strong>并发模型</strong>:</p>\n<p>1.<code>系统线程 (OS Thread)</code><br>\n由操作系统提供线程,进行并发,如 <code>std::thread</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>简单易使用, 建模能力强, 足够传统</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作系统就是运行时, 与C语言交互方便</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据同步困难, 易发生数据竞争</p>\n</li>\n<li class=\"lvl-2\">\n<p>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>\n</li>\n</ul>\n<p>2.<code>绿色线程 (Green Thread)</code><br>\n它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身, 由程序本身进行模拟<br>\nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>由程序本身实现模拟出来, Runtime 较大</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互</p>\n</li>\n<li class=\"lvl-2\">\n<p>绿色线程在不同平台上,其实现可能不同</p>\n</li>\n<li class=\"lvl-2\">\n<p>对多平台的支持/维护/改进得靠实现者保证</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"yi-bu\">异步</h1>\n<p>我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read(file);</span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>读取 <code>file</code>, 获取 <code>content</code>, 在此期间, 我们做不了任何其他事, 得等待<code>IO操作(Input/Output, 输入/输出)</code> 完毕, 才能进行接下来的 <code>compute</code><br>\n<code>读取文件</code>, 属于<code>IO操作</code>, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"><span class=\"comment\">// 使用 join 阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n<p>两个任务 <code>read</code> 与 <code>compute</code> 是独立无依赖的, 所以我们<code>spawn</code>了两个线程</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个用于读取文件,获取数据</p>\n</li>\n<li class=\"lvl-2\">\n<p>第二个用于执行 <code>compute</code></p>\n</li>\n</ul>\n<p>速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作<br>\n单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read_async(file);</span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n<p>你会注意到:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code> -&gt; <code>read_async</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>compute</code> -&gt; <code>compute_async</code></p>\n</li>\n</ul>\n<p>伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code>:<br>\n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 <code>compute</code><br>\n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>read_async</code>:<br>\n它处于阻塞时,会运行 <code>compute_async</code>, 线程由 <code>read_async</code> 接管, 变为由 <code>compute_async</code> 接管<br>\n当阻塞时间结束,则程序继续变为运行<code>read_async</code></p>\n</li>\n</ul>\n<p>瞧, <code>read_async</code> 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程<br>\n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨<br>\n异步操作, 就像是可以随意 <code>start/stop</code> 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待</p>\n<p>即使是单线程, 也能做到同时运行多个 <code>Task(异步任务)</code>, 而异步结合多线程也是可以的, 只要存在耗时的IO操作<br>\n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步</p>\n<hr>\n<h1 id=\"wei-sheng\">尾声</h1>\n<p>Q:<br>\n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>\nA:<br>\n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了<br>\n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!</p>"},{"title":"rust-async-p4~> 状态的保存与变换","abbrlink":"posts/rust-async/p4","date":"2021-09-12T06:50:14.000Z","top":9896,"keywords":["Async","异步","Rust"],"is_series":true,"prev_post":["posts/rust-async/p3","Future"],"_content":"> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n**注**: 参考了 \\<\\<Writing an OS in Rust\\>\\> 中的 async 篇,可以自己搜索下看看  \n为了更好地理解 `Rust异步`背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:   \n- 多任务: 抢占式与协作式  \n- 状态机  \n- 自引用结构体   \n\n\n现在,让我们开始吧!  \n- - -\n# 两种多任务  \n## 介绍\n抢占式 与 协作式, 是 多任务 的不同分类  \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会  \n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉  \n这是强迫/抢占的    \n\n- 协作式多任务:  \n任务们本身进行协调, 决定CPU的运行权  \n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending  \n自己放弃继续执行, 并通知运行时执行其他Task  \n这是自愿/协作的, Task 们自愿放弃CPU的执行权\n\n## 状态的恢复/保存\n既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时  \n该任务,应当从先前暂停的地方开始, 继续执行  \n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存  \n\n对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:\n\n- 抢占式:  \n因为是强迫切换执行的, 任务会在任意某个时刻被中断  \n任务此时运行到了哪里?我们不知道啊!  \n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间  \n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n- 协作式:  \n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作, 我们称为`yield`    \n\n比如在Rust中, `xxx.await`会执行一个Future  \t\n意味着当程序执行到这里时, 可能会`yield`(poll返回Poll::Pending, 自愿放弃执行权)  \n\n`xxx.await`就是一个`stop/yield point`, 代表执行到此处时, 可能会发生暂停并yield  \n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此, 我们可以准确分配Future执行所需要的最大空间  \n\n其实, 每个`.await(也就是yield point)`, 就代表着`一种状态`(之后会讲)\n\n协作式的好处在于:  \n能自己掌握所有`yield point`, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理  \n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的  \n在任务暂停并转让执行权前, 准确保存`下次继续所需要的状态`, 内存/性能优势很大    \n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n\n- - -\n# 状态机的概念  \n在Rust中的异步, 我们之前也说过, 属于`协作式多任务`  \n而其`状态保存`的实现, 就是利用`状态机(state machine)`来实现  \n\n`状态机(state machine)`一般指`有限状态自动机`, 是一种数学模型  \n\n1. 状态(state):  \n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed\n2. 事件(event):  \n某事件发生后, 会触发相应动作, 可能改变状态  \n比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state)   \n3. 动作 (action):  \n事件发生后, 会触发动作  \n4. 变换 (transition):  \n`State_X=>State_Y`就叫`变换`, 比如门的状态从`Open=>Closed`  \n\n稍微了解下`状态机`的概念即可  \n\n那么现在, 就要看具体代码了  \n\n如果你想亲自运行一下, 先确保你的`Cargo.toml`中的依赖如下:  \n\n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下代码, 读取一个文件的行数  \n你可以通过 `cargo run -- ./src/main.rs` 运行  \n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)  \n\n```rust\nuse std::{\n\tenv::args,\n\tprocess,\n};\nuse async_std::{\n\tprelude::*,\n\tfs::File,\n\tio::{self,BufReader},\n};\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).unwrap_or_else(||{\n\t\teprintln!(\"Fuck you! No path for reading\");\n\t\tprocess::exit(1);\n\t}); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\n\n\nmian()产生一个新实例, 异步运行`open(path)`与`count()`  \t    \n对于编译器, 每一个`.await`其实都代表一种状态  \n\nFuture实例, 实际上是个状态机  \n在这里共有四种状态/阶段(其中包括两个`.await point(yield point)`):  \n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用当前Future的poll推动进度时, 若在`某一阶段`返回了`Poll::Pending`, 则放弃执行权  \n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态`恢复(resume)`, 继续执行  \n\n官方目前似乎采用`Generator(生成器)`为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态  \n\n**Note 1**:  \nStart状态, 会存储传入函数的参数(如果有参数)\n\n**Note 2**:  \nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义,  且point之后还需要使用的变量`  \n如上段代码中的 `file` 与 `count`就需要被保存, 因为从暂停中恢复后还需要使用  \n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象  \n所以不需要特殊的持久化操作\n\n- - - \n# 自引用结构体  \n## 保存引用\n当每个状态存储数据时,  可能会导致发生`自引用`, 比如:  \n\n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n\n这里有三个状态: `Start`, `Yield1`, `Done`, 而在`Yield1`这个状态下, 存储的数据如下:  \n\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3], \n    element: *const i32, // 数组最后一个元素的地址\n}\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```\n\n等等, 你可能会对上面的代码有疑惑:  \n不是说, 状态只需要保存 `在yield point之前定义,  并且该point之后还需要使用的变量` 吗  \n上面的代码, 只有element这个引用需要被保存吧?  \n\n这是因为, 它是`引用`嘛! 没了`引用`背后的实际数据, 那它还有啥用, 不就是`悬垂引用`了吗?  \n因此我们还得保存, `该引用`指向的背后数据: `arr`, 并**一起**存储在同个`struct(代表同一状态)`中  \n像这种 `结构体内部的指针, 指向结构体本身`, 就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下, 成员element指向了成员arr  \n\n## 内存移动问题\n如上所述,  这可能导致悬垂引用的产生, 若该struct实例的`内存地址发生改变`, 如使用 `std::mem`, 让struct实例的内存地址发生移动  \n以上面的那段代码为例, 如下:  \n\n- arr:  \n内存地址会跟着结构体实例而改变, 但是,  `值仍然是 [1, 2, 3]`\n- element:  \n内存地址会跟着结构体实例而改变, 但是, 值仍然是`先前arr的地址`, `注意, 是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n官方提出了`std::pin::Pin(trait)` 来解决自引用结构体方面的悬垂指针/引用问题 \n\n其实你听名字也很好理解, `Pin(中文意思是钉子)`的作用是, 防止内存地址发生改变(给爷钉死吧!)  \n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了  \n\n欲知后事如何,  且听下回分解  \n~~(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~  \n","source":"_posts/rust/async/p4-状态的保存与变换.md","raw":"---\ntitle: \"rust-async-p4~> 状态的保存与变换\"\nabbrlink: posts/rust-async/p4\ndate: 2021-09-12 14:50:14\ntop: 9896\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\nis_series: true\nprev_post: [posts/rust-async/p3, Future]\n---\n> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n**注**: 参考了 \\<\\<Writing an OS in Rust\\>\\> 中的 async 篇,可以自己搜索下看看  \n为了更好地理解 `Rust异步`背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:   \n- 多任务: 抢占式与协作式  \n- 状态机  \n- 自引用结构体   \n\n\n现在,让我们开始吧!  \n- - -\n# 两种多任务  \n## 介绍\n抢占式 与 协作式, 是 多任务 的不同分类  \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会  \n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉  \n这是强迫/抢占的    \n\n- 协作式多任务:  \n任务们本身进行协调, 决定CPU的运行权  \n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending  \n自己放弃继续执行, 并通知运行时执行其他Task  \n这是自愿/协作的, Task 们自愿放弃CPU的执行权\n\n## 状态的恢复/保存\n既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时  \n该任务,应当从先前暂停的地方开始, 继续执行  \n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存  \n\n对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:\n\n- 抢占式:  \n因为是强迫切换执行的, 任务会在任意某个时刻被中断  \n任务此时运行到了哪里?我们不知道啊!  \n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间  \n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n- 协作式:  \n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作, 我们称为`yield`    \n\n比如在Rust中, `xxx.await`会执行一个Future  \t\n意味着当程序执行到这里时, 可能会`yield`(poll返回Poll::Pending, 自愿放弃执行权)  \n\n`xxx.await`就是一个`stop/yield point`, 代表执行到此处时, 可能会发生暂停并yield  \n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此, 我们可以准确分配Future执行所需要的最大空间  \n\n其实, 每个`.await(也就是yield point)`, 就代表着`一种状态`(之后会讲)\n\n协作式的好处在于:  \n能自己掌握所有`yield point`, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理  \n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的  \n在任务暂停并转让执行权前, 准确保存`下次继续所需要的状态`, 内存/性能优势很大    \n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n\n- - -\n# 状态机的概念  \n在Rust中的异步, 我们之前也说过, 属于`协作式多任务`  \n而其`状态保存`的实现, 就是利用`状态机(state machine)`来实现  \n\n`状态机(state machine)`一般指`有限状态自动机`, 是一种数学模型  \n\n1. 状态(state):  \n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed\n2. 事件(event):  \n某事件发生后, 会触发相应动作, 可能改变状态  \n比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state)   \n3. 动作 (action):  \n事件发生后, 会触发动作  \n4. 变换 (transition):  \n`State_X=>State_Y`就叫`变换`, 比如门的状态从`Open=>Closed`  \n\n稍微了解下`状态机`的概念即可  \n\n那么现在, 就要看具体代码了  \n\n如果你想亲自运行一下, 先确保你的`Cargo.toml`中的依赖如下:  \n\n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下代码, 读取一个文件的行数  \n你可以通过 `cargo run -- ./src/main.rs` 运行  \n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)  \n\n```rust\nuse std::{\n\tenv::args,\n\tprocess,\n};\nuse async_std::{\n\tprelude::*,\n\tfs::File,\n\tio::{self,BufReader},\n};\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).unwrap_or_else(||{\n\t\teprintln!(\"Fuck you! No path for reading\");\n\t\tprocess::exit(1);\n\t}); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\n\n\nmian()产生一个新实例, 异步运行`open(path)`与`count()`  \t    \n对于编译器, 每一个`.await`其实都代表一种状态  \n\nFuture实例, 实际上是个状态机  \n在这里共有四种状态/阶段(其中包括两个`.await point(yield point)`):  \n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用当前Future的poll推动进度时, 若在`某一阶段`返回了`Poll::Pending`, 则放弃执行权  \n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态`恢复(resume)`, 继续执行  \n\n官方目前似乎采用`Generator(生成器)`为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态  \n\n**Note 1**:  \nStart状态, 会存储传入函数的参数(如果有参数)\n\n**Note 2**:  \nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义,  且point之后还需要使用的变量`  \n如上段代码中的 `file` 与 `count`就需要被保存, 因为从暂停中恢复后还需要使用  \n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象  \n所以不需要特殊的持久化操作\n\n- - - \n# 自引用结构体  \n## 保存引用\n当每个状态存储数据时,  可能会导致发生`自引用`, 比如:  \n\n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n\n这里有三个状态: `Start`, `Yield1`, `Done`, 而在`Yield1`这个状态下, 存储的数据如下:  \n\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3], \n    element: *const i32, // 数组最后一个元素的地址\n}\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```\n\n等等, 你可能会对上面的代码有疑惑:  \n不是说, 状态只需要保存 `在yield point之前定义,  并且该point之后还需要使用的变量` 吗  \n上面的代码, 只有element这个引用需要被保存吧?  \n\n这是因为, 它是`引用`嘛! 没了`引用`背后的实际数据, 那它还有啥用, 不就是`悬垂引用`了吗?  \n因此我们还得保存, `该引用`指向的背后数据: `arr`, 并**一起**存储在同个`struct(代表同一状态)`中  \n像这种 `结构体内部的指针, 指向结构体本身`, 就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下, 成员element指向了成员arr  \n\n## 内存移动问题\n如上所述,  这可能导致悬垂引用的产生, 若该struct实例的`内存地址发生改变`, 如使用 `std::mem`, 让struct实例的内存地址发生移动  \n以上面的那段代码为例, 如下:  \n\n- arr:  \n内存地址会跟着结构体实例而改变, 但是,  `值仍然是 [1, 2, 3]`\n- element:  \n内存地址会跟着结构体实例而改变, 但是, 值仍然是`先前arr的地址`, `注意, 是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n官方提出了`std::pin::Pin(trait)` 来解决自引用结构体方面的悬垂指针/引用问题 \n\n其实你听名字也很好理解, `Pin(中文意思是钉子)`的作用是, 防止内存地址发生改变(给爷钉死吧!)  \n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了  \n\n欲知后事如何,  且听下回分解  \n~~(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~  \n","slug":"rust/async/p4-状态的保存与变换","published":1,"updated":"2021-09-12T06:50:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogv001kj1s63uof7fo9","content":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>注</strong>: 参考了 &lt;&lt;Writing an OS in Rust&gt;&gt; 中的 async 篇,可以自己搜索下看看<br>\n为了更好地理解 <code>Rust异步</code>背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>多任务: 抢占式与协作式</p>\n</li>\n<li class=\"lvl-2\">\n<p>状态机</p>\n</li>\n<li class=\"lvl-2\">\n<p>自引用结构体</p>\n</li>\n</ul>\n<p>现在,让我们开始吧!</p>\n<hr>\n<h1 id=\"liang-chong-duo-ren-wu\">两种多任务</h1>\n<h2 id=\"jie-shao\" id=\"介绍\">介绍</h2>\n<p>抢占式 与 协作式, 是 多任务 的不同分类</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式多任务:<br>\n操作系统决定CPU的运行权<br>\n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会<br>\n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉<br>\n这是强迫/抢占的</p>\n</li>\n<li class=\"lvl-2\">\n<p>协作式多任务:<br>\n任务们本身进行协调, 决定CPU的运行权<br>\n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending<br>\n自己放弃继续执行, 并通知运行时执行其他Task<br>\n这是自愿/协作的, Task 们自愿放弃CPU的执行权</p>\n</li>\n</ul>\n<h2 id=\"zhuang-tai-de-hui-fu-bao-cun\" id=\"状态的恢复-保存\">状态的恢复/保存</h2>\n<p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>\n该任务,应当从先前暂停的地方开始, 继续执行<br>\n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存</p>\n<p>对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式:<br>\n因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>\n任务此时运行到了哪里?我们不知道啊!<br>\n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)</p>\n</li>\n</ul>\n<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>\n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>协作式:<br>\n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>\n这种放弃执行权的操作, 我们称为<code>yield</code></p>\n</li>\n</ul>\n<p>比如在Rust中, <code>xxx.await</code>会执行一个Future  \t<br>\n意味着当程序执行到这里时, 可能会<code>yield</code>(poll返回Poll::Pending, 自愿放弃执行权)</p>\n<p><code>xxx.await</code>就是一个<code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>\n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>\n因此, 我们可以准确分配Future执行所需要的最大空间</p>\n<p>其实, 每个<code>.await(也就是yield point)</code>, 就代表着<code>一种状态</code>(之后会讲)</p>\n<p>协作式的好处在于:<br>\n能自己掌握所有<code>yield point</code>, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理<br>\n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的<br>\n在任务暂停并转让执行权前, 准确保存<code>下次继续所需要的状态</code>, 内存/性能优势很大<br>\n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行</p>\n<hr>\n<h1 id=\"zhuang-tai-ji-de-gai-nian\">状态机的概念</h1>\n<p>在Rust中的异步, 我们之前也说过, 属于<code>协作式多任务</code><br>\n而其<code>状态保存</code>的实现, 就是利用<code>状态机(state machine)</code>来实现</p>\n<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>, 是一种数学模型</p>\n<ol>\n<li class=\"lvl-3\">\n<p>状态(state):<br>\n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed</p>\n</li>\n<li class=\"lvl-3\">\n<p>事件(event):<br>\n某事件发生后, 会触发相应动作, 可能改变状态<br>\n比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p>\n</li>\n<li class=\"lvl-3\">\n<p>动作 (action):<br>\n事件发生后, 会触发动作</p>\n</li>\n<li class=\"lvl-3\">\n<p>变换 (transition):<br>\n<code>State_X=&gt;State_Y</code>就叫<code>变换</code>, 比如门的状态从<code>Open=&gt;Closed</code></p>\n</li>\n</ol>\n<p>稍微了解下<code>状态机</code>的概念即可</p>\n<p>那么现在, 就要看具体代码了</p>\n<p>如果你想亲自运行一下, 先确保你的<code>Cargo.toml</code>中的依赖如下:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>如下代码, 读取一个文件的行数<br>\n你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>\n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    env::args,</span><br><span class=\"line\">    process,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> async_std::&#123;</span><br><span class=\"line\">    prelude::*,</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).unwrap_or_else(||&#123;</span><br><span class=\"line\">        eprintln!(<span class=\"string\">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class=\"line\">        process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n<p>mian()产生一个新实例, 异步运行<code>open(path)</code>与<code>count()</code>  \t<br>\n对于编译器, 每一个<code>.await</code>其实都代表一种状态</p>\n<p>Future实例, 实际上是个状态机<br>\n在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Start: 此Future刚开始执行</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield1: 第一个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield2: 第二个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Done: 此Future执行完毕</p>\n</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>\n执行器调用当前Future的poll推动进度时, 若在<code>某一阶段</code>返回了<code>Poll::Pending</code>, 则放弃执行权<br>\n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态<code>恢复(resume)</code>, 继续执行</p>\n<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态</p>\n<p><strong>Note 1</strong>:<br>\nStart状态, 会存储传入函数的参数(如果有参数)</p>\n<p><strong>Note 2</strong>:<br>\nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的</p>\n<p><strong>Note 3</strong>:<br>\n怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br>\n<code>某个yield point之前定义,  且point之后还需要使用的变量</code><br>\n如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存, 因为从暂停中恢复后还需要使用<br>\n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>\n所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"zi-yin-yong-jie-gou-ti\">自引用结构体</h1>\n<h2 id=\"bao-cun-yin-yong\" id=\"保存引用\">保存引用</h2>\n<p>当每个状态存储数据时,  可能会导致发生<code>自引用</code>, 比如:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code>, 而在<code>Yield1</code>这个状态下, 存储的数据如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Yield1State</span></span> &#123;</span><br><span class=\"line\">    arr: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>], </span><br><span class=\"line\">    element: *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>, <span class=\"comment\">// 数组最后一个元素的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 状态的实例</span></span><br><span class=\"line\">Yield1State &#123;</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">    element: &amp;arr[<span class=\"number\">2</span>] <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等等, 你可能会对上面的代码有疑惑:<br>\n不是说, 状态只需要保存 <code>在yield point之前定义,  并且该point之后还需要使用的变量</code> 吗<br>\n上面的代码, 只有element这个引用需要被保存吧?</p>\n<p>这是因为, 它是<code>引用</code>嘛! 没了<code>引用</code>背后的实际数据, 那它还有啥用, 不就是<code>悬垂引用</code>了吗?<br>\n因此我们还得保存, <code>该引用</code>指向的背后数据: <code>arr</code>, 并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中<br>\n像这种 <code>结构体内部的指针, 指向结构体本身</code>, 就叫 <code>自引用结构</code></p>\n<p>比如上面代码: 同一结构体下, 成员element指向了成员arr</p>\n<h2 id=\"nei-cun-yi-dong-wen-ti\" id=\"内存移动问题\">内存移动问题</h2>\n<p>如上所述,  这可能导致悬垂引用的产生, 若该struct实例的<code>内存地址发生改变</code>, 如使用 <code>std::mem</code>, 让struct实例的内存地址发生移动<br>\n以上面的那段代码为例, 如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>arr:<br>\n内存地址会跟着结构体实例而改变, 但是,  <code>值仍然是 [1, 2, 3]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>element:<br>\n内存地址会跟着结构体实例而改变, 但是, 值仍然是<code>先前arr的地址</code>, <code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)<br>\n官方提出了<code>std::pin::Pin(trait)</code> 来解决自引用结构体方面的悬垂指针/引用问题</p>\n<p>其实你听名字也很好理解, <code>Pin(中文意思是钉子)</code>的作用是, 防止内存地址发生改变(给爷钉死吧!)<br>\n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了</p>\n<p>欲知后事如何,  且听下回分解<br>\n<s>(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>\n","site":{"data":{}},"length":3826,"excerpt":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>注</strong>: 参考了 &lt;&lt;Writing an OS in Rust&gt;&gt; 中的 async 篇,可以自己搜索下看看<br>\n为了更好地理解 <code>Rust异步</code>背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>多任务: 抢占式与协作式</p>\n</li>\n<li class=\"lvl-2\">\n<p>状态机</p>\n</li>\n<li class=\"lvl-2\">\n<p>自引用结构体</p>\n</li>\n</ul>\n<p>现在,让我们开始吧!</p>\n<hr>\n<h1 id=\"liang-chong-duo-ren-wu\">两种多任务</h1>\n<h2 id=\"jie-shao\" id=\"介绍\">介绍</h2>\n<p>抢占式 与 协作式, 是 多任务 的不同分类</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式多任务:<br>\n操作系统决定CPU的运行权<br>\n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会<br>\n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉<br>\n这是强迫/抢占的</p>\n</li>\n<li class=\"lvl-2\">\n<p>协作式多任务:<br>\n任务们本身进行协调, 决定CPU的运行权<br>\n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending<br>\n自己放弃继续执行, 并通知运行时执行其他Task<br>\n这是自愿/协作的, Task 们自愿放弃CPU的执行权</p>\n</li>\n</ul>\n<h2 id=\"zhuang-tai-de-hui-fu-bao-cun\" id=\"状态的恢复-保存\">状态的恢复/保存</h2>\n<p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>\n该任务,应当从先前暂停的地方开始, 继续执行<br>\n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存</p>\n<p>对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式:<br>\n因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>\n任务此时运行到了哪里?我们不知道啊!<br>\n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)</p>\n</li>\n</ul>\n<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>\n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>协作式:<br>\n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>\n这种放弃执行权的操作, 我们称为<code>yield</code></p>\n</li>\n</ul>\n<p>比如在Rust中, <code>xxx.await</code>会执行一个Future  \t<br>\n意味着当程序执行到这里时, 可能会<code>yield</code>(poll返回Poll::Pending, 自愿放弃执行权)</p>\n<p><code>xxx.await</code>就是一个<code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>\n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>\n因此, 我们可以准确分配Future执行所需要的最大空间</p>\n<p>其实, 每个<code>.await(也就是yield point)</code>, 就代表着<code>一种状态</code>(之后会讲)</p>\n<p>协作式的好处在于:<br>\n能自己掌握所有<code>yield point</code>, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理<br>\n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的<br>\n在任务暂停并转让执行权前, 准确保存<code>下次继续所需要的状态</code>, 内存/性能优势很大<br>\n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行</p>\n<hr>\n<h1 id=\"zhuang-tai-ji-de-gai-nian\">状态机的概念</h1>\n<p>在Rust中的异步, 我们之前也说过, 属于<code>协作式多任务</code><br>\n而其<code>状态保存</code>的实现, 就是利用<code>状态机(state machine)</code>来实现</p>\n<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>, 是一种数学模型</p>\n<ol>\n<li class=\"lvl-3\">\n<p>状态(state):<br>\n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed</p>\n</li>\n<li class=\"lvl-3\">\n<p>事件(event):<br>\n某事件发生后, 会触发相应动作, 可能改变状态<br>\n比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p>\n</li>\n<li class=\"lvl-3\">\n<p>动作 (action):<br>\n事件发生后, 会触发动作</p>\n</li>\n<li class=\"lvl-3\">\n<p>变换 (transition):<br>\n<code>State_X=&gt;State_Y</code>就叫<code>变换</code>, 比如门的状态从<code>Open=&gt;Closed</code></p>\n</li>\n</ol>\n<p>稍微了解下<code>状态机</code>的概念即可</p>\n<p>那么现在, 就要看具体代码了</p>\n<p>如果你想亲自运行一下, 先确保你的<code>Cargo.toml</code>中的依赖如下:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>如下代码, 读取一个文件的行数<br>\n你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>\n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    env::args,</span><br><span class=\"line\">    process,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> async_std::&#123;</span><br><span class=\"line\">    prelude::*,</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).unwrap_or_else(||&#123;</span><br><span class=\"line\">        eprintln!(<span class=\"string\">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class=\"line\">        process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n<p>mian()产生一个新实例, 异步运行<code>open(path)</code>与<code>count()</code>  \t<br>\n对于编译器, 每一个<code>.await</code>其实都代表一种状态</p>\n<p>Future实例, 实际上是个状态机<br>\n在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Start: 此Future刚开始执行</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield1: 第一个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield2: 第二个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Done: 此Future执行完毕</p>\n</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>\n执行器调用当前Future的poll推动进度时, 若在<code>某一阶段</code>返回了<code>Poll::Pending</code>, 则放弃执行权<br>\n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态<code>恢复(resume)</code>, 继续执行</p>\n<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态</p>\n<p><strong>Note 1</strong>:<br>\nStart状态, 会存储传入函数的参数(如果有参数)</p>\n<p><strong>Note 2</strong>:<br>\nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的</p>\n<p><strong>Note 3</strong>:<br>\n怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br>\n<code>某个yield point之前定义,  且point之后还需要使用的变量</code><br>\n如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存, 因为从暂停中恢复后还需要使用<br>\n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>\n所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"zi-yin-yong-jie-gou-ti\">自引用结构体</h1>\n<h2 id=\"bao-cun-yin-yong\" id=\"保存引用\">保存引用</h2>\n<p>当每个状态存储数据时,  可能会导致发生<code>自引用</code>, 比如:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code>, 而在<code>Yield1</code>这个状态下, 存储的数据如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Yield1State</span></span> &#123;</span><br><span class=\"line\">    arr: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>], </span><br><span class=\"line\">    element: *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>, <span class=\"comment\">// 数组最后一个元素的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 状态的实例</span></span><br><span class=\"line\">Yield1State &#123;</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">    element: &amp;arr[<span class=\"number\">2</span>] <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等等, 你可能会对上面的代码有疑惑:<br>\n不是说, 状态只需要保存 <code>在yield point之前定义,  并且该point之后还需要使用的变量</code> 吗<br>\n上面的代码, 只有element这个引用需要被保存吧?</p>\n<p>这是因为, 它是<code>引用</code>嘛! 没了<code>引用</code>背后的实际数据, 那它还有啥用, 不就是<code>悬垂引用</code>了吗?<br>\n因此我们还得保存, <code>该引用</code>指向的背后数据: <code>arr</code>, 并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中<br>\n像这种 <code>结构体内部的指针, 指向结构体本身</code>, 就叫 <code>自引用结构</code></p>\n<p>比如上面代码: 同一结构体下, 成员element指向了成员arr</p>\n<h2 id=\"nei-cun-yi-dong-wen-ti\" id=\"内存移动问题\">内存移动问题</h2>\n<p>如上所述,  这可能导致悬垂引用的产生, 若该struct实例的<code>内存地址发生改变</code>, 如使用 <code>std::mem</code>, 让struct实例的内存地址发生移动<br>\n以上面的那段代码为例, 如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>arr:<br>\n内存地址会跟着结构体实例而改变, 但是,  <code>值仍然是 [1, 2, 3]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>element:<br>\n内存地址会跟着结构体实例而改变, 但是, 值仍然是<code>先前arr的地址</code>, <code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)<br>\n官方提出了<code>std::pin::Pin(trait)</code> 来解决自引用结构体方面的悬垂指针/引用问题</p>\n<p>其实你听名字也很好理解, <code>Pin(中文意思是钉子)</code>的作用是, 防止内存地址发生改变(给爷钉死吧!)<br>\n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了</p>\n<p>欲知后事如何,  且听下回分解<br>\n<s>(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>"},{"title":"rust-async-p3~> Future","abbrlink":"posts/rust-async/p3","date":"2021-09-12T05:56:48.000Z","top":9897,"keywords":["Async","异步","Rust"],"is_series":true,"prev_post":["posts/rust-async/p2","异步简介"],"next_post":["posts/rust-async/p4","状态的保存与变换"],"_content":"> Rust 中的 Future/async/.await 说明  \n<!-- more -->  \n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧    \n\n本节, 我们将学习以下三个概念的大致含义:  \n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n- - -\n\n# Future\n## 概念\n`Future`,一个标准/核心库中的trait: `std/core::future::Future`   \n\n在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 `一次异步计算`, 可将其交给 `Runtime(运行时)` 来异步执行   \n\n`异步执行`, 也就是指:    \n- 其他异步任务阻塞时,当前异步任务有机会执行  \n- 当前异步任务阻塞时,其他异步任务有机会执行  \n\n总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别,举个例子你就明白了:  \n  \n假设有这么个父计算, 由两个子计算组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期  \n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算  \n(我们将`最顶层的父计算(top-level Future, 即最顶层的Future实例)`称为`Task(任务)`)  \n\n当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算  \n\n总结:  \n- Task 是一个顶层 Future 实例 (即一次顶层异步计算) \n- 一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future\n- Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算\n- Task 可以只是一次单独计算\n\n一个 Future, 可理解为是组成一个 Task 的最小单位 \n\n## 定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output: 代表 Future 执行完毕后, 产出的值的类型   \n- poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成\n- Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:  \n`Poll::Pending`: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)  \n`Poll::Ready(T)`: 指明该计算执行完毕, 并产出一个类型为 T 的值  \n\n- - -\n\n# Async  \nRust 为我们提供了关键字 async, 方便人们为某次计算实现 Future  \n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊  \nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例  \n\n来个例子,看看 async 的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n// 2 \nstruct HelloStr;\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的  \n看看它们两的返回值:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n注意, 异步函数的调用, 只是返回一个 Future实例  \n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户\n\n这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作  \n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可  \n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了\n\nasync 的作用就是创建一个 Future 实例, 以下是不同的语法糖:  \n- `async fn`: 异步函数, 要求返回一个 Future 实例   \n- `async block`: 异步代码块, 创建一个 Future 实例  \n- `async closure`: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?  \n请接着往下看\n\n- - -\n\n# 执行\n## 背景介绍  \nRust本身并不提供 `异步运行时 (async runtime)`, 以便语言内核精小, 便于进化/迭代/维护  \n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境  \n\n异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n因此它是可选的, 你可以凭借 `cartes.io` 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序  \n\n在开始下面的章节前, 请确保你已经在 `Cargo.toml` 中添加了如下代码  \n以 `async-std` 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:  \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n## Runtime\n\n我们先来创建一个打印 \"hello world\" 的 Future吧:   \n\n```rust\nuse async_std::task;\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?  \n`async_std::task` 提供了大量 API, 用来执行/操控这些 Task  \n\n如这里出现的`task::block_on`, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程  \n该任务执行完毕后产出的值,会作为 `block_on` 的返回值  \n\n我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n`.await` 关键字出场了! \n\n- - -\n\n# Await  \n`.await` 只能出现在 `async fn/block` 内部, 在某个 Future 变量后面添加 `.await` 后, 该 Future 就会执行  \n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future   \n\n来看看它的使用:  \n\n```rust\nuse async_std::task;\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await` 是一个标记点, 可理解为是一个 `yield point`, Runtime 执行到 `xxx.await` 时,先会执行一次 `xxx`  \n\n一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 `Poll::Pending` 或 `Poll::Ready(T)`  \n来决定做以下两件事中的哪一件:  \n- 让其他 Task 接管执行权(yield)  \n- 继续执行当前 Task  \n\n若为`Pending`: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)  \n若为`Ready`: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)  \n\n可能有点难理解, 来个简单粗暴理解版:  \n\n`.await` 指明 `执行某个Future` 这一逻辑  \n当 `xxx.await` 所在的 Task 交给 Runtime 并并执行到 `xxx.await` 时, `xxx` 这个 Future实例 会执行  \n\n若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行  \n若不阻塞, 就继续往下执行(可能还会碰见 `.await` 哟), 直到该 Task 结束   \n\n- - -  \n\n# 补充\n- `#[async_std::main]`  \n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰  \n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 `async_std::task::JoinHandle` 类型的实例  \n它实现了 Future, 与标准库中的 `JoinHandle` 无比相似, 不过 `join` 相应地改变为了 `.await`  \n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 `.await` 进行修饰哦:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n\n","source":"_posts/rust/async/p3-Future.md","raw":"---\ntitle: \"rust-async-p3~> Future\"\nabbrlink: posts/rust-async/p3\ndate: 2021-09-12 13:56:48\ntop: 9897\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\nis_series: true\nprev_post: [posts/rust-async/p2, 异步简介]\nnext_post: [posts/rust-async/p4, 状态的保存与变换]\n---\n> Rust 中的 Future/async/.await 说明  \n<!-- more -->  \n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧    \n\n本节, 我们将学习以下三个概念的大致含义:  \n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n- - -\n\n# Future\n## 概念\n`Future`,一个标准/核心库中的trait: `std/core::future::Future`   \n\n在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 `一次异步计算`, 可将其交给 `Runtime(运行时)` 来异步执行   \n\n`异步执行`, 也就是指:    \n- 其他异步任务阻塞时,当前异步任务有机会执行  \n- 当前异步任务阻塞时,其他异步任务有机会执行  \n\n总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别,举个例子你就明白了:  \n  \n假设有这么个父计算, 由两个子计算组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期  \n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算  \n(我们将`最顶层的父计算(top-level Future, 即最顶层的Future实例)`称为`Task(任务)`)  \n\n当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算  \n\n总结:  \n- Task 是一个顶层 Future 实例 (即一次顶层异步计算) \n- 一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future\n- Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算\n- Task 可以只是一次单独计算\n\n一个 Future, 可理解为是组成一个 Task 的最小单位 \n\n## 定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output: 代表 Future 执行完毕后, 产出的值的类型   \n- poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成\n- Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:  \n`Poll::Pending`: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)  \n`Poll::Ready(T)`: 指明该计算执行完毕, 并产出一个类型为 T 的值  \n\n- - -\n\n# Async  \nRust 为我们提供了关键字 async, 方便人们为某次计算实现 Future  \n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊  \nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例  \n\n来个例子,看看 async 的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n// 2 \nstruct HelloStr;\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的  \n看看它们两的返回值:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n注意, 异步函数的调用, 只是返回一个 Future实例  \n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户\n\n这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作  \n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可  \n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了\n\nasync 的作用就是创建一个 Future 实例, 以下是不同的语法糖:  \n- `async fn`: 异步函数, 要求返回一个 Future 实例   \n- `async block`: 异步代码块, 创建一个 Future 实例  \n- `async closure`: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?  \n请接着往下看\n\n- - -\n\n# 执行\n## 背景介绍  \nRust本身并不提供 `异步运行时 (async runtime)`, 以便语言内核精小, 便于进化/迭代/维护  \n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境  \n\n异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n因此它是可选的, 你可以凭借 `cartes.io` 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序  \n\n在开始下面的章节前, 请确保你已经在 `Cargo.toml` 中添加了如下代码  \n以 `async-std` 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:  \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n## Runtime\n\n我们先来创建一个打印 \"hello world\" 的 Future吧:   \n\n```rust\nuse async_std::task;\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?  \n`async_std::task` 提供了大量 API, 用来执行/操控这些 Task  \n\n如这里出现的`task::block_on`, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程  \n该任务执行完毕后产出的值,会作为 `block_on` 的返回值  \n\n我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n`.await` 关键字出场了! \n\n- - -\n\n# Await  \n`.await` 只能出现在 `async fn/block` 内部, 在某个 Future 变量后面添加 `.await` 后, 该 Future 就会执行  \n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future   \n\n来看看它的使用:  \n\n```rust\nuse async_std::task;\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await` 是一个标记点, 可理解为是一个 `yield point`, Runtime 执行到 `xxx.await` 时,先会执行一次 `xxx`  \n\n一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 `Poll::Pending` 或 `Poll::Ready(T)`  \n来决定做以下两件事中的哪一件:  \n- 让其他 Task 接管执行权(yield)  \n- 继续执行当前 Task  \n\n若为`Pending`: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)  \n若为`Ready`: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)  \n\n可能有点难理解, 来个简单粗暴理解版:  \n\n`.await` 指明 `执行某个Future` 这一逻辑  \n当 `xxx.await` 所在的 Task 交给 Runtime 并并执行到 `xxx.await` 时, `xxx` 这个 Future实例 会执行  \n\n若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行  \n若不阻塞, 就继续往下执行(可能还会碰见 `.await` 哟), 直到该 Task 结束   \n\n- - -  \n\n# 补充\n- `#[async_std::main]`  \n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰  \n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 `async_std::task::JoinHandle` 类型的实例  \n它实现了 Future, 与标准库中的 `JoinHandle` 无比相似, 不过 `join` 相应地改变为了 `.await`  \n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 `.await` 进行修饰哦:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n\n","slug":"rust/async/p3-Future","published":1,"updated":"2021-09-12T05:56:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogw001mj1s6hz1h5z7p","content":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明</p>\n</blockquote>\n<span id=\"more\"></span>  \n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧</p>\n<p>本节, 我们将学习以下三个概念的大致含义:<br>\n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future (trait)</p>\n</li>\n<li class=\"lvl-2\">\n<p>async (keyword)</p>\n</li>\n<li class=\"lvl-2\">\n<p>.await (keyword)</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"future\">Future</h1>\n<h2 id=\"gai-nian\" id=\"概念\">概念</h2>\n<p><code>Future</code>,一个标准/核心库中的trait: <code>std/core::future::Future</code></p>\n<p>在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 <code>一次异步计算</code>, 可将其交给 <code>Runtime(运行时)</code> 来异步执行</p>\n<p><code>异步执行</code>, 也就是指:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其他异步任务阻塞时,当前异步任务有机会执行</p>\n</li>\n<li class=\"lvl-2\">\n<p>当前异步任务阻塞时,其他异步任务有机会执行</p>\n</li>\n</ul>\n<p>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>异步 计算</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>异步 任务</code></p>\n</li>\n</ul>\n<p>两者有着区别,举个例子你就明白了:</p>\n<p>假设有这么个父计算, 由两个子计算组成:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Open: 先异步打开一个文件(async open)</p>\n</li>\n<li class=\"lvl-3\">\n<p>Read: 再异步读取该文件(async read)</p>\n</li>\n</ol>\n<p>我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>\n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算<br>\n(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p>\n<p>当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算</p>\n<p>总结:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Task 是一个顶层 Future 实例 (即一次顶层异步计算)</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 可以只是一次单独计算</p>\n</li>\n</ul>\n<p>一个 Future, 可理解为是组成一个 Task 的最小单位</p>\n<h2 id=\"ding-yi\" id=\"定义\">定义</h2>\n<p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future:<br>\n代表一次异步计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Output: 代表 Future 执行完毕后, 产出的值的类型</p>\n</li>\n<li class=\"lvl-2\">\n<p>poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成</p>\n</li>\n<li class=\"lvl-2\">\n<p>Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:<br>\n<code>Poll::Pending</code>: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br>\n<code>Poll::Ready(T)</code>: 指明该计算执行完毕, 并产出一个类型为 T 的值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"async\">Async</h1>\n<p>Rust 为我们提供了关键字 async, 方便人们为某次计算实现 Future<br>\n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊<br>\nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例</p>\n<p>来个例子,看看 async 的好处:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的<br>\n看看它们两的返回值:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n<p>注意, 异步函数的调用, 只是返回一个 Future实例<br>\n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户</p>\n<p>这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作<br>\n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可<br>\n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了</p>\n<p>async 的作用就是创建一个 Future 实例, 以下是不同的语法糖:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async fn</code>: 异步函数, 要求返回一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async block</code>: 异步代码块, 创建一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async closure</code>: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n<p>创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?<br>\n请接着往下看</p>\n<hr>\n<h1 id=\"zhi-xing\">执行</h1>\n<h2 id=\"bei-jing-jie-shao\" id=\"背景介绍\">背景介绍</h2>\n<p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>\n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境</p>\n<p>异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序<br>\n因此它是可选的, 你可以凭借 <code>cartes.io</code> 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序</p>\n<p>在开始下面的章节前, 请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码<br>\n以 <code>async-std</code> 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"runtime\" id=\"Runtime\">Runtime</h2>\n<p>我们先来创建一个打印 “hello world” 的 Future吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?<br>\n<code>async_std::task</code> 提供了大量 API, 用来执行/操控这些 Task</p>\n<p>如这里出现的<code>task::block_on</code>, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程<br>\n该任务执行完毕后产出的值,会作为 <code>block_on</code> 的返回值</p>\n<p>我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?<br>\n<code>.await</code> 关键字出场了!</p>\n<hr>\n<h1 id=\"await\">Await</h1>\n<p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部, 在某个 Future 变量后面添加 <code>.await</code> 后, 该 Future 就会执行<br>\n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>\n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future</p>\n<p>来看看它的使用:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>.await</code> 是一个标记点, 可理解为是一个 <code>yield point</code>, Runtime 执行到 <code>xxx.await</code> 时,先会执行一次 <code>xxx</code></p>\n<p>一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 <code>Poll::Pending</code> 或 <code>Poll::Ready(T)</code><br>\n来决定做以下两件事中的哪一件:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让其他 Task 接管执行权(yield)</p>\n</li>\n<li class=\"lvl-2\">\n<p>继续执行当前 Task</p>\n</li>\n</ul>\n<p>若为<code>Pending</code>: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)<br>\n若为<code>Ready</code>: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)</p>\n<p>可能有点难理解, 来个简单粗暴理解版:</p>\n<p><code>.await</code> 指明 <code>执行某个Future</code> 这一逻辑<br>\n当 <code>xxx.await</code> 所在的 Task 交给 Runtime 并并执行到 <code>xxx.await</code> 时, <code>xxx</code> 这个 Future实例 会执行</p>\n<p>若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行<br>\n若不阻塞, 就继续往下执行(可能还会碰见 <code>.await</code> 哟), 直到该 Task 结束</p>\n<hr>\n<h1 id=\"bu-chong\">补充</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#[async_std::main]</code><br>\n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰<br>\n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async_std::task::spawn</code><br>\n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 <code>async_std::task::JoinHandle</code> 类型的实例<br>\n它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似, 不过 <code>join</code> 相应地改变为了 <code>.await</code><br>\n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 <code>.await</code> 进行修饰哦:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":5078,"excerpt":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧</p>\n<p>本节, 我们将学习以下三个概念的大致含义:<br>\n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future (trait)</p>\n</li>\n<li class=\"lvl-2\">\n<p>async (keyword)</p>\n</li>\n<li class=\"lvl-2\">\n<p>.await (keyword)</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"future\">Future</h1>\n<h2 id=\"gai-nian\" id=\"概念\">概念</h2>\n<p><code>Future</code>,一个标准/核心库中的trait: <code>std/core::future::Future</code></p>\n<p>在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 <code>一次异步计算</code>, 可将其交给 <code>Runtime(运行时)</code> 来异步执行</p>\n<p><code>异步执行</code>, 也就是指:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其他异步任务阻塞时,当前异步任务有机会执行</p>\n</li>\n<li class=\"lvl-2\">\n<p>当前异步任务阻塞时,其他异步任务有机会执行</p>\n</li>\n</ul>\n<p>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>异步 计算</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>异步 任务</code></p>\n</li>\n</ul>\n<p>两者有着区别,举个例子你就明白了:</p>\n<p>假设有这么个父计算, 由两个子计算组成:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Open: 先异步打开一个文件(async open)</p>\n</li>\n<li class=\"lvl-3\">\n<p>Read: 再异步读取该文件(async read)</p>\n</li>\n</ol>\n<p>我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>\n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算<br>\n(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p>\n<p>当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算</p>\n<p>总结:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Task 是一个顶层 Future 实例 (即一次顶层异步计算)</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 可以只是一次单独计算</p>\n</li>\n</ul>\n<p>一个 Future, 可理解为是组成一个 Task 的最小单位</p>\n<h2 id=\"ding-yi\" id=\"定义\">定义</h2>\n<p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future:<br>\n代表一次异步计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Output: 代表 Future 执行完毕后, 产出的值的类型</p>\n</li>\n<li class=\"lvl-2\">\n<p>poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成</p>\n</li>\n<li class=\"lvl-2\">\n<p>Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:<br>\n<code>Poll::Pending</code>: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br>\n<code>Poll::Ready(T)</code>: 指明该计算执行完毕, 并产出一个类型为 T 的值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"async\">Async</h1>\n<p>Rust 为我们提供了关键字 async, 方便人们为某次计算实现 Future<br>\n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊<br>\nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例</p>\n<p>来个例子,看看 async 的好处:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的<br>\n看看它们两的返回值:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n<p>注意, 异步函数的调用, 只是返回一个 Future实例<br>\n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户</p>\n<p>这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作<br>\n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可<br>\n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了</p>\n<p>async 的作用就是创建一个 Future 实例, 以下是不同的语法糖:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async fn</code>: 异步函数, 要求返回一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async block</code>: 异步代码块, 创建一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async closure</code>: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n<p>创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?<br>\n请接着往下看</p>\n<hr>\n<h1 id=\"zhi-xing\">执行</h1>\n<h2 id=\"bei-jing-jie-shao\" id=\"背景介绍\">背景介绍</h2>\n<p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>\n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境</p>\n<p>异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序<br>\n因此它是可选的, 你可以凭借 <code>cartes.io</code> 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序</p>\n<p>在开始下面的章节前, 请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码<br>\n以 <code>async-std</code> 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"runtime\" id=\"Runtime\">Runtime</h2>\n<p>我们先来创建一个打印 “hello world” 的 Future吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?<br>\n<code>async_std::task</code> 提供了大量 API, 用来执行/操控这些 Task</p>\n<p>如这里出现的<code>task::block_on</code>, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程<br>\n该任务执行完毕后产出的值,会作为 <code>block_on</code> 的返回值</p>\n<p>我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?<br>\n<code>.await</code> 关键字出场了!</p>\n<hr>\n<h1 id=\"await\">Await</h1>\n<p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部, 在某个 Future 变量后面添加 <code>.await</code> 后, 该 Future 就会执行<br>\n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>\n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future</p>\n<p>来看看它的使用:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>.await</code> 是一个标记点, 可理解为是一个 <code>yield point</code>, Runtime 执行到 <code>xxx.await</code> 时,先会执行一次 <code>xxx</code></p>\n<p>一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 <code>Poll::Pending</code> 或 <code>Poll::Ready(T)</code><br>\n来决定做以下两件事中的哪一件:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让其他 Task 接管执行权(yield)</p>\n</li>\n<li class=\"lvl-2\">\n<p>继续执行当前 Task</p>\n</li>\n</ul>\n<p>若为<code>Pending</code>: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)<br>\n若为<code>Ready</code>: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)</p>\n<p>可能有点难理解, 来个简单粗暴理解版:</p>\n<p><code>.await</code> 指明 <code>执行某个Future</code> 这一逻辑<br>\n当 <code>xxx.await</code> 所在的 Task 交给 Runtime 并并执行到 <code>xxx.await</code> 时, <code>xxx</code> 这个 Future实例 会执行</p>\n<p>若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行<br>\n若不阻塞, 就继续往下执行(可能还会碰见 <code>.await</code> 哟), 直到该 Task 结束</p>\n<hr>\n<h1 id=\"bu-chong\">补充</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#[async_std::main]</code><br>\n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰<br>\n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async_std::task::spawn</code><br>\n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 <code>async_std::task::JoinHandle</code> 类型的实例<br>\n它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似, 不过 <code>join</code> 相应地改变为了 <code>.await</code><br>\n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 <code>.await</code> 进行修饰哦:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"clap-rs 简介","abbrlink":"posts/rust-clap/intro","hidden":false,"date":"2022-08-16T12:03:34.000Z","top":99995,"keywords":["Rust","Clap","CLI","命令行"],"_content":"> 了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能  \n<!-- more -->\n\n前置知识: Rust基础  \n完整代码: [github/jedsek/rust-wc](https://github.com/Jedsek/rust-wc)\n\n**注意**\n本项目基于当前最新版本的 clap, 也就是 version 4\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)\n\n推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手  \n官方教程: [derive tutorial](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)\n官方资料: [derive reference](https://docs.rs/clap/latest/clap/_derive/index.html)\n\n# 成品展示\n你可以通过如下命令, 从 [crates.io](https://crates.io) 上下载该成品, 可执行文件的名称是 `rwc`:  \n\n```bash\ncargo install rust-wc\n```\n\n以下是使用 [asciinema](https://asciinema.org/) 录制的展示:  \n\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n\n- - -\n\n# 基础概念\nCLI, 是 `command-line interface` 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理  \n如在Linux下常见的 `ls/cp/mv` 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出  \n\nGNU 项目提供了非常多的开源命令, 如 `wc`, 它可以统计文件的 bytes/char/line 的数量  \n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 `wc`  \n\n**注意:**  \ncli 可以代表抽象的界面, 也可以指代具体的某个程序  \n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等\n\n再写之前, 我们还应了解些基本概念 ~~(直接跳过感觉也木得问题??)~~:  \n\n- `参数(Arguments)`:  \n传给命令的参数, 比如一个路径 ~~(嘶, 感觉在说废话)~~\n\n- `选项(Options)`:\n通常以单/双横杠开头, 不同的options表示不同的行为  \n比如 `ls ./*`, 表示以默认行为下进行输出, `ls -l ./*` 以长列表形式输出, `ls -a ./*` 输出所有隐藏文件  \n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 `ls -i` 与 `ls --inode`  \n\n- `子命令(Subcommands)`:  \n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options  \n比如 `cargo build` 与 `cargo publish`, 都是 `cargo` 的子命令  \n\n- `双横杠(--)`:  \n在命令后面的某处位置, 加上 `--`, 可以将 `--` 后面的内容当作 argument 传入, 而非 options  \n举个例子, 我有个文件, 叫做 `--asd`, 我想使用 `cat --asd` 来输出里面的内容  \n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 `--asd` 这个option, 故失败  \n在比如有个文件叫 `--help`, 使用 `cat --help` 将会打印其 help 信息  \n此时, 你应该使用 `cat -- --asd`, 将 `--asd` 视作参数传入\n\n- `短/长帮助(short/long help)`:\n有些命令, `-h` 与 `--help` 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息\n\n- - -\n\n# 初始配置\n以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件  \n请自行创建好目录:  \n\n```\n./rust-wc\n├── Cargo.lock\n├── Cargo.toml\n└── src\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n   ├── lib.rs         # 声明模块, 类型别名\n   └── main.rs\n```\n\n让我们新建一个叫做 `rust-wc` 的项目, 然后在 `Cargo.toml` 中添加 clap 吧:\n\n```toml Cargo.toml\n# 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)\n[package]\nname = \"rust-wc\"\nauthors = [\"jedsek <jedsek@qq.com>\"]\nversion = \"0.0.1\"\ndescription = \"A GNU/wc implementation written in rust, which is faster when reading a large of big files\"\nedition = \"2021\"\n\n# 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`\n[[bin]]\nname = \"rwc\"\npath = \"src/main.rs\"\n\n# 指定依赖\n[dependencies]\nclap = {version = \"4.0.29\", features = [\"derive\"]}     # 解析参数\nunicode-width = \"0.1.10\"                               # 计算 Unicode 字符宽度\nindicatif = \"0.17.2\"                                   # 进度条\nprettytable-rs = \"0.9.0\"                               # 打印表格\nrayon = \"1.6.1\"                                        # 并行化\n```\n\n以下是 lib.rs 的内容:  \n\n```rust src/lib.rs\nuse std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n- - -\n\n# 命令定义\n\n**注意:**\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt  \n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap  \n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码  \n\n\n让我们来想象下这个命令:  \n\n- 必须接受一个参数\n- 参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容\n- 根据启用的 flag 来决定计算并打印哪些东西\n\n多亏了 derive 宏, 我们可以这样定义它, 下面是 `src/cli.rs` 的完整代码:  \n\n```rust src/cli.rs\nuse clap::{ArgGroup, Parser, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Parser)]  // 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 \n#[command(\n    author, version, about, subcommand_negates_reqs = true,\n    group(\n        ArgGroup::new(\"options\")\n            .multiple(true)\n            .required(true)\n            .args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])\n    ),\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n\n    /// Print the byte counts\n    #[arg(short, long)]\n    pub bytes: bool,\n\n    /// Print the character counts\n    #[arg(short, long)]\n    pub chars: bool,\n\n    /// Print the word counts\n    #[arg(short, long)]\n    pub words: bool,\n\n    /// Print the line counts\n    #[arg(short, long)]\n    pub lines: bool,\n\n    /// Print the maximum line width (Unicode)\n    #[arg(short = 'L', long)]\n    pub longest_line: bool,\n\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n\n\n// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n\nimpl Cli {\n    // 开启所有的 options\n    pub fn enable_all_options(&mut self) {\n        self.bytes = true;\n        self.chars = true;\n        self.words = true;\n        self.lines = true;\n        self.longest_line = true;\n    }\n        \n    // 返回启用的options, 类型是 Vec<&str>, 方便后面打印表格时, 作为表格的标题\n    pub fn get_enabled_options(&self) -> Vec<&'static str> {\n        let mut enabled_options = vec![];\n\n        self.bytes.then(|| enabled_options.push(\"Bytes\"));\n        self.chars.then(|| enabled_options.push(\"Chars\"));\n        self.words.then(|| enabled_options.push(\"Words\"));\n        self.lines.then(|| enabled_options.push(\"Lines\"));\n        self.longest_line.then(|| enabled_options.push(\"Maximum line width (Unicode)\"));\n\n        enabled_options\n    }\n}\n```\n\n以上的代码表示, 我们定义了一个 `Cli` 结构体, 表示对输入参数的建模  \n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型  \n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示  \n\nclap 以及为我们做好了一切 :)  \n\n我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:  \n\n```rust\nuse clap::Parser;\nuse rust_wc::{cli::Cli, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    Ok(())\n}\n```\n\n## 文档注释与帮助\n\n等下再解释, 现在先让我们看看效果, 查看下 help 吧:  \n\n```rust\ncargo run -- -h\n```\n\n```\nA GNU/wc clone written in rust, which is super faster when reading a large of big files\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n       rwc [PATH]... <COMMAND>\n\nCommands:\n  all   Enabled all available options\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  <PATH>...  The path(s) you should provide\n\nOptions:\n  -b, --bytes         Print the byte counts\n  -c, --chars         Print the character counts\n  -w, --words         Print the word counts\n  -l, --lines         Print the line counts\n  -L, --longest-line  Print the maximum line width (Unicode)\n  -h, --help          Print help information\n  -V, --version       Print version information\n```\n\n哇哦! 若你用这段文字, 对比下前面的 `src/cli.rs`, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息  \n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息  \n\n如果你不想要 `about` 信息直接照搬 `Cargo.toml` 里的 `description` 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:  \n\n```rust\n#[derive(Parser)]\n#[command(\n    about = \"...\",\n// ......\n// ......\n```\n\n并且, 像 author/version/about 等信息, 是通过读取 `Cargo.toml` 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁  \n你可以查看 [help_template](https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template) 知晓如何显示, 例子可能是 `builder形式`, 也就是非声明式, 但别慌张:  \n\n你可以像这样将 builder形式 的代码转化为 derive形式:  \n\n```rust\nCommand::new(\"myprog\")\n    .help_template(\"{bin} ({version}) - {usage}\")\n\n#[derive(Parser)]\n#[command(\n    help_template = \"{bin} ({version}) - {usage}\",\n// ......\n// ......\n```\n\n实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码  \n\n## 选项与参数的生成\nclap 能非常方便地以声明的方式, 定义选项/参数\n\n### 选项\n对于一个option, 比如 `-b/--bytes`, 你只需要这样写:  \n\n```rust\n/// Print the byte counts\n#[arg(short, long)]\npub bytes: bool,\n```\n\n它由三部分组成:  \n\n- 文档注释: help 中对该命令的解释\n- `#[arg(short, long)]`: 该 option 具有短/长横杠的形式\n- 类型为bool: 传入时默认的行为是将其设置为 true\n\n如 help 中所示, 会生成如下内容:\n\n```\nOptions:\n  -b, --bytes         Print the byte counts\n```\n\n当你传入该参数时, `Cli` 实例中的 `bytes` 属性将被设置为 true  \n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部  \n\n比如 `-l/--lines` 与 `-L/--longest-line`, 不指定时都是 `-l`, 编译会报错, 需要自己指定:  \n\n```rust\n/// Print the maximum line width (Unicode)\n#[arg(short = 'L', long)]\npub longest_line: bool,\n```\n\n### 参数\n当你没有添加 `short` 或 `long` 时, 自然就代表这是个 argument  \n\n在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径   \n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 `PATH`, 同时指定该参数必选, 防止路径数为0:  \n\n```rust\n/// The path(s) you should provide\n#[arg(value_name = \"PATH\", required = true)]\npub paths: Vec<PathBuf>,\n```\n\n如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:  \n\n```bash\ncargo run -- -b\n```\n\n```\nerror: The following required arguments were not provided:\n  <PATH>...\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n\nFor more information try '--help'\n```\n\n但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行  \n没错, clap 只是负责帮我们生成 `进行转换的代码`  \n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 :)  \n\n因此, 我们来学学如何使用自定义的参数解析器吧\n\n## 自定义参数解析器\n有些疑问或许会萦绕在你的心头:  \n- clap 是怎么进行解析的?\n- clap 能否将传入的参数, 解析为自定义的类型呢?  \n- 我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?\n\n实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证  \n比如, 如果我们想验证传入的路径是否合法, 可以这样写:  \n\n```rust\n// ......\n// ......\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n```\n\nGood, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误  \n该错误会在用户传入非法路径时, 作为报错信息出现:  \n\n```bash\ncargo run -- -b asdxxx\n```\n\n```\nerror: Invalid value \"asd\" for '<PATH>...': No such path: `asdxxx`\n\nFor more information try '--help'\n```\n\n于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser  \n得益于此, 你可以为任何类型定义对应的 parser\n\n## 参数关系\n有时候, 我们可能会面临这样或那样的问题:  \n\n- 当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用\n- 一个或多个指定的 option(s) 必须被启用\n- 多个指定的 options 可以同时被启用\n\n如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情  \n它叫做 `参数关系(Argument Relations)`, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改  \n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系\n\n实际上, 你先前在 `paths` 头上写的 `required = true`, 就是一种参数关系  \n\n以我们的 `rwc` 举个例子:  \n- `-b/-c/-w/-l/-L` 能同时出现, 即支持类似 `-b -c -w` 或 `-bcw` 的形式\n- `-b/-c/-w/-l/-L` 至少出现其中一个, 防止只传路径不传 option \n\n任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系  \n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 `-b/-c/-w/-l/-L` 都放入其中:  \n\n```rust\n// ......\n// ......\n#[derive(Parser)]\n#[command(\n    author, version, about, subcommand_negates_reqs = true,\n    group(\n        ArgGroup::new(\"options\")\n            .multiple(true)\n            .required(true)\n            .args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])\n    ),\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n```\n\n`multiple(true)` 表示可以同时出现参数组的成员, `required(true)` 表示至少传入该参数组中的其中一个成员  \n\n## 子命令\n我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数  \n\n```rust\npub struct Cli {\n// ......\n// ......\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n```\n\n你可以会想, 能不能让子命令复用 `Cli` 中定义的 `paths`, 减少重复代码呢?  \n当然可以, 请在 `Cli` 的成员 `paths`, 头上的`#[arg]` 中添加 `global = true`, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数  \n\n但非常遗憾, 当设置 `global = true` 后, 就无法设置 `required = true` 了, 因此我们还是得定义一份相同的参数, 详见 [相关issue](https://github.com/clap-rs/clap/issues/1546)\n\n**注意:**  \n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入  \n但本文还是定义了 subcommand 以便读者了解, 起演示作用\n\n\n- - -\n# 逻辑实现\n根据:\n\n```\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n```\n\n我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了  \n为了避免你回到前面看 `lib.rs` 的内容, 下面再贴一遍:  \n\n```rust src/lib.rs\nuse std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:  \n\n{% tabs 逻辑实现代码 %}\n\n<!-- tab 读取文件 -->\n\n```rust src/files.rs\n// 声明依赖\n// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好\nuse crate::{PathWithContent, Result};\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse rayon::prelude::*;\nuse std::ffi::OsStr;\nuse std::process;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{\n    fs::File,\n    io::{BufReader, Read},\n    path::PathBuf,\n};\n\n\n// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果\n// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)\nstatic INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(0);\nconst BUFFER_SIZR: usize = 16 * 1024;\n\n\n// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀\n// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下\n// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰\ntrait PathExt {\n    fn without_dotted_prefix(&self) -> bool;\n    fn add_dotted_prefix(&mut self);\n}\n\nimpl PathExt for PathBuf {\n    fn without_dotted_prefix(&self) -> bool {\n        self.is_relative() && !self.starts_with(\"../\") && !self.starts_with(\"./\")\n    }\n\n    fn add_dotted_prefix(&mut self) {\n        *self = PathBuf::from_iter([OsStr::new(\"./\"), self.as_os_str()]);\n    }\n}\n\n\n// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组\npub fn read_files(paths: Vec<PathBuf>) -> Result<PathWithContent> {\n    println!(\"Reading files / Getting content from stdin:\");\n\n    // 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧\n    let result = paths\n        .into_par_iter()\n        .filter(|path| path.is_file() || path.as_os_str() == \"-\")\n        .map(|mut path| {\n            let should_read_from_input = path.as_os_str() == \"-\";\n\n            let content = get_content(&path, should_read_from_input);\n\n            if path.without_dotted_prefix() {\n                path.add_dotted_prefix();\n            }\n\n            if should_read_from_input {\n                let inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(1, Ordering::SeqCst);\n                path = PathBuf::from(format!(\"Input/{}\", inputted_file_number));\n            }\n\n            let content = content.unwrap_or_else(|err| {\n                eprintln!(\"{}: {}\", path.display(), err);\n                process::exit(1);\n            });\n\n            (path, content)\n        })\n        .collect();\n    Ok(result)\n}\n\n\n// helper 函数, 针对单个路径\nfn get_content(path: &PathBuf, should_read_from_input: bool) -> Result<String> {\n    if should_read_from_input {\n        read_from_stdin()\n    } else {\n        let bars = MultiProgress::new();\n        let style =\n            ProgressStyle::with_template(\"[{elapsed}][{percent}%] {bar:45.cyan/blue} {bytes} {wide_msg}\")?\n                .progress_chars(\">-\");\n        read_file_with_progress(path, style, bars)\n    }\n}\n\n\n// 读取对应路径的文件\nfn read_file_with_progress(path: &PathBuf, style: ProgressStyle, bars: MultiProgress) -> Result<String> {\n    let mut content = String::new();\n\n    let file = File::open(path)?;\n    let size = file.metadata()?.len();\n\n    let bar = ProgressBar::new(size).with_message(format! {\"Reading {}\", path.display()}).with_style(style);\n    let bar = bars.add(bar);\n\n    let mut bufreader = BufReader::new(file);\n    let mut buf = [0; BUFFER_SIZR];\n\n    while let Ok(n) = bufreader.read(&mut buf) {\n        if n == 0 {\n            break;\n        }\n        bar.inc(n as u64);\n        content += &String::from_utf8_lossy(&buf[..n]);\n    }\n    bar.finish_with_message(\"Done!\");\n\n    Ok(content)\n}\n\n\n// 从 stdin 中读取, 作为临时文件的内容\nfn read_from_stdin() -> Result<String> {\n    let mut content = vec![];\n    std::io::stdin().read_to_end(&mut content)?;\n    Ok(String::from_utf8(content)?)\n}\n```\n\n<!-- endtab -->\n\n<!-- tab  进行计算 -->\n\n```rust src/wc_result.rs\n// 声明依赖\nuse crate::{\n    cli::{Cli, SubCommands},\n    files::read_files,\n    Counts, Result,\n};\nuse prettytable::{cell, format::consts::FORMAT_BOX_CHARS, Row, Table};\nuse rayon::prelude::*;\nuse std::{collections::HashMap, path::PathBuf, str};\n\n\n// 存放被启用的 options, 与键值对\npub struct WcResult {\n    enabled_options: Vec<&'static str>,\n    paths_with_counts: HashMap<PathBuf, Counts>,\n}\n\n\n// 实例化函数\npub fn get(mut cli: Cli) -> Result<WcResult> {\n    println!(\"Please waiting...\\n\");\n\n    // 根据子命令进行相应操作\n    match cli.sub_commands {\n        Some(SubCommands::All { ref paths }) => {\n            cli.paths = paths.clone();\n            cli.enable_all_options();\n        }\n        None => cli.enable_all_options(),\n    };\n\n    // 进行计算\n    println!(\"Calculating...\");\n    let wc_result = WcResult {\n        enabled_options: cli.get_enabled_options(),\n        paths_with_counts: {\n            let contents = read_files(cli.paths.clone())?;\n            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&cli, content))).collect()\n        },\n    };\n\n    Ok(wc_result)\n}\n\n\nimpl WcResult {\n    // 将保存的信息转化为美化后的表格\n    pub fn to_pretty_table(self) -> Table {\n        let titles = {\n            let enabled_options = self.enabled_options;\n            let mut titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -> x)).collect());\n            titles.insert_cell(0, cell!(Fybi -> \"Path\"));\n            titles\n        };\n\n        let mut table = Table::new();\n        table.set_titles(titles);\n        table.set_format(*FORMAT_BOX_CHARS);\n\n        for (path, counts) in self.paths_with_counts {\n            let mut row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());\n            let path_cell = if path.starts_with(\"Input\") {\n                cell!(Fbb -> path.display())\n            } else {\n                cell!(Fmb -> path.display())\n            };\n\n            row.insert_cell(0, path_cell);\n            table.add_row(row);\n        }\n\n        table\n    }\n}\n\n\n// 不太懂 rayon, 暂时这样糊上去了\nfn calculate_counts(cli: &Cli, content: String) -> Counts {\n    let v: Vec<Option<usize>> = vec![None; 5];\n    v.into_par_iter()\n        .enumerate()\n        .map(|(idx, _)| match idx {\n            0 => cli.bytes.then_some(content.len()),\n            1 => cli.chars.then_some(content.chars().count()),\n            2 => cli.words.then_some(content.split_whitespace().count()),\n            3 => cli.lines.then_some(content.lines().count()),\n            4 => cli\n                .longest_line\n                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(0)),\n            _ => None,\n        })\n        .flatten()\n        .collect()\n}\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n然后就是 main 函数:  \n\n```rust src/main.rs\nuse clap::Parser;\nuse rust_wc::{cli::Cli, wc_result, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    let pretty_table = wc_result::get(cli)?.to_pretty_table();\n    pretty_table.printstd();\n    Ok(())\n}\n```\n\n- - -\n\n# 自动补全\n我们已经写好了命令行程序, 可以通过 -h/--help 查看帮助信息, 但能不能更方便地与 shell 集成呢?  \n比如, 当你使用 bash/zsh/fish 时, 输入命令后点 Tab, 能帮你自动显示该命令的 flag/subcommand  \n\n我们将使用 `clap_complete` 这个库, 在编译器生成特定于 shell 的自动补全文件 (也可以运行时生成, 自看 [clap_complete](https://docs.rs/clap_complete/latest/clap_complete/) 的文档)  \n首先要修改 `Cargo.toml`, 在后面添加 [`build-dependencies`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#build-dependencies):  \n\n```toml Cargo.toml\n[build-dependencies]\nclap = {version = \"4.0.29\", features = [\"derive\"]}\nclap_complete = \"4.0.6\"\n```\n\n在项目根目录下添加 `build.rs`, 内容如下:  \n\n```rust\nuse clap::CommandFactory;\nuse clap_complete::{generate_to, shells::*};\nuse std::error::Error;\n\ninclude!(\"src/cli.rs\");\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let outdir = \"completions\";\n    let app_name = \"rwc\";\n    let mut cmd = Cli::command();\n\n    generate_to(Bash, &mut cmd, app_name, outdir)?;\n    generate_to(Zsh, &mut cmd, app_name, outdir)?;\n    generate_to(Fish, &mut cmd, app_name, outdir)?;\n    generate_to(Elvish, &mut cmd, app_name, outdir)?;\n    generate_to(PowerShell, &mut cmd, app_name, outdir)?;\n\n    Ok(())\n}\n```\n\n目前, clap_complete 仅支持以上几种 shell, 更多的偏小众 shell, 一般以 `clap_complete_xxx` 的形式出现在 `crates.io` 上  \n比如 `clap_complete_nushell`, 但亲测质量不佳, 不建议使用  \n\n同时, 请确保项目根目录下存在 `completions` 目录, 随后运行 `cargo build`, 通过 `tree` 命令可以看到生成的补全文件:  \n\n```bash\ncompletions\n├── _rwc\n├── rwc.bash\n├── rwc.elv\n├── rwc.fish\n└── _rwc.ps1\n```\n\n就酱, 本文结束啦!  \n希望本文能帮到你, 让你快速了解使用 clap 的流程 :)","source":"_posts/rust/clap/intro.md","raw":"---\ntitle: \"clap-rs 简介\"\nabbrlink: posts/rust-clap/intro\nhidden: false\ndate: 2022-08-16 20:03:34\ntop: 99995\ntags: [Rust, Clap, CLI]\nkeywords: [Rust, Clap, CLI, 命令行]\n---\n> 了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能  \n<!-- more -->\n\n前置知识: Rust基础  \n完整代码: [github/jedsek/rust-wc](https://github.com/Jedsek/rust-wc)\n\n**注意**\n本项目基于当前最新版本的 clap, 也就是 version 4\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)\n\n推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手  \n官方教程: [derive tutorial](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)\n官方资料: [derive reference](https://docs.rs/clap/latest/clap/_derive/index.html)\n\n# 成品展示\n你可以通过如下命令, 从 [crates.io](https://crates.io) 上下载该成品, 可执行文件的名称是 `rwc`:  \n\n```bash\ncargo install rust-wc\n```\n\n以下是使用 [asciinema](https://asciinema.org/) 录制的展示:  \n\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n\n- - -\n\n# 基础概念\nCLI, 是 `command-line interface` 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理  \n如在Linux下常见的 `ls/cp/mv` 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出  \n\nGNU 项目提供了非常多的开源命令, 如 `wc`, 它可以统计文件的 bytes/char/line 的数量  \n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 `wc`  \n\n**注意:**  \ncli 可以代表抽象的界面, 也可以指代具体的某个程序  \n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等\n\n再写之前, 我们还应了解些基本概念 ~~(直接跳过感觉也木得问题??)~~:  \n\n- `参数(Arguments)`:  \n传给命令的参数, 比如一个路径 ~~(嘶, 感觉在说废话)~~\n\n- `选项(Options)`:\n通常以单/双横杠开头, 不同的options表示不同的行为  \n比如 `ls ./*`, 表示以默认行为下进行输出, `ls -l ./*` 以长列表形式输出, `ls -a ./*` 输出所有隐藏文件  \n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 `ls -i` 与 `ls --inode`  \n\n- `子命令(Subcommands)`:  \n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options  \n比如 `cargo build` 与 `cargo publish`, 都是 `cargo` 的子命令  \n\n- `双横杠(--)`:  \n在命令后面的某处位置, 加上 `--`, 可以将 `--` 后面的内容当作 argument 传入, 而非 options  \n举个例子, 我有个文件, 叫做 `--asd`, 我想使用 `cat --asd` 来输出里面的内容  \n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 `--asd` 这个option, 故失败  \n在比如有个文件叫 `--help`, 使用 `cat --help` 将会打印其 help 信息  \n此时, 你应该使用 `cat -- --asd`, 将 `--asd` 视作参数传入\n\n- `短/长帮助(short/long help)`:\n有些命令, `-h` 与 `--help` 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息\n\n- - -\n\n# 初始配置\n以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件  \n请自行创建好目录:  \n\n```\n./rust-wc\n├── Cargo.lock\n├── Cargo.toml\n└── src\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n   ├── lib.rs         # 声明模块, 类型别名\n   └── main.rs\n```\n\n让我们新建一个叫做 `rust-wc` 的项目, 然后在 `Cargo.toml` 中添加 clap 吧:\n\n```toml Cargo.toml\n# 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)\n[package]\nname = \"rust-wc\"\nauthors = [\"jedsek <jedsek@qq.com>\"]\nversion = \"0.0.1\"\ndescription = \"A GNU/wc implementation written in rust, which is faster when reading a large of big files\"\nedition = \"2021\"\n\n# 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`\n[[bin]]\nname = \"rwc\"\npath = \"src/main.rs\"\n\n# 指定依赖\n[dependencies]\nclap = {version = \"4.0.29\", features = [\"derive\"]}     # 解析参数\nunicode-width = \"0.1.10\"                               # 计算 Unicode 字符宽度\nindicatif = \"0.17.2\"                                   # 进度条\nprettytable-rs = \"0.9.0\"                               # 打印表格\nrayon = \"1.6.1\"                                        # 并行化\n```\n\n以下是 lib.rs 的内容:  \n\n```rust src/lib.rs\nuse std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n- - -\n\n# 命令定义\n\n**注意:**\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt  \n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap  \n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码  \n\n\n让我们来想象下这个命令:  \n\n- 必须接受一个参数\n- 参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容\n- 根据启用的 flag 来决定计算并打印哪些东西\n\n多亏了 derive 宏, 我们可以这样定义它, 下面是 `src/cli.rs` 的完整代码:  \n\n```rust src/cli.rs\nuse clap::{ArgGroup, Parser, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Parser)]  // 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 \n#[command(\n    author, version, about, subcommand_negates_reqs = true,\n    group(\n        ArgGroup::new(\"options\")\n            .multiple(true)\n            .required(true)\n            .args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])\n    ),\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n\n    /// Print the byte counts\n    #[arg(short, long)]\n    pub bytes: bool,\n\n    /// Print the character counts\n    #[arg(short, long)]\n    pub chars: bool,\n\n    /// Print the word counts\n    #[arg(short, long)]\n    pub words: bool,\n\n    /// Print the line counts\n    #[arg(short, long)]\n    pub lines: bool,\n\n    /// Print the maximum line width (Unicode)\n    #[arg(short = 'L', long)]\n    pub longest_line: bool,\n\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n\n\n// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n\nimpl Cli {\n    // 开启所有的 options\n    pub fn enable_all_options(&mut self) {\n        self.bytes = true;\n        self.chars = true;\n        self.words = true;\n        self.lines = true;\n        self.longest_line = true;\n    }\n        \n    // 返回启用的options, 类型是 Vec<&str>, 方便后面打印表格时, 作为表格的标题\n    pub fn get_enabled_options(&self) -> Vec<&'static str> {\n        let mut enabled_options = vec![];\n\n        self.bytes.then(|| enabled_options.push(\"Bytes\"));\n        self.chars.then(|| enabled_options.push(\"Chars\"));\n        self.words.then(|| enabled_options.push(\"Words\"));\n        self.lines.then(|| enabled_options.push(\"Lines\"));\n        self.longest_line.then(|| enabled_options.push(\"Maximum line width (Unicode)\"));\n\n        enabled_options\n    }\n}\n```\n\n以上的代码表示, 我们定义了一个 `Cli` 结构体, 表示对输入参数的建模  \n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型  \n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示  \n\nclap 以及为我们做好了一切 :)  \n\n我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:  \n\n```rust\nuse clap::Parser;\nuse rust_wc::{cli::Cli, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    Ok(())\n}\n```\n\n## 文档注释与帮助\n\n等下再解释, 现在先让我们看看效果, 查看下 help 吧:  \n\n```rust\ncargo run -- -h\n```\n\n```\nA GNU/wc clone written in rust, which is super faster when reading a large of big files\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n       rwc [PATH]... <COMMAND>\n\nCommands:\n  all   Enabled all available options\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  <PATH>...  The path(s) you should provide\n\nOptions:\n  -b, --bytes         Print the byte counts\n  -c, --chars         Print the character counts\n  -w, --words         Print the word counts\n  -l, --lines         Print the line counts\n  -L, --longest-line  Print the maximum line width (Unicode)\n  -h, --help          Print help information\n  -V, --version       Print version information\n```\n\n哇哦! 若你用这段文字, 对比下前面的 `src/cli.rs`, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息  \n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息  \n\n如果你不想要 `about` 信息直接照搬 `Cargo.toml` 里的 `description` 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:  \n\n```rust\n#[derive(Parser)]\n#[command(\n    about = \"...\",\n// ......\n// ......\n```\n\n并且, 像 author/version/about 等信息, 是通过读取 `Cargo.toml` 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁  \n你可以查看 [help_template](https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template) 知晓如何显示, 例子可能是 `builder形式`, 也就是非声明式, 但别慌张:  \n\n你可以像这样将 builder形式 的代码转化为 derive形式:  \n\n```rust\nCommand::new(\"myprog\")\n    .help_template(\"{bin} ({version}) - {usage}\")\n\n#[derive(Parser)]\n#[command(\n    help_template = \"{bin} ({version}) - {usage}\",\n// ......\n// ......\n```\n\n实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码  \n\n## 选项与参数的生成\nclap 能非常方便地以声明的方式, 定义选项/参数\n\n### 选项\n对于一个option, 比如 `-b/--bytes`, 你只需要这样写:  \n\n```rust\n/// Print the byte counts\n#[arg(short, long)]\npub bytes: bool,\n```\n\n它由三部分组成:  \n\n- 文档注释: help 中对该命令的解释\n- `#[arg(short, long)]`: 该 option 具有短/长横杠的形式\n- 类型为bool: 传入时默认的行为是将其设置为 true\n\n如 help 中所示, 会生成如下内容:\n\n```\nOptions:\n  -b, --bytes         Print the byte counts\n```\n\n当你传入该参数时, `Cli` 实例中的 `bytes` 属性将被设置为 true  \n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部  \n\n比如 `-l/--lines` 与 `-L/--longest-line`, 不指定时都是 `-l`, 编译会报错, 需要自己指定:  \n\n```rust\n/// Print the maximum line width (Unicode)\n#[arg(short = 'L', long)]\npub longest_line: bool,\n```\n\n### 参数\n当你没有添加 `short` 或 `long` 时, 自然就代表这是个 argument  \n\n在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径   \n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 `PATH`, 同时指定该参数必选, 防止路径数为0:  \n\n```rust\n/// The path(s) you should provide\n#[arg(value_name = \"PATH\", required = true)]\npub paths: Vec<PathBuf>,\n```\n\n如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:  \n\n```bash\ncargo run -- -b\n```\n\n```\nerror: The following required arguments were not provided:\n  <PATH>...\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n\nFor more information try '--help'\n```\n\n但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行  \n没错, clap 只是负责帮我们生成 `进行转换的代码`  \n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 :)  \n\n因此, 我们来学学如何使用自定义的参数解析器吧\n\n## 自定义参数解析器\n有些疑问或许会萦绕在你的心头:  \n- clap 是怎么进行解析的?\n- clap 能否将传入的参数, 解析为自定义的类型呢?  \n- 我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?\n\n实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证  \n比如, 如果我们想验证传入的路径是否合法, 可以这样写:  \n\n```rust\n// ......\n// ......\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n```\n\nGood, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误  \n该错误会在用户传入非法路径时, 作为报错信息出现:  \n\n```bash\ncargo run -- -b asdxxx\n```\n\n```\nerror: Invalid value \"asd\" for '<PATH>...': No such path: `asdxxx`\n\nFor more information try '--help'\n```\n\n于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser  \n得益于此, 你可以为任何类型定义对应的 parser\n\n## 参数关系\n有时候, 我们可能会面临这样或那样的问题:  \n\n- 当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用\n- 一个或多个指定的 option(s) 必须被启用\n- 多个指定的 options 可以同时被启用\n\n如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情  \n它叫做 `参数关系(Argument Relations)`, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改  \n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系\n\n实际上, 你先前在 `paths` 头上写的 `required = true`, 就是一种参数关系  \n\n以我们的 `rwc` 举个例子:  \n- `-b/-c/-w/-l/-L` 能同时出现, 即支持类似 `-b -c -w` 或 `-bcw` 的形式\n- `-b/-c/-w/-l/-L` 至少出现其中一个, 防止只传路径不传 option \n\n任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系  \n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 `-b/-c/-w/-l/-L` 都放入其中:  \n\n```rust\n// ......\n// ......\n#[derive(Parser)]\n#[command(\n    author, version, about, subcommand_negates_reqs = true,\n    group(\n        ArgGroup::new(\"options\")\n            .multiple(true)\n            .required(true)\n            .args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])\n    ),\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n```\n\n`multiple(true)` 表示可以同时出现参数组的成员, `required(true)` 表示至少传入该参数组中的其中一个成员  \n\n## 子命令\n我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数  \n\n```rust\npub struct Cli {\n// ......\n// ......\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n```\n\n你可以会想, 能不能让子命令复用 `Cli` 中定义的 `paths`, 减少重复代码呢?  \n当然可以, 请在 `Cli` 的成员 `paths`, 头上的`#[arg]` 中添加 `global = true`, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数  \n\n但非常遗憾, 当设置 `global = true` 后, 就无法设置 `required = true` 了, 因此我们还是得定义一份相同的参数, 详见 [相关issue](https://github.com/clap-rs/clap/issues/1546)\n\n**注意:**  \n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入  \n但本文还是定义了 subcommand 以便读者了解, 起演示作用\n\n\n- - -\n# 逻辑实现\n根据:\n\n```\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n```\n\n我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了  \n为了避免你回到前面看 `lib.rs` 的内容, 下面再贴一遍:  \n\n```rust src/lib.rs\nuse std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:  \n\n{% tabs 逻辑实现代码 %}\n\n<!-- tab 读取文件 -->\n\n```rust src/files.rs\n// 声明依赖\n// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好\nuse crate::{PathWithContent, Result};\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse rayon::prelude::*;\nuse std::ffi::OsStr;\nuse std::process;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{\n    fs::File,\n    io::{BufReader, Read},\n    path::PathBuf,\n};\n\n\n// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果\n// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)\nstatic INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(0);\nconst BUFFER_SIZR: usize = 16 * 1024;\n\n\n// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀\n// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下\n// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰\ntrait PathExt {\n    fn without_dotted_prefix(&self) -> bool;\n    fn add_dotted_prefix(&mut self);\n}\n\nimpl PathExt for PathBuf {\n    fn without_dotted_prefix(&self) -> bool {\n        self.is_relative() && !self.starts_with(\"../\") && !self.starts_with(\"./\")\n    }\n\n    fn add_dotted_prefix(&mut self) {\n        *self = PathBuf::from_iter([OsStr::new(\"./\"), self.as_os_str()]);\n    }\n}\n\n\n// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组\npub fn read_files(paths: Vec<PathBuf>) -> Result<PathWithContent> {\n    println!(\"Reading files / Getting content from stdin:\");\n\n    // 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧\n    let result = paths\n        .into_par_iter()\n        .filter(|path| path.is_file() || path.as_os_str() == \"-\")\n        .map(|mut path| {\n            let should_read_from_input = path.as_os_str() == \"-\";\n\n            let content = get_content(&path, should_read_from_input);\n\n            if path.without_dotted_prefix() {\n                path.add_dotted_prefix();\n            }\n\n            if should_read_from_input {\n                let inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(1, Ordering::SeqCst);\n                path = PathBuf::from(format!(\"Input/{}\", inputted_file_number));\n            }\n\n            let content = content.unwrap_or_else(|err| {\n                eprintln!(\"{}: {}\", path.display(), err);\n                process::exit(1);\n            });\n\n            (path, content)\n        })\n        .collect();\n    Ok(result)\n}\n\n\n// helper 函数, 针对单个路径\nfn get_content(path: &PathBuf, should_read_from_input: bool) -> Result<String> {\n    if should_read_from_input {\n        read_from_stdin()\n    } else {\n        let bars = MultiProgress::new();\n        let style =\n            ProgressStyle::with_template(\"[{elapsed}][{percent}%] {bar:45.cyan/blue} {bytes} {wide_msg}\")?\n                .progress_chars(\">-\");\n        read_file_with_progress(path, style, bars)\n    }\n}\n\n\n// 读取对应路径的文件\nfn read_file_with_progress(path: &PathBuf, style: ProgressStyle, bars: MultiProgress) -> Result<String> {\n    let mut content = String::new();\n\n    let file = File::open(path)?;\n    let size = file.metadata()?.len();\n\n    let bar = ProgressBar::new(size).with_message(format! {\"Reading {}\", path.display()}).with_style(style);\n    let bar = bars.add(bar);\n\n    let mut bufreader = BufReader::new(file);\n    let mut buf = [0; BUFFER_SIZR];\n\n    while let Ok(n) = bufreader.read(&mut buf) {\n        if n == 0 {\n            break;\n        }\n        bar.inc(n as u64);\n        content += &String::from_utf8_lossy(&buf[..n]);\n    }\n    bar.finish_with_message(\"Done!\");\n\n    Ok(content)\n}\n\n\n// 从 stdin 中读取, 作为临时文件的内容\nfn read_from_stdin() -> Result<String> {\n    let mut content = vec![];\n    std::io::stdin().read_to_end(&mut content)?;\n    Ok(String::from_utf8(content)?)\n}\n```\n\n<!-- endtab -->\n\n<!-- tab  进行计算 -->\n\n```rust src/wc_result.rs\n// 声明依赖\nuse crate::{\n    cli::{Cli, SubCommands},\n    files::read_files,\n    Counts, Result,\n};\nuse prettytable::{cell, format::consts::FORMAT_BOX_CHARS, Row, Table};\nuse rayon::prelude::*;\nuse std::{collections::HashMap, path::PathBuf, str};\n\n\n// 存放被启用的 options, 与键值对\npub struct WcResult {\n    enabled_options: Vec<&'static str>,\n    paths_with_counts: HashMap<PathBuf, Counts>,\n}\n\n\n// 实例化函数\npub fn get(mut cli: Cli) -> Result<WcResult> {\n    println!(\"Please waiting...\\n\");\n\n    // 根据子命令进行相应操作\n    match cli.sub_commands {\n        Some(SubCommands::All { ref paths }) => {\n            cli.paths = paths.clone();\n            cli.enable_all_options();\n        }\n        None => cli.enable_all_options(),\n    };\n\n    // 进行计算\n    println!(\"Calculating...\");\n    let wc_result = WcResult {\n        enabled_options: cli.get_enabled_options(),\n        paths_with_counts: {\n            let contents = read_files(cli.paths.clone())?;\n            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&cli, content))).collect()\n        },\n    };\n\n    Ok(wc_result)\n}\n\n\nimpl WcResult {\n    // 将保存的信息转化为美化后的表格\n    pub fn to_pretty_table(self) -> Table {\n        let titles = {\n            let enabled_options = self.enabled_options;\n            let mut titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -> x)).collect());\n            titles.insert_cell(0, cell!(Fybi -> \"Path\"));\n            titles\n        };\n\n        let mut table = Table::new();\n        table.set_titles(titles);\n        table.set_format(*FORMAT_BOX_CHARS);\n\n        for (path, counts) in self.paths_with_counts {\n            let mut row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());\n            let path_cell = if path.starts_with(\"Input\") {\n                cell!(Fbb -> path.display())\n            } else {\n                cell!(Fmb -> path.display())\n            };\n\n            row.insert_cell(0, path_cell);\n            table.add_row(row);\n        }\n\n        table\n    }\n}\n\n\n// 不太懂 rayon, 暂时这样糊上去了\nfn calculate_counts(cli: &Cli, content: String) -> Counts {\n    let v: Vec<Option<usize>> = vec![None; 5];\n    v.into_par_iter()\n        .enumerate()\n        .map(|(idx, _)| match idx {\n            0 => cli.bytes.then_some(content.len()),\n            1 => cli.chars.then_some(content.chars().count()),\n            2 => cli.words.then_some(content.split_whitespace().count()),\n            3 => cli.lines.then_some(content.lines().count()),\n            4 => cli\n                .longest_line\n                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(0)),\n            _ => None,\n        })\n        .flatten()\n        .collect()\n}\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n然后就是 main 函数:  \n\n```rust src/main.rs\nuse clap::Parser;\nuse rust_wc::{cli::Cli, wc_result, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    let pretty_table = wc_result::get(cli)?.to_pretty_table();\n    pretty_table.printstd();\n    Ok(())\n}\n```\n\n- - -\n\n# 自动补全\n我们已经写好了命令行程序, 可以通过 -h/--help 查看帮助信息, 但能不能更方便地与 shell 集成呢?  \n比如, 当你使用 bash/zsh/fish 时, 输入命令后点 Tab, 能帮你自动显示该命令的 flag/subcommand  \n\n我们将使用 `clap_complete` 这个库, 在编译器生成特定于 shell 的自动补全文件 (也可以运行时生成, 自看 [clap_complete](https://docs.rs/clap_complete/latest/clap_complete/) 的文档)  \n首先要修改 `Cargo.toml`, 在后面添加 [`build-dependencies`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#build-dependencies):  \n\n```toml Cargo.toml\n[build-dependencies]\nclap = {version = \"4.0.29\", features = [\"derive\"]}\nclap_complete = \"4.0.6\"\n```\n\n在项目根目录下添加 `build.rs`, 内容如下:  \n\n```rust\nuse clap::CommandFactory;\nuse clap_complete::{generate_to, shells::*};\nuse std::error::Error;\n\ninclude!(\"src/cli.rs\");\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let outdir = \"completions\";\n    let app_name = \"rwc\";\n    let mut cmd = Cli::command();\n\n    generate_to(Bash, &mut cmd, app_name, outdir)?;\n    generate_to(Zsh, &mut cmd, app_name, outdir)?;\n    generate_to(Fish, &mut cmd, app_name, outdir)?;\n    generate_to(Elvish, &mut cmd, app_name, outdir)?;\n    generate_to(PowerShell, &mut cmd, app_name, outdir)?;\n\n    Ok(())\n}\n```\n\n目前, clap_complete 仅支持以上几种 shell, 更多的偏小众 shell, 一般以 `clap_complete_xxx` 的形式出现在 `crates.io` 上  \n比如 `clap_complete_nushell`, 但亲测质量不佳, 不建议使用  \n\n同时, 请确保项目根目录下存在 `completions` 目录, 随后运行 `cargo build`, 通过 `tree` 命令可以看到生成的补全文件:  \n\n```bash\ncompletions\n├── _rwc\n├── rwc.bash\n├── rwc.elv\n├── rwc.fish\n└── _rwc.ps1\n```\n\n就酱, 本文结束啦!  \n希望本文能帮到你, 让你快速了解使用 clap 的流程 :)","slug":"rust/clap/intro","published":1,"updated":"2022-08-16T12:03:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogw001oj1s6dnc81aeq","content":"<blockquote>\n<p>了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>前置知识: Rust基础<br>\n完整代码: <a href=\"https://github.com/Jedsek/rust-wc\">github/jedsek/rust-wc</a></p>\n<p><strong>注意</strong><br>\n本项目基于当前最新版本的 clap, 也就是 version 4<br>\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p>\n<p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>\n官方教程: <a href=\"https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html\">derive tutorial</a><br>\n官方资料: <a href=\"https://docs.rs/clap/latest/clap/_derive/index.html\">derive reference</a></p>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>你可以通过如下命令, 从 <a href=\"https://crates.io\">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo install rust-wc</span><br></pre></td></tr></table></figure>\n<p>以下是使用 <a href=\"https://asciinema.org/\">asciinema</a> 录制的展示:</p>\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n<hr>\n<h1 id=\"ji-chu-gai-nian\">基础概念</h1>\n<p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>\n如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p>\n<p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>\n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p>\n<p><strong>注意:</strong><br>\ncli 可以代表抽象的界面, 也可以指代具体的某个程序<br>\n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p>\n<p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>参数(Arguments)</code>:<br>\n传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>选项(Options)</code>:<br>\n通常以单/双横杠开头, 不同的options表示不同的行为<br>\n比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>\n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>子命令(Subcommands)</code>:<br>\n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>\n比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>双横杠(--)</code>:<br>\n在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>\n举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>\n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>\n在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>\n此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>短/长帮助(short/long help)</code>:<br>\n有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"chu-shi-pei-zhi\">初始配置</h1>\n<p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>\n请自行创建好目录:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">./rust-wc</span><br><span class=\"line\">├── Cargo.lock</span><br><span class=\"line\">├── Cargo.toml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">   ├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">   ├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">   ├── files.rs       <span class=\"meta\"># 读取文件</span></span><br><span class=\"line\">   ├── lib.rs         <span class=\"meta\"># 声明模块, 类型别名</span></span><br><span class=\"line\">   └── main.rs</span><br></pre></td></tr></table></figure>\n<p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rust-wc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">authors</span> = [<span class=\"string\">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">&quot;0.0.1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">description</span> = <span class=\"string\">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class=\"line\"><span class=\"attr\">edition</span> = <span class=\"string\">&quot;2021&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class=\"line\"><span class=\"section\">[[bin]]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rwc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">path</span> = <span class=\"string\">&quot;src/main.rs&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定依赖</span></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">clap</span> = &#123;version = <span class=\"string\">&quot;4.0.29&quot;</span>, features = [<span class=\"string\">&quot;derive&quot;</span>]&#125;     <span class=\"comment\"># 解析参数</span></span><br><span class=\"line\"><span class=\"attr\">unicode-width</span> = <span class=\"string\">&quot;0.1.10&quot;</span>                               <span class=\"comment\"># 计算 Unicode 字符宽度</span></span><br><span class=\"line\"><span class=\"attr\">indicatif</span> = <span class=\"string\">&quot;0.17.2&quot;</span>                                   <span class=\"comment\"># 进度条</span></span><br><span class=\"line\"><span class=\"attr\">prettytable-rs</span> = <span class=\"string\">&quot;0.9.0&quot;</span>                               <span class=\"comment\"># 打印表格</span></span><br><span class=\"line\"><span class=\"attr\">rayon</span> = <span class=\"string\">&quot;1.6.1&quot;</span>                                        <span class=\"comment\"># 并行化</span></span><br></pre></td></tr></table></figure>\n<p>以下是 <a href=\"http://lib.rs\">lib.rs</a> 的内容:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ming-ling-ding-yi\">命令定义</h1>\n<p><strong>注意:</strong><br>\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>\n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>\n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p>\n<p>让我们来想象下这个命令:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>必须接受一个参数</p>\n</li>\n<li class=\"lvl-2\">\n<p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p>\n</li>\n<li class=\"lvl-2\">\n<p>根据启用的 flag 来决定计算并打印哪些东西</p>\n</li>\n</ul>\n<p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::path::PathBuf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span>  <span class=\"comment\">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about, subcommand_negates_reqs = true,</span></span><br><span class=\"line\"><span class=\"meta\">    group(</span></span><br><span class=\"line\"><span class=\"meta\">        ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">            .multiple(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .required(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the character counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> chars: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the word counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> words: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the line counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> lines: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Cli &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开启所有的 options</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">enable_all_options</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_enabled_options</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> enabled_options = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes.then(|| enabled_options.push(<span class=\"string\">&quot;Bytes&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars.then(|| enabled_options.push(<span class=\"string\">&quot;Chars&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words.then(|| enabled_options.push(<span class=\"string\">&quot;Words&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines.then(|| enabled_options.push(<span class=\"string\">&quot;Lines&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line.then(|| enabled_options.push(<span class=\"string\">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        enabled_options</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>\n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>\n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p>\n<p>clap 以及为我们做好了一切 😃</p>\n<p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"wen-dang-zhu-shi-yu-bang-zhu\" id=\"文档注释与帮助\">文档注释与帮助</h2>\n<p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -h</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">A GNU/wc clone written in rust, which <span class=\"keyword\">is</span> super faster when reading <span class=\"keyword\">a</span> large of big <span class=\"keyword\">files</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class=\"built_in\">line</span>&gt; <span class=\"symbol\">&lt;PATH&gt;</span>...</span><br><span class=\"line\">       rwc [PATH]... <span class=\"symbol\">&lt;COMMAND&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Command<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"keyword\">all</span>   Enabled <span class=\"keyword\">all</span> available <span class=\"keyword\">options</span></span><br><span class=\"line\">  <span class=\"keyword\">help</span>  <span class=\"keyword\">Print</span> this message <span class=\"built_in\">or</span> the <span class=\"keyword\">help</span> of the given subcommand(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Argument<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"symbol\">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class=\"line\"></span><br><span class=\"line\">Option<span class=\"variable\">s:</span></span><br><span class=\"line\">  -<span class=\"keyword\">b</span>, --bytes         <span class=\"keyword\">Print</span> the byte counts</span><br><span class=\"line\">  -<span class=\"keyword\">c</span>, --chars         <span class=\"keyword\">Print</span> the character counts</span><br><span class=\"line\">  -<span class=\"keyword\">w</span>, --words         <span class=\"keyword\">Print</span> the word counts</span><br><span class=\"line\">  -<span class=\"keyword\">l</span>, --lines         <span class=\"keyword\">Print</span> the <span class=\"built_in\">line</span> counts</span><br><span class=\"line\">  -L, --longest-<span class=\"built_in\">line</span>  <span class=\"keyword\">Print</span> the maximum <span class=\"built_in\">line</span> width (Unicode)</span><br><span class=\"line\">  -h, --<span class=\"keyword\">help</span>          <span class=\"keyword\">Print</span> <span class=\"keyword\">help</span> information</span><br><span class=\"line\">  -V, --<span class=\"keyword\">version</span>       <span class=\"keyword\">Print</span> <span class=\"keyword\">version</span> information</span><br></pre></td></tr></table></figure>\n<p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>\n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p>\n<p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    about = <span class=\"meta-string\">&quot;...&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>\n你可以查看 <a href=\"https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template\">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p>\n<p>你可以像这样将 builder形式 的代码转化为 derive形式:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command::new(<span class=\"string\">&quot;myprog&quot;</span>)</span><br><span class=\"line\">    .help_template(<span class=\"string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    help_template = <span class=\"meta-string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p>\n<h2 id=\"xuan-xiang-yu-can-shu-de-sheng-cheng\" id=\"选项与参数的生成\">选项与参数的生成</h2>\n<p>clap 能非常方便地以声明的方式, 定义选项/参数</p>\n<h3 id=\"xuan-xiang\" id=\"选项\">选项</h3>\n<p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<p>它由三部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文档注释: help 中对该命令的解释</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p>类型为bool: 传入时默认的行为是将其设置为 true</p>\n</li>\n</ul>\n<p>如 help 中所示, 会生成如下内容:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Options</span>:</span><br><span class=\"line\">  -b, --bytes         <span class=\"keyword\">Print</span> the <span class=\"keyword\">byte</span> counts</span><br></pre></td></tr></table></figure>\n<p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>\n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p>\n<p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<h3 id=\"can-shu\" id=\"参数\">参数</h3>\n<p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p>\n<p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>\n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure>\n<p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>The following required arguments were not provided:</span><br><span class=\"line\">  &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>\n没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>\n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p>\n<p>因此, 我们来学学如何使用自定义的参数解析器吧</p>\n<h2 id=\"zi-ding-yi-can-shu-jie-xi-qi\" id=\"自定义参数解析器\">自定义参数解析器</h2>\n<p>有些疑问或许会萦绕在你的心头:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>clap 是怎么进行解析的?</p>\n</li>\n<li class=\"lvl-2\">\n<p>clap 能否将传入的参数, 解析为自定义的类型呢?</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p>\n</li>\n</ul>\n<p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>\n比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>\n该错误会在用户传入非法路径时, 作为报错信息出现:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>\n得益于此, 你可以为任何类型定义对应的 parser</p>\n<h2 id=\"can-shu-guan-xi\" id=\"参数关系\">参数关系</h2>\n<p>有时候, 我们可能会面临这样或那样的问题:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个或多个指定的 option(s) 必须被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个指定的 options 可以同时被启用</p>\n</li>\n</ul>\n<p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>\n它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>\n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p>\n<p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p>\n<p>以我们的 <code>rwc</code> 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p>\n</li>\n</ul>\n<p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>\n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about, subcommand_negates_reqs = true,</span></span><br><span class=\"line\"><span class=\"meta\">    group(</span></span><br><span class=\"line\"><span class=\"meta\">        ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">            .multiple(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .required(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n<p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p>\n<h2 id=\"zi-ming-ling\" id=\"子命令\">子命令</h2>\n<p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>\n当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p>\n<p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href=\"https://github.com/clap-rs/clap/issues/1546\">相关issue</a></p>\n<p><strong>注意:</strong><br>\n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>\n但本文还是定义了 subcommand 以便读者了解, 起演示作用</p>\n<hr>\n<h1 id=\"luo-ji-shi-xian\">逻辑实现</h1>\n<p>根据:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">├── files.rs       <span class=\"meta\"># 读取文件</span></span><br></pre></td></tr></table></figure>\n<p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>\n为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p>\n<div class=\"tabs\" id=\"逻辑实现代码\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#逻辑实现代码-1\">读取文件</a></li><li class=\"tab\"><a href=\"#逻辑实现代码-2\">进行计算</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"逻辑实现代码-1\"><figure class=\"highlight rust\"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"comment\">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;PathWithContent, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ffi::OsStr;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::process;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;BufReader, Read&#125;,</span><br><span class=\"line\">    path::PathBuf,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class=\"line\"><span class=\"comment\">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> BUFFER_SIZR: <span class=\"built_in\">usize</span> = <span class=\"number\">16</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class=\"line\"><span class=\"comment\">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class=\"line\"><span class=\"comment\">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">PathExt</span></span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> PathExt <span class=\"keyword\">for</span> PathBuf &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.is_relative() &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;../&quot;</span>) &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;./&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        *<span class=\"keyword\">self</span> = PathBuf::from_iter([OsStr::new(<span class=\"string\">&quot;./&quot;</span>), <span class=\"keyword\">self</span>.as_os_str()]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_files</span></span>(paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;) -&gt; <span class=\"built_in\">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = paths</span><br><span class=\"line\">        .into_par_iter()</span><br><span class=\"line\">        .filter(|path| path.is_file() || path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>)</span><br><span class=\"line\">        .map(|<span class=\"keyword\">mut</span> path| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> should_read_from_input = path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> path.without_dotted_prefix() &#123;</span><br><span class=\"line\">                path.add_dotted_prefix();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class=\"number\">1</span>, Ordering::SeqCst);</span><br><span class=\"line\">                path = PathBuf::from(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class=\"line\">                eprintln!(<span class=\"string\">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            (path, content)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .collect();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// helper 函数, 针对单个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class=\"built_in\">bool</span>) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">        read_from_stdin()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bars = MultiProgress::new();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> style =</span><br><span class=\"line\">            ProgressStyle::with_template(<span class=\"string\">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class=\"line\">                .progress_chars(<span class=\"string\">&quot;&gt;-&quot;</span>);</span><br><span class=\"line\">        read_file_with_progress(path, style, bars)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取对应路径的文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path)?;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> size = file.metadata()?.len();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = ProgressBar::new(size).with_message(<span class=\"built_in\">format!</span> &#123;<span class=\"string\">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = bars.add(bar);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> bufreader = BufReader::new(file);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = [<span class=\"number\">0</span>; BUFFER_SIZR];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Ok</span>(n) = bufreader.read(&amp;<span class=\"keyword\">mut</span> buf) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bar.inc(n <span class=\"keyword\">as</span> <span class=\"built_in\">u64</span>);</span><br><span class=\"line\">        content += &amp;<span class=\"built_in\">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar.finish_with_message(<span class=\"string\">&quot;Done!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_from_stdin</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">    std::io::stdin().read_to_end(&amp;<span class=\"keyword\">mut</span> content)?;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(<span class=\"built_in\">String</span>::from_utf8(content)?)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"逻辑实现代码-2\"><figure class=\"highlight rust\"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;</span><br><span class=\"line\">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class=\"line\">    files::read_files,</span><br><span class=\"line\">    Counts, <span class=\"built_in\">Result</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class=\"built_in\">str</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存放被启用的 options, 与键值对</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WcResult</span></span> &#123;</span><br><span class=\"line\">    enabled_options: <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt;,</span><br><span class=\"line\">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例化函数</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get</span></span>(<span class=\"keyword\">mut</span> cli: Cli) -&gt; <span class=\"built_in\">Result</span>&lt;WcResult&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Please waiting...\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据子命令进行相应操作</span></span><br><span class=\"line\">    <span class=\"keyword\">match</span> cli.sub_commands &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(SubCommands::All &#123; <span class=\"keyword\">ref</span> paths &#125;) =&gt; &#123;</span><br><span class=\"line\">            cli.paths = paths.clone();</span><br><span class=\"line\">            cli.enable_all_options();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">None</span> =&gt; cli.enable_all_options(),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行计算</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Calculating...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> wc_result = WcResult &#123;</span><br><span class=\"line\">        enabled_options: cli.get_enabled_options(),</span><br><span class=\"line\">        paths_with_counts: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class=\"line\">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(wc_result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WcResult &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将保存的信息转化为美化后的表格</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_pretty_table</span></span>(<span class=\"keyword\">self</span>) -&gt; Table &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> titles = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> enabled_options = <span class=\"keyword\">self</span>.enabled_options;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class=\"line\">            titles.insert_cell(<span class=\"number\">0</span>, cell!(Fybi -&gt; <span class=\"string\">&quot;Path&quot;</span>));</span><br><span class=\"line\">            titles</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> table = Table::new();</span><br><span class=\"line\">        table.set_titles(titles);</span><br><span class=\"line\">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (path, counts) <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.paths_with_counts &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class=\"line\">            <span class=\"keyword\">let</span> path_cell = <span class=\"keyword\">if</span> path.starts_with(<span class=\"string\">&quot;Input&quot;</span>) &#123;</span><br><span class=\"line\">                cell!(Fbb -&gt; path.display())</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cell!(Fmb -&gt; path.display())</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            row.insert_cell(<span class=\"number\">0</span>, path_cell);</span><br><span class=\"line\">            table.add_row(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        table</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">calculate_counts</span></span>(cli: &amp;Cli, content: <span class=\"built_in\">String</span>) -&gt; Counts &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">usize</span>&gt;&gt; = <span class=\"built_in\">vec!</span>[<span class=\"literal\">None</span>; <span class=\"number\">5</span>];</span><br><span class=\"line\">    v.into_par_iter()</span><br><span class=\"line\">        .enumerate()</span><br><span class=\"line\">        .map(|(idx, _)| <span class=\"keyword\">match</span> idx &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class=\"line\">            <span class=\"number\">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class=\"line\">            <span class=\"number\">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class=\"line\">            <span class=\"number\">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class=\"line\">            <span class=\"number\">4</span> =&gt; cli</span><br><span class=\"line\">                .longest_line</span><br><span class=\"line\">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class=\"number\">0</span>)),</span><br><span class=\"line\">            _ =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .flatten()</span><br><span class=\"line\">        .collect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></div></div>\n<p>然后就是 main 函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class=\"line\">    pretty_table.printstd();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"zi-dong-bu-quan\">自动补全</h1>\n<p>我们已经写好了命令行程序, 可以通过 -h/–help 查看帮助信息, 但能不能更方便地与 shell 集成呢?<br>\n比如, 当你使用 bash/zsh/fish 时, 输入命令后点 Tab, 能帮你自动显示该命令的 flag/subcommand</p>\n<p>我们将使用 <code>clap_complete</code> 这个库, 在编译器生成特定于 shell 的自动补全文件 (也可以运行时生成, 自看 <a href=\"https://docs.rs/clap_complete/latest/clap_complete/\">clap_complete</a> 的文档)<br>\n首先要修改 <code>Cargo.toml</code>, 在后面添加 <a href=\"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#build-dependencies\"><code>build-dependencies</code></a>:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[build-dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">clap</span> = &#123;version = <span class=\"string\">&quot;4.0.29&quot;</span>, features = [<span class=\"string\">&quot;derive&quot;</span>]&#125;</span><br><span class=\"line\"><span class=\"attr\">clap_complete</span> = <span class=\"string\">&quot;4.0.6&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在项目根目录下添加 <code>build.rs</code>, 内容如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::CommandFactory;</span><br><span class=\"line\"><span class=\"keyword\">use</span> clap_complete::&#123;generate_to, shells::*&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::error::Error;</span><br><span class=\"line\"></span><br><span class=\"line\">include!(<span class=\"string\">&quot;src/cli.rs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;(), <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> Error&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> outdir = <span class=\"string\">&quot;completions&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app_name = <span class=\"string\">&quot;rwc&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cmd = Cli::command();</span><br><span class=\"line\"></span><br><span class=\"line\">    generate_to(Bash, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(Zsh, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(Fish, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(Elvish, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(PowerShell, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前, clap_complete 仅支持以上几种 shell, 更多的偏小众 shell, 一般以 <code>clap_complete_xxx</code> 的形式出现在 <code>crates.io</code> 上<br>\n比如 <code>clap_complete_nushell</code>, 但亲测质量不佳, 不建议使用</p>\n<p>同时, 请确保项目根目录下存在 <code>completions</code> 目录, 随后运行 <code>cargo build</code>, 通过 <code>tree</code> 命令可以看到生成的补全文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">completions</span><br><span class=\"line\">├── _rwc</span><br><span class=\"line\">├── rwc.bash</span><br><span class=\"line\">├── rwc.elv</span><br><span class=\"line\">├── rwc.fish</span><br><span class=\"line\">└── _rwc.ps1</span><br></pre></td></tr></table></figure>\n<p>就酱, 本文结束啦!<br>\n希望本文能帮到你, 让你快速了解使用 clap 的流程 😃</p>\n","site":{"data":{}},"length":17058,"excerpt":"<blockquote>\n<p>了解命令行, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p>\n</blockquote>","more":"<p>前置知识: Rust基础<br>\n完整代码: <a href=\"https://github.com/Jedsek/rust-wc\">github/jedsek/rust-wc</a></p>\n<p><strong>注意</strong><br>\n本项目基于当前最新版本的 clap, 也就是 version 4<br>\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p>\n<p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>\n官方教程: <a href=\"https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html\">derive tutorial</a><br>\n官方资料: <a href=\"https://docs.rs/clap/latest/clap/_derive/index.html\">derive reference</a></p>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>你可以通过如下命令, 从 <a href=\"https://crates.io\">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo install rust-wc</span><br></pre></td></tr></table></figure>\n<p>以下是使用 <a href=\"https://asciinema.org/\">asciinema</a> 录制的展示:</p>\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n<hr>\n<h1 id=\"ji-chu-gai-nian\">基础概念</h1>\n<p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>\n如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p>\n<p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>\n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p>\n<p><strong>注意:</strong><br>\ncli 可以代表抽象的界面, 也可以指代具体的某个程序<br>\n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p>\n<p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>参数(Arguments)</code>:<br>\n传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>选项(Options)</code>:<br>\n通常以单/双横杠开头, 不同的options表示不同的行为<br>\n比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>\n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>子命令(Subcommands)</code>:<br>\n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>\n比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>双横杠(--)</code>:<br>\n在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>\n举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>\n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>\n在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>\n此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>短/长帮助(short/long help)</code>:<br>\n有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"chu-shi-pei-zhi\">初始配置</h1>\n<p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>\n请自行创建好目录:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">./rust-wc</span><br><span class=\"line\">├── Cargo.lock</span><br><span class=\"line\">├── Cargo.toml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">   ├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">   ├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">   ├── files.rs       <span class=\"meta\"># 读取文件</span></span><br><span class=\"line\">   ├── lib.rs         <span class=\"meta\"># 声明模块, 类型别名</span></span><br><span class=\"line\">   └── main.rs</span><br></pre></td></tr></table></figure>\n<p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rust-wc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">authors</span> = [<span class=\"string\">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">&quot;0.0.1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">description</span> = <span class=\"string\">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class=\"line\"><span class=\"attr\">edition</span> = <span class=\"string\">&quot;2021&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class=\"line\"><span class=\"section\">[[bin]]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rwc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">path</span> = <span class=\"string\">&quot;src/main.rs&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定依赖</span></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">clap</span> = &#123;version = <span class=\"string\">&quot;4.0.29&quot;</span>, features = [<span class=\"string\">&quot;derive&quot;</span>]&#125;     <span class=\"comment\"># 解析参数</span></span><br><span class=\"line\"><span class=\"attr\">unicode-width</span> = <span class=\"string\">&quot;0.1.10&quot;</span>                               <span class=\"comment\"># 计算 Unicode 字符宽度</span></span><br><span class=\"line\"><span class=\"attr\">indicatif</span> = <span class=\"string\">&quot;0.17.2&quot;</span>                                   <span class=\"comment\"># 进度条</span></span><br><span class=\"line\"><span class=\"attr\">prettytable-rs</span> = <span class=\"string\">&quot;0.9.0&quot;</span>                               <span class=\"comment\"># 打印表格</span></span><br><span class=\"line\"><span class=\"attr\">rayon</span> = <span class=\"string\">&quot;1.6.1&quot;</span>                                        <span class=\"comment\"># 并行化</span></span><br></pre></td></tr></table></figure>\n<p>以下是 <a href=\"http://lib.rs\">lib.rs</a> 的内容:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ming-ling-ding-yi\">命令定义</h1>\n<p><strong>注意:</strong><br>\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>\n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>\n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p>\n<p>让我们来想象下这个命令:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>必须接受一个参数</p>\n</li>\n<li class=\"lvl-2\">\n<p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p>\n</li>\n<li class=\"lvl-2\">\n<p>根据启用的 flag 来决定计算并打印哪些东西</p>\n</li>\n</ul>\n<p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::path::PathBuf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span>  <span class=\"comment\">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about, subcommand_negates_reqs = true,</span></span><br><span class=\"line\"><span class=\"meta\">    group(</span></span><br><span class=\"line\"><span class=\"meta\">        ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">            .multiple(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .required(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the character counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> chars: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the word counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> words: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the line counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> lines: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Cli &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开启所有的 options</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">enable_all_options</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_enabled_options</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> enabled_options = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes.then(|| enabled_options.push(<span class=\"string\">&quot;Bytes&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars.then(|| enabled_options.push(<span class=\"string\">&quot;Chars&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words.then(|| enabled_options.push(<span class=\"string\">&quot;Words&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines.then(|| enabled_options.push(<span class=\"string\">&quot;Lines&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line.then(|| enabled_options.push(<span class=\"string\">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        enabled_options</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>\n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>\n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p>\n<p>clap 以及为我们做好了一切 😃</p>\n<p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"wen-dang-zhu-shi-yu-bang-zhu\" id=\"文档注释与帮助\">文档注释与帮助</h2>\n<p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -h</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">A GNU/wc clone written in rust, which <span class=\"keyword\">is</span> super faster when reading <span class=\"keyword\">a</span> large of big <span class=\"keyword\">files</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class=\"built_in\">line</span>&gt; <span class=\"symbol\">&lt;PATH&gt;</span>...</span><br><span class=\"line\">       rwc [PATH]... <span class=\"symbol\">&lt;COMMAND&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Command<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"keyword\">all</span>   Enabled <span class=\"keyword\">all</span> available <span class=\"keyword\">options</span></span><br><span class=\"line\">  <span class=\"keyword\">help</span>  <span class=\"keyword\">Print</span> this message <span class=\"built_in\">or</span> the <span class=\"keyword\">help</span> of the given subcommand(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Argument<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"symbol\">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class=\"line\"></span><br><span class=\"line\">Option<span class=\"variable\">s:</span></span><br><span class=\"line\">  -<span class=\"keyword\">b</span>, --bytes         <span class=\"keyword\">Print</span> the byte counts</span><br><span class=\"line\">  -<span class=\"keyword\">c</span>, --chars         <span class=\"keyword\">Print</span> the character counts</span><br><span class=\"line\">  -<span class=\"keyword\">w</span>, --words         <span class=\"keyword\">Print</span> the word counts</span><br><span class=\"line\">  -<span class=\"keyword\">l</span>, --lines         <span class=\"keyword\">Print</span> the <span class=\"built_in\">line</span> counts</span><br><span class=\"line\">  -L, --longest-<span class=\"built_in\">line</span>  <span class=\"keyword\">Print</span> the maximum <span class=\"built_in\">line</span> width (Unicode)</span><br><span class=\"line\">  -h, --<span class=\"keyword\">help</span>          <span class=\"keyword\">Print</span> <span class=\"keyword\">help</span> information</span><br><span class=\"line\">  -V, --<span class=\"keyword\">version</span>       <span class=\"keyword\">Print</span> <span class=\"keyword\">version</span> information</span><br></pre></td></tr></table></figure>\n<p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>\n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p>\n<p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    about = <span class=\"meta-string\">&quot;...&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>\n你可以查看 <a href=\"https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template\">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p>\n<p>你可以像这样将 builder形式 的代码转化为 derive形式:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command::new(<span class=\"string\">&quot;myprog&quot;</span>)</span><br><span class=\"line\">    .help_template(<span class=\"string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    help_template = <span class=\"meta-string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p>\n<h2 id=\"xuan-xiang-yu-can-shu-de-sheng-cheng\" id=\"选项与参数的生成\">选项与参数的生成</h2>\n<p>clap 能非常方便地以声明的方式, 定义选项/参数</p>\n<h3 id=\"xuan-xiang\" id=\"选项\">选项</h3>\n<p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<p>它由三部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文档注释: help 中对该命令的解释</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p>类型为bool: 传入时默认的行为是将其设置为 true</p>\n</li>\n</ul>\n<p>如 help 中所示, 会生成如下内容:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Options</span>:</span><br><span class=\"line\">  -b, --bytes         <span class=\"keyword\">Print</span> the <span class=\"keyword\">byte</span> counts</span><br></pre></td></tr></table></figure>\n<p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>\n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p>\n<p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<h3 id=\"can-shu\" id=\"参数\">参数</h3>\n<p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p>\n<p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>\n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure>\n<p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>The following required arguments were not provided:</span><br><span class=\"line\">  &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>\n没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>\n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p>\n<p>因此, 我们来学学如何使用自定义的参数解析器吧</p>\n<h2 id=\"zi-ding-yi-can-shu-jie-xi-qi\" id=\"自定义参数解析器\">自定义参数解析器</h2>\n<p>有些疑问或许会萦绕在你的心头:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>clap 是怎么进行解析的?</p>\n</li>\n<li class=\"lvl-2\">\n<p>clap 能否将传入的参数, 解析为自定义的类型呢?</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p>\n</li>\n</ul>\n<p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>\n比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>\n该错误会在用户传入非法路径时, 作为报错信息出现:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>\n得益于此, 你可以为任何类型定义对应的 parser</p>\n<h2 id=\"can-shu-guan-xi\" id=\"参数关系\">参数关系</h2>\n<p>有时候, 我们可能会面临这样或那样的问题:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个或多个指定的 option(s) 必须被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个指定的 options 可以同时被启用</p>\n</li>\n</ul>\n<p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>\n它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>\n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p>\n<p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p>\n<p>以我们的 <code>rwc</code> 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p>\n</li>\n</ul>\n<p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>\n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about, subcommand_negates_reqs = true,</span></span><br><span class=\"line\"><span class=\"meta\">    group(</span></span><br><span class=\"line\"><span class=\"meta\">        ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">            .multiple(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .required(true)</span></span><br><span class=\"line\"><span class=\"meta\">            .args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n<p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p>\n<h2 id=\"zi-ming-ling\" id=\"子命令\">子命令</h2>\n<p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>\n当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p>\n<p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href=\"https://github.com/clap-rs/clap/issues/1546\">相关issue</a></p>\n<p><strong>注意:</strong><br>\n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>\n但本文还是定义了 subcommand 以便读者了解, 起演示作用</p>\n<hr>\n<h1 id=\"luo-ji-shi-xian\">逻辑实现</h1>\n<p>根据:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">├── files.rs       <span class=\"meta\"># 读取文件</span></span><br></pre></td></tr></table></figure>\n<p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>\n为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p>\n<div class=\"tabs\" id=\"逻辑实现代码\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#逻辑实现代码-1\">读取文件</a></li><li class=\"tab\"><a href=\"#逻辑实现代码-2\">进行计算</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"逻辑实现代码-1\"><figure class=\"highlight rust\"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"comment\">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;PathWithContent, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ffi::OsStr;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::process;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;BufReader, Read&#125;,</span><br><span class=\"line\">    path::PathBuf,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class=\"line\"><span class=\"comment\">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> BUFFER_SIZR: <span class=\"built_in\">usize</span> = <span class=\"number\">16</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class=\"line\"><span class=\"comment\">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class=\"line\"><span class=\"comment\">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">PathExt</span></span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> PathExt <span class=\"keyword\">for</span> PathBuf &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.is_relative() &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;../&quot;</span>) &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;./&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        *<span class=\"keyword\">self</span> = PathBuf::from_iter([OsStr::new(<span class=\"string\">&quot;./&quot;</span>), <span class=\"keyword\">self</span>.as_os_str()]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_files</span></span>(paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;) -&gt; <span class=\"built_in\">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = paths</span><br><span class=\"line\">        .into_par_iter()</span><br><span class=\"line\">        .filter(|path| path.is_file() || path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>)</span><br><span class=\"line\">        .map(|<span class=\"keyword\">mut</span> path| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> should_read_from_input = path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> path.without_dotted_prefix() &#123;</span><br><span class=\"line\">                path.add_dotted_prefix();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class=\"number\">1</span>, Ordering::SeqCst);</span><br><span class=\"line\">                path = PathBuf::from(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class=\"line\">                eprintln!(<span class=\"string\">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            (path, content)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .collect();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// helper 函数, 针对单个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class=\"built_in\">bool</span>) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">        read_from_stdin()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bars = MultiProgress::new();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> style =</span><br><span class=\"line\">            ProgressStyle::with_template(<span class=\"string\">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class=\"line\">                .progress_chars(<span class=\"string\">&quot;&gt;-&quot;</span>);</span><br><span class=\"line\">        read_file_with_progress(path, style, bars)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取对应路径的文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path)?;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> size = file.metadata()?.len();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = ProgressBar::new(size).with_message(<span class=\"built_in\">format!</span> &#123;<span class=\"string\">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = bars.add(bar);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> bufreader = BufReader::new(file);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = [<span class=\"number\">0</span>; BUFFER_SIZR];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Ok</span>(n) = bufreader.read(&amp;<span class=\"keyword\">mut</span> buf) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bar.inc(n <span class=\"keyword\">as</span> <span class=\"built_in\">u64</span>);</span><br><span class=\"line\">        content += &amp;<span class=\"built_in\">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar.finish_with_message(<span class=\"string\">&quot;Done!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_from_stdin</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">    std::io::stdin().read_to_end(&amp;<span class=\"keyword\">mut</span> content)?;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(<span class=\"built_in\">String</span>::from_utf8(content)?)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"逻辑实现代码-2\"><figure class=\"highlight rust\"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;</span><br><span class=\"line\">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class=\"line\">    files::read_files,</span><br><span class=\"line\">    Counts, <span class=\"built_in\">Result</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class=\"built_in\">str</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存放被启用的 options, 与键值对</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WcResult</span></span> &#123;</span><br><span class=\"line\">    enabled_options: <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt;,</span><br><span class=\"line\">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例化函数</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get</span></span>(<span class=\"keyword\">mut</span> cli: Cli) -&gt; <span class=\"built_in\">Result</span>&lt;WcResult&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Please waiting...\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据子命令进行相应操作</span></span><br><span class=\"line\">    <span class=\"keyword\">match</span> cli.sub_commands &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(SubCommands::All &#123; <span class=\"keyword\">ref</span> paths &#125;) =&gt; &#123;</span><br><span class=\"line\">            cli.paths = paths.clone();</span><br><span class=\"line\">            cli.enable_all_options();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">None</span> =&gt; cli.enable_all_options(),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行计算</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Calculating...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> wc_result = WcResult &#123;</span><br><span class=\"line\">        enabled_options: cli.get_enabled_options(),</span><br><span class=\"line\">        paths_with_counts: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class=\"line\">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(wc_result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WcResult &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将保存的信息转化为美化后的表格</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_pretty_table</span></span>(<span class=\"keyword\">self</span>) -&gt; Table &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> titles = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> enabled_options = <span class=\"keyword\">self</span>.enabled_options;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class=\"line\">            titles.insert_cell(<span class=\"number\">0</span>, cell!(Fybi -&gt; <span class=\"string\">&quot;Path&quot;</span>));</span><br><span class=\"line\">            titles</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> table = Table::new();</span><br><span class=\"line\">        table.set_titles(titles);</span><br><span class=\"line\">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (path, counts) <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.paths_with_counts &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class=\"line\">            <span class=\"keyword\">let</span> path_cell = <span class=\"keyword\">if</span> path.starts_with(<span class=\"string\">&quot;Input&quot;</span>) &#123;</span><br><span class=\"line\">                cell!(Fbb -&gt; path.display())</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cell!(Fmb -&gt; path.display())</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            row.insert_cell(<span class=\"number\">0</span>, path_cell);</span><br><span class=\"line\">            table.add_row(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        table</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">calculate_counts</span></span>(cli: &amp;Cli, content: <span class=\"built_in\">String</span>) -&gt; Counts &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">usize</span>&gt;&gt; = <span class=\"built_in\">vec!</span>[<span class=\"literal\">None</span>; <span class=\"number\">5</span>];</span><br><span class=\"line\">    v.into_par_iter()</span><br><span class=\"line\">        .enumerate()</span><br><span class=\"line\">        .map(|(idx, _)| <span class=\"keyword\">match</span> idx &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class=\"line\">            <span class=\"number\">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class=\"line\">            <span class=\"number\">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class=\"line\">            <span class=\"number\">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class=\"line\">            <span class=\"number\">4</span> =&gt; cli</span><br><span class=\"line\">                .longest_line</span><br><span class=\"line\">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class=\"number\">0</span>)),</span><br><span class=\"line\">            _ =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .flatten()</span><br><span class=\"line\">        .collect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></div></div>\n<p>然后就是 main 函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class=\"line\">    pretty_table.printstd();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"zi-dong-bu-quan\">自动补全</h1>\n<p>我们已经写好了命令行程序, 可以通过 -h/–help 查看帮助信息, 但能不能更方便地与 shell 集成呢?<br>\n比如, 当你使用 bash/zsh/fish 时, 输入命令后点 Tab, 能帮你自动显示该命令的 flag/subcommand</p>\n<p>我们将使用 <code>clap_complete</code> 这个库, 在编译器生成特定于 shell 的自动补全文件 (也可以运行时生成, 自看 <a href=\"https://docs.rs/clap_complete/latest/clap_complete/\">clap_complete</a> 的文档)<br>\n首先要修改 <code>Cargo.toml</code>, 在后面添加 <a href=\"https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#build-dependencies\"><code>build-dependencies</code></a>:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[build-dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">clap</span> = &#123;version = <span class=\"string\">&quot;4.0.29&quot;</span>, features = [<span class=\"string\">&quot;derive&quot;</span>]&#125;</span><br><span class=\"line\"><span class=\"attr\">clap_complete</span> = <span class=\"string\">&quot;4.0.6&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在项目根目录下添加 <code>build.rs</code>, 内容如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::CommandFactory;</span><br><span class=\"line\"><span class=\"keyword\">use</span> clap_complete::&#123;generate_to, shells::*&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::error::Error;</span><br><span class=\"line\"></span><br><span class=\"line\">include!(<span class=\"string\">&quot;src/cli.rs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;(), <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> Error&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> outdir = <span class=\"string\">&quot;completions&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app_name = <span class=\"string\">&quot;rwc&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> cmd = Cli::command();</span><br><span class=\"line\"></span><br><span class=\"line\">    generate_to(Bash, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(Zsh, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(Fish, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(Elvish, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\">    generate_to(PowerShell, &amp;<span class=\"keyword\">mut</span> cmd, app_name, outdir)?;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前, clap_complete 仅支持以上几种 shell, 更多的偏小众 shell, 一般以 <code>clap_complete_xxx</code> 的形式出现在 <code>crates.io</code> 上<br>\n比如 <code>clap_complete_nushell</code>, 但亲测质量不佳, 不建议使用</p>\n<p>同时, 请确保项目根目录下存在 <code>completions</code> 目录, 随后运行 <code>cargo build</code>, 通过 <code>tree</code> 命令可以看到生成的补全文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">completions</span><br><span class=\"line\">├── _rwc</span><br><span class=\"line\">├── rwc.bash</span><br><span class=\"line\">├── rwc.elv</span><br><span class=\"line\">├── rwc.fish</span><br><span class=\"line\">└── _rwc.ps1</span><br></pre></td></tr></table></figure>\n<p>就酱, 本文结束啦!<br>\n希望本文能帮到你, 让你快速了解使用 clap 的流程 😃</p>"},{"title":"rust-decl-macro-p1~> 系列说明","abbrlink":"posts/rust-decl-macro/p1","date":"2021-09-19T13:51:27.000Z","top":97999,"keywords":["Macro","声明宏","Rust"],"is_series":true,"next_post":["posts/rust-decl-macro/p2","从println!开始"],"_content":"> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 系列说明\n此系列,我们将学习Rust中的 `声明宏`  \n请注意, 是声明宏, 过程宏日后再说\n- - - \n# 参考资料\n1. 书籍\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. 文章  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)\n","source":"_posts/rust/decl-macro/p1-系列说明.md","raw":"---\ntitle: \"rust-decl-macro-p1~> 系列说明\"\nabbrlink: posts/rust-decl-macro/p1\ndate: 2021-09-19 21:51:27\ntop: 97999\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\nis_series: true\nnext_post: [posts/rust-decl-macro/p2, 从println!开始]\n---\n> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 系列说明\n此系列,我们将学习Rust中的 `声明宏`  \n请注意, 是声明宏, 过程宏日后再说\n- - - \n# 参考资料\n1. 书籍\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. 文章  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)\n","slug":"rust/decl-macro/p1-系列说明","published":1,"updated":"2021-09-19T13:51:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogx001qj1s66ooi5m6b","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>声明宏</code><br>\n请注意, 是声明宏, 过程宏日后再说</p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文章</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":233,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>声明宏</code><br>\n请注意, 是声明宏, 过程宏日后再说</p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文章</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"},{"title":"rust-decl-macro-p2~> 从println开始","abbrlink":"posts/rust-decl-macro/p2","date":"2021-09-19T14:50:27.000Z","top":97998,"keywords":["Macro","声明宏","Rust"],"is_series":true,"prev_post":["posts/rust-decl-macro/p1","系列说明"],"next_post":["posts/rust-decl-macro/p3","声明与使用"],"_content":"> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇  \n大家应该都用过一个宏, 它就是 `println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?  \n\n亲爱的 TRPl 在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 时告诉过你: 名字后加个感叹号,就是个`宏(macro)`  \n可 macro 到底是啥? ~~(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)~~  \n\n- - -\n\n# 查看定义  \n让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现, 根本看不懂这堆鬼画符... 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:  \n\n- 我们将`macro_rules!`放在`println`前面,说明后者是个宏 (`macro_rules!`当作特定语法即可)  \n- 之后用花括号包起来,里面是该宏的具体定义  \n\n问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?  \n请容许我来帮你粗暴地类比一下`match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:  \n\nmatch:\n- match表达式,称呼每个匹配分支为`arm`  \n- 逗号分割它们彼此,或者不用逗号而用花括号包裹来分割  \n- 最后一个arm可省略逗号  \n\nmacro:\n- macro,则称呼每个匹配分支为`rule`(明白为什么使用`macro_rules!`创建宏了吗)  \n- 必须使用花括号包裹,使用分号分隔彼此  \n- 最后一个rule可省略分号  \n\n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可  \n现在再来看看 `println`,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\nfn main() {}\n```\n\n2. 然后创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {}\n```\n\n3. 调用时, 要做到: 宏名+感叹号+传参:  \n(传入的参数,若与任何rule都不匹配,则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  \n","source":"_posts/rust/decl-macro/p2-从println开始.md","raw":"---\ntitle: \"rust-decl-macro-p2~> 从println开始\"\nabbrlink: posts/rust-decl-macro/p2\ndate: 2021-09-19 22:50:27\ntop: 97998\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\nis_series: true\nprev_post: [posts/rust-decl-macro/p1, 系列说明]\nnext_post: [posts/rust-decl-macro/p3, 声明与使用]\n---\n> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇  \n大家应该都用过一个宏, 它就是 `println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?  \n\n亲爱的 TRPl 在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 时告诉过你: 名字后加个感叹号,就是个`宏(macro)`  \n可 macro 到底是啥? ~~(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)~~  \n\n- - -\n\n# 查看定义  \n让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现, 根本看不懂这堆鬼画符... 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:  \n\n- 我们将`macro_rules!`放在`println`前面,说明后者是个宏 (`macro_rules!`当作特定语法即可)  \n- 之后用花括号包起来,里面是该宏的具体定义  \n\n问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?  \n请容许我来帮你粗暴地类比一下`match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:  \n\nmatch:\n- match表达式,称呼每个匹配分支为`arm`  \n- 逗号分割它们彼此,或者不用逗号而用花括号包裹来分割  \n- 最后一个arm可省略逗号  \n\nmacro:\n- macro,则称呼每个匹配分支为`rule`(明白为什么使用`macro_rules!`创建宏了吗)  \n- 必须使用花括号包裹,使用分号分隔彼此  \n- 最后一个rule可省略分号  \n\n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可  \n现在再来看看 `println`,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\nfn main() {}\n```\n\n2. 然后创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {}\n```\n\n3. 调用时, 要做到: 宏名+感叹号+传参:  \n(传入的参数,若与任何rule都不匹配,则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  \n","slug":"rust/decl-macro/p2-从println开始","published":1,"updated":"2021-09-19T14:50:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogx001rj1s68icocttf","content":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家应该都用过一个宏, 它就是 <code>println!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?</p>\n<p>亲爱的 TRPl 在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 时告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>\n可 macro 到底是啥? <s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p>\n<hr>\n<h1 id=\"cha-kan-ding-yi\">查看定义</h1>\n<p>让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n<p>你悲催地发现, 根本看不懂这堆鬼画符… 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏 (<code>macro_rules!</code>当作特定语法即可)</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后用花括号包起来,里面是该宏的具体定义</p>\n</li>\n</ul>\n<p>问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?<br>\n请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>macro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:</p>\n<p>match:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>match表达式,称呼每个匹配分支为<code>arm</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个arm可省略逗号</p>\n</li>\n</ul>\n<p>macro:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)</p>\n</li>\n<li class=\"lvl-2\">\n<p>必须使用花括号包裹,使用分号分隔彼此</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个rule可省略分号</p>\n</li>\n</ul>\n<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>\n现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>然后创建两个匹配分支:<br>\n(匹配空参 =&gt; 不做任何事)<br>\n(匹配123 =&gt; 打印123)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>调用时, 要做到: 宏名+感叹号+传参:<br>\n(传入的参数,若与任何rule都不匹配,则报错)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>\n咱们下期见</p>\n","site":{"data":{}},"length":2285,"excerpt":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家应该都用过一个宏, 它就是 <code>println!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?</p>\n<p>亲爱的 TRPl 在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 时告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>\n可 macro 到底是啥? <s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p>\n<hr>\n<h1 id=\"cha-kan-ding-yi\">查看定义</h1>\n<p>让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n<p>你悲催地发现, 根本看不懂这堆鬼画符… 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏 (<code>macro_rules!</code>当作特定语法即可)</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后用花括号包起来,里面是该宏的具体定义</p>\n</li>\n</ul>\n<p>问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?<br>\n请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>macro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:</p>\n<p>match:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>match表达式,称呼每个匹配分支为<code>arm</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个arm可省略逗号</p>\n</li>\n</ul>\n<p>macro:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)</p>\n</li>\n<li class=\"lvl-2\">\n<p>必须使用花括号包裹,使用分号分隔彼此</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个rule可省略分号</p>\n</li>\n</ul>\n<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>\n现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>然后创建两个匹配分支:<br>\n(匹配空参 =&gt; 不做任何事)<br>\n(匹配123 =&gt; 打印123)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>调用时, 要做到: 宏名+感叹号+传参:<br>\n(传入的参数,若与任何rule都不匹配,则报错)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>\n咱们下期见</p>"},{"title":"rust-decl-macro-p3~> 声明与使用","abbrlink":"posts/rust-decl-macro/p3","date":"2021-09-20T12:06:15.000Z","top":97997,"keywords":["Macro","声明宏","Rust"],"is_series":true,"prev_post":["posts/rust-decl-macro/p2","从println!开始"],"next_post":["posts/rust-decl-macro/p4","重复"],"_content":"> 关于 macro 的 正式说明\n<!-- more -->  \n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 框架建立\n前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:  \n- `macro_rules!(这是特点语法)`来创建一个macro\n- `rule(s)(匹配分支,以 \"参数=>展开代码\" 的形式)`放在最外层的花括号内  \n- 调用宏时,宏名+感叹号+括号内传参,比如: `println!(some_str)`  \n\n现在稍微深入一点:  \n一个 `rule` 可以被这样抽象地表示: (matcher)=>(transcriber), 它由三个重要的部分组成:\n\n- `matcher (匹配器)`: 用来匹配传入的参数  \n- `metavariable/literal (元变量/字面量)`: 绑定传入的代码片段,出现于 `matcher`\n- `transcriber (转录器)`: 用来在宏匹配成功后,进行代码替换\n\n以`println!`为例子,我们向其传入了一些参数,它给我们打印到标准输出上  \n因为原本的`println!`涉及到`卫生性`,`重复语法`,`路径作用域`等,不适合新鸟阅读,所以我抽象了它:  \n\n```rust\nmacro_rules! println {\n    (/* 空参匹配 */) => (/* `换行` 的代码 */);\n    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)\n}\n```\n\n`println`由两个`rule`组成,每个的形式都是: `matcher=>transcriber`, 从上往下,每个rule的`matcher`会与传入参数尝试匹配, 匹配时括号具有多样性  \n下面是具体阐述:  \n\n匹配规则:  \n- 匹配到: 就替换为`transcriber`里面的代码  \n- 匹配不到: 所有`matcher`都无法与`传入参数`进行匹配,则编译报错  \n\n括号多样性: \n- 概念: `matcher`与`transcriber`的括号,可以是(),[],{}三种之一  \n- 定义时: 比如, rule可写成 `[pattern]=>{expansion}`  \n- 调用时: 一样遵从该规则, 比如 `vec![0, 1,2,3]` 与 `pritnln!(\"xx\")`\n\n而`metavariable/literal`则出现在`matcher`中,用于匹配并捕获代码片段  \n在对应的`transcriber`中,则可以操控这些`元值`,即操控捕获到的代码片段  \n\n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n\n- - -\n\n# 两种宏参数\n是时候引入一些新的东西了, 顺便加深下你的印象  \n\n## 元变量  \n元变量, 即Metavariable, 让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\nfn main() {\n\tmy_macro!(1);\n\tmy_macro!(1, 2);\n}\n/* 宏全部展开后, 可以理解为下面: \nfn main() {\n    1;\n    1 + 2;\n}\n*/\n```\n\n你会注意到,每个rule之间的参数, 其声明都有点奇怪:  \n比如: `$a:expr` -> `$+参数标识符+类型`  \n\n`$` 这个前缀是干嘛的?  \n这显式说明, 它是 `metavariable`, 可以匹配并捕获代码片段, 这里会捕获表达式  \n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~  \n\n先看看 `expr` 类型, 其全称为 `expression(表达式)`  \n第一次宏调用时, 传入了 `1(一个字面量)`, 这当然是个expr, 与第一个rule成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为相应的展开代码`  \n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码  \nmacro就像个code generator: 一段用来生成code的code  \n注意: \nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点  \n在本节下面会更详细地讲讲\n## 元字面量  \n元字面量, 即Metaliteral  \n为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 -- 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  \n\n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  \n这种固定的参数, 如同token中的字面量一样  \n我姑且称它为 `Literal Token(字面量标记)`, 或者 `Metaliteral (元字面量)`\n(因为我也不知道有什么对应术语, 所以用了 \"姑且\", 知道的麻烦告诉我)  \n\n假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! fuck {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tfuck!(1);       // No\n\tfuck!(a:expr);  // Yes ~~(Oh~)~~\n}\n```\n\n对于定义中的 \"a:expr\"(它是 `MetaLiteral`), 传入固定形式的 \"a:expr\" 时才可发生匹配  \n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰  \n\n## 例子\n假设有这么个宏 `map!`(联想一下`vec!`)  \n它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  \n如下:  \n\n```rust\nfn main() {\n\tlet m = map![\n\t\t\"吉良吉影\" => 33,\n\t\t\"空条承太郎\" => 41,\n\t]\n\t// `m` 的类型为: std::collections::HashMap<&str, i32>\n}\n```\n\n我们来写一个这样的宏吧!  \n不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  \n\n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key=>Value`  \n来看看两种宏参数在宏中, 发挥着怎样的作用:  \n- `Metavariable`: \n将捕获的传入的代码片段绑定到自身, 并在 `Transcriber` 中被使用, 最后展开为新代码  \n\n- `Metaliteral `: \n限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配\n若改成 `map!(\"普通上班族\", 33)`, 则每个rule的 `Matcher` 都无法匹配上  \n(这里只有一个rule, 空匹配的懒得放里面了)  \n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  \n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  \n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册  \n(博客的话, 我周六放学回来慢慢更吧......)\n~~(潜台词是随时会鸽子)~~\n\n- - -\n\n# 本质  \nmacro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  \n\n假若由你来设计一个Rust编译器:  \n\n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n若我们将每遍扫描并做点事情的过程, 称为`pass`, pass一次就生成了, 对于很大的源码来说, 这不现实吧  \n那我们就pass多次, 将 `从源码编译为目标码` 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗\n\n这种 `中间表示`, 就称为 `IR (Intermediate Representation )`  \n\n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:  \n\n```rust\n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  \nenum ASTNode {\n\tInt(i32), \n\tBinaryExpr {\n\t\top: Op,\n\t\tlhs: Box<ASTNode>,\n\t\trhs: Box<ASTNode>,\n\t}\n}\n// 二元运算的符号: 这里只抽象了加法\nenum Op {\n\tPlus, \n}\n```\n\n你只需明白AST是对源码封装的一层抽象产物就可以了  \n\n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了  \n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n\n基于AST, 我们可以再来一些`IR`, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛  \n`AST`很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码    \n\nQ: 生成AST需要点啥? 或者说, 它由什么组成?  \nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 `token`  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架  \n这个庞然大物便是 AST 了  \n\n- - - \n\n# 回到Macro  \n## Token类型表\n生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型  \n\nmacro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?  \n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 `Metavariable`)  \n\n所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\n|名称|对应|\n|--|--|\n|ident|标识符, 如函数名, 变量名, 关键字|\n|expr|expression, 表达式,如`x`与`1_i32`|\n|literal|literal expression, 即字面量表达式, 是expr的子集|\n|pat|pattern, 比如在match表达式下的 (pattern) => todo!()|\n|path|路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的|\n|ty|type, 如 i32, u32, String, Option<T>等|\n|tt|token tree, 之后我会单独再讲解下它的|\n|meta|元条目/项, 比如 `#[allow(unsued)]`, `meta` 就对应 `allow(unuse)` |\n|vis|visibility, 可见性, 比如pub, pub(crate)等, 也可能为空|\n|lifetime|生命周期|\n|item|条目/项, 例如函数定义|\n|block|代码块|\n|stmt|statemen, 语句|\n\n## TT\n这里有个比较特殊的类型 `tt (Token Tree)`  \n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~  \n\n`tt`,可以捕获`Single Token`,或由(),[],{}及括号包裹起来的东西  \n作为 Token Tree 的根节点, 先让我们来点例子:  \n```rust\nmacro_rules! aa {\n    ($a:tt) => {\n        println!(\"{}\", stringify!($a));\n    };\n}\nfn main() {\n\t// Single Token\n    aa!(123);          // Yes: 123\n    aa!(FuckYou);      // Yes: FuckYou\n    // aa!(Fuck You);     // No\n    // aa!(123 + 11);     // No\n\t// (), [], {}\n\taa!([123]);        // Yes: [123]\n\taa!({123 + 123});  // Yes: { 123 + 123 }\n}\n```\n上面的代码, 展示了 `tt` 可以匹配捕获哪些东西  \n请看以下内容, 以理解它, 我们以`<<xxx>>`, 来表示 `xxx` 是一颗 `Token Tree`  \n```rust\n// 你的眼中:\n1 + 2 + (3 + 4)\n// tt的眼中:\n<<1>> <<+>> <<2>> <<+>> <<( )>>\n                           |\n                           |\n                   <<3>> <<+>> <<4>>\n```\n这段代码的Token Tree共有5个:  \n1. <<1>>\n2. <<+>>\n3. <<2>>\n4. <<+>>\n5. <<(3 + 4)>>\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree  \n对于第5个, 因为有()包裹, <<(...)>> 作为根节点, 它还有三个子节点(这里正好同层)  \n\n有没有对 `Token后面跟着Tree` 更加理解?  \n\n\n## AST节点\n\nmacro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)  \n比如 `map!` 中, `$key:value` 与 `$val:expr`, 都会被解析为expr类型的AST节点:  \n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n\n我们通过使用 macro , 站在了更抽象的视角上  \n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  \n\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md) 上面的代码了:  \n\n```rust\nmacro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5)\n    );\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5)\n    );\n}\n```\n\n输出结果会是:  \n```rust\ngot an identifier\ngot an addition\ngot something else\ngot something else\ngot something else\ngot something else\n```\n\n比如这里, `match_tokens` 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!  \n\n比如 `5 + 7`, 原本是可以与 `$a:tt + $b:tt` 相匹配, 也可以与 `$a: expr` 匹配  \n但经二次传入后(向 `capture_then_match_tokens`传入的参数又传给 `match_tokens`)  \n`5 + 7` 变成AST表达式节点, 只能与 `$a: expr`, 而不能与 `$a:tt + $b:tt` 匹配  \n\n只有 `tt`, `ident`, `lifetime` 能免遭 AST节点化, 可以好好理解下这块  \n\n总结:  \n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点  \n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 :D)\n\n宏展开的结果是个某类型的AST节点, 这相比于C语言的 `#define` 宏, 有什么好处?  \n最直接的好处, 如下 ~~(相当于自动给你加上了括号)~~:\n```rust\n// C语言: 简单的文本替换\n#define SUM(a,b) a+b\nint main(void) {\n\tSUM(2, 2);     // 2 * 2\n\t5 * SUM(2, 2); // 5 * 2 + 2\n\treturn 0;\n}\n// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点\nmacro_rules! sum {\n\t($a:expr,$b:expr) => {$a + $b};\n}\nfn main() {\n\tsum!(2,2);     // 2 + 2\n\t5 * sum!(2,2); // 5 * (2 + 2)\n}\n```\n\n\n## 匹配注意点\n在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md)\n\n### 匹配误区\n来看看下面一段代码:\n```rust\nmacro_rules! aa {\n\t($a: expr) => {};\n\t($a: ident +) => {}\n}\nfn main() {\n\taa!(a);   // Yes\n\taa!(a+);  // No\n}\n```\n\n按照你的直觉, `aa!(a+)` 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:  \n\n```rust\nexpected expression, found end of macro arguments\n// 期望表达式, 却发现宏参数结束了\n```\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \n\n`a (lhs, left hand side)` 能被第一个rule匹配  \n而 `+ (二元加)` 因为可以尾随表达式, 也可以被第一个rule匹配\n但由于缺少 `rhs`, 此时会直接报错, 而不是去尝试匹配下一个rule  \n\n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n\n### 歧义限制  \n由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 `Metavariable` 后面可以跟的内容有所限制, 详情可见 [Rust-Reference: 限制](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)  \n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可  \n~~(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)~~  \n\n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n","source":"_posts/rust/decl-macro/p3-声明与使用.md","raw":"---\ntitle: \"rust-decl-macro-p3~> 声明与使用\"\nabbrlink: posts/rust-decl-macro/p3\ndate: 2021-09-20 20:06:15\ntop: 97997\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\nis_series: true\nprev_post: [posts/rust-decl-macro/p2, 从println!开始]\nnext_post: [posts/rust-decl-macro/p4, 重复]\n---\n> 关于 macro 的 正式说明\n<!-- more -->  \n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 框架建立\n前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:  \n- `macro_rules!(这是特点语法)`来创建一个macro\n- `rule(s)(匹配分支,以 \"参数=>展开代码\" 的形式)`放在最外层的花括号内  \n- 调用宏时,宏名+感叹号+括号内传参,比如: `println!(some_str)`  \n\n现在稍微深入一点:  \n一个 `rule` 可以被这样抽象地表示: (matcher)=>(transcriber), 它由三个重要的部分组成:\n\n- `matcher (匹配器)`: 用来匹配传入的参数  \n- `metavariable/literal (元变量/字面量)`: 绑定传入的代码片段,出现于 `matcher`\n- `transcriber (转录器)`: 用来在宏匹配成功后,进行代码替换\n\n以`println!`为例子,我们向其传入了一些参数,它给我们打印到标准输出上  \n因为原本的`println!`涉及到`卫生性`,`重复语法`,`路径作用域`等,不适合新鸟阅读,所以我抽象了它:  \n\n```rust\nmacro_rules! println {\n    (/* 空参匹配 */) => (/* `换行` 的代码 */);\n    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)\n}\n```\n\n`println`由两个`rule`组成,每个的形式都是: `matcher=>transcriber`, 从上往下,每个rule的`matcher`会与传入参数尝试匹配, 匹配时括号具有多样性  \n下面是具体阐述:  \n\n匹配规则:  \n- 匹配到: 就替换为`transcriber`里面的代码  \n- 匹配不到: 所有`matcher`都无法与`传入参数`进行匹配,则编译报错  \n\n括号多样性: \n- 概念: `matcher`与`transcriber`的括号,可以是(),[],{}三种之一  \n- 定义时: 比如, rule可写成 `[pattern]=>{expansion}`  \n- 调用时: 一样遵从该规则, 比如 `vec![0, 1,2,3]` 与 `pritnln!(\"xx\")`\n\n而`metavariable/literal`则出现在`matcher`中,用于匹配并捕获代码片段  \n在对应的`transcriber`中,则可以操控这些`元值`,即操控捕获到的代码片段  \n\n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n\n- - -\n\n# 两种宏参数\n是时候引入一些新的东西了, 顺便加深下你的印象  \n\n## 元变量  \n元变量, 即Metavariable, 让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\nfn main() {\n\tmy_macro!(1);\n\tmy_macro!(1, 2);\n}\n/* 宏全部展开后, 可以理解为下面: \nfn main() {\n    1;\n    1 + 2;\n}\n*/\n```\n\n你会注意到,每个rule之间的参数, 其声明都有点奇怪:  \n比如: `$a:expr` -> `$+参数标识符+类型`  \n\n`$` 这个前缀是干嘛的?  \n这显式说明, 它是 `metavariable`, 可以匹配并捕获代码片段, 这里会捕获表达式  \n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~  \n\n先看看 `expr` 类型, 其全称为 `expression(表达式)`  \n第一次宏调用时, 传入了 `1(一个字面量)`, 这当然是个expr, 与第一个rule成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为相应的展开代码`  \n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码  \nmacro就像个code generator: 一段用来生成code的code  \n注意: \nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点  \n在本节下面会更详细地讲讲\n## 元字面量  \n元字面量, 即Metaliteral  \n为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 -- 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  \n\n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  \n这种固定的参数, 如同token中的字面量一样  \n我姑且称它为 `Literal Token(字面量标记)`, 或者 `Metaliteral (元字面量)`\n(因为我也不知道有什么对应术语, 所以用了 \"姑且\", 知道的麻烦告诉我)  \n\n假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! fuck {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tfuck!(1);       // No\n\tfuck!(a:expr);  // Yes ~~(Oh~)~~\n}\n```\n\n对于定义中的 \"a:expr\"(它是 `MetaLiteral`), 传入固定形式的 \"a:expr\" 时才可发生匹配  \n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰  \n\n## 例子\n假设有这么个宏 `map!`(联想一下`vec!`)  \n它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  \n如下:  \n\n```rust\nfn main() {\n\tlet m = map![\n\t\t\"吉良吉影\" => 33,\n\t\t\"空条承太郎\" => 41,\n\t]\n\t// `m` 的类型为: std::collections::HashMap<&str, i32>\n}\n```\n\n我们来写一个这样的宏吧!  \n不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  \n\n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key=>Value`  \n来看看两种宏参数在宏中, 发挥着怎样的作用:  \n- `Metavariable`: \n将捕获的传入的代码片段绑定到自身, 并在 `Transcriber` 中被使用, 最后展开为新代码  \n\n- `Metaliteral `: \n限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配\n若改成 `map!(\"普通上班族\", 33)`, 则每个rule的 `Matcher` 都无法匹配上  \n(这里只有一个rule, 空匹配的懒得放里面了)  \n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  \n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  \n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册  \n(博客的话, 我周六放学回来慢慢更吧......)\n~~(潜台词是随时会鸽子)~~\n\n- - -\n\n# 本质  \nmacro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  \n\n假若由你来设计一个Rust编译器:  \n\n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n若我们将每遍扫描并做点事情的过程, 称为`pass`, pass一次就生成了, 对于很大的源码来说, 这不现实吧  \n那我们就pass多次, 将 `从源码编译为目标码` 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗\n\n这种 `中间表示`, 就称为 `IR (Intermediate Representation )`  \n\n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:  \n\n```rust\n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  \nenum ASTNode {\n\tInt(i32), \n\tBinaryExpr {\n\t\top: Op,\n\t\tlhs: Box<ASTNode>,\n\t\trhs: Box<ASTNode>,\n\t}\n}\n// 二元运算的符号: 这里只抽象了加法\nenum Op {\n\tPlus, \n}\n```\n\n你只需明白AST是对源码封装的一层抽象产物就可以了  \n\n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了  \n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n\n基于AST, 我们可以再来一些`IR`, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛  \n`AST`很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码    \n\nQ: 生成AST需要点啥? 或者说, 它由什么组成?  \nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 `token`  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架  \n这个庞然大物便是 AST 了  \n\n- - - \n\n# 回到Macro  \n## Token类型表\n生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型  \n\nmacro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?  \n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 `Metavariable`)  \n\n所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\n|名称|对应|\n|--|--|\n|ident|标识符, 如函数名, 变量名, 关键字|\n|expr|expression, 表达式,如`x`与`1_i32`|\n|literal|literal expression, 即字面量表达式, 是expr的子集|\n|pat|pattern, 比如在match表达式下的 (pattern) => todo!()|\n|path|路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的|\n|ty|type, 如 i32, u32, String, Option<T>等|\n|tt|token tree, 之后我会单独再讲解下它的|\n|meta|元条目/项, 比如 `#[allow(unsued)]`, `meta` 就对应 `allow(unuse)` |\n|vis|visibility, 可见性, 比如pub, pub(crate)等, 也可能为空|\n|lifetime|生命周期|\n|item|条目/项, 例如函数定义|\n|block|代码块|\n|stmt|statemen, 语句|\n\n## TT\n这里有个比较特殊的类型 `tt (Token Tree)`  \n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~  \n\n`tt`,可以捕获`Single Token`,或由(),[],{}及括号包裹起来的东西  \n作为 Token Tree 的根节点, 先让我们来点例子:  \n```rust\nmacro_rules! aa {\n    ($a:tt) => {\n        println!(\"{}\", stringify!($a));\n    };\n}\nfn main() {\n\t// Single Token\n    aa!(123);          // Yes: 123\n    aa!(FuckYou);      // Yes: FuckYou\n    // aa!(Fuck You);     // No\n    // aa!(123 + 11);     // No\n\t// (), [], {}\n\taa!([123]);        // Yes: [123]\n\taa!({123 + 123});  // Yes: { 123 + 123 }\n}\n```\n上面的代码, 展示了 `tt` 可以匹配捕获哪些东西  \n请看以下内容, 以理解它, 我们以`<<xxx>>`, 来表示 `xxx` 是一颗 `Token Tree`  \n```rust\n// 你的眼中:\n1 + 2 + (3 + 4)\n// tt的眼中:\n<<1>> <<+>> <<2>> <<+>> <<( )>>\n                           |\n                           |\n                   <<3>> <<+>> <<4>>\n```\n这段代码的Token Tree共有5个:  \n1. <<1>>\n2. <<+>>\n3. <<2>>\n4. <<+>>\n5. <<(3 + 4)>>\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree  \n对于第5个, 因为有()包裹, <<(...)>> 作为根节点, 它还有三个子节点(这里正好同层)  \n\n有没有对 `Token后面跟着Tree` 更加理解?  \n\n\n## AST节点\n\nmacro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)  \n比如 `map!` 中, `$key:value` 与 `$val:expr`, 都会被解析为expr类型的AST节点:  \n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n\n我们通过使用 macro , 站在了更抽象的视角上  \n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  \n\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md) 上面的代码了:  \n\n```rust\nmacro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5)\n    );\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5)\n    );\n}\n```\n\n输出结果会是:  \n```rust\ngot an identifier\ngot an addition\ngot something else\ngot something else\ngot something else\ngot something else\n```\n\n比如这里, `match_tokens` 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!  \n\n比如 `5 + 7`, 原本是可以与 `$a:tt + $b:tt` 相匹配, 也可以与 `$a: expr` 匹配  \n但经二次传入后(向 `capture_then_match_tokens`传入的参数又传给 `match_tokens`)  \n`5 + 7` 变成AST表达式节点, 只能与 `$a: expr`, 而不能与 `$a:tt + $b:tt` 匹配  \n\n只有 `tt`, `ident`, `lifetime` 能免遭 AST节点化, 可以好好理解下这块  \n\n总结:  \n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点  \n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 :D)\n\n宏展开的结果是个某类型的AST节点, 这相比于C语言的 `#define` 宏, 有什么好处?  \n最直接的好处, 如下 ~~(相当于自动给你加上了括号)~~:\n```rust\n// C语言: 简单的文本替换\n#define SUM(a,b) a+b\nint main(void) {\n\tSUM(2, 2);     // 2 * 2\n\t5 * SUM(2, 2); // 5 * 2 + 2\n\treturn 0;\n}\n// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点\nmacro_rules! sum {\n\t($a:expr,$b:expr) => {$a + $b};\n}\nfn main() {\n\tsum!(2,2);     // 2 + 2\n\t5 * sum!(2,2); // 5 * (2 + 2)\n}\n```\n\n\n## 匹配注意点\n在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md)\n\n### 匹配误区\n来看看下面一段代码:\n```rust\nmacro_rules! aa {\n\t($a: expr) => {};\n\t($a: ident +) => {}\n}\nfn main() {\n\taa!(a);   // Yes\n\taa!(a+);  // No\n}\n```\n\n按照你的直觉, `aa!(a+)` 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:  \n\n```rust\nexpected expression, found end of macro arguments\n// 期望表达式, 却发现宏参数结束了\n```\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \n\n`a (lhs, left hand side)` 能被第一个rule匹配  \n而 `+ (二元加)` 因为可以尾随表达式, 也可以被第一个rule匹配\n但由于缺少 `rhs`, 此时会直接报错, 而不是去尝试匹配下一个rule  \n\n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n\n### 歧义限制  \n由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 `Metavariable` 后面可以跟的内容有所限制, 详情可见 [Rust-Reference: 限制](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)  \n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可  \n~~(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)~~  \n\n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n","slug":"rust/decl-macro/p3-声明与使用","published":1,"updated":"2021-09-20T12:06:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogy001tj1s6dwn9bwjy","content":"<blockquote>\n<p>关于 macro 的 正式说明</p>\n</blockquote>\n<span id=\"more\"></span>  \n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kuang-jia-jian-li\">框架建立</h1>\n<p>前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p>\n</li>\n</ul>\n<p>现在稍微深入一点:<br>\n一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber), 它由三个重要的部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>matcher (匹配器)</code>: 用来匹配传入的参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>metavariable/literal (元变量/字面量)</code>: 绑定传入的代码片段,出现于 <code>matcher</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>transcriber (转录器)</code>: 用来在宏匹配成功后,进行代码替换</p>\n</li>\n</ul>\n<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>\n因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    (<span class=\"comment\">/* 空参匹配 */</span>) =&gt; (<span class=\"comment\">/* `换行` 的代码 */</span>);</span><br><span class=\"line\">    (<span class=\"comment\">/* 有参匹配 */</span>) =&gt; (<span class=\"comment\">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code>, 从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配, 匹配时括号具有多样性<br>\n下面是具体阐述:</p>\n<p>匹配规则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匹配到: 就替换为<code>transcriber</code>里面的代码</p>\n</li>\n<li class=\"lvl-2\">\n<p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p>\n</li>\n</ul>\n<p>括号多样性:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p>\n</li>\n<li class=\"lvl-2\">\n<p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>\n</li>\n</ul>\n<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>\n在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p>\n<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p>\n<hr>\n<h1 id=\"liang-chong-hong-can-shu\">两种宏参数</h1>\n<p>是时候引入一些新的东西了, 顺便加深下你的印象</p>\n<h2 id=\"yuan-bian-liang\" id=\"元变量\">元变量</h2>\n<p>元变量, 即Metavariable, 让我们来看个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    1;</span></span><br><span class=\"line\"><span class=\"comment\">    1 + 2;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>\n比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p>\n<p><code>$</code> 这个前缀是干嘛的?<br>\n这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>\n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~</p>\n<p>先看看 <code>expr</code> 类型, 其全称为 <code>expression(表达式)</code><br>\n第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>\n这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>\n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)<br>\n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>\nmacro就像个code generator: 一段用来生成code的code<br>\n注意:<br>\nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点<br>\n在本节下面会更详细地讲讲</p>\n<h2 id=\"yuan-zi-mian-liang\" id=\"元字面量\">元字面量</h2>\n<p>元字面量, 即Metaliteral<br>\n为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>\n你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p>\n<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>\n这种固定的参数, 如同token中的字面量一样<br>\n我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>\n(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p>\n<p>假若 rule 中的参数没有 $前缀 进行区分:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> fuck &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    fuck!(<span class=\"number\">1</span>);       <span class=\"comment\">// No</span></span><br><span class=\"line\">    fuck!(a:expr);  <span class=\"comment\">// Yes ~~(Oh~)~~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>), 传入固定形式的 “a:expr” 时才可发生匹配<br>\n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰</p>\n<h2 id=\"li-zi\" id=\"例子\">例子</h2>\n<p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>\n它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>\n如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map![</span><br><span class=\"line\">        <span class=\"string\">&quot;吉良吉影&quot;</span> =&gt; <span class=\"number\">33</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;空条承太郎&quot;</span> =&gt; <span class=\"number\">41</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来写一个这样的宏吧!<br>\n不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>\n来看看两种宏参数在宏中, 发挥着怎样的作用:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Metavariable</code>:<br>\n将捕获的传入的代码片段绑定到自身, 并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Metaliteral </code>:<br>\n限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>\n(这里只有一个rule, 空匹配的懒得放里面了)</p>\n</li>\n</ul>\n<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>\n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>\n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>\n(博客的话, 我周六放学回来慢慢更吧…)<br>\n<s>(潜台词是随时会鸽子)</s></p>\n<hr>\n<h1 id=\"ben-zhi\">本质</h1>\n<p>macro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p>\n<p>假若由你来设计一个Rust编译器:</p>\n<p>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>\n若我们将每遍扫描并做点事情的过程, 称为<code>pass</code>, pass一次就生成了, 对于很大的源码来说, 这不现实吧<br>\n那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗</p>\n<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p>\n<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASTNode</span></span> &#123;</span><br><span class=\"line\">    Int(<span class=\"built_in\">i32</span>), </span><br><span class=\"line\">    BinaryExpr &#123;</span><br><span class=\"line\">        op: Op,</span><br><span class=\"line\">        lhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">        rhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Op</span></span> &#123;</span><br><span class=\"line\">    Plus, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你只需明白AST是对源码封装的一层抽象产物就可以了</p>\n<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了<br>\n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p>\n<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛<br>\n<code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码</p>\n<p>Q: 生成AST需要点啥? 或者说, 它由什么组成?<br>\nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架<br>\n这个庞然大物便是 AST 了</p>\n<hr>\n<h1 id=\"hui-dao-macro\">回到Macro</h1>\n<h2 id=\"token-lei-xing-biao\" id=\"Token类型表\">Token类型表</h2>\n<p>生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型</p>\n<p>macro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?<br>\n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p>\n<p>所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>对应</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ident</td>\n<td>标识符, 如函数名, 变量名, 关键字</td>\n</tr>\n<tr>\n<td>expr</td>\n<td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td>\n</tr>\n<tr>\n<td>literal</td>\n<td>literal expression, 即字面量表达式, 是expr的子集</td>\n</tr>\n<tr>\n<td>pat</td>\n<td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td>\n</tr>\n<tr>\n<td>path</td>\n<td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td>\n</tr>\n<tr>\n<td>ty</td>\n<td>type, 如 i32, u32, String, Option<T>等</td>\n</tr>\n<tr>\n<td>tt</td>\n<td>token tree, 之后我会单独再讲解下它的</td>\n</tr>\n<tr>\n<td>meta</td>\n<td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td>\n</tr>\n<tr>\n<td>vis</td>\n<td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td>\n</tr>\n<tr>\n<td>lifetime</td>\n<td>生命周期</td>\n</tr>\n<tr>\n<td>item</td>\n<td>条目/项, 例如函数定义</td>\n</tr>\n<tr>\n<td>block</td>\n<td>代码块</td>\n</tr>\n<tr>\n<td>stmt</td>\n<td>statemen, 语句</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"tt\" id=\"TT\">TT</h2>\n<p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>\n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p>\n<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>\n作为 Token Tree 的根节点, 先让我们来点例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a:tt) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($a));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Single Token</span></span><br><span class=\"line\">    aa!(<span class=\"number\">123</span>);          <span class=\"comment\">// Yes: 123</span></span><br><span class=\"line\">    aa!(FuckYou);      <span class=\"comment\">// Yes: FuckYou</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(Fuck You);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(123 + 11);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// (), [], &#123;&#125;</span></span><br><span class=\"line\">    aa!([<span class=\"number\">123</span>]);        <span class=\"comment\">// Yes: [123]</span></span><br><span class=\"line\">    aa!(&#123;<span class=\"number\">123</span> + <span class=\"number\">123</span>&#125;);  <span class=\"comment\">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>\n请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你的眼中:</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span> + (<span class=\"number\">3</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// tt的眼中:</span></span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                   &lt;&lt;<span class=\"number\">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的Token Tree共有5个:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>&lt;&lt;1&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;2&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;(3 + 4)&gt;&gt;</p>\n</li>\n</ol>\n<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>\n对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p>\n<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p>\n<h2 id=\"ast-jie-dian\" id=\"AST节点\">AST节点</h2>\n<p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>\n比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们通过使用 macro , 站在了更抽象的视角上<br>\n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)<br>\n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p>\n<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a> 上面的代码了:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class=\"line\">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> match_tokens &#123;</span><br><span class=\"line\">    ($a:tt + $b:tt) =&gt; &#123;<span class=\"string\">&quot;got an addition&quot;</span>&#125;;</span><br><span class=\"line\">    (($i:ident)) =&gt; &#123;<span class=\"string\">&quot;got an identifier&quot;</span>&#125;;</span><br><span class=\"line\">    ($($other:tt)*) =&gt; &#123;<span class=\"string\">&quot;got something else&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;</span>,</span><br><span class=\"line\">        match_tokens!((caravan)),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;</span>,</span><br><span class=\"line\">        capture_then_match_tokens!((caravan)),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果会是:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">got an identifier</span><br><span class=\"line\">got an addition</span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br></pre></td></tr></table></figure>\n<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!</p>\n<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>\n但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br>\n<code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p>\n<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p>\n<p>总结:<br>\n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>\n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 😄)</p>\n<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>\n最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言: 简单的文本替换</span></span><br><span class=\"line\">#define SUM(a,b) a+b</span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>);     <span class=\"comment\">// 2 * 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 5 * 2 + 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>);     <span class=\"comment\">// 2 + 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 5 * (2 + 2)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"pi-pei-zhu-yi-dian\" id=\"匹配注意点\">匹配注意点</h2>\n<p>在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a></p>\n<h3 id=\"pi-pei-wu-qu\" id=\"匹配误区\">匹配误区</h3>\n<p>来看看下面一段代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    aa!(a);   <span class=\"comment\">// Yes</span></span><br><span class=\"line\">    aa!(a+);  <span class=\"comment\">// No</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">expected expression, found end of <span class=\"keyword\">macro</span> arguments</span><br><span class=\"line\"><span class=\"comment\">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>\n<p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p>\n<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>\n而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p>\n<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p>\n<h3 id=\"qi-yi-xian-zhi\" id=\"歧义限制\">歧义限制</h3>\n<p>由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">Rust-Reference: 限制</a><br>\n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br>\n<s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)</s></p>\n<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p>\n","site":{"data":{}},"length":8371,"excerpt":"<blockquote>\n<p>关于 macro 的 正式说明</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kuang-jia-jian-li\">框架建立</h1>\n<p>前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p>\n</li>\n</ul>\n<p>现在稍微深入一点:<br>\n一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber), 它由三个重要的部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>matcher (匹配器)</code>: 用来匹配传入的参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>metavariable/literal (元变量/字面量)</code>: 绑定传入的代码片段,出现于 <code>matcher</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>transcriber (转录器)</code>: 用来在宏匹配成功后,进行代码替换</p>\n</li>\n</ul>\n<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>\n因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    (<span class=\"comment\">/* 空参匹配 */</span>) =&gt; (<span class=\"comment\">/* `换行` 的代码 */</span>);</span><br><span class=\"line\">    (<span class=\"comment\">/* 有参匹配 */</span>) =&gt; (<span class=\"comment\">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code>, 从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配, 匹配时括号具有多样性<br>\n下面是具体阐述:</p>\n<p>匹配规则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匹配到: 就替换为<code>transcriber</code>里面的代码</p>\n</li>\n<li class=\"lvl-2\">\n<p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p>\n</li>\n</ul>\n<p>括号多样性:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p>\n</li>\n<li class=\"lvl-2\">\n<p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>\n</li>\n</ul>\n<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>\n在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p>\n<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p>\n<hr>\n<h1 id=\"liang-chong-hong-can-shu\">两种宏参数</h1>\n<p>是时候引入一些新的东西了, 顺便加深下你的印象</p>\n<h2 id=\"yuan-bian-liang\" id=\"元变量\">元变量</h2>\n<p>元变量, 即Metavariable, 让我们来看个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    1;</span></span><br><span class=\"line\"><span class=\"comment\">    1 + 2;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>\n比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p>\n<p><code>$</code> 这个前缀是干嘛的?<br>\n这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>\n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~</p>\n<p>先看看 <code>expr</code> 类型, 其全称为 <code>expression(表达式)</code><br>\n第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>\n这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>\n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)<br>\n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>\nmacro就像个code generator: 一段用来生成code的code<br>\n注意:<br>\nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点<br>\n在本节下面会更详细地讲讲</p>\n<h2 id=\"yuan-zi-mian-liang\" id=\"元字面量\">元字面量</h2>\n<p>元字面量, 即Metaliteral<br>\n为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>\n你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p>\n<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>\n这种固定的参数, 如同token中的字面量一样<br>\n我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>\n(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p>\n<p>假若 rule 中的参数没有 $前缀 进行区分:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> fuck &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    fuck!(<span class=\"number\">1</span>);       <span class=\"comment\">// No</span></span><br><span class=\"line\">    fuck!(a:expr);  <span class=\"comment\">// Yes ~~(Oh~)~~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>), 传入固定形式的 “a:expr” 时才可发生匹配<br>\n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰</p>\n<h2 id=\"li-zi\" id=\"例子\">例子</h2>\n<p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>\n它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>\n如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map![</span><br><span class=\"line\">        <span class=\"string\">&quot;吉良吉影&quot;</span> =&gt; <span class=\"number\">33</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;空条承太郎&quot;</span> =&gt; <span class=\"number\">41</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来写一个这样的宏吧!<br>\n不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>\n来看看两种宏参数在宏中, 发挥着怎样的作用:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Metavariable</code>:<br>\n将捕获的传入的代码片段绑定到自身, 并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Metaliteral </code>:<br>\n限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>\n(这里只有一个rule, 空匹配的懒得放里面了)</p>\n</li>\n</ul>\n<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>\n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>\n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>\n(博客的话, 我周六放学回来慢慢更吧…)<br>\n<s>(潜台词是随时会鸽子)</s></p>\n<hr>\n<h1 id=\"ben-zhi\">本质</h1>\n<p>macro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p>\n<p>假若由你来设计一个Rust编译器:</p>\n<p>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>\n若我们将每遍扫描并做点事情的过程, 称为<code>pass</code>, pass一次就生成了, 对于很大的源码来说, 这不现实吧<br>\n那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗</p>\n<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p>\n<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASTNode</span></span> &#123;</span><br><span class=\"line\">    Int(<span class=\"built_in\">i32</span>), </span><br><span class=\"line\">    BinaryExpr &#123;</span><br><span class=\"line\">        op: Op,</span><br><span class=\"line\">        lhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">        rhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Op</span></span> &#123;</span><br><span class=\"line\">    Plus, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你只需明白AST是对源码封装的一层抽象产物就可以了</p>\n<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了<br>\n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p>\n<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛<br>\n<code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码</p>\n<p>Q: 生成AST需要点啥? 或者说, 它由什么组成?<br>\nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架<br>\n这个庞然大物便是 AST 了</p>\n<hr>\n<h1 id=\"hui-dao-macro\">回到Macro</h1>\n<h2 id=\"token-lei-xing-biao\" id=\"Token类型表\">Token类型表</h2>\n<p>生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型</p>\n<p>macro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?<br>\n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p>\n<p>所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>对应</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ident</td>\n<td>标识符, 如函数名, 变量名, 关键字</td>\n</tr>\n<tr>\n<td>expr</td>\n<td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td>\n</tr>\n<tr>\n<td>literal</td>\n<td>literal expression, 即字面量表达式, 是expr的子集</td>\n</tr>\n<tr>\n<td>pat</td>\n<td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td>\n</tr>\n<tr>\n<td>path</td>\n<td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td>\n</tr>\n<tr>\n<td>ty</td>\n<td>type, 如 i32, u32, String, Option<T>等</td>\n</tr>\n<tr>\n<td>tt</td>\n<td>token tree, 之后我会单独再讲解下它的</td>\n</tr>\n<tr>\n<td>meta</td>\n<td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td>\n</tr>\n<tr>\n<td>vis</td>\n<td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td>\n</tr>\n<tr>\n<td>lifetime</td>\n<td>生命周期</td>\n</tr>\n<tr>\n<td>item</td>\n<td>条目/项, 例如函数定义</td>\n</tr>\n<tr>\n<td>block</td>\n<td>代码块</td>\n</tr>\n<tr>\n<td>stmt</td>\n<td>statemen, 语句</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"tt\" id=\"TT\">TT</h2>\n<p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>\n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p>\n<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>\n作为 Token Tree 的根节点, 先让我们来点例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a:tt) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($a));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Single Token</span></span><br><span class=\"line\">    aa!(<span class=\"number\">123</span>);          <span class=\"comment\">// Yes: 123</span></span><br><span class=\"line\">    aa!(FuckYou);      <span class=\"comment\">// Yes: FuckYou</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(Fuck You);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(123 + 11);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// (), [], &#123;&#125;</span></span><br><span class=\"line\">    aa!([<span class=\"number\">123</span>]);        <span class=\"comment\">// Yes: [123]</span></span><br><span class=\"line\">    aa!(&#123;<span class=\"number\">123</span> + <span class=\"number\">123</span>&#125;);  <span class=\"comment\">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>\n请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你的眼中:</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span> + (<span class=\"number\">3</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// tt的眼中:</span></span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                   &lt;&lt;<span class=\"number\">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的Token Tree共有5个:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>&lt;&lt;1&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;2&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;(3 + 4)&gt;&gt;</p>\n</li>\n</ol>\n<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>\n对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p>\n<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p>\n<h2 id=\"ast-jie-dian\" id=\"AST节点\">AST节点</h2>\n<p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>\n比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们通过使用 macro , 站在了更抽象的视角上<br>\n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)<br>\n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p>\n<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a> 上面的代码了:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class=\"line\">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> match_tokens &#123;</span><br><span class=\"line\">    ($a:tt + $b:tt) =&gt; &#123;<span class=\"string\">&quot;got an addition&quot;</span>&#125;;</span><br><span class=\"line\">    (($i:ident)) =&gt; &#123;<span class=\"string\">&quot;got an identifier&quot;</span>&#125;;</span><br><span class=\"line\">    ($($other:tt)*) =&gt; &#123;<span class=\"string\">&quot;got something else&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;</span>,</span><br><span class=\"line\">        match_tokens!((caravan)),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;</span>,</span><br><span class=\"line\">        capture_then_match_tokens!((caravan)),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果会是:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">got an identifier</span><br><span class=\"line\">got an addition</span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br></pre></td></tr></table></figure>\n<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!</p>\n<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>\n但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br>\n<code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p>\n<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p>\n<p>总结:<br>\n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>\n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 😄)</p>\n<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>\n最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言: 简单的文本替换</span></span><br><span class=\"line\">#define SUM(a,b) a+b</span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>);     <span class=\"comment\">// 2 * 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 5 * 2 + 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>);     <span class=\"comment\">// 2 + 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 5 * (2 + 2)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"pi-pei-zhu-yi-dian\" id=\"匹配注意点\">匹配注意点</h2>\n<p>在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a></p>\n<h3 id=\"pi-pei-wu-qu\" id=\"匹配误区\">匹配误区</h3>\n<p>来看看下面一段代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    aa!(a);   <span class=\"comment\">// Yes</span></span><br><span class=\"line\">    aa!(a+);  <span class=\"comment\">// No</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">expected expression, found end of <span class=\"keyword\">macro</span> arguments</span><br><span class=\"line\"><span class=\"comment\">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>\n<p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p>\n<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>\n而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p>\n<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p>\n<h3 id=\"qi-yi-xian-zhi\" id=\"歧义限制\">歧义限制</h3>\n<p>由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">Rust-Reference: 限制</a><br>\n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br>\n<s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)</s></p>\n<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p>"},{"title":"rust-decl-macro-p4~> 重复","abbrlink":"posts/rust-decl-macro/p4","date":"2021-10-09T14:36:00.000Z","top":97996,"keywords":["Macro","声明宏","Rust"],"is_series":true,"prev_post":["posts/rust-decl-macro/p3","声明与使用"],"next_post":["posts/rust-decl-macro/p5","卫生性"],"_content":"> 宏中非常重要的语法: 重复(repetition)\n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 介绍\n`重复 (Repetition)` 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n\n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n- Matcher: 将一段指定的模式, 重复地匹配与捕获\n- Transcriber: 将一段指定的模式, 重复地展开\n\n~~(废话, Rust的声明宏不就这两个主要部分嘛)~~  \n\n假设你要设计一个宏, 进行求和(参数个数不确定):  \n\n```rust\n// Examples:\nassert_eq!( 0,  sum!() );\nassert_eq!( 15, sum!(1,2,3,4,5) );\n```\n  \n让我们来看看, 如何使用重复吧\n\n# 语法  \n关键在于参数的个数不确定, 因此我们应使用重复语法:  \n```rust\nmacro_rules! sum {\n\t($($a:expr),*) => {\n\t\t0 $(+ $a)*\n\t}\n}\nfn main() {\n\tsum!();          // 0\n\tsum!(5);         // 5\n\tsum!(1,2,3,4,5); // 15\n}\n```\n\n伪代码表示:  \n```rust\n$( Pattern )   Sep    RepOp\n$(   模式   )  分隔符  重复符号\n```\n\n它可以被分为三个部分:  \n- 模式(Pattern): \n被包裹于 `$( )`, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n\n- 分隔符(Separator): \n用来分割重复的模式, 比如 `vec![1,2,3]` 中的逗号  \n\n- 重复符号(Repetition Operator): \n对模式匹配次数, 进行说明限制, 不符合就编译报错  \n\n\n以 `sum!` 为例子, 它在第二个rule中用到了重复:  \n\n- In Matcher: \n模式: `$a:expr` 是重复的模式, 表示重复地匹配与捕获expr  \n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配  \n次数: *号, 说明了重复模式的个数, 它被限制为>=0  \n\n- In Transcriber: \n模式: `+ $a` 是重复模式, 比如传入 `1,2,3,4,5` 时, 会被展开为 `0+1+2+3+4+5`  \n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep\n次数:\t 同 Matcher  \n\n`$()` 与 `RepOp` 是必填的, `Sep` 是可选的  \n\nRepOp 有三种可选项, 有点像正则:\n- `*` 表示 模式匹配的次数 >= 0  \n记忆法-> 该符号看上去像是一个点, 联想为0\n- `+` 表示 模式匹配的次数 >= 1\n记忆法-> 联想为正数, 那就>=1\n- `?` 表示 模式匹配的次数 = 0 or 1  \n记忆法-> 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n- 当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  \n- Sep 是有限制的, [p3#歧义限制](/posts/rust-decl-macro/p3#qi-yi-xian-zhi) 提到过, 详情可见 [rust-reference](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)\n","source":"_posts/rust/decl-macro/p4-重复.md","raw":"---\ntitle: \"rust-decl-macro-p4~> 重复\"\nabbrlink: posts/rust-decl-macro/p4\ndate: 2021-10-09 22:36:00\ntop: 97996\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\nis_series: true\nprev_post: [posts/rust-decl-macro/p3, 声明与使用]\nnext_post: [posts/rust-decl-macro/p5, 卫生性]\n---\n> 宏中非常重要的语法: 重复(repetition)\n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 介绍\n`重复 (Repetition)` 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n\n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n- Matcher: 将一段指定的模式, 重复地匹配与捕获\n- Transcriber: 将一段指定的模式, 重复地展开\n\n~~(废话, Rust的声明宏不就这两个主要部分嘛)~~  \n\n假设你要设计一个宏, 进行求和(参数个数不确定):  \n\n```rust\n// Examples:\nassert_eq!( 0,  sum!() );\nassert_eq!( 15, sum!(1,2,3,4,5) );\n```\n  \n让我们来看看, 如何使用重复吧\n\n# 语法  \n关键在于参数的个数不确定, 因此我们应使用重复语法:  \n```rust\nmacro_rules! sum {\n\t($($a:expr),*) => {\n\t\t0 $(+ $a)*\n\t}\n}\nfn main() {\n\tsum!();          // 0\n\tsum!(5);         // 5\n\tsum!(1,2,3,4,5); // 15\n}\n```\n\n伪代码表示:  \n```rust\n$( Pattern )   Sep    RepOp\n$(   模式   )  分隔符  重复符号\n```\n\n它可以被分为三个部分:  \n- 模式(Pattern): \n被包裹于 `$( )`, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n\n- 分隔符(Separator): \n用来分割重复的模式, 比如 `vec![1,2,3]` 中的逗号  \n\n- 重复符号(Repetition Operator): \n对模式匹配次数, 进行说明限制, 不符合就编译报错  \n\n\n以 `sum!` 为例子, 它在第二个rule中用到了重复:  \n\n- In Matcher: \n模式: `$a:expr` 是重复的模式, 表示重复地匹配与捕获expr  \n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配  \n次数: *号, 说明了重复模式的个数, 它被限制为>=0  \n\n- In Transcriber: \n模式: `+ $a` 是重复模式, 比如传入 `1,2,3,4,5` 时, 会被展开为 `0+1+2+3+4+5`  \n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep\n次数:\t 同 Matcher  \n\n`$()` 与 `RepOp` 是必填的, `Sep` 是可选的  \n\nRepOp 有三种可选项, 有点像正则:\n- `*` 表示 模式匹配的次数 >= 0  \n记忆法-> 该符号看上去像是一个点, 联想为0\n- `+` 表示 模式匹配的次数 >= 1\n记忆法-> 联想为正数, 那就>=1\n- `?` 表示 模式匹配的次数 = 0 or 1  \n记忆法-> 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n- 当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  \n- Sep 是有限制的, [p3#歧义限制](/posts/rust-decl-macro/p3#qi-yi-xian-zhi) 提到过, 详情可见 [rust-reference](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)\n","slug":"rust/decl-macro/p4-重复","published":1,"updated":"2021-10-09T14:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ogz001vj1s6cps01cs9","content":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"jie-shao\">介绍</h1>\n<p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p>\n<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p>\n</li>\n<li class=\"lvl-2\">\n<p>Transcriber: 将一段指定的模式, 重复地展开</p>\n</li>\n</ul>\n<p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p>\n<p>假设你要设计一个宏, 进行求和(参数个数不确定):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Examples:</span></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">0</span>,  sum!() );</span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">15</span>, sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) );</span><br></pre></td></tr></table></figure>\n<p>让我们来看看, 如何使用重复吧</p>\n<h1 id=\"yu-fa\">语法</h1>\n<p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($a:expr),*) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> $(+ $a)*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();          <span class=\"comment\">// 0</span></span><br><span class=\"line\">    sum!(<span class=\"number\">5</span>);         <span class=\"comment\">// 5</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>伪代码表示:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">$( Pattern )   Sep    RepOp</span><br><span class=\"line\">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>\n<p>它可以被分为三个部分:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>模式(Pattern):<br>\n被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p>\n</li>\n<li class=\"lvl-2\">\n<p>分隔符(Separator):<br>\n用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p>\n</li>\n<li class=\"lvl-2\">\n<p>重复符号(Repetition Operator):<br>\n对模式匹配次数, 进行说明限制, 不符合就编译报错</p>\n</li>\n</ul>\n<p>以 <code>sum!</code> 为例子, 它在第二个rule中用到了重复:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>In Matcher:<br>\n模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>\n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>\n次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p>\n</li>\n<li class=\"lvl-2\">\n<p>In Transcriber:<br>\n模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>\n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>\n次数:\t 同 Matcher</p>\n</li>\n</ul>\n<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p>\n<p>RepOp 有三种可选项, 有点像正则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>\n记忆法-&gt; 该符号看上去像是一个点, 联想为0</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>\n记忆法-&gt; 联想为正数, 那就&gt;=1</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>\n记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p>\n</li>\n</ul>\n<p>有一些注意点:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Sep 是有限制的, <a href=\"/posts/rust-decl-macro/p3#qi-yi-xian-zhi\">p3#歧义限制</a> 提到过, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">rust-reference</a></p>\n</li>\n</ul>\n","site":{"data":{}},"length":1121,"excerpt":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"jie-shao\">介绍</h1>\n<p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p>\n<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p>\n</li>\n<li class=\"lvl-2\">\n<p>Transcriber: 将一段指定的模式, 重复地展开</p>\n</li>\n</ul>\n<p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p>\n<p>假设你要设计一个宏, 进行求和(参数个数不确定):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Examples:</span></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">0</span>,  sum!() );</span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">15</span>, sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) );</span><br></pre></td></tr></table></figure>\n<p>让我们来看看, 如何使用重复吧</p>\n<h1 id=\"yu-fa\">语法</h1>\n<p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($a:expr),*) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> $(+ $a)*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();          <span class=\"comment\">// 0</span></span><br><span class=\"line\">    sum!(<span class=\"number\">5</span>);         <span class=\"comment\">// 5</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>伪代码表示:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">$( Pattern )   Sep    RepOp</span><br><span class=\"line\">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>\n<p>它可以被分为三个部分:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>模式(Pattern):<br>\n被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p>\n</li>\n<li class=\"lvl-2\">\n<p>分隔符(Separator):<br>\n用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p>\n</li>\n<li class=\"lvl-2\">\n<p>重复符号(Repetition Operator):<br>\n对模式匹配次数, 进行说明限制, 不符合就编译报错</p>\n</li>\n</ul>\n<p>以 <code>sum!</code> 为例子, 它在第二个rule中用到了重复:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>In Matcher:<br>\n模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>\n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>\n次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p>\n</li>\n<li class=\"lvl-2\">\n<p>In Transcriber:<br>\n模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>\n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>\n次数:\t 同 Matcher</p>\n</li>\n</ul>\n<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p>\n<p>RepOp 有三种可选项, 有点像正则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>\n记忆法-&gt; 该符号看上去像是一个点, 联想为0</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>\n记忆法-&gt; 联想为正数, 那就&gt;=1</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>\n记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p>\n</li>\n</ul>\n<p>有一些注意点:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Sep 是有限制的, <a href=\"/posts/rust-decl-macro/p3#qi-yi-xian-zhi\">p3#歧义限制</a> 提到过, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">rust-reference</a></p>\n</li>\n</ul>"},{"title":"rust-decl-macro-p5~> 卫生性","abbrlink":"posts/rust-decl-macro/p5","date":"2021-10-16T06:04:12.000Z","top":97995,"keywords":["Macro","声明宏","Rust"],"is_series":true,"prev_post":["posts/rust-decl-macro/p4","重复"],"next_post":["posts/rust-decl-macro/p6",{"实战":"递推序列生成器"}],"_content":"> 本节将介绍宏的 卫生性(hygienic)\n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇\n什么是 卫生性(Hygienic) 呢?\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染  \n如果你是第一次接触此概念, 我不信你不会懵逼  \n不过实际上, 这个概念理解起来不算困难  \n\n让我们先来讨论一个问题, 请看下面的代码:\n```rust\nmacro_rules! create_var {\n\t() => {\n\t\tlet a = 1;\n\t};\n}\nfn main() {\n\tcreate_var!();\n\tprintln!(\"{}\",a);\n}\n```\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","source":"_posts/rust/decl-macro/p5-卫生性.md","raw":"---\ntitle: \"rust-decl-macro-p5~> 卫生性\"\nabbrlink: posts/rust-decl-macro/p5\ndate: 2021-10-16 14:04:12\ntop: 97995\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\nis_series: true\nprev_post: [posts/rust-decl-macro/p4, 重复]\nnext_post: [posts/rust-decl-macro/p6, 实战: 递推序列生成器]\n---\n> 本节将介绍宏的 卫生性(hygienic)\n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇\n什么是 卫生性(Hygienic) 呢?\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染  \n如果你是第一次接触此概念, 我不信你不会懵逼  \n不过实际上, 这个概念理解起来不算困难  \n\n让我们先来讨论一个问题, 请看下面的代码:\n```rust\nmacro_rules! create_var {\n\t() => {\n\t\tlet a = 1;\n\t};\n}\nfn main() {\n\tcreate_var!();\n\tprintln!(\"{}\",a);\n}\n```\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","slug":"rust/decl-macro/p5-卫生性","published":1,"updated":"2021-10-16T06:04:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh0001yj1s6a1measal","content":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>什么是 卫生性(Hygienic) 呢?<br>\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>\n如果你是第一次接触此概念, 我不信你不会懵逼<br>\n不过实际上, 这个概念理解起来不算困难</p>\n<p>让我们先来讨论一个问题, 请看下面的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_var &#123;</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_var!();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>\n","site":{"data":{}},"length":346,"excerpt":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>什么是 卫生性(Hygienic) 呢?<br>\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>\n如果你是第一次接触此概念, 我不信你不会懵逼<br>\n不过实际上, 这个概念理解起来不算困难</p>\n<p>让我们先来讨论一个问题, 请看下面的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_var &#123;</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_var!();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>"},{"title":"rust-gstreamer-p1~> 系列说明","abbrlink":"posts/rust-gstreamer/p1","hidden":false,"date":"2022-10-22T14:42:00.000Z","top":11999,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 欢迎大家来到 gstreamer 的系列, 学习如何处理音视频\n<!-- more -->\n","source":"_posts/rust/gstreamer/p1-系列说明.md","raw":"---\ntitle: \"rust-gstreamer-p1~> 系列说明\"\nabbrlink: posts/rust-gstreamer/p1\nhidden: false\ndate: 2022-10-22 22:42:00\ntop: 11999\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 欢迎大家来到 gstreamer 的系列, 学习如何处理音视频\n<!-- more -->\n","slug":"rust/gstreamer/p1-系列说明","published":1,"updated":"2022-10-22T14:42:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh0001zj1s6e6l2ex0p","content":"<blockquote>\n<p>欢迎大家来到 gstreamer 的系列, 学习如何处理音视频</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":28,"excerpt":"<blockquote>\n<p>欢迎大家来到 gstreamer 的系列, 学习如何处理音视频</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p2~> 管道的基础概念","abbrlink":"posts/rust-gstreamer/p2","hidden":false,"date":"2022-10-22T14:43:36.000Z","top":11998,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 通过一个入门级例子, 讲述 gstreamer 中管道的基础概念\n<!-- more -->\n","source":"_posts/rust/gstreamer/p2-管道的基础概念.md","raw":"---\ntitle: \"rust-gstreamer-p2~> 管道的基础概念\"\nabbrlink: posts/rust-gstreamer/p2\nhidden: false\ndate: 2022-10-22 22:43:36\ntop: 11998\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 通过一个入门级例子, 讲述 gstreamer 中管道的基础概念\n<!-- more -->\n","slug":"rust/gstreamer/p2-管道的基础概念","published":1,"updated":"2022-10-22T14:43:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh10020j1s6d4i4ctan","content":"<blockquote>\n<p>通过一个入门级例子, 讲述 gstreamer 中管道的基础概念</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":29,"excerpt":"<blockquote>\n<p>通过一个入门级例子, 讲述 gstreamer 中管道的基础概念</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p3~> 管道的动态构建","abbrlink":"posts/rust-gstreamer/p3","hidden":false,"date":"2022-10-22T14:43:55.000Z","top":11996,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 学习如何在 gstreamer 中动态地构建管道\n<!-- more -->","source":"_posts/rust/gstreamer/p3-管道的动态构建.md","raw":"---\ntitle: \"rust-gstreamer-p3~> 管道的动态构建\"\nabbrlink: posts/rust-gstreamer/p3\nhidden: false\ndate: 2022-10-22 22:43:55\ntop: 11996\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 学习如何在 gstreamer 中动态地构建管道\n<!-- more -->","slug":"rust/gstreamer/p3-管道的动态构建","published":1,"updated":"2022-10-22T14:43:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh10023j1s6c5ia3bju","content":"<blockquote>\n<p>学习如何在 gstreamer 中动态地构建管道</p>\n</blockquote>\n<span id=\"more\"></span>","site":{"data":{}},"length":22,"excerpt":"<blockquote>\n<p>学习如何在 gstreamer 中动态地构建管道</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p4~> 时间管理","abbrlink":"posts/rust-gstreamer/p4","hidden":false,"date":"2022-10-22T14:44:02.000Z","top":11995,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 学习 gstreamer 中的时间管理, 执行快进/后退等操作\n<!-- more -->","source":"_posts/rust/gstreamer/p4-时间管理.md","raw":"---\ntitle: \"rust-gstreamer-p4~> 时间管理\"\nabbrlink: posts/rust-gstreamer/p4\nhidden: false\ndate: 2022-10-22 22:44:02\ntop: 11995\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 学习 gstreamer 中的时间管理, 执行快进/后退等操作\n<!-- more -->","slug":"rust/gstreamer/p4-时间管理","published":1,"updated":"2022-10-22T14:44:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh20025j1s6h6kf8ezl","content":"<blockquote>\n<p>学习 gstreamer 中的时间管理, 执行快进/后退等操作</p>\n</blockquote>\n<span id=\"more\"></span>","site":{"data":{}},"length":28,"excerpt":"<blockquote>\n<p>学习 gstreamer 中的时间管理, 执行快进/后退等操作</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p5~> 与GUI集成","abbrlink":"posts/rust-gstreamer/p5","hidden":false,"date":"2022-10-22T14:44:16.000Z","top":11994,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器\n<!-- more -->","source":"_posts/rust/gstreamer/p5-与GUI集成.md","raw":"---\ntitle: \"rust-gstreamer-p5~> 与GUI集成\"\nabbrlink: posts/rust-gstreamer/p5\nhidden: false\ndate: 2022-10-22 22:44:16\ntop: 11994\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器\n<!-- more -->","slug":"rust/gstreamer/p5-与GUI集成","published":1,"updated":"2022-10-22T14:44:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh30027j1s6gaqqe98m","content":"<blockquote>\n<p>通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器</p>\n</blockquote>\n<span id=\"more\"></span>","site":{"data":{}},"length":32,"excerpt":"<blockquote>\n<p>通过将 GUI 与 gstreamer 集成, 来制作一个简易的音乐播放器</p>\n</blockquote>","more":""},{"title":"rust-atomics-and-locks-p1-系列说明","abbrlink":"posts/rust-atomics-and-locks/p1","hidden":false,"date":"2023-06-23T11:03:19.000Z","top":95999,"keywords":["Rust","Concurrency"],"is_series":true,"next_post":["posts/rust-atomics-and-locks/p2","基础概念"],"_content":"\n> 欢迎大家来到 Rust 的 并发 系列\n<!-- more -->\n\n同系列传送门: [rust-atomics-and-locks](/categories/rust-atomics-and-locks)\n\n# 系列说明\n你可以将本系列看作英文书籍 [《Rust Atomics And Locks》](https://marabos.nl/atomics/preface.html) 的中文翻译  \n那是一本讲述在 Rust 中进行并发编程的好书, 讲述了原子与锁, 内存序, 如何自己构建一个并发锁等内容  \n鉴于本人能力, 有些地方可能会有错误与瑕疵, 请大家多多纠错并指教, 谢谢!  \n\n翻译进度可能会很慢, 因为我本人还有学业要忙, 请理解  \n\n- - -\n\n# 欢迎骚扰\n发现错误的话请及时跟我联系  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","source":"_posts/rust/rust-atomics-and-locks/p1-系列说明.md","raw":"---\ntitle: \"rust-atomics-and-locks-p1-系列说明\"\nabbrlink: posts/rust-atomics-and-locks/p1\nhidden: false\ndate: 2023-06-23 19:03:19\ntop: 95999\ntags: [Rust, Concurrency]\nkeywords: [Rust, Concurrency]\nis_series: true\nnext_post: [posts/rust-atomics-and-locks/p2, 基础概念]\n---\n\n> 欢迎大家来到 Rust 的 并发 系列\n<!-- more -->\n\n同系列传送门: [rust-atomics-and-locks](/categories/rust-atomics-and-locks)\n\n# 系列说明\n你可以将本系列看作英文书籍 [《Rust Atomics And Locks》](https://marabos.nl/atomics/preface.html) 的中文翻译  \n那是一本讲述在 Rust 中进行并发编程的好书, 讲述了原子与锁, 内存序, 如何自己构建一个并发锁等内容  \n鉴于本人能力, 有些地方可能会有错误与瑕疵, 请大家多多纠错并指教, 谢谢!  \n\n翻译进度可能会很慢, 因为我本人还有学业要忙, 请理解  \n\n- - -\n\n# 欢迎骚扰\n发现错误的话请及时跟我联系  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","slug":"rust/rust-atomics-and-locks/p1-系列说明","published":1,"updated":"2023-06-23T11:03:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh30029j1s64tsr7lmc","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 并发 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-atomics-and-locks\">rust-atomics-and-locks</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>你可以将本系列看作英文书籍 <a href=\"https://marabos.nl/atomics/preface.html\">《Rust Atomics And Locks》</a> 的中文翻译<br>\n那是一本讲述在 Rust 中进行并发编程的好书, 讲述了原子与锁, 内存序, 如何自己构建一个并发锁等内容<br>\n鉴于本人能力, 有些地方可能会有错误与瑕疵, 请大家多多纠错并指教, 谢谢!</p>\n<p>翻译进度可能会很慢, 因为我本人还有学业要忙, 请理解</p>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话请及时跟我联系<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":244,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 并发 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-atomics-and-locks\">rust-atomics-and-locks</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>你可以将本系列看作英文书籍 <a href=\"https://marabos.nl/atomics/preface.html\">《Rust Atomics And Locks》</a> 的中文翻译<br>\n那是一本讲述在 Rust 中进行并发编程的好书, 讲述了原子与锁, 内存序, 如何自己构建一个并发锁等内容<br>\n鉴于本人能力, 有些地方可能会有错误与瑕疵, 请大家多多纠错并指教, 谢谢!</p>\n<p>翻译进度可能会很慢, 因为我本人还有学业要忙, 请理解</p>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话请及时跟我联系<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"},{"title":"rust-tui-p1~> 系列说明","abbrlink":"posts/rust-tui/p1","hidden":false,"date":"2022-06-19T04:59:50.000Z","top":9799,"keywords":["Terminal","终端","TUI","Rust"],"is_series":true,"series_link":"rust-tui","next_post":["posts/rust-tui/p2","基础架构"],"_content":"> 欢迎大家来到 Rust 的 TUI 系列\n<!-- more -->\n\n同系列传送门: [rust-tui](/categories/rust-tui)\n\n# 系列说明\n本系列会介绍一下什么是 `TUI(Text-based User Interface)`  \n当然, 还会介绍Rust中的两个crate: `ratatui` && `crossterm`  \n\n- - -\n\n# 参考资料\n1. 博客:\n- [Playing with tui-rs](https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/)\n- [Building a command-line interface in Rust](https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/)\n2. 文档:\n- [ratatui-rs](https://docs.rs/ratatui/latest/)\n- [crossterm](https://docs.rs/crossterm/latest/crossterm/)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","source":"_posts/rust/tui/p1-系列说明.md","raw":"---\ntitle: \"rust-tui-p1~> 系列说明\"\nabbrlink: posts/rust-tui/p1\nhidden: false\ndate: 2022-06-19 12:59:50\ntop: 9799\ntags: [Rust, TUI]\nkeywords: [Terminal, 终端, TUI, Rust]\nis_series: true\nseries_link: rust-tui\nnext_post: [posts/rust-tui/p2, \"基础架构\"]\n---\n> 欢迎大家来到 Rust 的 TUI 系列\n<!-- more -->\n\n同系列传送门: [rust-tui](/categories/rust-tui)\n\n# 系列说明\n本系列会介绍一下什么是 `TUI(Text-based User Interface)`  \n当然, 还会介绍Rust中的两个crate: `ratatui` && `crossterm`  \n\n- - -\n\n# 参考资料\n1. 博客:\n- [Playing with tui-rs](https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/)\n- [Building a command-line interface in Rust](https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/)\n2. 文档:\n- [ratatui-rs](https://docs.rs/ratatui/latest/)\n- [crossterm](https://docs.rs/crossterm/latest/crossterm/)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","slug":"rust/tui/p1-系列说明","published":1,"updated":"2022-06-19T04:59:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh4002bj1s6chny3pbq","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 TUI 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-tui\">rust-tui</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>\n当然, 还会介绍Rust中的两个crate: <code>ratatui</code> &amp;&amp; <code>crossterm</code></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>博客:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/\">Playing with tui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/\">Building a command-line interface in Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文档:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/ratatui/latest/\">ratatui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/crossterm/latest/crossterm/\">crossterm</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":253,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 TUI 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-tui\">rust-tui</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>\n当然, 还会介绍Rust中的两个crate: <code>ratatui</code> &amp;&amp; <code>crossterm</code></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>博客:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/\">Playing with tui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/\">Building a command-line interface in Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文档:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/ratatui/latest/\">ratatui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/crossterm/latest/crossterm/\">crossterm</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"},{"title":"rust-tui-p2~> 基础架构","abbrlink":"posts/rust-tui/p2","hidden":false,"date":"2023-06-22T11:07:34.000Z","top":9798,"keywords":["Terminal","终端","TUI","Rust"],"is_series":true,"series_link":"rust-tui","prev_post":["posts/rust-tui/p1","系列说明"],"next_post":["posts/rust-tui/p3","基础架构"],"_content":"> 本节我们将学习一个 tui 应用的基本架构\n<!-- more -->\n\n同系列传送门: [rust-tui](/categories/rust-tui)\n\n# 参考项目\n本节的内容大致是带你捋下一个 tui 应用的基本架构， 参考项目是官方的 [github.com/tui-rs-revival/rust-tui-template](https://github.com/tui-rs-revival/rust-tui-template)  \n在这之前, 你可以选择下载 `cargo-generate` 来快速开发 (当然光看下面的代码与概念也不是不行):  \n\n```bash\ncargo install cargo-generate\n```\n\n上面的项目是一个模板项目, 专门为了让别人快速开始敲代码, 而不是将时间浪费在编写大量重复代码身上  \n如果你选择下载了 `cargo-generate`, 你可以通过如下命令快速搭建一个叫做 `tui-demo` 的项目 (为了网速考虑已经换成gitee镜像仓库了):  \n\n```bash\ncargo generate --git https://gitee.com/jedsek/rust-tui-template --name tui-demo\n```\n\n你会获得一个经典的双按钮应用: 显示一个数字, 随着按键而 +1 或 -1\n搭建过程讲完了, 下面开始正文, 关于架构的讲解  \n\n- - -\n\n# 架构说明\n\n```bash\nsrc/\n├── app.rs     -> 保存状态与应用逻辑\n├── event.rs   -> 将待处理的终端事件包装成我们自己定义的事件模型, 并且分发事件 (key-event, mouse-event, resize-event 等)\n├── handler.rs -> 接受分发的事件, 并让具体的处理函数与其一一匹配 (本系列我们只处理按键事件, 即 key-event)\n├── lib.rs     -> 定义模块 (单纯的别把 `pub mod xxx` 写在 `main.rs` 里面而已) \n├── main.rs    -> 应用程序的入口\n├── tui.rs     -> 初始化/退出tui时的一些操作\n└── ui.rs      -> 渲染组件ui\n```\n\n项目中同时存在 `lib.rs` 与 `main.rs`, 因此存在两个crate, 前者是lib_crate, 后者是bin_crate  \n\n```rust src/lib.rs\n/// Application.\npub mod app;\n\n/// Terminal events handler.\npub mod event;\n\n/// Widget renderer.\npub mod ui;\n\n/// Terminal user interface.\npub mod tui;\n\n/// Event handler.\npub mod handler;\n```\n\n`lib.rs` 定义了这些模块, 因此我们不必在 `main.rs` 的头部再定义了  \n**注意:**  \n当 `lib.rs` 与 `main.rs` 同时存在时, 视 `lib.rs` 为项目根, 调用里面的东西用 `crate::xxx`  \n而 `main.rs` 则视作作为依赖的bin_crate, 比如你的项目叫 `tui_app`, 调用里面的东西时就用 `tui_app::xxx` 即可  \n\n看着这些架构, 你可能会有点懵, 没事, 爷慢慢跟你说, 保证你能明白  \n\n## 状态管理\n\n我们从简单开始, 先看 `app.rs`:  \n\n+++ **点击展开/隐藏代码**\n```rust src/app.rs\nuse std::error;\n\n/// Application result type.\npub type AppResult<T> = std::result::Result<T, Box<dyn error::Error>>;\n\n/// Application.\n#[derive(Debug)]\npub struct App {\n    /// Is the application running?\n    pub running: bool,\n    /// counter\n    pub counter: u8,\n}\n\nimpl Default for App {\n    fn default() -> Self {\n        Self {\n            running: true,\n            counter: 0,\n        }\n    }\n}\n\nimpl App {\n    /// Constructs a new instance of [`App`].\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Handles the tick event of the terminal.\n    pub fn tick(&self) {}\n\n    /// Set running to false to quit the application.\n    pub fn quit(&mut self) {\n        self.running = false;\n    }\n\n    pub fn increment_counter(&mut self) {\n        if let Some(res) = self.counter.checked_add(1) {\n            self.counter = res;\n        }\n    }\n\n    pub fn decrement_counter(&mut self) {\n        if let Some(res) = self.counter.checked_sub(1) {\n            self.counter = res;\n        }\n    }\n}\n```\n+++\n\n逻辑很简单, `App` 结构体里装着随应用运行而可能被改变的状态, 除此以外, 我们还定义了一些方法来修改这些状态  \n\n比如 `quit()` 会让 `running` 变成 false, 以此来退出程序  \n比如 `inc()/dec()` 会让要显示的数字的值 +1/-1, 并保证处于 0..=255 的范围内不产生溢出  \n\n你可能会问, `tick()` 这玩意是干啥的? 空方法有啥用?  \n\n在这之前, 你需要了解下 `Tick` 的概念, 其意思是时钟秒针的滴答声, 用来表示时间的最小化单位  \n现实世界中目前可观测到的时间的最小单位是普朗克时间, 但一个运行在计算机里面的应用肯定不能这么算啊  \n\n举个例子, 在著名的MMO类型游戏, Screeps 中, 游戏的基本时间单位就叫 `tick`  \n所有玩家的代码会在同一时间并行执行, 随后以最后一份代码执行的结束, 代表着这一 `tick` 的结束  \n再举个例子, 在大部分枪战fps游戏中, 也有 `tick` 这个概念, 代表每秒钟可以刷新多少次  \n\n在该模板项目中, 会在一个设定好的时间如 200ms 后, 尝试着捕获一次终端事件, 若什么事件也没, 那就分发一个 Event::Tick 给我们的处理程序  \n在处理程序中, 当接受到 Tick 事件时, 我们返回一个 (), 以此来无视它, 状态的变化啊, 视图的更改啊什么的, 也就根本不会发生  \n\n这里的 `tick()` 方法, 也就是我们对 Event::Tick 事件的处理函数啦! 函数体是空的也就表示着无视它哦  \n\n\n## 处理程序\n讲完了 `app.rs` 中 `状态的保存` 与 `状态的更改` 之后, 我们会来看下 `handler.rs`, 即对事件的处理部分  \n代码如下:  \n\n+++ **点击展开/隐藏代码**\n```rust src/handler.rs\nuse crate::app::{App, AppResult};\nuse crossterm::event::{KeyCode, KeyEvent, KeyModifiers};\n\n/// Handles the key events and updates the state of [`App`].\npub fn handle_key_events(key_event: KeyEvent, app: &mut App) -> AppResult<()> {\n    match key_event.code {\n        // Exit application on `ESC` or `q`\n        KeyCode::Esc | KeyCode::Char('q') => {\n            app.quit();\n        }\n        // Exit application on `Ctrl-C`\n        KeyCode::Char('c') | KeyCode::Char('C') => {\n            if key_event.modifiers == KeyModifiers::CONTROL {\n                app.quit();\n            }\n        }\n        // Counter handlers\n        KeyCode::Right => {\n            app.increment_counter();\n        }\n        KeyCode::Left => {\n            app.decrement_counter();\n        }\n        // Other handlers you could add here.\n        _ => {}\n    }\n    Ok(())\n}\n```\n+++\n\n`crossterm` 是一个用于操作终端的跨平台库, 提供了一些抽象与封装, 比如 `KeyEvent`:  \n\n```rust\npub struct KeyEvent {\n    /// The key itself.\n    pub code: KeyCode,\n    /// Additional key modifiers.\n    pub modifiers: KeyModifiers,\n    \n    // ......\n    // ......\n    // ......\n}\n```\n\n- `code`: 表示你按下的比如字母啊数字啊这种  \n- `modifiers`: 表示修饰键, 如 `Shift`/`Ctrl`/`Alt`/`Super (windows里的图标键, 或macos里的cmd键)`  \n\n顺带一提, 类似的终端操作库还有:  \n\n- `termion`: 不跨平台, 仅限linux  \n- `termwiz`: `wezterm` 的配套终端操作库, 有很多高级特性 + 跨终端, 但文档少而且api有亿点难用  \n\n`ratatui-rs` 对其都有适配与支持, 比如当你如果想使用 `termwiz` + `ratatui`, 可以这样:  \n\n```toml Cargo.toml\ntui = { package = \"ratatui\", version = \"0.21\", default_features = false, features = [\"crossterm\", \"macros\"] }\ntermwiz = { version = \"0.20.0\", features = [\"use_image\"] }\n```\n\n本系列都将使用 `crossterm`, 因为资料多文档全 ~~(加上懒)~~  \n\n位于 `handler.rs` 中的代码很好理解, 不过你可能还会再问:  \n实际的处理程序, 好像就是 `app.rs` 里面的方法啊?  \n那能不能取消这个模块, 全装到 `App` 里面去呢?  \n\n刑, 当然可刑, 只是耦合度太高了, 不能想现在这样一目了然  \n\n你想啊, 如果你全装到 `app.rs` 里面去, 本来只需要管理状态, 对状态进行保存与更改  \n但现在就得与其他模块, 比如 `event.rs` 接轨打交道, 接受分发过来的事件并匹配相应的处理函数  \n耦合度太高了!  各种事情粘在一起, 耦合在一起, 复杂啊!  \n\n因此, `handler.rs` 是必不可少的, 其作用就像是网页中的路由那样, 调用着 `app.rs` 中改变状态的方法, 降低了耦合度  \n\n**注意:**  \n此处仅处理按键事件, 这也是大多数 tui 应用会处理的唯一事件  \n你没有看见 `app::tick()`, 是因为 Event::Tick 不是按键事件, 自然没有在处理按键的相应函数中看见  \n在 `main.rs` 中, 对全部终端事件的处理是这样的 (后面会讲) :  \n\n```rust src/main.rs\n// ......\n    // Handle events.\n    match tui.events.next()? {\n        Event::Tick => app.tick(),\n        Event::Key(key_event) => handle_key_events(key_event, &mut app)?,\n        Event::Mouse(_) => {}\n        Event::Resize(_, _) => {}\n    }\n// ......\n```\n\n## 视图渲染\n一样, 我们先把简单的模块看了:  \n\n+++ **点击展开/隐藏代码**\n```rust src/ui.rs\nuse tui::{\n    backend::Backend,\n    layout::Alignment,\n    style::{Color, Style},\n    widgets::{Block, BorderType, Borders, Paragraph},\n    Frame,\n};\n\nuse crate::app::App;\n\n/// Renders the user interface widgets.\npub fn render<B: Backend>(app: &mut App, frame: &mut Frame<B>) {\n    // This is where you add new widgets.\n    // See the following resources:\n    // - https://docs.rs/ratatui/latest/ratatui/widgets/index.html\n    // - https://github.com/tui-rs-revival/ratatui/tree/master/examples\n    frame.render_widget(\n        Paragraph::new(format!(\n            \"This is a tui template.\\n\\\n                Press `Esc`, `Ctrl-C` or `q` to stop running.\\n\\\n                Press left and right to increment and decrement the counter respectively.\\n\\\n                Counter: {}\",\n            app.counter\n        ))\n        .block(\n            Block::default()\n                .title(\"Template\")\n                .title_alignment(Alignment::Center)\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Cyan).bg(Color::Black))\n        .alignment(Alignment::Center),\n        frame.size(),\n    )\n}\n```\n+++\n\n看懂就行, 渲染了一个组件叫 `Paragraph`, 将 `app` 里面的状态, 即 `app.counter` 放上去显示  \n因为 `ratatui-rs` 是 `即时模式` 的渲染策略, 所以用起来会比较简单, 当按下按键后counter加减, 视图会因为重渲染自己更新  \n\n根据 [github仓库](https://github.com/tui-rs-revival/ratatui) 里的介绍, 它会在每一个新帧渲染所有 UI  \n这虽然为丰富的交互式 UI 提供了极大的灵活性，但也可能会因高度动态的内容而带来开销  \n~~(根据这份README所说, 实际上鉴于Rust的速度, 开销一般来自于终端, 而不是库本身)~~  \n\n\n## 事件捕获\n接下来, 我们将学习 `event.rs` 里的代码:  \n\n+++ **点击展开/隐藏代码**\n```rust src/event.rs\nuse crate::app::AppResult;\nuse crossterm::event::{self, Event as CrosstermEvent, KeyEvent, MouseEvent};\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::{Duration, Instant};\n\n/// Terminal events.\n#[derive(Clone, Copy, Debug)]\npub enum Event {\n    /// Terminal tick.\n    Tick,\n    /// Key press.\n    Key(KeyEvent),\n    /// Mouse click/scroll.\n    Mouse(MouseEvent),\n    /// Terminal resize.\n    Resize(u16, u16),\n}\n\n/// Terminal event handler.\n#[allow(dead_code)]\n#[derive(Debug)]\npub struct EventHandler {\n    /// Event sender channel.\n    sender: mpsc::Sender<Event>,\n    /// Event receiver channel.\n    receiver: mpsc::Receiver<Event>,\n    /// Event handler thread.\n    handler: thread::JoinHandle<()>,\n}\n\nimpl EventHandler {\n    /// Constructs a new instance of [`EventHandler`].\n    pub fn new(tick_rate: u64) -> Self {\n        let tick_rate = Duration::from_millis(tick_rate);\n        let (sender, receiver) = mpsc::channel();\n        let handler = {\n            let sender = sender.clone();\n            thread::spawn(move || {\n                let mut last_tick = Instant::now();\n                loop {\n                    let timeout = tick_rate\n                        .checked_sub(last_tick.elapsed())\n                        .unwrap_or(tick_rate);\n\n                    if event::poll(timeout).expect(\"no events available\") {\n                        match event::read().expect(\"unable to read event\") {\n                            CrosstermEvent::Key(e) => sender.send(Event::Key(e)),\n                            CrosstermEvent::Mouse(e) => sender.send(Event::Mouse(e)),\n                            CrosstermEvent::Resize(w, h) => sender.send(Event::Resize(w, h)),\n                            _ => unimplemented!(),\n                        }\n                        .expect(\"failed to send terminal event\")\n                    }\n\n                    if last_tick.elapsed() >= tick_rate {\n                        sender.send(Event::Tick).expect(\"failed to send tick event\");\n                        last_tick = Instant::now();\n                    }\n                }\n            })\n        };\n        Self {\n            sender,\n            receiver,\n            handler,\n        }\n    }\n\n    /// Receive the next event from the handler thread.\n    ///\n    /// This function will always block the current thread if\n    /// there is no data available and it's possible for more data to be sent.\n    pub fn next(&self) -> AppResult<Event> {\n        Ok(self.receiver.recv()?)\n    }\n}\n```\n+++\n\n在这里, 我们定义了自己的 Event 枚举, \n\n\n## 终端设置\n呕吼, 你即将观看的代码, 其作用是设置与调整终端的环境, 以便我们的 tui 应用更好的运行, 接下来会逐步讲解相关概念  \n代码如下:  \n\n\n+++ **点击展开/隐藏代码**\n```rust src/tui.rs\nuse crate::app::{App, AppResult};\nuse crate::event::EventHandler;\nuse crate::ui;\nuse crossterm::event::{DisableMouseCapture, EnableMouseCapture};\nuse crossterm::terminal::{self, EnterAlternateScreen, LeaveAlternateScreen};\nuse std::io;\nuse tui::backend::Backend;\nuse tui::Terminal;\n\n/// Representation of a terminal user interface.\n///\n/// It is responsible for setting up the terminal,\n/// initializing the interface and handling the draw events.\n#[derive(Debug)]\npub struct Tui<B: Backend> {\n    /// Interface to the Terminal.\n    terminal: Terminal<B>,\n    /// Terminal event handler.\n    pub events: EventHandler,\n}\n\nimpl<B: Backend> Tui<B> {\n    /// Constructs a new instance of [`Tui`].\n    pub fn new(terminal: Terminal<B>, events: EventHandler) -> Self {\n        Self { terminal, events }\n    }\n\n    /// Initializes the terminal interface.\n    ///\n    /// It enables the raw mode and sets terminal properties.\n    pub fn init(&mut self) -> AppResult<()> {\n        terminal::enable_raw_mode()?;\n        crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;\n        self.terminal.hide_cursor()?;\n        self.terminal.clear()?;\n        Ok(())\n    }\n\n    /// [`Draw`] the terminal interface by [`rendering`] the widgets.\n    ///\n    /// [`Draw`]: tui::Terminal::draw\n    /// [`rendering`]: crate::ui:render\n    pub fn draw(&mut self, app: &mut App) -> AppResult<()> {\n        self.terminal.draw(|frame| ui::render(app, frame))?;\n        Ok(())\n    }\n\n    /// Exits the terminal interface.\n    ///\n    /// It disables the raw mode and reverts back the terminal properties.\n    pub fn exit(&mut self) -> AppResult<()> {\n        terminal::disable_raw_mode()?;\n        crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;\n        self.terminal.show_cursor()?;\n        Ok(())\n    }\n}\n```\n+++\n\n我们创建了一个叫做 `TUI` 的结构体, 它保存了\n","source":"_posts/rust/tui/p2-基础架构.md","raw":"---\ntitle: \"rust-tui-p2~> 基础架构\"\nabbrlink: posts/rust-tui/p2\nhidden: false\ndate: 2023-06-22 19:07:34\ntop: 9798\ntags: [Rust, TUI]\nkeywords: [Terminal, 终端, TUI, Rust]\nis_series: true\nseries_link: rust-tui\nprev_post: [posts/rust-tui/p1, \"系列说明\"]\nnext_post: [posts/rust-tui/p3, \"基础架构\"]\n---\n> 本节我们将学习一个 tui 应用的基本架构\n<!-- more -->\n\n同系列传送门: [rust-tui](/categories/rust-tui)\n\n# 参考项目\n本节的内容大致是带你捋下一个 tui 应用的基本架构， 参考项目是官方的 [github.com/tui-rs-revival/rust-tui-template](https://github.com/tui-rs-revival/rust-tui-template)  \n在这之前, 你可以选择下载 `cargo-generate` 来快速开发 (当然光看下面的代码与概念也不是不行):  \n\n```bash\ncargo install cargo-generate\n```\n\n上面的项目是一个模板项目, 专门为了让别人快速开始敲代码, 而不是将时间浪费在编写大量重复代码身上  \n如果你选择下载了 `cargo-generate`, 你可以通过如下命令快速搭建一个叫做 `tui-demo` 的项目 (为了网速考虑已经换成gitee镜像仓库了):  \n\n```bash\ncargo generate --git https://gitee.com/jedsek/rust-tui-template --name tui-demo\n```\n\n你会获得一个经典的双按钮应用: 显示一个数字, 随着按键而 +1 或 -1\n搭建过程讲完了, 下面开始正文, 关于架构的讲解  \n\n- - -\n\n# 架构说明\n\n```bash\nsrc/\n├── app.rs     -> 保存状态与应用逻辑\n├── event.rs   -> 将待处理的终端事件包装成我们自己定义的事件模型, 并且分发事件 (key-event, mouse-event, resize-event 等)\n├── handler.rs -> 接受分发的事件, 并让具体的处理函数与其一一匹配 (本系列我们只处理按键事件, 即 key-event)\n├── lib.rs     -> 定义模块 (单纯的别把 `pub mod xxx` 写在 `main.rs` 里面而已) \n├── main.rs    -> 应用程序的入口\n├── tui.rs     -> 初始化/退出tui时的一些操作\n└── ui.rs      -> 渲染组件ui\n```\n\n项目中同时存在 `lib.rs` 与 `main.rs`, 因此存在两个crate, 前者是lib_crate, 后者是bin_crate  \n\n```rust src/lib.rs\n/// Application.\npub mod app;\n\n/// Terminal events handler.\npub mod event;\n\n/// Widget renderer.\npub mod ui;\n\n/// Terminal user interface.\npub mod tui;\n\n/// Event handler.\npub mod handler;\n```\n\n`lib.rs` 定义了这些模块, 因此我们不必在 `main.rs` 的头部再定义了  \n**注意:**  \n当 `lib.rs` 与 `main.rs` 同时存在时, 视 `lib.rs` 为项目根, 调用里面的东西用 `crate::xxx`  \n而 `main.rs` 则视作作为依赖的bin_crate, 比如你的项目叫 `tui_app`, 调用里面的东西时就用 `tui_app::xxx` 即可  \n\n看着这些架构, 你可能会有点懵, 没事, 爷慢慢跟你说, 保证你能明白  \n\n## 状态管理\n\n我们从简单开始, 先看 `app.rs`:  \n\n+++ **点击展开/隐藏代码**\n```rust src/app.rs\nuse std::error;\n\n/// Application result type.\npub type AppResult<T> = std::result::Result<T, Box<dyn error::Error>>;\n\n/// Application.\n#[derive(Debug)]\npub struct App {\n    /// Is the application running?\n    pub running: bool,\n    /// counter\n    pub counter: u8,\n}\n\nimpl Default for App {\n    fn default() -> Self {\n        Self {\n            running: true,\n            counter: 0,\n        }\n    }\n}\n\nimpl App {\n    /// Constructs a new instance of [`App`].\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Handles the tick event of the terminal.\n    pub fn tick(&self) {}\n\n    /// Set running to false to quit the application.\n    pub fn quit(&mut self) {\n        self.running = false;\n    }\n\n    pub fn increment_counter(&mut self) {\n        if let Some(res) = self.counter.checked_add(1) {\n            self.counter = res;\n        }\n    }\n\n    pub fn decrement_counter(&mut self) {\n        if let Some(res) = self.counter.checked_sub(1) {\n            self.counter = res;\n        }\n    }\n}\n```\n+++\n\n逻辑很简单, `App` 结构体里装着随应用运行而可能被改变的状态, 除此以外, 我们还定义了一些方法来修改这些状态  \n\n比如 `quit()` 会让 `running` 变成 false, 以此来退出程序  \n比如 `inc()/dec()` 会让要显示的数字的值 +1/-1, 并保证处于 0..=255 的范围内不产生溢出  \n\n你可能会问, `tick()` 这玩意是干啥的? 空方法有啥用?  \n\n在这之前, 你需要了解下 `Tick` 的概念, 其意思是时钟秒针的滴答声, 用来表示时间的最小化单位  \n现实世界中目前可观测到的时间的最小单位是普朗克时间, 但一个运行在计算机里面的应用肯定不能这么算啊  \n\n举个例子, 在著名的MMO类型游戏, Screeps 中, 游戏的基本时间单位就叫 `tick`  \n所有玩家的代码会在同一时间并行执行, 随后以最后一份代码执行的结束, 代表着这一 `tick` 的结束  \n再举个例子, 在大部分枪战fps游戏中, 也有 `tick` 这个概念, 代表每秒钟可以刷新多少次  \n\n在该模板项目中, 会在一个设定好的时间如 200ms 后, 尝试着捕获一次终端事件, 若什么事件也没, 那就分发一个 Event::Tick 给我们的处理程序  \n在处理程序中, 当接受到 Tick 事件时, 我们返回一个 (), 以此来无视它, 状态的变化啊, 视图的更改啊什么的, 也就根本不会发生  \n\n这里的 `tick()` 方法, 也就是我们对 Event::Tick 事件的处理函数啦! 函数体是空的也就表示着无视它哦  \n\n\n## 处理程序\n讲完了 `app.rs` 中 `状态的保存` 与 `状态的更改` 之后, 我们会来看下 `handler.rs`, 即对事件的处理部分  \n代码如下:  \n\n+++ **点击展开/隐藏代码**\n```rust src/handler.rs\nuse crate::app::{App, AppResult};\nuse crossterm::event::{KeyCode, KeyEvent, KeyModifiers};\n\n/// Handles the key events and updates the state of [`App`].\npub fn handle_key_events(key_event: KeyEvent, app: &mut App) -> AppResult<()> {\n    match key_event.code {\n        // Exit application on `ESC` or `q`\n        KeyCode::Esc | KeyCode::Char('q') => {\n            app.quit();\n        }\n        // Exit application on `Ctrl-C`\n        KeyCode::Char('c') | KeyCode::Char('C') => {\n            if key_event.modifiers == KeyModifiers::CONTROL {\n                app.quit();\n            }\n        }\n        // Counter handlers\n        KeyCode::Right => {\n            app.increment_counter();\n        }\n        KeyCode::Left => {\n            app.decrement_counter();\n        }\n        // Other handlers you could add here.\n        _ => {}\n    }\n    Ok(())\n}\n```\n+++\n\n`crossterm` 是一个用于操作终端的跨平台库, 提供了一些抽象与封装, 比如 `KeyEvent`:  \n\n```rust\npub struct KeyEvent {\n    /// The key itself.\n    pub code: KeyCode,\n    /// Additional key modifiers.\n    pub modifiers: KeyModifiers,\n    \n    // ......\n    // ......\n    // ......\n}\n```\n\n- `code`: 表示你按下的比如字母啊数字啊这种  \n- `modifiers`: 表示修饰键, 如 `Shift`/`Ctrl`/`Alt`/`Super (windows里的图标键, 或macos里的cmd键)`  \n\n顺带一提, 类似的终端操作库还有:  \n\n- `termion`: 不跨平台, 仅限linux  \n- `termwiz`: `wezterm` 的配套终端操作库, 有很多高级特性 + 跨终端, 但文档少而且api有亿点难用  \n\n`ratatui-rs` 对其都有适配与支持, 比如当你如果想使用 `termwiz` + `ratatui`, 可以这样:  \n\n```toml Cargo.toml\ntui = { package = \"ratatui\", version = \"0.21\", default_features = false, features = [\"crossterm\", \"macros\"] }\ntermwiz = { version = \"0.20.0\", features = [\"use_image\"] }\n```\n\n本系列都将使用 `crossterm`, 因为资料多文档全 ~~(加上懒)~~  \n\n位于 `handler.rs` 中的代码很好理解, 不过你可能还会再问:  \n实际的处理程序, 好像就是 `app.rs` 里面的方法啊?  \n那能不能取消这个模块, 全装到 `App` 里面去呢?  \n\n刑, 当然可刑, 只是耦合度太高了, 不能想现在这样一目了然  \n\n你想啊, 如果你全装到 `app.rs` 里面去, 本来只需要管理状态, 对状态进行保存与更改  \n但现在就得与其他模块, 比如 `event.rs` 接轨打交道, 接受分发过来的事件并匹配相应的处理函数  \n耦合度太高了!  各种事情粘在一起, 耦合在一起, 复杂啊!  \n\n因此, `handler.rs` 是必不可少的, 其作用就像是网页中的路由那样, 调用着 `app.rs` 中改变状态的方法, 降低了耦合度  \n\n**注意:**  \n此处仅处理按键事件, 这也是大多数 tui 应用会处理的唯一事件  \n你没有看见 `app::tick()`, 是因为 Event::Tick 不是按键事件, 自然没有在处理按键的相应函数中看见  \n在 `main.rs` 中, 对全部终端事件的处理是这样的 (后面会讲) :  \n\n```rust src/main.rs\n// ......\n    // Handle events.\n    match tui.events.next()? {\n        Event::Tick => app.tick(),\n        Event::Key(key_event) => handle_key_events(key_event, &mut app)?,\n        Event::Mouse(_) => {}\n        Event::Resize(_, _) => {}\n    }\n// ......\n```\n\n## 视图渲染\n一样, 我们先把简单的模块看了:  \n\n+++ **点击展开/隐藏代码**\n```rust src/ui.rs\nuse tui::{\n    backend::Backend,\n    layout::Alignment,\n    style::{Color, Style},\n    widgets::{Block, BorderType, Borders, Paragraph},\n    Frame,\n};\n\nuse crate::app::App;\n\n/// Renders the user interface widgets.\npub fn render<B: Backend>(app: &mut App, frame: &mut Frame<B>) {\n    // This is where you add new widgets.\n    // See the following resources:\n    // - https://docs.rs/ratatui/latest/ratatui/widgets/index.html\n    // - https://github.com/tui-rs-revival/ratatui/tree/master/examples\n    frame.render_widget(\n        Paragraph::new(format!(\n            \"This is a tui template.\\n\\\n                Press `Esc`, `Ctrl-C` or `q` to stop running.\\n\\\n                Press left and right to increment and decrement the counter respectively.\\n\\\n                Counter: {}\",\n            app.counter\n        ))\n        .block(\n            Block::default()\n                .title(\"Template\")\n                .title_alignment(Alignment::Center)\n                .borders(Borders::ALL)\n                .border_type(BorderType::Rounded),\n        )\n        .style(Style::default().fg(Color::Cyan).bg(Color::Black))\n        .alignment(Alignment::Center),\n        frame.size(),\n    )\n}\n```\n+++\n\n看懂就行, 渲染了一个组件叫 `Paragraph`, 将 `app` 里面的状态, 即 `app.counter` 放上去显示  \n因为 `ratatui-rs` 是 `即时模式` 的渲染策略, 所以用起来会比较简单, 当按下按键后counter加减, 视图会因为重渲染自己更新  \n\n根据 [github仓库](https://github.com/tui-rs-revival/ratatui) 里的介绍, 它会在每一个新帧渲染所有 UI  \n这虽然为丰富的交互式 UI 提供了极大的灵活性，但也可能会因高度动态的内容而带来开销  \n~~(根据这份README所说, 实际上鉴于Rust的速度, 开销一般来自于终端, 而不是库本身)~~  \n\n\n## 事件捕获\n接下来, 我们将学习 `event.rs` 里的代码:  \n\n+++ **点击展开/隐藏代码**\n```rust src/event.rs\nuse crate::app::AppResult;\nuse crossterm::event::{self, Event as CrosstermEvent, KeyEvent, MouseEvent};\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::{Duration, Instant};\n\n/// Terminal events.\n#[derive(Clone, Copy, Debug)]\npub enum Event {\n    /// Terminal tick.\n    Tick,\n    /// Key press.\n    Key(KeyEvent),\n    /// Mouse click/scroll.\n    Mouse(MouseEvent),\n    /// Terminal resize.\n    Resize(u16, u16),\n}\n\n/// Terminal event handler.\n#[allow(dead_code)]\n#[derive(Debug)]\npub struct EventHandler {\n    /// Event sender channel.\n    sender: mpsc::Sender<Event>,\n    /// Event receiver channel.\n    receiver: mpsc::Receiver<Event>,\n    /// Event handler thread.\n    handler: thread::JoinHandle<()>,\n}\n\nimpl EventHandler {\n    /// Constructs a new instance of [`EventHandler`].\n    pub fn new(tick_rate: u64) -> Self {\n        let tick_rate = Duration::from_millis(tick_rate);\n        let (sender, receiver) = mpsc::channel();\n        let handler = {\n            let sender = sender.clone();\n            thread::spawn(move || {\n                let mut last_tick = Instant::now();\n                loop {\n                    let timeout = tick_rate\n                        .checked_sub(last_tick.elapsed())\n                        .unwrap_or(tick_rate);\n\n                    if event::poll(timeout).expect(\"no events available\") {\n                        match event::read().expect(\"unable to read event\") {\n                            CrosstermEvent::Key(e) => sender.send(Event::Key(e)),\n                            CrosstermEvent::Mouse(e) => sender.send(Event::Mouse(e)),\n                            CrosstermEvent::Resize(w, h) => sender.send(Event::Resize(w, h)),\n                            _ => unimplemented!(),\n                        }\n                        .expect(\"failed to send terminal event\")\n                    }\n\n                    if last_tick.elapsed() >= tick_rate {\n                        sender.send(Event::Tick).expect(\"failed to send tick event\");\n                        last_tick = Instant::now();\n                    }\n                }\n            })\n        };\n        Self {\n            sender,\n            receiver,\n            handler,\n        }\n    }\n\n    /// Receive the next event from the handler thread.\n    ///\n    /// This function will always block the current thread if\n    /// there is no data available and it's possible for more data to be sent.\n    pub fn next(&self) -> AppResult<Event> {\n        Ok(self.receiver.recv()?)\n    }\n}\n```\n+++\n\n在这里, 我们定义了自己的 Event 枚举, \n\n\n## 终端设置\n呕吼, 你即将观看的代码, 其作用是设置与调整终端的环境, 以便我们的 tui 应用更好的运行, 接下来会逐步讲解相关概念  \n代码如下:  \n\n\n+++ **点击展开/隐藏代码**\n```rust src/tui.rs\nuse crate::app::{App, AppResult};\nuse crate::event::EventHandler;\nuse crate::ui;\nuse crossterm::event::{DisableMouseCapture, EnableMouseCapture};\nuse crossterm::terminal::{self, EnterAlternateScreen, LeaveAlternateScreen};\nuse std::io;\nuse tui::backend::Backend;\nuse tui::Terminal;\n\n/// Representation of a terminal user interface.\n///\n/// It is responsible for setting up the terminal,\n/// initializing the interface and handling the draw events.\n#[derive(Debug)]\npub struct Tui<B: Backend> {\n    /// Interface to the Terminal.\n    terminal: Terminal<B>,\n    /// Terminal event handler.\n    pub events: EventHandler,\n}\n\nimpl<B: Backend> Tui<B> {\n    /// Constructs a new instance of [`Tui`].\n    pub fn new(terminal: Terminal<B>, events: EventHandler) -> Self {\n        Self { terminal, events }\n    }\n\n    /// Initializes the terminal interface.\n    ///\n    /// It enables the raw mode and sets terminal properties.\n    pub fn init(&mut self) -> AppResult<()> {\n        terminal::enable_raw_mode()?;\n        crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;\n        self.terminal.hide_cursor()?;\n        self.terminal.clear()?;\n        Ok(())\n    }\n\n    /// [`Draw`] the terminal interface by [`rendering`] the widgets.\n    ///\n    /// [`Draw`]: tui::Terminal::draw\n    /// [`rendering`]: crate::ui:render\n    pub fn draw(&mut self, app: &mut App) -> AppResult<()> {\n        self.terminal.draw(|frame| ui::render(app, frame))?;\n        Ok(())\n    }\n\n    /// Exits the terminal interface.\n    ///\n    /// It disables the raw mode and reverts back the terminal properties.\n    pub fn exit(&mut self) -> AppResult<()> {\n        terminal::disable_raw_mode()?;\n        crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;\n        self.terminal.show_cursor()?;\n        Ok(())\n    }\n}\n```\n+++\n\n我们创建了一个叫做 `TUI` 的结构体, 它保存了\n","slug":"rust/tui/p2-基础架构","published":1,"updated":"2023-06-22T11:07:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh6002dj1s60p56bxs9","content":"<blockquote>\n<p>本节我们将学习一个 tui 应用的基本架构</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-tui\">rust-tui</a></p>\n<h1 id=\"can-kao-xiang-mu\">参考项目</h1>\n<p>本节的内容大致是带你捋下一个 tui 应用的基本架构， 参考项目是官方的 <a href=\"https://github.com/tui-rs-revival/rust-tui-template\">github.com/tui-rs-revival/rust-tui-template</a><br>\n在这之前, 你可以选择下载 <code>cargo-generate</code> 来快速开发 (当然光看下面的代码与概念也不是不行):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo install cargo-generate</span><br></pre></td></tr></table></figure>\n<p>上面的项目是一个模板项目, 专门为了让别人快速开始敲代码, 而不是将时间浪费在编写大量重复代码身上<br>\n如果你选择下载了 <code>cargo-generate</code>, 你可以通过如下命令快速搭建一个叫做 <code>tui-demo</code> 的项目 (为了网速考虑已经换成gitee镜像仓库了):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo generate --git https://gitee.com/jedsek/rust-tui-template --name tui-demo</span><br></pre></td></tr></table></figure>\n<p>你会获得一个经典的双按钮应用: 显示一个数字, 随着按键而 +1 或 -1<br>\n搭建过程讲完了, 下面开始正文, 关于架构的讲解</p>\n<hr>\n<h1 id=\"jia-gou-shuo-ming\">架构说明</h1>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/</span><br><span class=\"line\">├── app.rs     -&gt; 保存状态与应用逻辑</span><br><span class=\"line\">├── event.rs   -&gt; 将待处理的终端事件包装成我们自己定义的事件模型, 并且分发事件 (key-event, mouse-event, resize-event 等)</span><br><span class=\"line\">├── handler.rs -&gt; 接受分发的事件, 并让具体的处理函数与其一一匹配 (本系列我们只处理按键事件, 即 key-event)</span><br><span class=\"line\">├── lib.rs     -&gt; 定义模块 (单纯的别把 `pub mod xxx` 写在 `main.rs` 里面而已) </span><br><span class=\"line\">├── main.rs    -&gt; 应用程序的入口</span><br><span class=\"line\">├── tui.rs     -&gt; 初始化/退出tui时的一些操作</span><br><span class=\"line\">└── ui.rs      -&gt; 渲染组件ui</span><br></pre></td></tr></table></figure>\n<p>项目中同时存在 <code>lib.rs</code> 与 <code>main.rs</code>, 因此存在两个crate, 前者是lib_crate, 后者是bin_crate</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Application.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> app;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal events handler.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> event;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Widget renderer.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> ui;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal user interface.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> tui;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Event handler.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> handler;</span><br></pre></td></tr></table></figure>\n<p><code>lib.rs</code> 定义了这些模块, 因此我们不必在 <code>main.rs</code> 的头部再定义了<br>\n<strong>注意:</strong><br>\n当 <code>lib.rs</code> 与 <code>main.rs</code> 同时存在时, 视 <code>lib.rs</code> 为项目根, 调用里面的东西用 <code>crate::xxx</code><br>\n而 <code>main.rs</code> 则视作作为依赖的bin_crate, 比如你的项目叫 <code>tui_app</code>, 调用里面的东西时就用 <code>tui_app::xxx</code> 即可</p>\n<p>看着这些架构, 你可能会有点懵, 没事, 爷慢慢跟你说, 保证你能明白</p>\n<h2 id=\"zhuang-tai-guan-li\" id=\"状态管理\">状态管理</h2>\n<p>我们从简单开始, 先看 <code>app.rs</code>:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/app.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::error;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Application result type.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">AppResult</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> error::Error&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Application.</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">App</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Is the application running?</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> running: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\">    <span class=\"comment\">/// counter</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> counter: <span class=\"built_in\">u8</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"built_in\">Default</span> <span class=\"keyword\">for</span> App &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">default</span></span>() -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            running: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            counter: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> App &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Constructs a new instance of [`App`].</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>() -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        Self::default()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Handles the tick event of the terminal.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">tick</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set running to false to quit the application.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">quit</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.running = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">increment_counter</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(res) = <span class=\"keyword\">self</span>.counter.checked_add(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.counter = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">decrement_counter</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(res) = <span class=\"keyword\">self</span>.counter.checked_sub(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.counter = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>逻辑很简单, <code>App</code> 结构体里装着随应用运行而可能被改变的状态, 除此以外, 我们还定义了一些方法来修改这些状态</p>\n<p>比如 <code>quit()</code> 会让 <code>running</code> 变成 false, 以此来退出程序<br>\n比如 <code>inc()/dec()</code> 会让要显示的数字的值 +1/-1, 并保证处于 0…=255 的范围内不产生溢出</p>\n<p>你可能会问, <code>tick()</code> 这玩意是干啥的? 空方法有啥用?</p>\n<p>在这之前, 你需要了解下 <code>Tick</code> 的概念, 其意思是时钟秒针的滴答声, 用来表示时间的最小化单位<br>\n现实世界中目前可观测到的时间的最小单位是普朗克时间, 但一个运行在计算机里面的应用肯定不能这么算啊</p>\n<p>举个例子, 在著名的MMO类型游戏, Screeps 中, 游戏的基本时间单位就叫 <code>tick</code><br>\n所有玩家的代码会在同一时间并行执行, 随后以最后一份代码执行的结束, 代表着这一 <code>tick</code> 的结束<br>\n再举个例子, 在大部分枪战fps游戏中, 也有 <code>tick</code> 这个概念, 代表每秒钟可以刷新多少次</p>\n<p>在该模板项目中, 会在一个设定好的时间如 200ms 后, 尝试着捕获一次终端事件, 若什么事件也没, 那就分发一个 Event::Tick 给我们的处理程序<br>\n在处理程序中, 当接受到 Tick 事件时, 我们返回一个 (), 以此来无视它, 状态的变化啊, 视图的更改啊什么的, 也就根本不会发生</p>\n<p>这里的 <code>tick()</code> 方法, 也就是我们对 Event::Tick 事件的处理函数啦! 函数体是空的也就表示着无视它哦</p>\n<h2 id=\"chu-li-cheng-xu\" id=\"处理程序\">处理程序</h2>\n<p>讲完了 <code>app.rs</code> 中 <code>状态的保存</code> 与 <code>状态的更改</code> 之后, 我们会来看下 <code>handler.rs</code>, 即对事件的处理部分<br>\n代码如下:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/handler.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::app::&#123;App, AppResult&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::event::&#123;KeyCode, KeyEvent, KeyModifiers&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Handles the key events and updates the state of [`App`].</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">handle_key_events</span></span>(key_event: KeyEvent, app: &amp;<span class=\"keyword\">mut</span> App) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> key_event.code &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Exit application on `ESC` or `q`</span></span><br><span class=\"line\">        KeyCode::Esc | KeyCode::Char(<span class=\"string\">&#x27;q&#x27;</span>) =&gt; &#123;</span><br><span class=\"line\">            app.quit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Exit application on `Ctrl-C`</span></span><br><span class=\"line\">        KeyCode::Char(<span class=\"string\">&#x27;c&#x27;</span>) | KeyCode::Char(<span class=\"string\">&#x27;C&#x27;</span>) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> key_event.modifiers == KeyModifiers::CONTROL &#123;</span><br><span class=\"line\">                app.quit();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Counter handlers</span></span><br><span class=\"line\">        KeyCode::Right =&gt; &#123;</span><br><span class=\"line\">            app.increment_counter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        KeyCode::Left =&gt; &#123;</span><br><span class=\"line\">            app.decrement_counter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Other handlers you could add here.</span></span><br><span class=\"line\">        _ =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p><code>crossterm</code> 是一个用于操作终端的跨平台库, 提供了一些抽象与封装, 比如 <code>KeyEvent</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">KeyEvent</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The key itself.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> code: KeyCode,</span><br><span class=\"line\">    <span class=\"comment\">/// Additional key modifiers.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> modifiers: KeyModifiers,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>code</code>: 表示你按下的比如字母啊数字啊这种</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>modifiers</code>: 表示修饰键, 如 <code>Shift</code>/<code>Ctrl</code>/<code>Alt</code>/<code>Super (windows里的图标键, 或macos里的cmd键)</code></p>\n</li>\n</ul>\n<p>顺带一提, 类似的终端操作库还有:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>termion</code>: 不跨平台, 仅限linux</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>termwiz</code>: <code>wezterm</code> 的配套终端操作库, 有很多高级特性 + 跨终端, 但文档少而且api有亿点难用</p>\n</li>\n</ul>\n<p><code>ratatui-rs</code> 对其都有适配与支持, 比如当你如果想使用 <code>termwiz</code> + <code>ratatui</code>, 可以这样:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">tui</span> = &#123; package = <span class=\"string\">&quot;ratatui&quot;</span>, version = <span class=\"string\">&quot;0.21&quot;</span>, default_features = <span class=\"literal\">false</span>, features = [<span class=\"string\">&quot;crossterm&quot;</span>, <span class=\"string\">&quot;macros&quot;</span>] &#125;</span><br><span class=\"line\"><span class=\"attr\">termwiz</span> = &#123; version = <span class=\"string\">&quot;0.20.0&quot;</span>, features = [<span class=\"string\">&quot;use_image&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n<p>本系列都将使用 <code>crossterm</code>, 因为资料多文档全 <s>(加上懒)</s></p>\n<p>位于 <code>handler.rs</code> 中的代码很好理解, 不过你可能还会再问:<br>\n实际的处理程序, 好像就是 <code>app.rs</code> 里面的方法啊?<br>\n那能不能取消这个模块, 全装到 <code>App</code> 里面去呢?</p>\n<p>刑, 当然可刑, 只是耦合度太高了, 不能想现在这样一目了然</p>\n<p>你想啊, 如果你全装到 <code>app.rs</code> 里面去, 本来只需要管理状态, 对状态进行保存与更改<br>\n但现在就得与其他模块, 比如 <code>event.rs</code> 接轨打交道, 接受分发过来的事件并匹配相应的处理函数<br>\n耦合度太高了!  各种事情粘在一起, 耦合在一起, 复杂啊!</p>\n<p>因此, <code>handler.rs</code> 是必不可少的, 其作用就像是网页中的路由那样, 调用着 <code>app.rs</code> 中改变状态的方法, 降低了耦合度</p>\n<p><strong>注意:</strong><br>\n此处仅处理按键事件, 这也是大多数 tui 应用会处理的唯一事件<br>\n你没有看见 <code>app::tick()</code>, 是因为 Event::Tick 不是按键事件, 自然没有在处理按键的相应函数中看见<br>\n在 <code>main.rs</code> 中, 对全部终端事件的处理是这样的 (后面会讲) :</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// Handle events.</span></span><br><span class=\"line\">    <span class=\"keyword\">match</span> tui.events.next()? &#123;</span><br><span class=\"line\">        Event::Tick =&gt; app.tick(),</span><br><span class=\"line\">        Event::Key(key_event) =&gt; handle_key_events(key_event, &amp;<span class=\"keyword\">mut</span> app)?,</span><br><span class=\"line\">        Event::Mouse(_) =&gt; &#123;&#125;</span><br><span class=\"line\">        Event::Resize(_, _) =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shi-tu-xuan-ran\" id=\"视图渲染\">视图渲染</h2>\n<p>一样, 我们先把简单的模块看了:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/ui.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> tui::&#123;</span><br><span class=\"line\">    backend::Backend,</span><br><span class=\"line\">    layout::Alignment,</span><br><span class=\"line\">    style::&#123;Color, Style&#125;,</span><br><span class=\"line\">    widgets::&#123;Block, BorderType, Borders, Paragraph&#125;,</span><br><span class=\"line\">    Frame,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::app::App;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Renders the user interface widgets.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">render</span></span>&lt;B: Backend&gt;(app: &amp;<span class=\"keyword\">mut</span> App, frame: &amp;<span class=\"keyword\">mut</span> Frame&lt;B&gt;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This is where you add new widgets.</span></span><br><span class=\"line\">    <span class=\"comment\">// See the following resources:</span></span><br><span class=\"line\">    <span class=\"comment\">// - https://docs.rs/ratatui/latest/ratatui/widgets/index.html</span></span><br><span class=\"line\">    <span class=\"comment\">// - https://github.com/tui-rs-revival/ratatui/tree/master/examples</span></span><br><span class=\"line\">    frame.render_widget(</span><br><span class=\"line\">        Paragraph::new(<span class=\"built_in\">format!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;This is a tui template.\\n\\</span></span><br><span class=\"line\"><span class=\"string\">                Press `Esc`, `Ctrl-C` or `q` to stop running.\\n\\</span></span><br><span class=\"line\"><span class=\"string\">                Press left and right to increment and decrement the counter respectively.\\n\\</span></span><br><span class=\"line\"><span class=\"string\">                Counter: &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            app.counter</span><br><span class=\"line\">        ))</span><br><span class=\"line\">        .block(</span><br><span class=\"line\">            Block::default()</span><br><span class=\"line\">                .title(<span class=\"string\">&quot;Template&quot;</span>)</span><br><span class=\"line\">                .title_alignment(Alignment::Center)</span><br><span class=\"line\">                .borders(Borders::ALL)</span><br><span class=\"line\">                .border_type(BorderType::Rounded),</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .style(Style::default().fg(Color::Cyan).bg(Color::Black))</span><br><span class=\"line\">        .alignment(Alignment::Center),</span><br><span class=\"line\">        frame.size(),</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>看懂就行, 渲染了一个组件叫 <code>Paragraph</code>, 将 <code>app</code> 里面的状态, 即 <code>app.counter</code> 放上去显示<br>\n因为 <code>ratatui-rs</code> 是 <code>即时模式</code> 的渲染策略, 所以用起来会比较简单, 当按下按键后counter加减, 视图会因为重渲染自己更新</p>\n<p>根据 <a href=\"https://github.com/tui-rs-revival/ratatui\">github仓库</a> 里的介绍, 它会在每一个新帧渲染所有 UI<br>\n这虽然为丰富的交互式 UI 提供了极大的灵活性，但也可能会因高度动态的内容而带来开销<br>\n<s>(根据这份README所说, 实际上鉴于Rust的速度, 开销一般来自于终端, 而不是库本身)</s></p>\n<h2 id=\"shi-jian-bu-huo\" id=\"事件捕获\">事件捕获</h2>\n<p>接下来, 我们将学习 <code>event.rs</code> 里的代码:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/event.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::app::AppResult;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::event::&#123;<span class=\"keyword\">self</span>, Event <span class=\"keyword\">as</span> CrosstermEvent, KeyEvent, MouseEvent&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::sync::mpsc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal events.</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Clone, Copy, Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Event</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Terminal tick.</span></span><br><span class=\"line\">    Tick,</span><br><span class=\"line\">    <span class=\"comment\">/// Key press.</span></span><br><span class=\"line\">    Key(KeyEvent),</span><br><span class=\"line\">    <span class=\"comment\">/// Mouse click/scroll.</span></span><br><span class=\"line\">    Mouse(MouseEvent),</span><br><span class=\"line\">    <span class=\"comment\">/// Terminal resize.</span></span><br><span class=\"line\">    Resize(<span class=\"built_in\">u16</span>, <span class=\"built_in\">u16</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal event handler.</span></span><br><span class=\"line\"><span class=\"meta\">#[allow(dead_code)]</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EventHandler</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Event sender channel.</span></span><br><span class=\"line\">    sender: mpsc::Sender&lt;Event&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/// Event receiver channel.</span></span><br><span class=\"line\">    receiver: mpsc::Receiver&lt;Event&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/// Event handler thread.</span></span><br><span class=\"line\">    handler: thread::JoinHandle&lt;()&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> EventHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Constructs a new instance of [`EventHandler`].</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(tick_rate: <span class=\"built_in\">u64</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> tick_rate = Duration::from_millis(tick_rate);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (sender, receiver) = mpsc::channel();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sender = sender.clone();</span><br><span class=\"line\">            thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> last_tick = Instant::now();</span><br><span class=\"line\">                <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> timeout = tick_rate</span><br><span class=\"line\">                        .checked_sub(last_tick.elapsed())</span><br><span class=\"line\">                        .unwrap_or(tick_rate);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> event::poll(timeout).expect(<span class=\"string\">&quot;no events available&quot;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">match</span> event::read().expect(<span class=\"string\">&quot;unable to read event&quot;</span>) &#123;</span><br><span class=\"line\">                            CrosstermEvent::Key(e) =&gt; sender.send(Event::Key(e)),</span><br><span class=\"line\">                            CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e)),</span><br><span class=\"line\">                            CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h)),</span><br><span class=\"line\">                            _ =&gt; <span class=\"built_in\">unimplemented!</span>(),</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        .expect(<span class=\"string\">&quot;failed to send terminal event&quot;</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> last_tick.elapsed() &gt;= tick_rate &#123;</span><br><span class=\"line\">                        sender.send(Event::Tick).expect(<span class=\"string\">&quot;failed to send tick event&quot;</span>);</span><br><span class=\"line\">                        last_tick = Instant::now();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            sender,</span><br><span class=\"line\">            receiver,</span><br><span class=\"line\">            handler,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Receive the next event from the handler thread.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// This function will always block the current thread if</span></span><br><span class=\"line\">    <span class=\"comment\">/// there is no data available and it&#x27;s possible for more data to be sent.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">next</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; AppResult&lt;Event&gt; &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(<span class=\"keyword\">self</span>.receiver.recv()?)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>在这里, 我们定义了自己的 Event 枚举,</p>\n<h2 id=\"zhong-duan-she-zhi\" id=\"终端设置\">终端设置</h2>\n<p>呕吼, 你即将观看的代码, 其作用是设置与调整终端的环境, 以便我们的 tui 应用更好的运行, 接下来会逐步讲解相关概念<br>\n代码如下:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/tui.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::app::&#123;App, AppResult&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::event::EventHandler;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::ui;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::event::&#123;DisableMouseCapture, EnableMouseCapture&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::terminal::&#123;<span class=\"keyword\">self</span>, EnterAlternateScreen, LeaveAlternateScreen&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> tui::backend::Backend;</span><br><span class=\"line\"><span class=\"keyword\">use</span> tui::Terminal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Representation of a terminal user interface.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// It is responsible for setting up the terminal,</span></span><br><span class=\"line\"><span class=\"comment\">/// initializing the interface and handling the draw events.</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tui</span></span>&lt;B: Backend&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Interface to the Terminal.</span></span><br><span class=\"line\">    terminal: Terminal&lt;B&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/// Terminal event handler.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> events: EventHandler,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;B: Backend&gt; Tui&lt;B&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Constructs a new instance of [`Tui`].</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(terminal: Terminal&lt;B&gt;, events: EventHandler) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123; terminal, events &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Initializes the terminal interface.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It enables the raw mode and sets terminal properties.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">init</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">        terminal::enable_raw_mode()?;</span><br><span class=\"line\">        crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.hide_cursor()?;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.clear()?;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// [`Draw`] the terminal interface by [`rendering`] the widgets.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// [`Draw`]: tui::Terminal::draw</span></span><br><span class=\"line\">    <span class=\"comment\">/// [`rendering`]: crate::ui:render</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">draw</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, app: &amp;<span class=\"keyword\">mut</span> App) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.draw(|frame| ui::render(app, frame))?;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Exits the terminal interface.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It disables the raw mode and reverts back the terminal properties.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">exit</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">        terminal::disable_raw_mode()?;</span><br><span class=\"line\">        crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.show_cursor()?;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>我们创建了一个叫做 <code>TUI</code> 的结构体, 它保存了</p>\n","site":{"data":{}},"length":9576,"excerpt":"<blockquote>\n<p>本节我们将学习一个 tui 应用的基本架构</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-tui\">rust-tui</a></p>\n<h1 id=\"can-kao-xiang-mu\">参考项目</h1>\n<p>本节的内容大致是带你捋下一个 tui 应用的基本架构， 参考项目是官方的 <a href=\"https://github.com/tui-rs-revival/rust-tui-template\">github.com/tui-rs-revival/rust-tui-template</a><br>\n在这之前, 你可以选择下载 <code>cargo-generate</code> 来快速开发 (当然光看下面的代码与概念也不是不行):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo install cargo-generate</span><br></pre></td></tr></table></figure>\n<p>上面的项目是一个模板项目, 专门为了让别人快速开始敲代码, 而不是将时间浪费在编写大量重复代码身上<br>\n如果你选择下载了 <code>cargo-generate</code>, 你可以通过如下命令快速搭建一个叫做 <code>tui-demo</code> 的项目 (为了网速考虑已经换成gitee镜像仓库了):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo generate --git https://gitee.com/jedsek/rust-tui-template --name tui-demo</span><br></pre></td></tr></table></figure>\n<p>你会获得一个经典的双按钮应用: 显示一个数字, 随着按键而 +1 或 -1<br>\n搭建过程讲完了, 下面开始正文, 关于架构的讲解</p>\n<hr>\n<h1 id=\"jia-gou-shuo-ming\">架构说明</h1>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/</span><br><span class=\"line\">├── app.rs     -&gt; 保存状态与应用逻辑</span><br><span class=\"line\">├── event.rs   -&gt; 将待处理的终端事件包装成我们自己定义的事件模型, 并且分发事件 (key-event, mouse-event, resize-event 等)</span><br><span class=\"line\">├── handler.rs -&gt; 接受分发的事件, 并让具体的处理函数与其一一匹配 (本系列我们只处理按键事件, 即 key-event)</span><br><span class=\"line\">├── lib.rs     -&gt; 定义模块 (单纯的别把 `pub mod xxx` 写在 `main.rs` 里面而已) </span><br><span class=\"line\">├── main.rs    -&gt; 应用程序的入口</span><br><span class=\"line\">├── tui.rs     -&gt; 初始化/退出tui时的一些操作</span><br><span class=\"line\">└── ui.rs      -&gt; 渲染组件ui</span><br></pre></td></tr></table></figure>\n<p>项目中同时存在 <code>lib.rs</code> 与 <code>main.rs</code>, 因此存在两个crate, 前者是lib_crate, 后者是bin_crate</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Application.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> app;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal events handler.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> event;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Widget renderer.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> ui;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal user interface.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> tui;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Event handler.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> handler;</span><br></pre></td></tr></table></figure>\n<p><code>lib.rs</code> 定义了这些模块, 因此我们不必在 <code>main.rs</code> 的头部再定义了<br>\n<strong>注意:</strong><br>\n当 <code>lib.rs</code> 与 <code>main.rs</code> 同时存在时, 视 <code>lib.rs</code> 为项目根, 调用里面的东西用 <code>crate::xxx</code><br>\n而 <code>main.rs</code> 则视作作为依赖的bin_crate, 比如你的项目叫 <code>tui_app</code>, 调用里面的东西时就用 <code>tui_app::xxx</code> 即可</p>\n<p>看着这些架构, 你可能会有点懵, 没事, 爷慢慢跟你说, 保证你能明白</p>\n<h2 id=\"zhuang-tai-guan-li\" id=\"状态管理\">状态管理</h2>\n<p>我们从简单开始, 先看 <code>app.rs</code>:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/app.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::error;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Application result type.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">AppResult</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> error::Error&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Application.</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">App</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Is the application running?</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> running: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\">    <span class=\"comment\">/// counter</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> counter: <span class=\"built_in\">u8</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"built_in\">Default</span> <span class=\"keyword\">for</span> App &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">default</span></span>() -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            running: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            counter: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> App &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Constructs a new instance of [`App`].</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>() -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        Self::default()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Handles the tick event of the terminal.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">tick</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Set running to false to quit the application.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">quit</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.running = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">increment_counter</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(res) = <span class=\"keyword\">self</span>.counter.checked_add(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.counter = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">decrement_counter</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(res) = <span class=\"keyword\">self</span>.counter.checked_sub(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.counter = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>逻辑很简单, <code>App</code> 结构体里装着随应用运行而可能被改变的状态, 除此以外, 我们还定义了一些方法来修改这些状态</p>\n<p>比如 <code>quit()</code> 会让 <code>running</code> 变成 false, 以此来退出程序<br>\n比如 <code>inc()/dec()</code> 会让要显示的数字的值 +1/-1, 并保证处于 0…=255 的范围内不产生溢出</p>\n<p>你可能会问, <code>tick()</code> 这玩意是干啥的? 空方法有啥用?</p>\n<p>在这之前, 你需要了解下 <code>Tick</code> 的概念, 其意思是时钟秒针的滴答声, 用来表示时间的最小化单位<br>\n现实世界中目前可观测到的时间的最小单位是普朗克时间, 但一个运行在计算机里面的应用肯定不能这么算啊</p>\n<p>举个例子, 在著名的MMO类型游戏, Screeps 中, 游戏的基本时间单位就叫 <code>tick</code><br>\n所有玩家的代码会在同一时间并行执行, 随后以最后一份代码执行的结束, 代表着这一 <code>tick</code> 的结束<br>\n再举个例子, 在大部分枪战fps游戏中, 也有 <code>tick</code> 这个概念, 代表每秒钟可以刷新多少次</p>\n<p>在该模板项目中, 会在一个设定好的时间如 200ms 后, 尝试着捕获一次终端事件, 若什么事件也没, 那就分发一个 Event::Tick 给我们的处理程序<br>\n在处理程序中, 当接受到 Tick 事件时, 我们返回一个 (), 以此来无视它, 状态的变化啊, 视图的更改啊什么的, 也就根本不会发生</p>\n<p>这里的 <code>tick()</code> 方法, 也就是我们对 Event::Tick 事件的处理函数啦! 函数体是空的也就表示着无视它哦</p>\n<h2 id=\"chu-li-cheng-xu\" id=\"处理程序\">处理程序</h2>\n<p>讲完了 <code>app.rs</code> 中 <code>状态的保存</code> 与 <code>状态的更改</code> 之后, 我们会来看下 <code>handler.rs</code>, 即对事件的处理部分<br>\n代码如下:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/handler.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::app::&#123;App, AppResult&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::event::&#123;KeyCode, KeyEvent, KeyModifiers&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Handles the key events and updates the state of [`App`].</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">handle_key_events</span></span>(key_event: KeyEvent, app: &amp;<span class=\"keyword\">mut</span> App) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> key_event.code &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Exit application on `ESC` or `q`</span></span><br><span class=\"line\">        KeyCode::Esc | KeyCode::Char(<span class=\"string\">&#x27;q&#x27;</span>) =&gt; &#123;</span><br><span class=\"line\">            app.quit();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Exit application on `Ctrl-C`</span></span><br><span class=\"line\">        KeyCode::Char(<span class=\"string\">&#x27;c&#x27;</span>) | KeyCode::Char(<span class=\"string\">&#x27;C&#x27;</span>) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> key_event.modifiers == KeyModifiers::CONTROL &#123;</span><br><span class=\"line\">                app.quit();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Counter handlers</span></span><br><span class=\"line\">        KeyCode::Right =&gt; &#123;</span><br><span class=\"line\">            app.increment_counter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        KeyCode::Left =&gt; &#123;</span><br><span class=\"line\">            app.decrement_counter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Other handlers you could add here.</span></span><br><span class=\"line\">        _ =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p><code>crossterm</code> 是一个用于操作终端的跨平台库, 提供了一些抽象与封装, 比如 <code>KeyEvent</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">KeyEvent</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The key itself.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> code: KeyCode,</span><br><span class=\"line\">    <span class=\"comment\">/// Additional key modifiers.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> modifiers: KeyModifiers,</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>code</code>: 表示你按下的比如字母啊数字啊这种</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>modifiers</code>: 表示修饰键, 如 <code>Shift</code>/<code>Ctrl</code>/<code>Alt</code>/<code>Super (windows里的图标键, 或macos里的cmd键)</code></p>\n</li>\n</ul>\n<p>顺带一提, 类似的终端操作库还有:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>termion</code>: 不跨平台, 仅限linux</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>termwiz</code>: <code>wezterm</code> 的配套终端操作库, 有很多高级特性 + 跨终端, 但文档少而且api有亿点难用</p>\n</li>\n</ul>\n<p><code>ratatui-rs</code> 对其都有适配与支持, 比如当你如果想使用 <code>termwiz</code> + <code>ratatui</code>, 可以这样:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">tui</span> = &#123; package = <span class=\"string\">&quot;ratatui&quot;</span>, version = <span class=\"string\">&quot;0.21&quot;</span>, default_features = <span class=\"literal\">false</span>, features = [<span class=\"string\">&quot;crossterm&quot;</span>, <span class=\"string\">&quot;macros&quot;</span>] &#125;</span><br><span class=\"line\"><span class=\"attr\">termwiz</span> = &#123; version = <span class=\"string\">&quot;0.20.0&quot;</span>, features = [<span class=\"string\">&quot;use_image&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n<p>本系列都将使用 <code>crossterm</code>, 因为资料多文档全 <s>(加上懒)</s></p>\n<p>位于 <code>handler.rs</code> 中的代码很好理解, 不过你可能还会再问:<br>\n实际的处理程序, 好像就是 <code>app.rs</code> 里面的方法啊?<br>\n那能不能取消这个模块, 全装到 <code>App</code> 里面去呢?</p>\n<p>刑, 当然可刑, 只是耦合度太高了, 不能想现在这样一目了然</p>\n<p>你想啊, 如果你全装到 <code>app.rs</code> 里面去, 本来只需要管理状态, 对状态进行保存与更改<br>\n但现在就得与其他模块, 比如 <code>event.rs</code> 接轨打交道, 接受分发过来的事件并匹配相应的处理函数<br>\n耦合度太高了!  各种事情粘在一起, 耦合在一起, 复杂啊!</p>\n<p>因此, <code>handler.rs</code> 是必不可少的, 其作用就像是网页中的路由那样, 调用着 <code>app.rs</code> 中改变状态的方法, 降低了耦合度</p>\n<p><strong>注意:</strong><br>\n此处仅处理按键事件, 这也是大多数 tui 应用会处理的唯一事件<br>\n你没有看见 <code>app::tick()</code>, 是因为 Event::Tick 不是按键事件, 自然没有在处理按键的相应函数中看见<br>\n在 <code>main.rs</code> 中, 对全部终端事件的处理是这样的 (后面会讲) :</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// Handle events.</span></span><br><span class=\"line\">    <span class=\"keyword\">match</span> tui.events.next()? &#123;</span><br><span class=\"line\">        Event::Tick =&gt; app.tick(),</span><br><span class=\"line\">        Event::Key(key_event) =&gt; handle_key_events(key_event, &amp;<span class=\"keyword\">mut</span> app)?,</span><br><span class=\"line\">        Event::Mouse(_) =&gt; &#123;&#125;</span><br><span class=\"line\">        Event::Resize(_, _) =&gt; &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"shi-tu-xuan-ran\" id=\"视图渲染\">视图渲染</h2>\n<p>一样, 我们先把简单的模块看了:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/ui.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> tui::&#123;</span><br><span class=\"line\">    backend::Backend,</span><br><span class=\"line\">    layout::Alignment,</span><br><span class=\"line\">    style::&#123;Color, Style&#125;,</span><br><span class=\"line\">    widgets::&#123;Block, BorderType, Borders, Paragraph&#125;,</span><br><span class=\"line\">    Frame,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::app::App;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Renders the user interface widgets.</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">render</span></span>&lt;B: Backend&gt;(app: &amp;<span class=\"keyword\">mut</span> App, frame: &amp;<span class=\"keyword\">mut</span> Frame&lt;B&gt;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This is where you add new widgets.</span></span><br><span class=\"line\">    <span class=\"comment\">// See the following resources:</span></span><br><span class=\"line\">    <span class=\"comment\">// - https://docs.rs/ratatui/latest/ratatui/widgets/index.html</span></span><br><span class=\"line\">    <span class=\"comment\">// - https://github.com/tui-rs-revival/ratatui/tree/master/examples</span></span><br><span class=\"line\">    frame.render_widget(</span><br><span class=\"line\">        Paragraph::new(<span class=\"built_in\">format!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;This is a tui template.\\n\\</span></span><br><span class=\"line\"><span class=\"string\">                Press `Esc`, `Ctrl-C` or `q` to stop running.\\n\\</span></span><br><span class=\"line\"><span class=\"string\">                Press left and right to increment and decrement the counter respectively.\\n\\</span></span><br><span class=\"line\"><span class=\"string\">                Counter: &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            app.counter</span><br><span class=\"line\">        ))</span><br><span class=\"line\">        .block(</span><br><span class=\"line\">            Block::default()</span><br><span class=\"line\">                .title(<span class=\"string\">&quot;Template&quot;</span>)</span><br><span class=\"line\">                .title_alignment(Alignment::Center)</span><br><span class=\"line\">                .borders(Borders::ALL)</span><br><span class=\"line\">                .border_type(BorderType::Rounded),</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .style(Style::default().fg(Color::Cyan).bg(Color::Black))</span><br><span class=\"line\">        .alignment(Alignment::Center),</span><br><span class=\"line\">        frame.size(),</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>看懂就行, 渲染了一个组件叫 <code>Paragraph</code>, 将 <code>app</code> 里面的状态, 即 <code>app.counter</code> 放上去显示<br>\n因为 <code>ratatui-rs</code> 是 <code>即时模式</code> 的渲染策略, 所以用起来会比较简单, 当按下按键后counter加减, 视图会因为重渲染自己更新</p>\n<p>根据 <a href=\"https://github.com/tui-rs-revival/ratatui\">github仓库</a> 里的介绍, 它会在每一个新帧渲染所有 UI<br>\n这虽然为丰富的交互式 UI 提供了极大的灵活性，但也可能会因高度动态的内容而带来开销<br>\n<s>(根据这份README所说, 实际上鉴于Rust的速度, 开销一般来自于终端, 而不是库本身)</s></p>\n<h2 id=\"shi-jian-bu-huo\" id=\"事件捕获\">事件捕获</h2>\n<p>接下来, 我们将学习 <code>event.rs</code> 里的代码:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/event.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::app::AppResult;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::event::&#123;<span class=\"keyword\">self</span>, Event <span class=\"keyword\">as</span> CrosstermEvent, KeyEvent, MouseEvent&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::sync::mpsc;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::time::&#123;Duration, Instant&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal events.</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Clone, Copy, Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Event</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Terminal tick.</span></span><br><span class=\"line\">    Tick,</span><br><span class=\"line\">    <span class=\"comment\">/// Key press.</span></span><br><span class=\"line\">    Key(KeyEvent),</span><br><span class=\"line\">    <span class=\"comment\">/// Mouse click/scroll.</span></span><br><span class=\"line\">    Mouse(MouseEvent),</span><br><span class=\"line\">    <span class=\"comment\">/// Terminal resize.</span></span><br><span class=\"line\">    Resize(<span class=\"built_in\">u16</span>, <span class=\"built_in\">u16</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Terminal event handler.</span></span><br><span class=\"line\"><span class=\"meta\">#[allow(dead_code)]</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EventHandler</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Event sender channel.</span></span><br><span class=\"line\">    sender: mpsc::Sender&lt;Event&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/// Event receiver channel.</span></span><br><span class=\"line\">    receiver: mpsc::Receiver&lt;Event&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/// Event handler thread.</span></span><br><span class=\"line\">    handler: thread::JoinHandle&lt;()&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> EventHandler &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Constructs a new instance of [`EventHandler`].</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(tick_rate: <span class=\"built_in\">u64</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> tick_rate = Duration::from_millis(tick_rate);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> (sender, receiver) = mpsc::channel();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sender = sender.clone();</span><br><span class=\"line\">            thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> last_tick = Instant::now();</span><br><span class=\"line\">                <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> timeout = tick_rate</span><br><span class=\"line\">                        .checked_sub(last_tick.elapsed())</span><br><span class=\"line\">                        .unwrap_or(tick_rate);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> event::poll(timeout).expect(<span class=\"string\">&quot;no events available&quot;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">match</span> event::read().expect(<span class=\"string\">&quot;unable to read event&quot;</span>) &#123;</span><br><span class=\"line\">                            CrosstermEvent::Key(e) =&gt; sender.send(Event::Key(e)),</span><br><span class=\"line\">                            CrosstermEvent::Mouse(e) =&gt; sender.send(Event::Mouse(e)),</span><br><span class=\"line\">                            CrosstermEvent::Resize(w, h) =&gt; sender.send(Event::Resize(w, h)),</span><br><span class=\"line\">                            _ =&gt; <span class=\"built_in\">unimplemented!</span>(),</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        .expect(<span class=\"string\">&quot;failed to send terminal event&quot;</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> last_tick.elapsed() &gt;= tick_rate &#123;</span><br><span class=\"line\">                        sender.send(Event::Tick).expect(<span class=\"string\">&quot;failed to send tick event&quot;</span>);</span><br><span class=\"line\">                        last_tick = Instant::now();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">            sender,</span><br><span class=\"line\">            receiver,</span><br><span class=\"line\">            handler,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Receive the next event from the handler thread.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// This function will always block the current thread if</span></span><br><span class=\"line\">    <span class=\"comment\">/// there is no data available and it&#x27;s possible for more data to be sent.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">next</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; AppResult&lt;Event&gt; &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(<span class=\"keyword\">self</span>.receiver.recv()?)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>在这里, 我们定义了自己的 Event 枚举,</p>\n<h2 id=\"zhong-duan-she-zhi\" id=\"终端设置\">终端设置</h2>\n<p>呕吼, 你即将观看的代码, 其作用是设置与调整终端的环境, 以便我们的 tui 应用更好的运行, 接下来会逐步讲解相关概念<br>\n代码如下:</p>\n<details open>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏代码</strong></summary><figure class=\"highlight rust\"><figcaption><span>src/tui.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::app::&#123;App, AppResult&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::event::EventHandler;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::ui;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::event::&#123;DisableMouseCapture, EnableMouseCapture&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> crossterm::terminal::&#123;<span class=\"keyword\">self</span>, EnterAlternateScreen, LeaveAlternateScreen&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> tui::backend::Backend;</span><br><span class=\"line\"><span class=\"keyword\">use</span> tui::Terminal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Representation of a terminal user interface.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// It is responsible for setting up the terminal,</span></span><br><span class=\"line\"><span class=\"comment\">/// initializing the interface and handling the draw events.</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tui</span></span>&lt;B: Backend&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Interface to the Terminal.</span></span><br><span class=\"line\">    terminal: Terminal&lt;B&gt;,</span><br><span class=\"line\">    <span class=\"comment\">/// Terminal event handler.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> events: EventHandler,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;B: Backend&gt; Tui&lt;B&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Constructs a new instance of [`Tui`].</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>(terminal: Terminal&lt;B&gt;, events: EventHandler) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Self</span> &#123; terminal, events &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Initializes the terminal interface.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It enables the raw mode and sets terminal properties.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">init</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">        terminal::enable_raw_mode()?;</span><br><span class=\"line\">        crossterm::execute!(io::stderr(), EnterAlternateScreen, EnableMouseCapture)?;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.hide_cursor()?;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.clear()?;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// [`Draw`] the terminal interface by [`rendering`] the widgets.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// [`Draw`]: tui::Terminal::draw</span></span><br><span class=\"line\">    <span class=\"comment\">/// [`rendering`]: crate::ui:render</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">draw</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, app: &amp;<span class=\"keyword\">mut</span> App) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.draw(|frame| ui::render(app, frame))?;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Exits the terminal interface.</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">/// It disables the raw mode and reverts back the terminal properties.</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">exit</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) -&gt; AppResult&lt;()&gt; &#123;</span><br><span class=\"line\">        terminal::disable_raw_mode()?;</span><br><span class=\"line\">        crossterm::execute!(io::stderr(), LeaveAlternateScreen, DisableMouseCapture)?;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.terminal.show_cursor()?;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</details>\n<p>我们创建了一个叫做 <code>TUI</code> 的结构体, 它保存了</p>"},{"title":"Rust中那些常见的错误","abbrlink":"posts/rust-common-errors","hidden":false,"date":"2023-06-08T04:08:42.000Z","top":49999,"keywords":["Rust"],"_content":"> 一起来见识下那些 Rust 编程语言中常见的错误吧!\n<!-- more -->\n\n**本文说明:**\n本文会记录一下我本人遇见过的一些错误, 供大家参考, 喜欢或多或少能帮到大家  \n错误来源于群聊或者个人开发  \n开始吧! 时间...要加速了!! (jojo立, 神父换碟)  \n\n**注意:**  \n本文正在长期更新中, 你所看见的并非成品  \n\n\n# 对模式匹配不敏感\n\n```rust\nuse std::fmt::Display;\n\nfn info<T: Display>(t: &T) {\n    println!(\"{t}\")\n}\n\nfn main() {\n    // 报错\n    let a: &str = \"str_a\";\n    info(a);\n    \n    // 不报错\n    let b: &&str = &\"str_b\";\n    info(b);\n}\n```\n\n如果你在 [rust-playground](https://play.rust-lang.org) 上运行这段代码, 会报如下错误:  \n\n```\n --> src/main.rs:11:10\n   |\n   |     info(a);\n   |     ---- ^ doesn't have a size known at compile-time\n   |     |\n   |     required by a bound introduced by this call\n   |\nhelp: the trait `Sized` is not implemented for `str`\nnote: required by a bound in `info`\n\n  --> src/main.rs:3:9\n   |\n   | fn info<T: Display>(t: &T) {\n   |         ^ required by this bound in `info`\nhelp: consider relaxing the implicit `Sized` restriction\n   |\n   | fn info<T: Display + ?Sized>(t: &T) {\n   |                    ++++++++\n```\n\n报错信息非常友善, 第一段说, 我们在调用 `info` 函数时, 参数的大小无法在编译器知晓  \n随后提示帮助: `str` 没有实现 `Sized`, 即 `str` 的大小在编译期时无法求解  \n道理很简单嘛, 我们在模式匹配的时候, `&str` 对应 `&T`, 所以说 `T` 的类型是 `str`  \n又因为 Rust 中默认泛型 `T` 是 `T: Sized`, 所以自然报错了  \n\n编译器还非常贴心地在第二段贴出解决方案, 那就是为 `T` 指明, `T` 可以是大小在编译期时不知晓的 `?Sized`  \n毕竟 `T` 虽然是 `?Sized`, 但我们使用的参数 `t` 是 `&T` 嘛, 完全没有问题! 所以改成如下即可  \n\n```rust\nuse std::fmt::Display;\n\nfn info<T: Display + ?Sized>(t: &T) {\n    println!(\"{t}\")\n}\n\nfn main() {\n    let a: &str = \"str_a\";\n    info(a);\n    \n    let b: &&str = &\"str_b\";\n    info(b);\n}\n```\n\nPerfect!\n","source":"_posts/rust/syntax/Rust那些常见的错误.md","raw":"---\ntitle: Rust中那些常见的错误\nabbrlink: posts/rust-common-errors\nhidden: false\ndate: 2023-06-08 12:08:42\ntop: 49999\ntags: [Rust]\nkeywords: [Rust]\n---\n> 一起来见识下那些 Rust 编程语言中常见的错误吧!\n<!-- more -->\n\n**本文说明:**\n本文会记录一下我本人遇见过的一些错误, 供大家参考, 喜欢或多或少能帮到大家  \n错误来源于群聊或者个人开发  \n开始吧! 时间...要加速了!! (jojo立, 神父换碟)  \n\n**注意:**  \n本文正在长期更新中, 你所看见的并非成品  \n\n\n# 对模式匹配不敏感\n\n```rust\nuse std::fmt::Display;\n\nfn info<T: Display>(t: &T) {\n    println!(\"{t}\")\n}\n\nfn main() {\n    // 报错\n    let a: &str = \"str_a\";\n    info(a);\n    \n    // 不报错\n    let b: &&str = &\"str_b\";\n    info(b);\n}\n```\n\n如果你在 [rust-playground](https://play.rust-lang.org) 上运行这段代码, 会报如下错误:  \n\n```\n --> src/main.rs:11:10\n   |\n   |     info(a);\n   |     ---- ^ doesn't have a size known at compile-time\n   |     |\n   |     required by a bound introduced by this call\n   |\nhelp: the trait `Sized` is not implemented for `str`\nnote: required by a bound in `info`\n\n  --> src/main.rs:3:9\n   |\n   | fn info<T: Display>(t: &T) {\n   |         ^ required by this bound in `info`\nhelp: consider relaxing the implicit `Sized` restriction\n   |\n   | fn info<T: Display + ?Sized>(t: &T) {\n   |                    ++++++++\n```\n\n报错信息非常友善, 第一段说, 我们在调用 `info` 函数时, 参数的大小无法在编译器知晓  \n随后提示帮助: `str` 没有实现 `Sized`, 即 `str` 的大小在编译期时无法求解  \n道理很简单嘛, 我们在模式匹配的时候, `&str` 对应 `&T`, 所以说 `T` 的类型是 `str`  \n又因为 Rust 中默认泛型 `T` 是 `T: Sized`, 所以自然报错了  \n\n编译器还非常贴心地在第二段贴出解决方案, 那就是为 `T` 指明, `T` 可以是大小在编译期时不知晓的 `?Sized`  \n毕竟 `T` 虽然是 `?Sized`, 但我们使用的参数 `t` 是 `&T` 嘛, 完全没有问题! 所以改成如下即可  \n\n```rust\nuse std::fmt::Display;\n\nfn info<T: Display + ?Sized>(t: &T) {\n    println!(\"{t}\")\n}\n\nfn main() {\n    let a: &str = \"str_a\";\n    info(a);\n    \n    let b: &&str = &\"str_b\";\n    info(b);\n}\n```\n\nPerfect!\n","slug":"rust/syntax/Rust那些常见的错误","published":1,"updated":"2023-06-08T04:08:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh7002fj1s6ec4jcsw7","content":"<blockquote>\n<p>一起来见识下那些 Rust 编程语言中常见的错误吧!</p>\n</blockquote>\n<span id=\"more\"></span>\n<p><strong>本文说明:</strong><br>\n本文会记录一下我本人遇见过的一些错误, 供大家参考, 喜欢或多或少能帮到大家<br>\n错误来源于群聊或者个人开发<br>\n开始吧! 时间…要加速了!! (jojo立, 神父换碟)</p>\n<p><strong>注意:</strong><br>\n本文正在长期更新中, 你所看见的并非成品</p>\n<h1 id=\"dui-mo-shi-pi-pei-bu-min-gan\">对模式匹配不敏感</h1>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::Display;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">info</span></span>&lt;T: Display&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;t&#125;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 报错</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;str_a&quot;</span>;</span><br><span class=\"line\">    info(a);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 不报错</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b: &amp;&amp;<span class=\"built_in\">str</span> = &amp;<span class=\"string\">&quot;str_b&quot;</span>;</span><br><span class=\"line\">    info(b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你在 <a href=\"https://play.rust-lang.org\">rust-playground</a> 上运行这段代码, 会报如下错误:</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">--&gt; src/main.rs:11:10</span></span><br><span class=\"line\">   |</span><br><span class=\"line\">   |     <span class=\"keyword\">info</span>(a);</span><br><span class=\"line\">   |     <span class=\"comment\">---- ^ doesn&#x27;t have a size known at compile-time</span></span><br><span class=\"line\">   |     |</span><br><span class=\"line\">   |     required <span class=\"keyword\">by</span> a bound introduced <span class=\"keyword\">by</span> this <span class=\"keyword\">call</span></span><br><span class=\"line\">   |</span><br><span class=\"line\">help: the trait `Sized` <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> implemented <span class=\"keyword\">for</span> `str`</span><br><span class=\"line\">note: required <span class=\"keyword\">by</span> a bound <span class=\"keyword\">in</span> `<span class=\"keyword\">info</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">--&gt; src/main.rs:3:9</span></span><br><span class=\"line\">   |</span><br><span class=\"line\">   | fn <span class=\"keyword\">info</span>&lt;T: Display&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">   |         ^ required <span class=\"keyword\">by</span> this bound <span class=\"keyword\">in</span> `<span class=\"keyword\">info</span>`</span><br><span class=\"line\">help: consider relaxing the implicit `Sized` restriction</span><br><span class=\"line\">   |</span><br><span class=\"line\">   | fn <span class=\"keyword\">info</span>&lt;T: Display + ?Sized&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">   |                    ++++++++</span><br></pre></td></tr></table></figure>\n<p>报错信息非常友善, 第一段说, 我们在调用 <code>info</code> 函数时, 参数的大小无法在编译器知晓<br>\n随后提示帮助: <code>str</code> 没有实现 <code>Sized</code>, 即 <code>str</code> 的大小在编译期时无法求解<br>\n道理很简单嘛, 我们在模式匹配的时候, <code>&amp;str</code> 对应 <code>&amp;T</code>, 所以说 <code>T</code> 的类型是 <code>str</code><br>\n又因为 Rust 中默认泛型 <code>T</code> 是 <code>T: Sized</code>, 所以自然报错了</p>\n<p>编译器还非常贴心地在第二段贴出解决方案, 那就是为 <code>T</code> 指明, <code>T</code> 可以是大小在编译期时不知晓的 <code>?Sized</code><br>\n毕竟 <code>T</code> 虽然是 <code>?Sized</code>, 但我们使用的参数 <code>t</code> 是 <code>&amp;T</code> 嘛, 完全没有问题! 所以改成如下即可</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::Display;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">info</span></span>&lt;T: Display + ?<span class=\"built_in\">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;t&#125;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;str_a&quot;</span>;</span><br><span class=\"line\">    info(a);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> b: &amp;&amp;<span class=\"built_in\">str</span> = &amp;<span class=\"string\">&quot;str_b&quot;</span>;</span><br><span class=\"line\">    info(b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Perfect!</p>\n","site":{"data":{}},"length":1249,"excerpt":"<blockquote>\n<p>一起来见识下那些 Rust 编程语言中常见的错误吧!</p>\n</blockquote>","more":"<p><strong>本文说明:</strong><br>\n本文会记录一下我本人遇见过的一些错误, 供大家参考, 喜欢或多或少能帮到大家<br>\n错误来源于群聊或者个人开发<br>\n开始吧! 时间…要加速了!! (jojo立, 神父换碟)</p>\n<p><strong>注意:</strong><br>\n本文正在长期更新中, 你所看见的并非成品</p>\n<h1 id=\"dui-mo-shi-pi-pei-bu-min-gan\">对模式匹配不敏感</h1>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::Display;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">info</span></span>&lt;T: Display&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;t&#125;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 报错</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;str_a&quot;</span>;</span><br><span class=\"line\">    info(a);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 不报错</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b: &amp;&amp;<span class=\"built_in\">str</span> = &amp;<span class=\"string\">&quot;str_b&quot;</span>;</span><br><span class=\"line\">    info(b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你在 <a href=\"https://play.rust-lang.org\">rust-playground</a> 上运行这段代码, 会报如下错误:</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">--&gt; src/main.rs:11:10</span></span><br><span class=\"line\">   |</span><br><span class=\"line\">   |     <span class=\"keyword\">info</span>(a);</span><br><span class=\"line\">   |     <span class=\"comment\">---- ^ doesn&#x27;t have a size known at compile-time</span></span><br><span class=\"line\">   |     |</span><br><span class=\"line\">   |     required <span class=\"keyword\">by</span> a bound introduced <span class=\"keyword\">by</span> this <span class=\"keyword\">call</span></span><br><span class=\"line\">   |</span><br><span class=\"line\">help: the trait `Sized` <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> implemented <span class=\"keyword\">for</span> `str`</span><br><span class=\"line\">note: required <span class=\"keyword\">by</span> a bound <span class=\"keyword\">in</span> `<span class=\"keyword\">info</span>`</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">--&gt; src/main.rs:3:9</span></span><br><span class=\"line\">   |</span><br><span class=\"line\">   | fn <span class=\"keyword\">info</span>&lt;T: Display&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">   |         ^ required <span class=\"keyword\">by</span> this bound <span class=\"keyword\">in</span> `<span class=\"keyword\">info</span>`</span><br><span class=\"line\">help: consider relaxing the implicit `Sized` restriction</span><br><span class=\"line\">   |</span><br><span class=\"line\">   | fn <span class=\"keyword\">info</span>&lt;T: Display + ?Sized&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">   |                    ++++++++</span><br></pre></td></tr></table></figure>\n<p>报错信息非常友善, 第一段说, 我们在调用 <code>info</code> 函数时, 参数的大小无法在编译器知晓<br>\n随后提示帮助: <code>str</code> 没有实现 <code>Sized</code>, 即 <code>str</code> 的大小在编译期时无法求解<br>\n道理很简单嘛, 我们在模式匹配的时候, <code>&amp;str</code> 对应 <code>&amp;T</code>, 所以说 <code>T</code> 的类型是 <code>str</code><br>\n又因为 Rust 中默认泛型 <code>T</code> 是 <code>T: Sized</code>, 所以自然报错了</p>\n<p>编译器还非常贴心地在第二段贴出解决方案, 那就是为 <code>T</code> 指明, <code>T</code> 可以是大小在编译期时不知晓的 <code>?Sized</code><br>\n毕竟 <code>T</code> 虽然是 <code>?Sized</code>, 但我们使用的参数 <code>t</code> 是 <code>&amp;T</code> 嘛, 完全没有问题! 所以改成如下即可</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::Display;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">info</span></span>&lt;T: Display + ?<span class=\"built_in\">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;t&#125;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;str_a&quot;</span>;</span><br><span class=\"line\">    info(a);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> b: &amp;&amp;<span class=\"built_in\">str</span> = &amp;<span class=\"string\">&quot;str_b&quot;</span>;</span><br><span class=\"line\">    info(b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Perfect!</p>"},{"title":"rust-atomics-and-locks-p2-基础概念","abbrlink":"posts/rust-atomics-and-locks/p2","hidden":false,"date":"2023-06-23T11:04:09.000Z","top":95998,"keywords":["Rust","Concurrency"],"is_series":true,"prev_post":["posts/rust-atomics-and-locks/p1","系列说明"],"next_post":["posts/rust-atomics-and-locks/p2","基础概念"],"_content":"\n> 本节我们将学习线程、互斥锁、条件变量、线程安全、共享和独占引用、内部可变性等内容  \n<!-- more -->\n\n同系列传送门: [rust-atomics-and-locks](/categories/rust-atomics-and-locks)\n\n# 开篇\n早在多核处理器普及之前, 操作系统就允许一台计算机同时运行许多程序  \n这是通过在进程间快速切换来实现的, 允许每个进程一个接一个地重复取得一点进展  \n如今, 几乎所有的计算机, 甚至我们的手机和手表都有多核处理器, 可以真正并行执行多个进程  \n\n操作系统尽可能将进程彼此隔离, 允许程序在完全不知道其他进程在做什么的情况下, 做自己的事情  \n例如, 一个进程在不询问操作系统的内核之前, 通常无法访问另一个进程的内存, 也无法以任何方式与之通信  \n\n但是, 程序可以生成额外的名为线程之物, 作为同一进程下的一部分   \n同一进程中的线程彼此之间不隔离, 线程共享内存, 并且可以通过该内存相互交互  \n\n本章将解释线程在 Rust 中是如何生成的, 以及围绕它们的所有基本概念, 例如如何在多个线程之间安全地共享数据  \n本章中解释的概念是本系列中其余部分的基础  \n\n- - -\n\n# Rust 中的线程\n每个程序都只能从主线程开始, 即 `main` 函数所在的线程  \n该线程将执行您的 `main` 函数，并可以生成更多子线程  \n\n**当主线程结束之后, 由其派生的子线程也将直接提前结束**  \n\n在 Rust 中, 新线程是通过 `std::thread::spawn` 函数生成的, 它需要一个参数, 代表将执行的函数  \n此函数返回/结束后, 该线程将停止  \n\n来看个例子:  \n\n```rust\nuse std::thread;\n\nfn main() {\n    thread::spawn(f);\n    thread::spawn(f);\n\n    println!(\"Hello from the main thread.\");\n}\n\nfn f() {\n    println!(\"Hello from another thread!\");\n\n    let id = thread::current().id();\n    println!(\"This is my thread id: {id:?}\");\n}\n```\n\n我们生成(spawn)了两个线程, 它们都将执行 `f` 作为其主要函数  \n这两个线程都将打印一条消息, 并显示其 `线程ID`, 而主线程也将打印自己的消息  \n\n**Thread ID:**  \nRust 标准库为每个线程分配一个唯一的标识符, 此标识符可通过 Thread::id() 访问, 类型为 ThreadId   \n除了复制它们并检查相等性之外, 您对 ThreadId 无能为力, 不能保证这些 ID 将连续分配, 只是每个线程的 ID 会有所不同  \n\n如果您多次运行上面的示例程序, 您可能会注意到两次运行之间的输出不同, 这是我在一次特定运行期间在机器上获得的输出:  \n\n```text\nHello from the main thread.\nHello from another thread!\nThis is my thread id:\n```\n\n令人惊讶的是, 部分输出似乎丢失了  \n这是因为, 在新生成的线程完成其传入的函数之前, 主线程就已经完成了 main 函数  \n从 main 返回将退出整个程序, 即使其他线程仍在运行  \n\n在该示例中, 在程序被主线程关闭前, 其中一个新生成的线程只发生了一半的消息  \n如果我们想确保, 线程在从 main 返回之前完成, 我们可以通过 `join` 来等待它们  \n为此, 我们要使用 `spawn` 函数返回的 `JoinHandle`:  \n\n```rust\nfn main() {\n    let t1 = thread::spawn(f);\n    let t2 = thread::spawn(f);\n\n    println!(\"Hello from the main thread.\");\n\n    t1.join().unwrap();\n    t2.join().unwrap();\n}\n```\n\n`.join()` 方法将等待线程完成执行, 并返回 `std::thread::Result`  \n若线程由于死机而未成功完成其功能, 这将包含死机消息, 我们可以尝试处理这种情况, 或者在加入恐慌线程时只调用 `.unwrap()` 以恐慌  \n\n运行此版本的代码将不再导致输出的截断:  \n\n```text\nHello from the main thread.\nHello from another thread!\nThis is my thread id: ThreadId(3)\nHello from another thread!\nThis is my thread id: ThreadId(2)\n```\n\n运行之间仍然更改的是消息们的打印顺序, 因为是并发, 所以无法保证先后顺序  \n\n**Output Locking:**  \n`println!` 使用 `std::io::Stdout::lock()`, 来确保其输出不会因线程间的并发而交替  \n`println!()` 将等到任何并发运行的表达式完成, 然后再写入任何输出  \n如果不是这种情况, 我们可能会得到更多交错的混乱的输出:  \n\n```text\nHello fromHello from another thread!\n another This is my threthreadHello fromthread id: ThreadId!\n( the main thread.\n2)This is my thread\nid: ThreadId(3)\n```\n\n与其将函数传递给 `std::thread::spawn`, 不如将闭包传递给它, 这允许我们捕获值, 并将其移动到新线程中:  \n\n```rust\nlet numbers = vec![1, 2, 3];\n\nthread::spawn(move || {\n    for n in &numbers {\n        println!(\"{n}\");\n    }\n}).join().unwrap();\n```\n\n此处, `numbers` 的所有权转移到了新生成的线程中, 因为我们使用了 `move` 闭包  \n若我们未使用 `move` 关键字, 闭包将通过引用捕获 `numbers`, 这将导致编译错误, 因为新线程的寿命可能超过该变量  \n\n由于线程可能一直运行到程序执行结束, 因此 `spawn` 函数的参数类型具有 'static 约束  \n换句话说, 它只接受永远存在的函数, 而通过引用捕获局部变量的闭包, 闭包可能不会永远有效  \n因为, 当局部变量不复存在时，对该变量的引用自然变得无效, 闭包也因此变得无效  \n\n从线程中获取的返回值, 实际上就是传入的闭包的返回值, 它可以从 `join` 方法返回的 `Result` 中获取:  \n\n```rust\nlet numbers = Vec::from_iter(0..=1000);\n\nlet t = thread::spawn(move || {\n    let len = numbers.len();\n    let sum = numbers.iter().sum::<usize>();\n    sum / len  // 1\n});\n\nlet average = t.join().unwrap(); // 2\n\nprintln!(\"average: {average}\");\n```\n\n在这里, 闭包 (1) 返回的值通过 join 方法 (2) 的返回值获取  \n若 numbers 为空，则新线程会尝试除以零 (1), 这将导致 panic, 而 `join` 则会返回 Err, 导致主线程也因为 unwrap 而 panic  \n\n**Thread Builder:***  \n`std::thread::spawn()` 实际上只是 `std::thread::Builder::new().spawn().unwrap()` 的一个简写  \n`std::thread::Builder` 允许您在生成新线程之前, 为其进行一些设置  \n您可以使用它来配置新线程的堆栈大小, 为新线程命名  \n通过 `std::thread::current().name()` 可以获取当前线程的名称, 这将在 panic 的消息中使用, 并将在大多数平台上的 debug 工具中可见  \n\n此外, `Builder` 的 `spawn` 函数返回 `std::io::Result`, 允许您处理生成新线程失败的情况  \n比如操作系统内存不足，或者对您应用的资源限制(resource limit), 则可能会发生该情况  \n(若 `spawn` 函数无法生成新线程, 它只会产生 panic)  \n\n- - -\n\n# 作用域线程\n有一个问题就是, 默认的 `spawn` 会要求一个具有 'static 约束的闭包, 在编译器就确保了不会发生生命周期上的问题  \n但如果我们真的确定, 生成的线程肯定不会超过某个作用域, 那么该线程理论上就应该可以安全地借用局部变量, 只要它们比该作用域活得久  \n\nRust 标准库提供了 `std::thread::scope` 函数, 来生成这样的作用域线程  \n它允许我们生成 \"不超过我们传递给该函数的闭包范围\" 的线程, 从而安全地借用局部变量  \n\n一个例子:  \n\n```rust\nlet numbers = vec![1, 2, 3];\n\nthread::scope(|s| { // 1\n    s.spawn(|| { // 2\n        println!(\"length: {}\", numbers.len());\n    });\n    s.spawn(|| { // 2\n        for n in &numbers {\n            println!(\"{n}\");\n        }\n    });\n}); // 3\n```\n\n- 在 (1) 处: 我们调用 `std::thread::scope` 函数, 我们的闭包将在传入后立刻执行, 参数 `s`，代表 `Scope`  \n- 在 (2) 处: 我们通过 `s` 参数, 生成了 作用域线程(Scoped Threads), 其传入的闭包可以借用局部变量, 如 `numbers`  \n- 在 (3) 处: 我们生成的所有 `Scoped-Thread`, 若还没有 `join`, 将自动 `join`  \n\n它保证了作用域内生成的任何线程, 都不会超过作用域  \n正因如此, 这个 `spawn` 方法的参数类型上没有 'static 约束，允许我们引用任何内容，只要它比作用域长寿，例如 `numbers`  \n\n在上面的示例中, 两个新线程同时访问 `numbers`, 这很好, 因为所有都不会修改它  \n若我们要将第一个线程更改为修改 `numbers`, 编译器将不允许我们生成另一个也修改 `numbers` 的线程:  \n\n```rust\nlet mut numbers = vec![1, 2, 3];\n\nthread::scope(|s| {\n    s.spawn(|| {\n        numbers.push(1);\n    });\n    s.spawn(|| {\n        numbers.push(2); // Error!\n    });\n});\n```\n\n确切的错误消息取决于 Rust 编译器的版本, 因为它通常会得到改进, 以产生更好的报错，目前的报错信息如下:  \n\n```text\nerror[E0499]: cannot borrow `numbers` as mutable more than once at a time\n --> example.rs:7:13\n4 |     s.spawn(|| {\n  |             -- first mutable borrow occurs here\n5 |         numbers.push(1);\n  |         ------- first borrow occurs due to use of `numbers` in closure\n\n7 |     s.spawn(|| {\n  |             ^^ second mutable borrow occurs here\n8 |         numbers.push(2);\n  |         ------- second borrow occurs due to use of `numbers` in closure\n```\n\n**来自译者的题外话, 帮你更好地理解下作用域线程:**  \n如果你观察一下 `std::thread::scope`, 会发现其 lifetime 的关系如下:  \n\n```rust\npub fn scope<'env, F, T>(f: F) -> T\nwhere\n    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n```\n\n根据文档所述, 'scope 表示作用域本身的 lfetime, 'env 表示作用域内线程借用的任何变量的 lifetime  \n\n'scope 的 lifetime 在 `scope` 函数开始之后开始，位于 `f (传入的闭包参数)` 之前, 其 lifetime 在 `f` 结束之后结束  \n该 lifetime 结束后, 所有生成的作用域线程都将被自动 `join`  \n\n关系如下:  \n\n<pre style=\"width: 534px; margin: 0px\">\n┌──fn_scope(f: F)────────────────────┐\n│                                    │\n│  'scope                            │\n│     |                              │\n│     |  'f  // is your closure      │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |  'f                          │\n│     |                              │\n│     | // join scoped threads here  │\n│     |                              │\n│  'scope                            │\n│                                    │\n└────────────────────────────────────┘\n</pre>\n\n而 'env 的约束是 'env: 'scope, 表示了作用域线程借用的任何变量的 lifetime 一定得小于作用域本身的 lifetime  \n\n\n**The Leakpocalypse:**  \n在 Rust 1.0 之前, 标准库有个名为 `std::thread::scoped` 的函数, 它会直接生成一个线程, 如同 `std::thread::spawn`  \n它允许非 'static 的闭包, 因为它返回的不是 `JoinHandle`, 而是个在 drop 时会 join 线程的 `JoinGuard`  \n任何借用的数据只需要比这 JoinGuard 存在更长的时间, 这似乎是安全的, 只要 JoinGuard 在某个时候被丢弃  \n\n但就在 Rust 1.0 发布之前, 很多事情慢慢变得清楚, 你不能保证某些东西一定会被丢弃, 这有很多办法  \n例如创建引用计数节点的循环, 或者 leak 它, 这都不会 drop 它  \n\n最终, 在一些人所说的 \"泄漏启示录(Leakpocalypse)\" 中, 得出的结论是:  \n安全接口的设计, 不能依赖于对象在其生命周期结束时总是会被丢弃的假设  \n泄漏对象可能会合理地导致泄漏更多对象(例如，泄漏 Vec 也会泄漏其元素), 但可能不会导致未定义的行为  \n\n由于这个结论, `std::thread::scoped` 不再被认为是安全的, 并从标准库中删除  \n此外, `std::mem::forget` 从 unsafe 变成了 safec, 以强调 forget/leak 始终是可能的  \n\n**老生常谈的话: Rust 并不会阻止 内存泄漏, 内存泄漏 不归到 内存安全 的范畴里**  \n\n直到很久以后, 在 Rust 1.63 中, 添加了一个新的 `std::thread::scope` 函数, 其中包含一个不依赖 Drop 来表示正确性的新设计  \n\n- - -\n\n# 共享所有权\n到目前为止, 我们已经研究了使用 move 闭包, 将值的所有权转移到线程, 并从寿命更长的父线程借用数据  \n当在两个线程之间共享数据时, 当两个线程都不能保证比另一个线程活得久, 则它们都不能成为该数据的所有者  \n它们之间共享的任何数据的 lifetime, 都需要与活的最长的线程一样长或更长  \n\n## Static\n有几种方法可以创建不属于单个线程的内容, 其中最简单的是使用 static 关键字  \n它由整个程序 “拥有”, 而不是单个线程  \n\n在以下示例中, 两个线程都可以访问 X , 但它们都不拥有它:  \n\n```rust\nstatic X: [i32; 3] = [1, 2, 3];\n\nthread::spawn(|| dbg!(&X));\nthread::spawn(|| dbg!(&X));\n```\n\n 一个 static 项, 其以 const 字面量作为初始值, 永远不会 drop  \n且在 main 函数启动之前, 它就已经存在, 每个线程都能借用它, 毕竟它保证永远存在  \n\n## Leak\n共享所有权的另一种方法是leak, 使用 `Box::leak`  \n它可以释放 Box 的所有权, 承诺永远不会 drop 它, 从那时起, Box 将永远存在, 没有所有者, 只要程序运行, 它就可以被任何线程借用  \n\n```rust\nuse std::thread;\n\nfn main() {\n    let x: &'static [i32; 3] = Box::leak(Box::new([1, 2, 3]));\n\n    thread::spawn(move || dbg!(x));\n    thread::spawn(move || dbg!(x));\n}\n```\n\n可能看上去, 在 move 闭包, 我们将所有权转移到了线程中  \n但仔细观察 x 的类型, 你会发现, 我们只是为线程提供了对数据的引用, 而不是数据本身的所有权  \n\n**注意:**\n- 独享引用(&T) 实现了 Copy 这个 trait, 这意味着当您 move 它时, 原始值仍然存在, 就像整数或布尔值一样\n- 'static 生命周期并不意味着 \"该值自程序开始以来一直存在\", 而只是 \"它一直存在到程序结束\", 过去的经历并不在乎\n\n泄漏 Box 的缺点是, 我们正在泄漏内存, 我们分配一些东西, 但从不丢弃和解除分配它  \n如果这只发生有限的少量次数, 可能会达成很棒的效果, 但如果我们继续, 程序将慢慢耗尽内存  \n\n## 引用计数  \n为了确保共享的数据被 drop , 使得其内存被释放, 我们不能完全放弃其所有权  \n相反, 我们可以分享所有权, 通过跟踪所有者的数量, 我们可以确保仅在没有所有者时才丢弃该值  \n\nRust 标准库通过 `std::rc::Rc` 类型提供此功能, 这是 \"引用计数(References Counting)\" 的缩写  \n它与 `Box` 非常相似, 除了 clone 它时并不会真的 clone 其包含的值, 而只是增加计数器的值  \n原来的 Rc 与克隆的 Rc,  都将引用相同的分配, 因此, 它们可以共享所有权  \n\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new([1, 2, 3]);\nlet b = a.clone();\n\nassert_eq!(a.as_ptr(), b.as_ptr()); // Same allocation!\n```\n\ndrop 一个 Rc 将减少计数器, 当最后一个 Rc 被 drop 时(计数器将降至零), 将 drop 其包含的值并释放内存  \n\n但是, 当我们尝试将 Rc 发送到另一个线程, 我们将遇到以下编译器错误:  \n\n```rust\nerror[E0277]: `Rc` cannot be sent between threads safely\n    |\n8   |     thread::spawn(move || dbg!(b));\n    |                   ^^^^^^^^^^^^^^^\n```\n\n事实证明, Rc 不是线程安全的, 因为它没有实现 `Send` 这个 tait  \n未实现 `Send` 的类型, 表示其实现可能并没有考虑多线程, 导致不能将其 move 进其他线程  \n因此如果将 Rc 分配给多个线程, 则它们可能会尝试同时修改引用计数器, 这可能会产生不可预知的结果\n\n但编译器阻止了我们  \n\n相反, 我们可以使用 `std::sync::Arc`, 它代表“原子引用计数(Atomic References Counting)”  \n它与 Rc 相同, 只是它保证对引用计数器的修改是不可分割的原子操作, 因此可以安全地将其用于多个线程  \n\n```rust\nuse std::sync::Arc;\n\nlet a = Arc::new([1, 2, 3]); // 1\nlet b = a.clone(); // 2\n\nthread::spawn(move || dbg!(a)); // 3\nthread::spawn(move || dbg!(b)); // 3\n```\n\n在上述代码中:\n\n- 在 (1) 处: 我们将数组放进了一个 `Arc` 中进行包装, 其引用计数器从 1 开始  \n- 在 (2) 处: 克隆了 `Arc`, 使得引用计数增加到 2, 并为我们提供另一个 `Arc`, 指向相同的资源  \n- 在 (3) 处: 两个线程都获得自己的 `Arc`, 可以访问共享数组, 两者都在 `drop` 使得计数器减 1  \n- 在 (3) 处: 最后一个 `drop` 了 `Arc` 的线程, 使得计数器减小到 0, 此时将会 drop 被包装的数组, 释放资源  \n\n**Naming Clones:**  \n必须给 `Arc` 的每个克隆一个不同的名称, 会很快使代码变得非常混乱且难以理解  \n虽然 `Arc` 的每个克隆都是单独的对象, 但每个克隆都表示相同的共享值, 我们可以通过 `Shadow` 语法来处理  \n\nRust 允许(并鼓励)你通过定义一个同名的新变量来隐藏变量, 如果在同一作用域内执行此操作, 则无法再使用原始变量  \n但是通过打开一个新作用域, 可以使用像 `let a = a.clone();` 这样的语句, 在该作用域内重用名称, 同时将原始变量保留在作用域之外  \n\n通过将闭包包装在新作用域(使用 `{}`)中, 我们可以在将变量移动到闭包之前克隆变量, 而无需重命名它们:  \n\n```rust\nlet a = Arc::new([1, 2, 3]);\nlet b = a.clone();\n\nthread::spawn(move || {\n    dbg!(b);\n});\n\ndbg!(a);\n```\n\n```rust\nlet a = Arc::new([1, 2, 3]);\n\nthread::spawn({\n    let a = a.clone();\n    move || {\n        dbg!(a);\n    }\n});\n\ndbg!(a);\n```\n\n由于所有权是共享的, 因此引用计数指针 (`Rc<T>` 和 `Arc<T>`) 与共享引用 (`&T`) 具有相同限制  \n它们不允许您对其包含的值进行可变访问, 因为该值可能同时被其他代码借用  \n例如, 当我们尝试对 `Arc<[i32]>` 中的整数切片进行排序, 编译器会阻止我们, 告诉我们不允许改变数据:  \n\n```text\nerror[E0596]: cannot borrow data in an `Arc` as mutable\n  |\n6 |     a.sort();\n  |     ^^^^^^^^\n```\n\n- - -\n\n# 借用与数据竞争\n在 Rust 中, 可以通过两种方式借用值:  \n\n- 不可变借用(Immutable borrowing):  \n通过 `&` 借用, 这得到了一个不可变引用(immutable reference), 可以复制这样的引用  \n对被引用数据的访问, 在此类引用的所有副本之间共享, 编译器通常不允许通过这样的引用修改内容, 因为会影响借用了相同数据的其他代码  \n\n- 可变借用(Mutable borrowing):  \n通过 `&mut` 借用, 这得到了一个可变引用(mutable reference), 可变借用保证它是该数据唯一的有效借用(active borrow)  \n因此, 这可以确保, 改变数据的内容不会影响到其他代码\n\n这两个概念在一起, 完全防止了数据竞争(data races), 即一个线程正在改变数据, 而另一个线程同时访问数据的情况  \n数据竞争通常是未定义的行为(undefined behavior), 这意味着编译器不需考虑这些情况, 因为它只会假设这些情况不会发生  \n\n为阐明这到底意味着什么, 让我们看一个编译器可以使用借用规则做出有用假设的示例:  \n\n```rust\nfn f(a: &i32, b: &mut i32) {\n    let before = *a;\n    *b += 1;\n    let after = *a;\n    if before != after {\n        x(); // never happens\n    }\n}\n```\n\n在这里, 我们得到一个对整数的不可变引用, 并在递增 b 所引用的整数前后, 存储了整数的值  \n编译器可以自由地假设有关 \"借用和数据竞争的基本规则\" 得到维护, 这意味着 b 不可能像 a 一样引用相同的整数  \n事实上, 只要 a 还存在, 整个程序中没有任何东西可以可变地借用 a 所指的整数  \n因此, 编译器可以很容易地得出结论, *a 不会改变, `before` 永远等于 `after`  \n因此 if 语句永远无法成立, 可以从程序中完全删除对 x 的调用, 进行优化\n\n编写一个打破编译器假设的 Rust 程序是不可能的, 除非使用 unsafe 块来禁用编译器的某些安全检查  \n\n**Undefined Behavior(未定义的行为):**  \n像 C, C++, Rust 这样的语言有一套规则, 需要遵循这些规则, 以避免所谓的未定义行为(ub)  \n例如, Rust 的规则之一是: 对任何对象都不能有多个可变引用  \n\n在 Rust 中, 只有在使用 unsafe 代码时才能违反这些规则中的任何一个  \nunsafe 在 Rust 中并不意味着代码不正确或不安全, 而是编译器没为您验证代码是否安全  \n如果代码确实违反了这些规则，则称为 unsound(不健全), 因此, 你可以将 unsafe, 等价于 trust_me  \n\n编译器会假设这些规则永远不会被破坏, 当被破坏时, 会导致一种被称为未定义行为的情况发生, 我们需要不惜一切代价避免这种情况  \n因为, 若我们允许编译器做出一个实际上不正确的假设, 它很容易导致代码不同部分的更多错误结论, 从而影响整个程序  \n\n作为一个例子, 让我们看一下在切片上使用 `get_unchecked` 方法的代码实例:  \n\n```rust\nlet a = [123, 456, 789];\nlet b = unsafe { a.get_unchecked(index) };\n```\n\n`get_unchecked` 方法, 让我们得到了指定索引位置的切片元素, 如同 `a[index]` 一样  \n但它允许编译器假设索引始终在边界内, 而无需进行任何边界检查  \n\n这意味着, 在此代码段中, 由于 a 的长度为 3, 因此编译器可能会假定 index 小于 3, 我们有责任确保其假设成立  \n如果我们打破这个假设, 例如, 如果我们在 index 等于 3 的情况下运行这个假设, 任何事情都可能发生  \n这可能会导致, 从内存中读取到了存储在 a 之后的字节中的任何内容, 程序可能会因此崩溃  \n比如, 它最终可能会执行你程序中一些完全不相关的部分, 造成各种破坏  \n\n令人惊讶的是, 未定义行为甚至可以 “影响过去”, 导致它之前的代码出现问题  \n为了理解这是如何发生的, 假设在先前代码的前面有个 match 语句, 如下所示:  \n\n```rust\nmatch index {\n   0 => x(),\n   1 => y(),\n   _ => z(index),\n}\n\nlet a = [123, 456, 789];\nlet b = unsafe { a.get_unchecked(index) };\n```\n\n由于 unsafe 块, 编译器可以假定 index 只为 0、1 或 2  \n从逻辑上讲, 我们可以得出结论, 我们的 match 语句的最后一个分支只会与 2 匹配  \n因此 z(index) 只可能是 z(2), 该结论不仅可以用于优化 match, 还可优化 z 本身, 这可能包括删除代码中未使用的部分  \n\n如果我们让 index 为 3 时执行此操作, 我们的程序可能会尝试执行已优化的部分  \n这从而导致了完全不可预测的行为, 早于在我们到达最后一行的 unsafe 块之前  \n就像这样, 未定义行为可能以一种非常意想不到的方式, 向后和向前传播与污染整个程序  \n\n调用任何 unsafe 函数前, 请仔细阅读文档, 并确保完全了解其安全要求  \n作为调用者, 您需要秉承 \"避免未定义行为\" 的准则  \n\n- - -\n\n# 内部可变性\n上一节中介绍的借用规则很简单, 但可能非常有限, 尤其是在涉及多个线程时  \n遵循这些规则, 将使得线程间的通信被严重限制, 甚至会变得几乎不可能, 因为多线程间可访问的数据不能突变  \n幸运的是, 有个逃生舱口: 内部可变性(interior mutability)  \n具有内部可变性的数据类型, 会稍微改变其借用规则, 在某些情况下, 这些类型可通过 \"不可变引用\" 而允许突变  \n\n在先前讲述引用计数时, 我们已看到了个涉及内部可变性的微妙例子:  \n`Rc` 和 `Arc` 被 clone 与 drop 时, 会改变引用计数器的数值, 即使多个克隆都使用着相同的引用计数器  \n\n一旦涉及内部可变类型, 将引用称为 \"不可变\" 或 \"可变\" 会令人困惑和不准确, 因为两者都能够突变数据  \n更准确的术语是 \"共享\" 和 \"独占\":  \n共享引用(&T)可以复制并与他人共享, 而独占引用(&mut T)保证了它是该 T 的唯一独占借用  \n对于大多数类型, 共享引用不允许突变, 但也有例外  \n由于在本系列中, 我们将主要处理这些例外, 因此我们将在本系列的其余部分使用更准确的术语   \n\n**注意:**  \n请记住, 内部可变性只会改变共享借用的规则, 以允许共享时的突变, 而不会改变任何关于独占借用的行为  \n独占借用仍然保证没有其他独享的有效借用(active borrow)  \nunsafe 中对某物的多个有效的独占引用, 将始终导致未定义行为, 不会考虑内部可变性  \n\n## Cell\n`std::cell::Cell<T>` 只是个包裹了 T 类型数据的类型, 但允许通过共享引用进行突变  \n为避免未定义行为, 它只允许您复制值(T 必须实现 Copy), 或用另一个值替换已被包裹的值  \n此外, 它只能在单个线程中使用  \n\n让我们看个类似上一节中的示例, 但这次使用 Cell<i32> 而不是 i32:  \n\n```rust\nuse std::cell::Cell;\n\nfn f(a: &Cell<i32>, b: &Cell<i32>) {\n    let before = a.get();\n    b.set(b.get() + 1);\n    let after = a.get();\n    if before != after {\n        x(); // might happen\n    }\n}\n```\n\n与上次不同, 现在 if 条件可能为真, 因为 `Cell<i32>` 具有内部可变性, 所以只要我们有对它的共享引用, 编译器就不能再假设它的值不会改变  \na 和 b 可能都引用相同的值，因此通过 b 对数据突变, 也可能影响到 a  \n但是, 它仍假定没有其他线程同时访问 `Cell` 类型的 a 与 b  \n\n对 Cell 的限制并不总是那么容易处理, 因为它不能直接让我们借用它所持有的值  \n我们要将其值移出, 修改它后再放回去, 以改变它的内容:  \n\n```rust\nfn f(v: &Cell<Vec<i32>>) {\n    let mut v2 = v.take(); // Replaces the contents of the Cell with an empty Vec\n    v2.push(1);\n    v.set(v2); // Put the modified Vec back\n}\n```\n\n## RefCell\n\n与常规 `Cell` 不同, `std::cell::RefCell` 允许您以较小的运行时成本借用其值  \n`RefCell<T>` 不仅持有 `T`, 还持有引用计数器, 用于在运行时, 跟踪对被包裹数据的借用的情况  \n当你试图以不可变地借用它, 而它已经被可变借用了(反之亦然), 它会 panic, 从而避免未定义的行为  \n像 `Cell` 一样, `RefCell` 只能在单个线程中使用  \n\n借用 `RefCell` 包裹的值, 是通过调用 `borrow` 或 `borrow_mut` 来完成的:  \n\n```rust\nuse std::cell::RefCell;\n\nfn f(v: &RefCell<Vec<i32>>) {\n    v.borrow_mut().push(1); // We can modify the `Vec` directly.\n}\n```\n\n**译者注:**  \n`Cell/RefCell`, 简单来说, 属于在编译时欺骗了编译器, 将借用规则从编译器挪动到运行期, 以便于放宽要求  \n但借用规则还是满足的, 只是晚了一个阶段而已, 如果违背了借用规则, 依旧会报错  \n\n虽然 `Cell` 和 `RefCell` 非常有用, 但当我们处于多线程并发的环境时, 它们变得没啥用  \n因此, 让我们转到与并发相关的类型  \n\n## Mutex/RwLock\n`RwLock (reader-writer lock)`, 是 `RefCell` 的并发版本  \n一个 `RwLock<T>`, 持有 T 并跟踪借用的情况  \n但与 `RefCell` 不同的是, 它不会在借用冲突时 panic, 而是阻塞当前线程(使其进入睡眠状态), 同时等待冲突的借用消失  \n我们只需耐心地等待其他线程完成, 然后处理数据即可  \n\n借用被 `RwLock` 包裹的值, 称为锁定(lcok), 通过锁定它, 我们可以暂时阻止并发的冲突借用, 以允许我们借用它而不会引起数据竞争  \n`Mutex` 非常相似, 但在概念上稍微简单些, 它不像 `RwLock` 那样跟踪共享借用和独占借用的数量, 而只允许独占借用  \n\n我们将在本节之后, 更加详细地介绍这些类型  \n\n## Atomic\n`Atomic(原子)`, 该类型是 `Cell` 的并发版本, 是之后第 2 章和第 3 章的主题  \n像 `Cell` 一样, 它们通过将值作为一个整体, 复制进来和传出来, 以避免未定义行为, 而不让我们直接借用内容  \n\n但与 `Cell` 不同, 它们不能是任意大小  \n因此没有通用的 `Atomic<T>` 类型, 而只有特定的原子类型, 例如 `AtomicU32` 和 `AtomicPtr<T>`  \n哪些可用取决于平台, 因为它们需要处理器的支持以避免数据竞争(我们将在之后的第 7 章中深入探讨)  \n\n由于它们的大小非常有限, 因此原子通常不直接包含需要在线程之间共享的信息  \n相反, 它们通常被用作一种工具, 以便在线程之间共享其他(通常是更大的)数据, 此时事情可能会变得非常复杂  \n\n## UnsafeCell  \n\n`UnsafeCell` 是内部可变性的原始的构建块  \n`UnsafeCell<T>` 包装 `T`, 但不附带任何条件或限制以避免未定义行为  \n相反, 它的 `get()` 方法只是给出一个包装值的原始指针, 该值只能在 `unsafe` 块中使用  \n它让用户以不会导致任何未定义行为的方式使用它  \n\n最常见的是, `UnsafeCell` 不直接使用, 而是包装在另一类型中, 该类型通过有限的接口(例如 `Cell` 或 `Mutex`)提供安全性  \n所有具有内部可变性的类型(包括上面讨论的所有类型)都建立在 `UnsafeCell` 之上  \n\n- - -\n\n#  线程安全  \n在本章中, 我们看到了几种非线程安全的类型, 这些类型只能在单个线程上使用, 例如 `Rc`. `Cell`  \n由于需要限制以避免未定义行为, 因此编译器需要去理解并检查, 以便于知晓使用这些类型时无需使用 unsafe 块  \n\nRust 语言使用两个特殊的 Trait 来跟踪哪些类型可以跨线程安全使用:  \n\n- Send:  \n如果一个类型可以被发送到另一个线程, 则该类型为 Send, 即该类型的值的所有权, 可以转移到另一个线程  \n例如, `Arc<i32>` 实现了 Send, 但 `Rc<i32>` 没有  \n\n- Sync:  \n如果一个类型可以与其他线程共享, 则类型为 Sync, 即当且仅当 &T 是 Send 时, T 实现了 Sync  \n例如, `i32` 是 Sync, 因为 &i32 是 Send, 但 `Cell<i32>` 不是 (不过 `Cell<i32>` 是 Send)  \n\n所有基础类型, 如 i32, bool, str, 都是 Send 和 Sync  \n\n这两个 Trait 都是 auto 的, 这意味着它们会根据类型的字段而自动实现  \n比如, 当字段均为 Send 和 Sync 时, 该 struct 本身也是 Send 和 Sync  \n\n选择主动避免实现其中任何一个 Trait 的方法, 是向类型添加一个未实现相关 Trait 的字段  \n为此, 特殊的 `std::marker::PhantomData<T>` 类型通常会派上用场, 编译器将该类型视为 T. 但它在运行时实际上并不存在  \n这是一个零大小的类型, 不占用空间  \n\n我们来看看下面的 struct:  \n\n```rust\nuse std::marker::PhantomData;\n\nstruct X {\n    handle: i32,\n    _not_sync: PhantomData<Cell<()>>,\n}\n```\n\n在此示例中, 若 handle 是其唯一字段, 则 X 将是 Send 和 Sync  \n但是, 我们添加了一个大小为零的 `PhantomData<Cell<()>>` 字段, 该字段被视为 `Cell<()>`  \n因为 `Cell<()>` 不是 Sync, 所以 X 也不是, 但它仍然是 Send, 因为它的所有字段都实现了 Send  \n\n原始指针 (*const T 和 *mut T) 既不是 Send 也不是 Sync, 因为编译器对它们表示的数据知之甚少  \n\n选择手动实现其中任何一个 Trait , 都需要用 unsafe 进行标明:  \n\n```rust\nstruct X {\n    p: *mut i32,\n}\n\nunsafe impl Send for X {}\nunsafe impl Sync for X {}\n```\n\n实现这些特征之所以需要 unsafe 关键字, 是因为编译器无法为您检查它是否正确, 这是你对编译器的承诺, 它只需信任你  \n\n如果您尝试将某些内容移动到另一个非 Send 的线程中, 编译器会礼貌地阻止您这样做, 下面是个小示例:  \n\n```rust\nfn main() {\n    let a = Rc::new(123);\n    thread::spawn(move || { // Error!\n        dbg!(a);\n    });\n}\n```\n\n在这里, 我们尝试将 `Rc<i32>` 发送到新线程, 但 `Rc<i32>` 与 `Arc<i32>` 不同, 它没实现 Send   \n如果我们尝试编译上面的示例，我们将面临如下所示的错误:  \n\n```text\nerror[E0277]: `Rc<i32>` cannot be sent between threads safely\n   --> src/main.rs:3:5\n    |\n3   |     thread::spawn(move || {\n    |     ^^^^^^^^^^^^^ `Rc<i32>` cannot be sent between threads safely\n    |\n    = help: within `[closure]`, the trait `Send` is not implemented for `Rc<i32>`\nnote: required because it's used within this closure\n   --> src/main.rs:3:19\n    |\n3   |     thread::spawn(move || {\n    |                   ^^^^^^^\nnote: required by a bound in `spawn`\n```\n\n`thread::spawn` 函数要求其参数为 Send, 如果闭包的所有捕获都为 Send, 则闭包也为 Send   \n如果我们试图捕捉不是 Send 的东西, 那么我们的错误就会被抓住, 编译器会保护我们免受未定义行为的影响  \n\n- - -\n\n# 互斥锁\n在线程间共享不可变或可变的数据, 最常用的工具是 Mutex, 它是 互斥(mutual exclusion) 的缩写  \n互斥锁的工作是, 通过暂时阻塞尝试同时访问某些数据的其他线程, 来确保线程对某些数据具有独占访问权限  \n\n从概念上讲, 互斥锁只有两种状态: 锁定和解锁(lock and unlock)  \n\n当线程锁定了未锁定的互斥锁时, 互斥锁将标记为锁定, 线程可以立即继续  \n当线程尝试锁定已锁定的互斥锁时, 该操作将阻塞, 线程在等待互斥锁解锁时进入睡眠状态  \n\n解锁只能在锁定的互斥锁上进行, 并且应该由锁定它的同一线程完成  \n如果其他线程正在等待锁定互斥锁, 则解锁互斥锁将导致其中一个线程被唤醒, 被唤醒的线程可以尝试再次锁定互斥锁  \n该过程可以一直重复  \n\n使用互斥锁保护数据, 只是所有线程间的协议, 即它们仅在锁定互斥锁时访问数据  \n这样, 没有两个线程可以同时访问该数据, 避免了数据竞争  \n\n## Rust's Mutex\nRust 标准库通过 `std::sync::Mutex<T>` 提供此功能  \n类型 T 是互斥锁保护的数据类型, 通过将 T 类型的数据作为互斥锁的一部分, 数据将只能通过互斥锁访问  \n这允许了一个安全的接口, 可以保证所有线程都将遵守协议  \n\n为了确保锁定的互斥锁只能由锁定它的线程解锁, 它没有 `unlock()` 方法  \n相反, 它的 `lock()` 方法返回一个名为 `MutexGuard` 的特殊类型, 表示我们已锁定互斥锁的保证  \n它的行为类似于一个通过 `DerefMut` 获取的独占引用, 使我们能独占地访问互斥锁保护的数据  \n解锁互斥锁是通过 drop 这个 `MutexGuard` 类型的变量来完成的, 当我们放下 guard 时, 我们放弃了访问数据的能力, guard 的 Drop 实现将解锁互斥锁  \n\n让我们看一个例子, 看看互斥锁在实践中的运用:  \n\n```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let n = Mutex::new(0);\n    thread::scope(|s| {\n        for _ in 0..10 {\n            s.spawn(|| {\n                let mut guard = n.lock().unwrap();\n                for _ in 0..100 {\n                    *guard += 1;\n                }\n            });\n        }\n    });\n    assert_eq!(n.into_inner().unwrap(), 1000);\n}\n```\n\n在这里, 我们有一个 `Mutex<i32>`, 一个保护整数的互斥锁, 我们生成十个线程, 每个线程将整数递增一百次  \n每个线程将首先锁定互斥锁, 以获取 `MutexGuard`, 然后使用该 guard 访问整数并对其进行修改  \n当 guard 超出作用域后, 其将立即被隐式地 drop  \n\n线程完成后, 我们可以安全地从通过 `into_inner()` 方法以删除互斥保护  \n`into_inner` 方法获取了互斥锁的所有权, 这保证了没有其他任何东西可以再引用互斥锁, 因此不需要锁定  \n\n即使增量以 1 为步长发生, 但观察整数的线程也只能看到 100 的倍数, 因为它只能在互斥锁解锁时查看整数  \n实际上, 由于互斥锁, 一百个增量现在是一个不可分割的操作, 这样不可分割的操作也称为原子操作  \n\n为了清楚地看到互斥锁的效果, 我们可以让每个线程在解锁互斥锁之前等待一秒钟:  \n\n```rust\nuse std::time::Duration;\n\nfn main() {\n    let n = Mutex::new(0);\n    thread::scope(|s| {\n        for _ in 0..10 {\n            s.spawn(|| {\n                let mut guard = n.lock().unwrap();\n                for _ in 0..100 {\n                    *guard += 1;\n                }\n                thread::sleep(Duration::from_secs(1)); // New!\n            });\n        }\n    });\n    assert_eq!(n.into_inner().unwrap(), 1000);\n}\n```\n\n当您现在运行该程序时, 您将看到大约需要 10 秒才能完成, 每个线程只等待一秒钟, 但互斥锁会确保一次只有一个线程可以这样做  \n\n如果我们在 sleep 前, 就 drop 掉 guard, 从而解锁互斥锁, 我们将看到它并行发生:  \n\n```rust\nfn main() {\n    let n = Mutex::new(0);\n    thread::scope(|s| {\n        for _ in 0..10 {\n            s.spawn(|| {\n                let mut guard = n.lock().unwrap();\n                for _ in 0..100 {\n                    *guard += 1;\n                }\n                drop(guard); // New: drop the guard before sleeping!\n                thread::sleep(Duration::from_secs(1));\n            });\n        }\n    });\n    assert_eq!(n.into_inner().unwrap(), 1000);\n}\n```\n\n通过此更改, 该程序只需大约一秒钟, 因为现在 10 个线程可以同时执行一秒钟的睡眠, 这表明尽可能缩短互斥锁锁定时间的重要性  \n当互斥锁锁定的时间超过必要的时间, 可能会完全抵消并行性的任何好处, 从而有效地强制所有内容按顺序发生  \n\n## 锁中毒\n\n上面示例中的 `unwrap()` 调用与锁中毒(Lock Poisoning)有关  \n\n当线程在 lock 锁时发生 panic, `Mutex` 会被标记为中毒(Poisoned)  \n发生这种情况时, `Mutex` 将不再被锁定, 但调用其 `lock` 方法将导致得到一个 `Err`, 表示它已经中毒  \n\n这是一种 \"防止受互斥锁保护的数据处于不一致状态\" 的机制  \n在上面的示例中, 若线程在将整数递增不到 100 次后出现 panic, 则互斥锁将解锁  \n此时整数将处于意外状态, 不再是 100 的倍数, 这可能会破坏其他线程的假设  \n在这种情况下, 自动将互斥锁标记为中毒, 会强制用户处理这种可能性  \n\n在中毒的互斥锁上调用 `lock()` 仍会锁定互斥锁  \n`lock()` 返回的 `Err` 包含 `MutexGuard`, 允许我们在必要时更正不一致的状态  \n\n虽然锁中毒似乎是种强大的机制, 但在实践中并不经常从潜在的不一致状态中恢复  \n大多数代码要么忽略锁中毒, 要么在锁中毒时使用 `unwrap()` 进行 panic, 从而有效地将 panic 传播给互斥锁的所有用户  \n\n\n**Lifetime of the MutexGuard:**  \n虽然隐式地 drop 掉 guard 变量, 可以方便地解锁互斥锁, 但有时会导致微妙的意外  \n如果我们用 let 语句给 guard 分配一个名称(如上面的例子), 将会很直接地知晓它何时 drop, 因为局部变量在其作用域的末尾会自动被 drop  \n尽管如此, 不显式 drop 掉 guard, 可能会导致将互斥锁锁定的时间不必要的延长, 如上面的示例所示  \n\n使用无名称的 guard 也是可能的, 有时甚至非常方便  \n由于 MutexGuard 的行为, 类似于对受保护数据的独占引用, 因此我们可以直接使用它, 而无需先为 guard 分配名称  \n例如, 如果您有 Mutex<Vec<i32>>, 则可在单个语句中, 锁定互斥锁, 进行 push, 最后再次解锁互斥锁(drop):  \n\n```rust\nlist.lock().unwrap().push(1);\n```\n\n这是因为, 在表达式中生成的任何临时变量(例如通过 lock() 返回的守卫)都将在语句末尾删除  \n虽然这看起来是显而易见且合理的, 但它会导致一个常见的陷阱, 通常涉及 `match`, `if let`, `while let` 语句  \n下面是遇到此陷阱的示例:  \n\n```rust\nif let Some(item) = list.lock().unwrap().pop() {\n    process_item(item);\n}\n```\n\n这段代码的意图, 是锁定 list, 随后 pop 一个元素并解锁 list, 最后处理该元素, 但我们在这犯了个微妙但重要的错误  \n临时生成 guard, 将会直到整个 if let 语句结束才会 drop, 这意味着我们在处理项目时, 保持了不必要的锁定  \n\n令人惊讶的是, 对于类似的 if 语句, 这种情况不会发生:  \n\n```rust\nif list.lock().unwrap().pop() == Some(1) {\n    do_something();\n}\n```\n\n在这里, 不像先前的 `if let` 语句, 临时的 guard 确实在执行 if 语句的主体前就被 drop 了  \n原因是: 常规 if 语句的条件始终是普通 bool 值, 不会借用任何东西  \n因此, 没有理由将临时变量的 lifetime 从条件延长到语句结束  \n\n但是, 对于 `if let` 语句, 情况可能并非如此  \n例如, 如果我们使用 `front()` 而不是 `pop()`, 则 item 将从列表中借用, 因此有必要保持警惕  \n\n因为使用 `if let` 语句时可能会产生借用  \n于是在此情况下, 被创建的临时变量的生命周期, 被规定将会被延长到 `if let` 的主体结束  \n因此就算当我们使用 `pop()` 而非 `front()` 时, 也会发生同样的情况, 即使这不是必需的  \n故 guard 不会在第一时间被 drop 掉  \n\n我们可以通过将 `pop` 操作移动到单独的 let 语句, 来避免这种情况  \n因此, 在该语句的末尾, 在 if let 之前, 被临时创建的 guard 将会被 drop:  \n\n```rust\nlet item = list.lock().unwrap().pop();\nif let Some(item) = item {\n    process_item(item);\n}\n```\n\n## RwLock\n\n互斥锁只涉及独占访问, MutexGuard 将为我们提供对受保护数据的独占引用(&mut T)  \n即使我们只想查看数据, 并使用已经足够满足需求的共享引用(&T)  \n\n读写锁(RwLock)是互斥锁的一个稍微复杂点的版本, 它了解独占访问和共享访问之间的区别, 并且可以提供两者之一  \n它有三种状态: 解锁, 由单个写入器(writer)锁定(用于独占访问), 被任意数量的读取器(reader)锁定(用于共享访问)  \n它通常用于经常由多个线程读取但仅偶尔更新一次的数据  \n\nRust 标准库通过 `std::sync::RwLock<T>` 类型提供此锁  \n它的工作方式与 `Mutex` 类似, 只是它的接口主要分为两部分  \n它不是单个 `lock()` 方法, 而是具有用于锁定为 writer 或 reader 的 `read()` 和 `write()` 方法  \n它有两种 guard 类型, 一种用于 reader, 一种用于writer: `RwLockReadGuard` 和 `RwLockWriteGuard`  \n两者都实现了 `Deref` 以表现为对受保护数据的引用, 前者的表现类似于共享引用, 而后者的表现类似于独占引用  \n\n它实际上是 `RefCell` 的多线程版本, 动态跟踪引用的数量, 以确保遵守借用规则  \n\n`Mutex<T>` 和 `RwLock<T>` 都要求 T 为 `Send`, 因为它们可用于将 `T` 发送到另一个线程  \n`RwLock<T>` 还需要 T 来实现 `Sync`, 因为它允许多个线程保存对受保护数据的共享引用(&T)  \n严格来说, 您可以为不满足这些要求的 T 创建一个锁, 但您将无法在线程之间共享它, 因为锁本身不会实现 `Sync`  \n\nRust 标准库只提供一种通用的 `RwLock` 类型, 但其实现取决于操作系统, 其实现之间存在许多细微差异  \n当有 writer 等待时, 大多数实现都会选择阻塞新的 reader, 即使锁已经 read-locked 也是如此  \n这是为了防止 `writer starvation(写饿死/写入器匮乏`), 即一种 \"readers 过多导致锁一直无法被解锁, 导致 writer 无法更新数据\" 的情况  \n\n**Mutexes in Other Languages:**  \nRust 标准库中的 `Mutex` 和 `RwLock` 类型, 看起来与 C 或 C++ 等其他语言中的实现略有不同  \n最大的区别是 Rust 的 Mutex<T> 包含它正在保护的数据  \n\n例如, 在 C++ 中, `std::mutex` 不包含它保护的数据, 甚至不知道它在保护什么  \n这意味着, 用户有责任记住哪些数据受到保护, 以及由哪个互斥锁保护, 并确保每次访问 \"受保护数据\" 时, 都锁定正确的互斥锁  \n在阅读涉及其他语言互斥体的代码时, 或者与不熟悉 Rust 的程序员交流时, 记住这一点很有用  \n一个 Rust 程序员可能会谈论 \"互斥锁中的数据\", 或者 \"将其包装在互斥锁中\" 之类的话, 这可能会让那些只熟悉其他语言互斥锁的人感到困惑  \n\n如果您确实需要一个不包含任何数据的独立互斥锁, 例如保护某些外部硬件, 则可使用 `Mutex<()>`  \n但即使在这种情况下, 您最好定义一个(可能是零大小的)类型来与该硬件接口, 并将其包装在 `Mutex` 中  \n这样, 您仍然被迫锁定互斥锁, 然后才能与硬件交互  \n\n- - -\n\n# 线程等待\n当数据被多个线程改变时, 它们可能需要进行等待, 等到某些条件变为真再继续执行  \n例如, 如果我们有一个保护 `Vec` 的互斥锁, 我们可能需要等到它非空(被放入东西后再继续)  \n\n互斥锁确实允许线程等待它被解锁, 但它不提供这种 \"等待到某个条件成立\" 的功能  \n如果我们只有一个互斥锁, 我们将不得不继续锁定互斥锁, 以反复检查 `Vec` 中是否有任何东西  \n\n## Thread Parking\n等待来自另一个线程的通知的一种方法, 称为 `thread parking(线程停放)`  \n线程可以自行 park, 使其进入睡眠状态, 从而防止 CPU 空耗, 然后，另一个线程可以将线程唤醒/解除停放(unpark), 使其继续  \n\n**译者注:**  \npark 的意思就是把车停放下来, 对应让线程进入睡眠  \nunpark 的意思就是把车开走, 对应让线程继续  \n\npark 的行为, 可通过 `std::thread::park()` 函数表示  \nunpark 的行为, 您可以在要被唤醒的线程的 `Thread` 类型的对象上, 调用 `unpark()` 方法表示  \n`Thread` 对象可以从 `spawn` 返回的 `JoinHandle` 获取, 也可以通过 `std::thread::current()` 从线程本身获取  \n\n让我们深入了解一个使用互斥锁, 在两个线程之间共享队列的示例  \n在以下示例中, 新生成的线程将消耗队列中的元素(consumer), 而主线程将每秒将一个新元素插入到队列(producter)  \npark 被用于让 comsumer 线程在队列为空时进行等待  \n\n```rust\nuse std::collections::VecDeque;\n\nfn main() {\n    let queue = Mutex::new(VecDeque::new());\n\n    thread::scope(|s| {\n        // Consuming thread\n        let t = s.spawn(|| loop {\n            let item = queue.lock().unwrap().pop_front();\n            if let Some(item) = item {\n                dbg!(item);\n            } else {\n                thread::park();\n            }\n        });\n\n        // Producing thread\n        for i in 0.. {\n            queue.lock().unwrap().push_back(i);\n            t.thread().unpark();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n}\n```\n\n这是一个无限循环进行的例子, 在该循环中, 当元素不为空时, 它将元素从队列中弹出, 使用 `dbg!` 显示它们  \n当队列为空时, 它将调用 `park()`, 使线程进入睡眠状态, 防止 CPU 空耗  \n如果它被 unpark, 则先前调用的 `park()` 方法将会 return, 随后循环继续, 再次从队列中弹出元素, 直到它为空, 重复  \n\nconsumer 线程每秒生成一个新数字, 然后将其 push 到队列中  \n每次添加时, 都会在代表着 consumer 线程的 Thread 对象上, 调用 unpark() 方法来 unpark 它  \n这样, consumer 线程就会被唤醒, 以处理新的元素  \n\n这里要提出的一个重要观察是, 如果我们删除对 park() 的调用, 这个程序在理论上仍然正确, 但效率低下  \n这非常重要, 因为 `park()` 不能保证它会只因为相匹配的 `unpark()` 而返回  \n虽然罕见, 但它可能会虚假的唤醒(spurious wake-ups)  \n\n我们的示例很好地处理了这个问题, 因为 consumer 线程将锁定保护着队列的互斥锁, producter 线程将因此阻塞  \n随后, consumer 线程将检测队列是否为空, 当队列为空时, 就再次调用 `park()` 让自己进入睡眠状态  \nproducter 线程因此得以锁定互斥锁, 并对队列 push 新的元素, 随后调用 `unpark()` 唤醒 consumer 线程让其处理新元素  \n\n\n`Thread Parking` 的一个重要属性是, 对 `unpark()` 的调用在线程 park 自身之前, 不会丢失  \n对 unpark 的请求仍然会被记录, 下次线程尝试 park 时, 它会认识到该请求, 随后清除该请求后直接继续, 而不会实际进入睡眠  \n为了去了解为何这对正确性至关重要, 让我们来看看两个线程的执行步骤的可能顺序(从一开始观察):  \n\n1. consumer 线程(简写为C)锁定了队列\n2. C 尝试从队列中 pop 一个元素, 但它是空的, 结果为 None, 模式匹配后进去 else 分支 \n3. C 解锁队列\n4. producter 线程(简写为P)锁定了队列\n5. P 将新元素 push 到队列中\n6. P 再次解锁队列\n7. P 调用 `unpark()` 通知 C 有新元素\n8. C 调用 `park()` 进入睡眠, 等待更多元素\n\n# 以下内容为机翻还在改别着急\n\n虽然在步骤 3 中解锁队列和在步骤 8 中 unpark 之间很可能只有非常短暂的时刻，但步骤 4 到 7 可能会在线程 pack 之前的那一刻发生  \n如果 `unpark()` 在线程未停放时不执行任何操作, 则通知将丢失, 使用线程仍将在等待, 即使队列中有项目也是如此  \n由于取消寄存请求被保存以供将来调用 park()我们不必担心这一点  \n\n但是，取消寄存请求不会叠加。调用 unpark() 两次，然后调用 park() 两次仍会导致线程进入睡眠状态。前 park() 个清除请求并直接返回，但第二个像往常一样进入睡眠状态。  \n\n这意味着在上面的示例中，重要的是，只有在看到队列为空时才停放线程，而不是在每个处理的项目之后停放它。虽然由于睡眠时间巨大（一秒），此示例中极不可能发生，但多个 unpark() 调用可能只唤醒一个 park() 调用。  \n\n不幸的是，这确实意味着，如果在 park() 返回后立即调用 unpark() ，但在队列被锁定和清空之前，则 unpark() 调用是不必要的，但仍会导致下一个 park() 调用立即返回。这会导致（空）队列被锁定并解锁额外的时间。虽然这不会影响程序的正确性，但它确实会影响其效率和性能。  \n\n此机制适用于像我们示例中这样的简单情况，但当事情变得更加复杂时，很快就会崩溃。例如，如果我们有多个使用者线程从同一队列中获取项目，则生产者线程将无法知道哪个使用者实际上正在等待并且应该被唤醒。生产者必须确切地知道消费者何时在等待，以及它正在等待什么条件。  \n\n## Condvar\n条件变量是更常用的选项，用于等待受互斥锁保护的数据出现问题。它们有两个基本操作：等待和通知。线程可以等待条件变量，之后当另一个线程通知相同的条件变量时，它们可以被唤醒。多个线程可以等待同一个条件变量，通知可以发送到一个等待线程，也可以发送到所有线程。  \n\n这意味着我们可以为我们感兴趣的特定事件或条件创建一个条件变量，例如队列为非空，并等待该条件。然后，导致该事件或条件发生的任何线程都会通知条件变量，而不必知道哪些线程或有多少线程对该通知感兴趣。  \n\n为了避免在解锁互斥锁和等待条件变量之间的短暂时刻丢失通知的问题，条件变量提供了一种以原子方式解锁互斥锁并开始等待的方法。这意味着通知根本不可能丢失。  \n\nRust 标准库提供了一个条件变量为 std::sync::Condvar 。它的 wait 方法需要 MutexGuard 来证明我们已经锁定了互斥锁。它首先解锁互斥锁并进入睡眠状态。稍后，当唤醒时，它会重新锁定互斥锁并返回新的 MutexGuard （这证明互斥锁再次被锁定）。  \n\n它有两个通知函数： notify_one 只唤醒一个等待线程（如果有）， notify_all 唤醒它们。  \n\n让我们修改用于线程停放的示例，改用 Condvar ：   \n","source":"_posts/rust/rust-atomics-and-locks/p2-基础概念.md","raw":"---\ntitle: \"rust-atomics-and-locks-p2-基础概念\"\nabbrlink: posts/rust-atomics-and-locks/p2\nhidden: false\ndate: 2023-06-23 19:04:09\ntop: 95998\ntags: [Rust, Concurrency]\nkeywords: [Rust, Concurrency]\nis_series: true\nprev_post: [posts/rust-atomics-and-locks/p1, 系列说明]\nnext_post: [posts/rust-atomics-and-locks/p2, 基础概念]\n---\n\n> 本节我们将学习线程、互斥锁、条件变量、线程安全、共享和独占引用、内部可变性等内容  \n<!-- more -->\n\n同系列传送门: [rust-atomics-and-locks](/categories/rust-atomics-and-locks)\n\n# 开篇\n早在多核处理器普及之前, 操作系统就允许一台计算机同时运行许多程序  \n这是通过在进程间快速切换来实现的, 允许每个进程一个接一个地重复取得一点进展  \n如今, 几乎所有的计算机, 甚至我们的手机和手表都有多核处理器, 可以真正并行执行多个进程  \n\n操作系统尽可能将进程彼此隔离, 允许程序在完全不知道其他进程在做什么的情况下, 做自己的事情  \n例如, 一个进程在不询问操作系统的内核之前, 通常无法访问另一个进程的内存, 也无法以任何方式与之通信  \n\n但是, 程序可以生成额外的名为线程之物, 作为同一进程下的一部分   \n同一进程中的线程彼此之间不隔离, 线程共享内存, 并且可以通过该内存相互交互  \n\n本章将解释线程在 Rust 中是如何生成的, 以及围绕它们的所有基本概念, 例如如何在多个线程之间安全地共享数据  \n本章中解释的概念是本系列中其余部分的基础  \n\n- - -\n\n# Rust 中的线程\n每个程序都只能从主线程开始, 即 `main` 函数所在的线程  \n该线程将执行您的 `main` 函数，并可以生成更多子线程  \n\n**当主线程结束之后, 由其派生的子线程也将直接提前结束**  \n\n在 Rust 中, 新线程是通过 `std::thread::spawn` 函数生成的, 它需要一个参数, 代表将执行的函数  \n此函数返回/结束后, 该线程将停止  \n\n来看个例子:  \n\n```rust\nuse std::thread;\n\nfn main() {\n    thread::spawn(f);\n    thread::spawn(f);\n\n    println!(\"Hello from the main thread.\");\n}\n\nfn f() {\n    println!(\"Hello from another thread!\");\n\n    let id = thread::current().id();\n    println!(\"This is my thread id: {id:?}\");\n}\n```\n\n我们生成(spawn)了两个线程, 它们都将执行 `f` 作为其主要函数  \n这两个线程都将打印一条消息, 并显示其 `线程ID`, 而主线程也将打印自己的消息  \n\n**Thread ID:**  \nRust 标准库为每个线程分配一个唯一的标识符, 此标识符可通过 Thread::id() 访问, 类型为 ThreadId   \n除了复制它们并检查相等性之外, 您对 ThreadId 无能为力, 不能保证这些 ID 将连续分配, 只是每个线程的 ID 会有所不同  \n\n如果您多次运行上面的示例程序, 您可能会注意到两次运行之间的输出不同, 这是我在一次特定运行期间在机器上获得的输出:  \n\n```text\nHello from the main thread.\nHello from another thread!\nThis is my thread id:\n```\n\n令人惊讶的是, 部分输出似乎丢失了  \n这是因为, 在新生成的线程完成其传入的函数之前, 主线程就已经完成了 main 函数  \n从 main 返回将退出整个程序, 即使其他线程仍在运行  \n\n在该示例中, 在程序被主线程关闭前, 其中一个新生成的线程只发生了一半的消息  \n如果我们想确保, 线程在从 main 返回之前完成, 我们可以通过 `join` 来等待它们  \n为此, 我们要使用 `spawn` 函数返回的 `JoinHandle`:  \n\n```rust\nfn main() {\n    let t1 = thread::spawn(f);\n    let t2 = thread::spawn(f);\n\n    println!(\"Hello from the main thread.\");\n\n    t1.join().unwrap();\n    t2.join().unwrap();\n}\n```\n\n`.join()` 方法将等待线程完成执行, 并返回 `std::thread::Result`  \n若线程由于死机而未成功完成其功能, 这将包含死机消息, 我们可以尝试处理这种情况, 或者在加入恐慌线程时只调用 `.unwrap()` 以恐慌  \n\n运行此版本的代码将不再导致输出的截断:  \n\n```text\nHello from the main thread.\nHello from another thread!\nThis is my thread id: ThreadId(3)\nHello from another thread!\nThis is my thread id: ThreadId(2)\n```\n\n运行之间仍然更改的是消息们的打印顺序, 因为是并发, 所以无法保证先后顺序  \n\n**Output Locking:**  \n`println!` 使用 `std::io::Stdout::lock()`, 来确保其输出不会因线程间的并发而交替  \n`println!()` 将等到任何并发运行的表达式完成, 然后再写入任何输出  \n如果不是这种情况, 我们可能会得到更多交错的混乱的输出:  \n\n```text\nHello fromHello from another thread!\n another This is my threthreadHello fromthread id: ThreadId!\n( the main thread.\n2)This is my thread\nid: ThreadId(3)\n```\n\n与其将函数传递给 `std::thread::spawn`, 不如将闭包传递给它, 这允许我们捕获值, 并将其移动到新线程中:  \n\n```rust\nlet numbers = vec![1, 2, 3];\n\nthread::spawn(move || {\n    for n in &numbers {\n        println!(\"{n}\");\n    }\n}).join().unwrap();\n```\n\n此处, `numbers` 的所有权转移到了新生成的线程中, 因为我们使用了 `move` 闭包  \n若我们未使用 `move` 关键字, 闭包将通过引用捕获 `numbers`, 这将导致编译错误, 因为新线程的寿命可能超过该变量  \n\n由于线程可能一直运行到程序执行结束, 因此 `spawn` 函数的参数类型具有 'static 约束  \n换句话说, 它只接受永远存在的函数, 而通过引用捕获局部变量的闭包, 闭包可能不会永远有效  \n因为, 当局部变量不复存在时，对该变量的引用自然变得无效, 闭包也因此变得无效  \n\n从线程中获取的返回值, 实际上就是传入的闭包的返回值, 它可以从 `join` 方法返回的 `Result` 中获取:  \n\n```rust\nlet numbers = Vec::from_iter(0..=1000);\n\nlet t = thread::spawn(move || {\n    let len = numbers.len();\n    let sum = numbers.iter().sum::<usize>();\n    sum / len  // 1\n});\n\nlet average = t.join().unwrap(); // 2\n\nprintln!(\"average: {average}\");\n```\n\n在这里, 闭包 (1) 返回的值通过 join 方法 (2) 的返回值获取  \n若 numbers 为空，则新线程会尝试除以零 (1), 这将导致 panic, 而 `join` 则会返回 Err, 导致主线程也因为 unwrap 而 panic  \n\n**Thread Builder:***  \n`std::thread::spawn()` 实际上只是 `std::thread::Builder::new().spawn().unwrap()` 的一个简写  \n`std::thread::Builder` 允许您在生成新线程之前, 为其进行一些设置  \n您可以使用它来配置新线程的堆栈大小, 为新线程命名  \n通过 `std::thread::current().name()` 可以获取当前线程的名称, 这将在 panic 的消息中使用, 并将在大多数平台上的 debug 工具中可见  \n\n此外, `Builder` 的 `spawn` 函数返回 `std::io::Result`, 允许您处理生成新线程失败的情况  \n比如操作系统内存不足，或者对您应用的资源限制(resource limit), 则可能会发生该情况  \n(若 `spawn` 函数无法生成新线程, 它只会产生 panic)  \n\n- - -\n\n# 作用域线程\n有一个问题就是, 默认的 `spawn` 会要求一个具有 'static 约束的闭包, 在编译器就确保了不会发生生命周期上的问题  \n但如果我们真的确定, 生成的线程肯定不会超过某个作用域, 那么该线程理论上就应该可以安全地借用局部变量, 只要它们比该作用域活得久  \n\nRust 标准库提供了 `std::thread::scope` 函数, 来生成这样的作用域线程  \n它允许我们生成 \"不超过我们传递给该函数的闭包范围\" 的线程, 从而安全地借用局部变量  \n\n一个例子:  \n\n```rust\nlet numbers = vec![1, 2, 3];\n\nthread::scope(|s| { // 1\n    s.spawn(|| { // 2\n        println!(\"length: {}\", numbers.len());\n    });\n    s.spawn(|| { // 2\n        for n in &numbers {\n            println!(\"{n}\");\n        }\n    });\n}); // 3\n```\n\n- 在 (1) 处: 我们调用 `std::thread::scope` 函数, 我们的闭包将在传入后立刻执行, 参数 `s`，代表 `Scope`  \n- 在 (2) 处: 我们通过 `s` 参数, 生成了 作用域线程(Scoped Threads), 其传入的闭包可以借用局部变量, 如 `numbers`  \n- 在 (3) 处: 我们生成的所有 `Scoped-Thread`, 若还没有 `join`, 将自动 `join`  \n\n它保证了作用域内生成的任何线程, 都不会超过作用域  \n正因如此, 这个 `spawn` 方法的参数类型上没有 'static 约束，允许我们引用任何内容，只要它比作用域长寿，例如 `numbers`  \n\n在上面的示例中, 两个新线程同时访问 `numbers`, 这很好, 因为所有都不会修改它  \n若我们要将第一个线程更改为修改 `numbers`, 编译器将不允许我们生成另一个也修改 `numbers` 的线程:  \n\n```rust\nlet mut numbers = vec![1, 2, 3];\n\nthread::scope(|s| {\n    s.spawn(|| {\n        numbers.push(1);\n    });\n    s.spawn(|| {\n        numbers.push(2); // Error!\n    });\n});\n```\n\n确切的错误消息取决于 Rust 编译器的版本, 因为它通常会得到改进, 以产生更好的报错，目前的报错信息如下:  \n\n```text\nerror[E0499]: cannot borrow `numbers` as mutable more than once at a time\n --> example.rs:7:13\n4 |     s.spawn(|| {\n  |             -- first mutable borrow occurs here\n5 |         numbers.push(1);\n  |         ------- first borrow occurs due to use of `numbers` in closure\n\n7 |     s.spawn(|| {\n  |             ^^ second mutable borrow occurs here\n8 |         numbers.push(2);\n  |         ------- second borrow occurs due to use of `numbers` in closure\n```\n\n**来自译者的题外话, 帮你更好地理解下作用域线程:**  \n如果你观察一下 `std::thread::scope`, 会发现其 lifetime 的关系如下:  \n\n```rust\npub fn scope<'env, F, T>(f: F) -> T\nwhere\n    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n```\n\n根据文档所述, 'scope 表示作用域本身的 lfetime, 'env 表示作用域内线程借用的任何变量的 lifetime  \n\n'scope 的 lifetime 在 `scope` 函数开始之后开始，位于 `f (传入的闭包参数)` 之前, 其 lifetime 在 `f` 结束之后结束  \n该 lifetime 结束后, 所有生成的作用域线程都将被自动 `join`  \n\n关系如下:  \n\n<pre style=\"width: 534px; margin: 0px\">\n┌──fn_scope(f: F)────────────────────┐\n│                                    │\n│  'scope                            │\n│     |                              │\n│     |  'f  // is your closure      │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |  'f                          │\n│     |                              │\n│     | // join scoped threads here  │\n│     |                              │\n│  'scope                            │\n│                                    │\n└────────────────────────────────────┘\n</pre>\n\n而 'env 的约束是 'env: 'scope, 表示了作用域线程借用的任何变量的 lifetime 一定得小于作用域本身的 lifetime  \n\n\n**The Leakpocalypse:**  \n在 Rust 1.0 之前, 标准库有个名为 `std::thread::scoped` 的函数, 它会直接生成一个线程, 如同 `std::thread::spawn`  \n它允许非 'static 的闭包, 因为它返回的不是 `JoinHandle`, 而是个在 drop 时会 join 线程的 `JoinGuard`  \n任何借用的数据只需要比这 JoinGuard 存在更长的时间, 这似乎是安全的, 只要 JoinGuard 在某个时候被丢弃  \n\n但就在 Rust 1.0 发布之前, 很多事情慢慢变得清楚, 你不能保证某些东西一定会被丢弃, 这有很多办法  \n例如创建引用计数节点的循环, 或者 leak 它, 这都不会 drop 它  \n\n最终, 在一些人所说的 \"泄漏启示录(Leakpocalypse)\" 中, 得出的结论是:  \n安全接口的设计, 不能依赖于对象在其生命周期结束时总是会被丢弃的假设  \n泄漏对象可能会合理地导致泄漏更多对象(例如，泄漏 Vec 也会泄漏其元素), 但可能不会导致未定义的行为  \n\n由于这个结论, `std::thread::scoped` 不再被认为是安全的, 并从标准库中删除  \n此外, `std::mem::forget` 从 unsafe 变成了 safec, 以强调 forget/leak 始终是可能的  \n\n**老生常谈的话: Rust 并不会阻止 内存泄漏, 内存泄漏 不归到 内存安全 的范畴里**  \n\n直到很久以后, 在 Rust 1.63 中, 添加了一个新的 `std::thread::scope` 函数, 其中包含一个不依赖 Drop 来表示正确性的新设计  \n\n- - -\n\n# 共享所有权\n到目前为止, 我们已经研究了使用 move 闭包, 将值的所有权转移到线程, 并从寿命更长的父线程借用数据  \n当在两个线程之间共享数据时, 当两个线程都不能保证比另一个线程活得久, 则它们都不能成为该数据的所有者  \n它们之间共享的任何数据的 lifetime, 都需要与活的最长的线程一样长或更长  \n\n## Static\n有几种方法可以创建不属于单个线程的内容, 其中最简单的是使用 static 关键字  \n它由整个程序 “拥有”, 而不是单个线程  \n\n在以下示例中, 两个线程都可以访问 X , 但它们都不拥有它:  \n\n```rust\nstatic X: [i32; 3] = [1, 2, 3];\n\nthread::spawn(|| dbg!(&X));\nthread::spawn(|| dbg!(&X));\n```\n\n 一个 static 项, 其以 const 字面量作为初始值, 永远不会 drop  \n且在 main 函数启动之前, 它就已经存在, 每个线程都能借用它, 毕竟它保证永远存在  \n\n## Leak\n共享所有权的另一种方法是leak, 使用 `Box::leak`  \n它可以释放 Box 的所有权, 承诺永远不会 drop 它, 从那时起, Box 将永远存在, 没有所有者, 只要程序运行, 它就可以被任何线程借用  \n\n```rust\nuse std::thread;\n\nfn main() {\n    let x: &'static [i32; 3] = Box::leak(Box::new([1, 2, 3]));\n\n    thread::spawn(move || dbg!(x));\n    thread::spawn(move || dbg!(x));\n}\n```\n\n可能看上去, 在 move 闭包, 我们将所有权转移到了线程中  \n但仔细观察 x 的类型, 你会发现, 我们只是为线程提供了对数据的引用, 而不是数据本身的所有权  \n\n**注意:**\n- 独享引用(&T) 实现了 Copy 这个 trait, 这意味着当您 move 它时, 原始值仍然存在, 就像整数或布尔值一样\n- 'static 生命周期并不意味着 \"该值自程序开始以来一直存在\", 而只是 \"它一直存在到程序结束\", 过去的经历并不在乎\n\n泄漏 Box 的缺点是, 我们正在泄漏内存, 我们分配一些东西, 但从不丢弃和解除分配它  \n如果这只发生有限的少量次数, 可能会达成很棒的效果, 但如果我们继续, 程序将慢慢耗尽内存  \n\n## 引用计数  \n为了确保共享的数据被 drop , 使得其内存被释放, 我们不能完全放弃其所有权  \n相反, 我们可以分享所有权, 通过跟踪所有者的数量, 我们可以确保仅在没有所有者时才丢弃该值  \n\nRust 标准库通过 `std::rc::Rc` 类型提供此功能, 这是 \"引用计数(References Counting)\" 的缩写  \n它与 `Box` 非常相似, 除了 clone 它时并不会真的 clone 其包含的值, 而只是增加计数器的值  \n原来的 Rc 与克隆的 Rc,  都将引用相同的分配, 因此, 它们可以共享所有权  \n\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new([1, 2, 3]);\nlet b = a.clone();\n\nassert_eq!(a.as_ptr(), b.as_ptr()); // Same allocation!\n```\n\ndrop 一个 Rc 将减少计数器, 当最后一个 Rc 被 drop 时(计数器将降至零), 将 drop 其包含的值并释放内存  \n\n但是, 当我们尝试将 Rc 发送到另一个线程, 我们将遇到以下编译器错误:  \n\n```rust\nerror[E0277]: `Rc` cannot be sent between threads safely\n    |\n8   |     thread::spawn(move || dbg!(b));\n    |                   ^^^^^^^^^^^^^^^\n```\n\n事实证明, Rc 不是线程安全的, 因为它没有实现 `Send` 这个 tait  \n未实现 `Send` 的类型, 表示其实现可能并没有考虑多线程, 导致不能将其 move 进其他线程  \n因此如果将 Rc 分配给多个线程, 则它们可能会尝试同时修改引用计数器, 这可能会产生不可预知的结果\n\n但编译器阻止了我们  \n\n相反, 我们可以使用 `std::sync::Arc`, 它代表“原子引用计数(Atomic References Counting)”  \n它与 Rc 相同, 只是它保证对引用计数器的修改是不可分割的原子操作, 因此可以安全地将其用于多个线程  \n\n```rust\nuse std::sync::Arc;\n\nlet a = Arc::new([1, 2, 3]); // 1\nlet b = a.clone(); // 2\n\nthread::spawn(move || dbg!(a)); // 3\nthread::spawn(move || dbg!(b)); // 3\n```\n\n在上述代码中:\n\n- 在 (1) 处: 我们将数组放进了一个 `Arc` 中进行包装, 其引用计数器从 1 开始  \n- 在 (2) 处: 克隆了 `Arc`, 使得引用计数增加到 2, 并为我们提供另一个 `Arc`, 指向相同的资源  \n- 在 (3) 处: 两个线程都获得自己的 `Arc`, 可以访问共享数组, 两者都在 `drop` 使得计数器减 1  \n- 在 (3) 处: 最后一个 `drop` 了 `Arc` 的线程, 使得计数器减小到 0, 此时将会 drop 被包装的数组, 释放资源  \n\n**Naming Clones:**  \n必须给 `Arc` 的每个克隆一个不同的名称, 会很快使代码变得非常混乱且难以理解  \n虽然 `Arc` 的每个克隆都是单独的对象, 但每个克隆都表示相同的共享值, 我们可以通过 `Shadow` 语法来处理  \n\nRust 允许(并鼓励)你通过定义一个同名的新变量来隐藏变量, 如果在同一作用域内执行此操作, 则无法再使用原始变量  \n但是通过打开一个新作用域, 可以使用像 `let a = a.clone();` 这样的语句, 在该作用域内重用名称, 同时将原始变量保留在作用域之外  \n\n通过将闭包包装在新作用域(使用 `{}`)中, 我们可以在将变量移动到闭包之前克隆变量, 而无需重命名它们:  \n\n```rust\nlet a = Arc::new([1, 2, 3]);\nlet b = a.clone();\n\nthread::spawn(move || {\n    dbg!(b);\n});\n\ndbg!(a);\n```\n\n```rust\nlet a = Arc::new([1, 2, 3]);\n\nthread::spawn({\n    let a = a.clone();\n    move || {\n        dbg!(a);\n    }\n});\n\ndbg!(a);\n```\n\n由于所有权是共享的, 因此引用计数指针 (`Rc<T>` 和 `Arc<T>`) 与共享引用 (`&T`) 具有相同限制  \n它们不允许您对其包含的值进行可变访问, 因为该值可能同时被其他代码借用  \n例如, 当我们尝试对 `Arc<[i32]>` 中的整数切片进行排序, 编译器会阻止我们, 告诉我们不允许改变数据:  \n\n```text\nerror[E0596]: cannot borrow data in an `Arc` as mutable\n  |\n6 |     a.sort();\n  |     ^^^^^^^^\n```\n\n- - -\n\n# 借用与数据竞争\n在 Rust 中, 可以通过两种方式借用值:  \n\n- 不可变借用(Immutable borrowing):  \n通过 `&` 借用, 这得到了一个不可变引用(immutable reference), 可以复制这样的引用  \n对被引用数据的访问, 在此类引用的所有副本之间共享, 编译器通常不允许通过这样的引用修改内容, 因为会影响借用了相同数据的其他代码  \n\n- 可变借用(Mutable borrowing):  \n通过 `&mut` 借用, 这得到了一个可变引用(mutable reference), 可变借用保证它是该数据唯一的有效借用(active borrow)  \n因此, 这可以确保, 改变数据的内容不会影响到其他代码\n\n这两个概念在一起, 完全防止了数据竞争(data races), 即一个线程正在改变数据, 而另一个线程同时访问数据的情况  \n数据竞争通常是未定义的行为(undefined behavior), 这意味着编译器不需考虑这些情况, 因为它只会假设这些情况不会发生  \n\n为阐明这到底意味着什么, 让我们看一个编译器可以使用借用规则做出有用假设的示例:  \n\n```rust\nfn f(a: &i32, b: &mut i32) {\n    let before = *a;\n    *b += 1;\n    let after = *a;\n    if before != after {\n        x(); // never happens\n    }\n}\n```\n\n在这里, 我们得到一个对整数的不可变引用, 并在递增 b 所引用的整数前后, 存储了整数的值  \n编译器可以自由地假设有关 \"借用和数据竞争的基本规则\" 得到维护, 这意味着 b 不可能像 a 一样引用相同的整数  \n事实上, 只要 a 还存在, 整个程序中没有任何东西可以可变地借用 a 所指的整数  \n因此, 编译器可以很容易地得出结论, *a 不会改变, `before` 永远等于 `after`  \n因此 if 语句永远无法成立, 可以从程序中完全删除对 x 的调用, 进行优化\n\n编写一个打破编译器假设的 Rust 程序是不可能的, 除非使用 unsafe 块来禁用编译器的某些安全检查  \n\n**Undefined Behavior(未定义的行为):**  \n像 C, C++, Rust 这样的语言有一套规则, 需要遵循这些规则, 以避免所谓的未定义行为(ub)  \n例如, Rust 的规则之一是: 对任何对象都不能有多个可变引用  \n\n在 Rust 中, 只有在使用 unsafe 代码时才能违反这些规则中的任何一个  \nunsafe 在 Rust 中并不意味着代码不正确或不安全, 而是编译器没为您验证代码是否安全  \n如果代码确实违反了这些规则，则称为 unsound(不健全), 因此, 你可以将 unsafe, 等价于 trust_me  \n\n编译器会假设这些规则永远不会被破坏, 当被破坏时, 会导致一种被称为未定义行为的情况发生, 我们需要不惜一切代价避免这种情况  \n因为, 若我们允许编译器做出一个实际上不正确的假设, 它很容易导致代码不同部分的更多错误结论, 从而影响整个程序  \n\n作为一个例子, 让我们看一下在切片上使用 `get_unchecked` 方法的代码实例:  \n\n```rust\nlet a = [123, 456, 789];\nlet b = unsafe { a.get_unchecked(index) };\n```\n\n`get_unchecked` 方法, 让我们得到了指定索引位置的切片元素, 如同 `a[index]` 一样  \n但它允许编译器假设索引始终在边界内, 而无需进行任何边界检查  \n\n这意味着, 在此代码段中, 由于 a 的长度为 3, 因此编译器可能会假定 index 小于 3, 我们有责任确保其假设成立  \n如果我们打破这个假设, 例如, 如果我们在 index 等于 3 的情况下运行这个假设, 任何事情都可能发生  \n这可能会导致, 从内存中读取到了存储在 a 之后的字节中的任何内容, 程序可能会因此崩溃  \n比如, 它最终可能会执行你程序中一些完全不相关的部分, 造成各种破坏  \n\n令人惊讶的是, 未定义行为甚至可以 “影响过去”, 导致它之前的代码出现问题  \n为了理解这是如何发生的, 假设在先前代码的前面有个 match 语句, 如下所示:  \n\n```rust\nmatch index {\n   0 => x(),\n   1 => y(),\n   _ => z(index),\n}\n\nlet a = [123, 456, 789];\nlet b = unsafe { a.get_unchecked(index) };\n```\n\n由于 unsafe 块, 编译器可以假定 index 只为 0、1 或 2  \n从逻辑上讲, 我们可以得出结论, 我们的 match 语句的最后一个分支只会与 2 匹配  \n因此 z(index) 只可能是 z(2), 该结论不仅可以用于优化 match, 还可优化 z 本身, 这可能包括删除代码中未使用的部分  \n\n如果我们让 index 为 3 时执行此操作, 我们的程序可能会尝试执行已优化的部分  \n这从而导致了完全不可预测的行为, 早于在我们到达最后一行的 unsafe 块之前  \n就像这样, 未定义行为可能以一种非常意想不到的方式, 向后和向前传播与污染整个程序  \n\n调用任何 unsafe 函数前, 请仔细阅读文档, 并确保完全了解其安全要求  \n作为调用者, 您需要秉承 \"避免未定义行为\" 的准则  \n\n- - -\n\n# 内部可变性\n上一节中介绍的借用规则很简单, 但可能非常有限, 尤其是在涉及多个线程时  \n遵循这些规则, 将使得线程间的通信被严重限制, 甚至会变得几乎不可能, 因为多线程间可访问的数据不能突变  \n幸运的是, 有个逃生舱口: 内部可变性(interior mutability)  \n具有内部可变性的数据类型, 会稍微改变其借用规则, 在某些情况下, 这些类型可通过 \"不可变引用\" 而允许突变  \n\n在先前讲述引用计数时, 我们已看到了个涉及内部可变性的微妙例子:  \n`Rc` 和 `Arc` 被 clone 与 drop 时, 会改变引用计数器的数值, 即使多个克隆都使用着相同的引用计数器  \n\n一旦涉及内部可变类型, 将引用称为 \"不可变\" 或 \"可变\" 会令人困惑和不准确, 因为两者都能够突变数据  \n更准确的术语是 \"共享\" 和 \"独占\":  \n共享引用(&T)可以复制并与他人共享, 而独占引用(&mut T)保证了它是该 T 的唯一独占借用  \n对于大多数类型, 共享引用不允许突变, 但也有例外  \n由于在本系列中, 我们将主要处理这些例外, 因此我们将在本系列的其余部分使用更准确的术语   \n\n**注意:**  \n请记住, 内部可变性只会改变共享借用的规则, 以允许共享时的突变, 而不会改变任何关于独占借用的行为  \n独占借用仍然保证没有其他独享的有效借用(active borrow)  \nunsafe 中对某物的多个有效的独占引用, 将始终导致未定义行为, 不会考虑内部可变性  \n\n## Cell\n`std::cell::Cell<T>` 只是个包裹了 T 类型数据的类型, 但允许通过共享引用进行突变  \n为避免未定义行为, 它只允许您复制值(T 必须实现 Copy), 或用另一个值替换已被包裹的值  \n此外, 它只能在单个线程中使用  \n\n让我们看个类似上一节中的示例, 但这次使用 Cell<i32> 而不是 i32:  \n\n```rust\nuse std::cell::Cell;\n\nfn f(a: &Cell<i32>, b: &Cell<i32>) {\n    let before = a.get();\n    b.set(b.get() + 1);\n    let after = a.get();\n    if before != after {\n        x(); // might happen\n    }\n}\n```\n\n与上次不同, 现在 if 条件可能为真, 因为 `Cell<i32>` 具有内部可变性, 所以只要我们有对它的共享引用, 编译器就不能再假设它的值不会改变  \na 和 b 可能都引用相同的值，因此通过 b 对数据突变, 也可能影响到 a  \n但是, 它仍假定没有其他线程同时访问 `Cell` 类型的 a 与 b  \n\n对 Cell 的限制并不总是那么容易处理, 因为它不能直接让我们借用它所持有的值  \n我们要将其值移出, 修改它后再放回去, 以改变它的内容:  \n\n```rust\nfn f(v: &Cell<Vec<i32>>) {\n    let mut v2 = v.take(); // Replaces the contents of the Cell with an empty Vec\n    v2.push(1);\n    v.set(v2); // Put the modified Vec back\n}\n```\n\n## RefCell\n\n与常规 `Cell` 不同, `std::cell::RefCell` 允许您以较小的运行时成本借用其值  \n`RefCell<T>` 不仅持有 `T`, 还持有引用计数器, 用于在运行时, 跟踪对被包裹数据的借用的情况  \n当你试图以不可变地借用它, 而它已经被可变借用了(反之亦然), 它会 panic, 从而避免未定义的行为  \n像 `Cell` 一样, `RefCell` 只能在单个线程中使用  \n\n借用 `RefCell` 包裹的值, 是通过调用 `borrow` 或 `borrow_mut` 来完成的:  \n\n```rust\nuse std::cell::RefCell;\n\nfn f(v: &RefCell<Vec<i32>>) {\n    v.borrow_mut().push(1); // We can modify the `Vec` directly.\n}\n```\n\n**译者注:**  \n`Cell/RefCell`, 简单来说, 属于在编译时欺骗了编译器, 将借用规则从编译器挪动到运行期, 以便于放宽要求  \n但借用规则还是满足的, 只是晚了一个阶段而已, 如果违背了借用规则, 依旧会报错  \n\n虽然 `Cell` 和 `RefCell` 非常有用, 但当我们处于多线程并发的环境时, 它们变得没啥用  \n因此, 让我们转到与并发相关的类型  \n\n## Mutex/RwLock\n`RwLock (reader-writer lock)`, 是 `RefCell` 的并发版本  \n一个 `RwLock<T>`, 持有 T 并跟踪借用的情况  \n但与 `RefCell` 不同的是, 它不会在借用冲突时 panic, 而是阻塞当前线程(使其进入睡眠状态), 同时等待冲突的借用消失  \n我们只需耐心地等待其他线程完成, 然后处理数据即可  \n\n借用被 `RwLock` 包裹的值, 称为锁定(lcok), 通过锁定它, 我们可以暂时阻止并发的冲突借用, 以允许我们借用它而不会引起数据竞争  \n`Mutex` 非常相似, 但在概念上稍微简单些, 它不像 `RwLock` 那样跟踪共享借用和独占借用的数量, 而只允许独占借用  \n\n我们将在本节之后, 更加详细地介绍这些类型  \n\n## Atomic\n`Atomic(原子)`, 该类型是 `Cell` 的并发版本, 是之后第 2 章和第 3 章的主题  \n像 `Cell` 一样, 它们通过将值作为一个整体, 复制进来和传出来, 以避免未定义行为, 而不让我们直接借用内容  \n\n但与 `Cell` 不同, 它们不能是任意大小  \n因此没有通用的 `Atomic<T>` 类型, 而只有特定的原子类型, 例如 `AtomicU32` 和 `AtomicPtr<T>`  \n哪些可用取决于平台, 因为它们需要处理器的支持以避免数据竞争(我们将在之后的第 7 章中深入探讨)  \n\n由于它们的大小非常有限, 因此原子通常不直接包含需要在线程之间共享的信息  \n相反, 它们通常被用作一种工具, 以便在线程之间共享其他(通常是更大的)数据, 此时事情可能会变得非常复杂  \n\n## UnsafeCell  \n\n`UnsafeCell` 是内部可变性的原始的构建块  \n`UnsafeCell<T>` 包装 `T`, 但不附带任何条件或限制以避免未定义行为  \n相反, 它的 `get()` 方法只是给出一个包装值的原始指针, 该值只能在 `unsafe` 块中使用  \n它让用户以不会导致任何未定义行为的方式使用它  \n\n最常见的是, `UnsafeCell` 不直接使用, 而是包装在另一类型中, 该类型通过有限的接口(例如 `Cell` 或 `Mutex`)提供安全性  \n所有具有内部可变性的类型(包括上面讨论的所有类型)都建立在 `UnsafeCell` 之上  \n\n- - -\n\n#  线程安全  \n在本章中, 我们看到了几种非线程安全的类型, 这些类型只能在单个线程上使用, 例如 `Rc`. `Cell`  \n由于需要限制以避免未定义行为, 因此编译器需要去理解并检查, 以便于知晓使用这些类型时无需使用 unsafe 块  \n\nRust 语言使用两个特殊的 Trait 来跟踪哪些类型可以跨线程安全使用:  \n\n- Send:  \n如果一个类型可以被发送到另一个线程, 则该类型为 Send, 即该类型的值的所有权, 可以转移到另一个线程  \n例如, `Arc<i32>` 实现了 Send, 但 `Rc<i32>` 没有  \n\n- Sync:  \n如果一个类型可以与其他线程共享, 则类型为 Sync, 即当且仅当 &T 是 Send 时, T 实现了 Sync  \n例如, `i32` 是 Sync, 因为 &i32 是 Send, 但 `Cell<i32>` 不是 (不过 `Cell<i32>` 是 Send)  \n\n所有基础类型, 如 i32, bool, str, 都是 Send 和 Sync  \n\n这两个 Trait 都是 auto 的, 这意味着它们会根据类型的字段而自动实现  \n比如, 当字段均为 Send 和 Sync 时, 该 struct 本身也是 Send 和 Sync  \n\n选择主动避免实现其中任何一个 Trait 的方法, 是向类型添加一个未实现相关 Trait 的字段  \n为此, 特殊的 `std::marker::PhantomData<T>` 类型通常会派上用场, 编译器将该类型视为 T. 但它在运行时实际上并不存在  \n这是一个零大小的类型, 不占用空间  \n\n我们来看看下面的 struct:  \n\n```rust\nuse std::marker::PhantomData;\n\nstruct X {\n    handle: i32,\n    _not_sync: PhantomData<Cell<()>>,\n}\n```\n\n在此示例中, 若 handle 是其唯一字段, 则 X 将是 Send 和 Sync  \n但是, 我们添加了一个大小为零的 `PhantomData<Cell<()>>` 字段, 该字段被视为 `Cell<()>`  \n因为 `Cell<()>` 不是 Sync, 所以 X 也不是, 但它仍然是 Send, 因为它的所有字段都实现了 Send  \n\n原始指针 (*const T 和 *mut T) 既不是 Send 也不是 Sync, 因为编译器对它们表示的数据知之甚少  \n\n选择手动实现其中任何一个 Trait , 都需要用 unsafe 进行标明:  \n\n```rust\nstruct X {\n    p: *mut i32,\n}\n\nunsafe impl Send for X {}\nunsafe impl Sync for X {}\n```\n\n实现这些特征之所以需要 unsafe 关键字, 是因为编译器无法为您检查它是否正确, 这是你对编译器的承诺, 它只需信任你  \n\n如果您尝试将某些内容移动到另一个非 Send 的线程中, 编译器会礼貌地阻止您这样做, 下面是个小示例:  \n\n```rust\nfn main() {\n    let a = Rc::new(123);\n    thread::spawn(move || { // Error!\n        dbg!(a);\n    });\n}\n```\n\n在这里, 我们尝试将 `Rc<i32>` 发送到新线程, 但 `Rc<i32>` 与 `Arc<i32>` 不同, 它没实现 Send   \n如果我们尝试编译上面的示例，我们将面临如下所示的错误:  \n\n```text\nerror[E0277]: `Rc<i32>` cannot be sent between threads safely\n   --> src/main.rs:3:5\n    |\n3   |     thread::spawn(move || {\n    |     ^^^^^^^^^^^^^ `Rc<i32>` cannot be sent between threads safely\n    |\n    = help: within `[closure]`, the trait `Send` is not implemented for `Rc<i32>`\nnote: required because it's used within this closure\n   --> src/main.rs:3:19\n    |\n3   |     thread::spawn(move || {\n    |                   ^^^^^^^\nnote: required by a bound in `spawn`\n```\n\n`thread::spawn` 函数要求其参数为 Send, 如果闭包的所有捕获都为 Send, 则闭包也为 Send   \n如果我们试图捕捉不是 Send 的东西, 那么我们的错误就会被抓住, 编译器会保护我们免受未定义行为的影响  \n\n- - -\n\n# 互斥锁\n在线程间共享不可变或可变的数据, 最常用的工具是 Mutex, 它是 互斥(mutual exclusion) 的缩写  \n互斥锁的工作是, 通过暂时阻塞尝试同时访问某些数据的其他线程, 来确保线程对某些数据具有独占访问权限  \n\n从概念上讲, 互斥锁只有两种状态: 锁定和解锁(lock and unlock)  \n\n当线程锁定了未锁定的互斥锁时, 互斥锁将标记为锁定, 线程可以立即继续  \n当线程尝试锁定已锁定的互斥锁时, 该操作将阻塞, 线程在等待互斥锁解锁时进入睡眠状态  \n\n解锁只能在锁定的互斥锁上进行, 并且应该由锁定它的同一线程完成  \n如果其他线程正在等待锁定互斥锁, 则解锁互斥锁将导致其中一个线程被唤醒, 被唤醒的线程可以尝试再次锁定互斥锁  \n该过程可以一直重复  \n\n使用互斥锁保护数据, 只是所有线程间的协议, 即它们仅在锁定互斥锁时访问数据  \n这样, 没有两个线程可以同时访问该数据, 避免了数据竞争  \n\n## Rust's Mutex\nRust 标准库通过 `std::sync::Mutex<T>` 提供此功能  \n类型 T 是互斥锁保护的数据类型, 通过将 T 类型的数据作为互斥锁的一部分, 数据将只能通过互斥锁访问  \n这允许了一个安全的接口, 可以保证所有线程都将遵守协议  \n\n为了确保锁定的互斥锁只能由锁定它的线程解锁, 它没有 `unlock()` 方法  \n相反, 它的 `lock()` 方法返回一个名为 `MutexGuard` 的特殊类型, 表示我们已锁定互斥锁的保证  \n它的行为类似于一个通过 `DerefMut` 获取的独占引用, 使我们能独占地访问互斥锁保护的数据  \n解锁互斥锁是通过 drop 这个 `MutexGuard` 类型的变量来完成的, 当我们放下 guard 时, 我们放弃了访问数据的能力, guard 的 Drop 实现将解锁互斥锁  \n\n让我们看一个例子, 看看互斥锁在实践中的运用:  \n\n```rust\nuse std::sync::Mutex;\n\nfn main() {\n    let n = Mutex::new(0);\n    thread::scope(|s| {\n        for _ in 0..10 {\n            s.spawn(|| {\n                let mut guard = n.lock().unwrap();\n                for _ in 0..100 {\n                    *guard += 1;\n                }\n            });\n        }\n    });\n    assert_eq!(n.into_inner().unwrap(), 1000);\n}\n```\n\n在这里, 我们有一个 `Mutex<i32>`, 一个保护整数的互斥锁, 我们生成十个线程, 每个线程将整数递增一百次  \n每个线程将首先锁定互斥锁, 以获取 `MutexGuard`, 然后使用该 guard 访问整数并对其进行修改  \n当 guard 超出作用域后, 其将立即被隐式地 drop  \n\n线程完成后, 我们可以安全地从通过 `into_inner()` 方法以删除互斥保护  \n`into_inner` 方法获取了互斥锁的所有权, 这保证了没有其他任何东西可以再引用互斥锁, 因此不需要锁定  \n\n即使增量以 1 为步长发生, 但观察整数的线程也只能看到 100 的倍数, 因为它只能在互斥锁解锁时查看整数  \n实际上, 由于互斥锁, 一百个增量现在是一个不可分割的操作, 这样不可分割的操作也称为原子操作  \n\n为了清楚地看到互斥锁的效果, 我们可以让每个线程在解锁互斥锁之前等待一秒钟:  \n\n```rust\nuse std::time::Duration;\n\nfn main() {\n    let n = Mutex::new(0);\n    thread::scope(|s| {\n        for _ in 0..10 {\n            s.spawn(|| {\n                let mut guard = n.lock().unwrap();\n                for _ in 0..100 {\n                    *guard += 1;\n                }\n                thread::sleep(Duration::from_secs(1)); // New!\n            });\n        }\n    });\n    assert_eq!(n.into_inner().unwrap(), 1000);\n}\n```\n\n当您现在运行该程序时, 您将看到大约需要 10 秒才能完成, 每个线程只等待一秒钟, 但互斥锁会确保一次只有一个线程可以这样做  \n\n如果我们在 sleep 前, 就 drop 掉 guard, 从而解锁互斥锁, 我们将看到它并行发生:  \n\n```rust\nfn main() {\n    let n = Mutex::new(0);\n    thread::scope(|s| {\n        for _ in 0..10 {\n            s.spawn(|| {\n                let mut guard = n.lock().unwrap();\n                for _ in 0..100 {\n                    *guard += 1;\n                }\n                drop(guard); // New: drop the guard before sleeping!\n                thread::sleep(Duration::from_secs(1));\n            });\n        }\n    });\n    assert_eq!(n.into_inner().unwrap(), 1000);\n}\n```\n\n通过此更改, 该程序只需大约一秒钟, 因为现在 10 个线程可以同时执行一秒钟的睡眠, 这表明尽可能缩短互斥锁锁定时间的重要性  \n当互斥锁锁定的时间超过必要的时间, 可能会完全抵消并行性的任何好处, 从而有效地强制所有内容按顺序发生  \n\n## 锁中毒\n\n上面示例中的 `unwrap()` 调用与锁中毒(Lock Poisoning)有关  \n\n当线程在 lock 锁时发生 panic, `Mutex` 会被标记为中毒(Poisoned)  \n发生这种情况时, `Mutex` 将不再被锁定, 但调用其 `lock` 方法将导致得到一个 `Err`, 表示它已经中毒  \n\n这是一种 \"防止受互斥锁保护的数据处于不一致状态\" 的机制  \n在上面的示例中, 若线程在将整数递增不到 100 次后出现 panic, 则互斥锁将解锁  \n此时整数将处于意外状态, 不再是 100 的倍数, 这可能会破坏其他线程的假设  \n在这种情况下, 自动将互斥锁标记为中毒, 会强制用户处理这种可能性  \n\n在中毒的互斥锁上调用 `lock()` 仍会锁定互斥锁  \n`lock()` 返回的 `Err` 包含 `MutexGuard`, 允许我们在必要时更正不一致的状态  \n\n虽然锁中毒似乎是种强大的机制, 但在实践中并不经常从潜在的不一致状态中恢复  \n大多数代码要么忽略锁中毒, 要么在锁中毒时使用 `unwrap()` 进行 panic, 从而有效地将 panic 传播给互斥锁的所有用户  \n\n\n**Lifetime of the MutexGuard:**  \n虽然隐式地 drop 掉 guard 变量, 可以方便地解锁互斥锁, 但有时会导致微妙的意外  \n如果我们用 let 语句给 guard 分配一个名称(如上面的例子), 将会很直接地知晓它何时 drop, 因为局部变量在其作用域的末尾会自动被 drop  \n尽管如此, 不显式 drop 掉 guard, 可能会导致将互斥锁锁定的时间不必要的延长, 如上面的示例所示  \n\n使用无名称的 guard 也是可能的, 有时甚至非常方便  \n由于 MutexGuard 的行为, 类似于对受保护数据的独占引用, 因此我们可以直接使用它, 而无需先为 guard 分配名称  \n例如, 如果您有 Mutex<Vec<i32>>, 则可在单个语句中, 锁定互斥锁, 进行 push, 最后再次解锁互斥锁(drop):  \n\n```rust\nlist.lock().unwrap().push(1);\n```\n\n这是因为, 在表达式中生成的任何临时变量(例如通过 lock() 返回的守卫)都将在语句末尾删除  \n虽然这看起来是显而易见且合理的, 但它会导致一个常见的陷阱, 通常涉及 `match`, `if let`, `while let` 语句  \n下面是遇到此陷阱的示例:  \n\n```rust\nif let Some(item) = list.lock().unwrap().pop() {\n    process_item(item);\n}\n```\n\n这段代码的意图, 是锁定 list, 随后 pop 一个元素并解锁 list, 最后处理该元素, 但我们在这犯了个微妙但重要的错误  \n临时生成 guard, 将会直到整个 if let 语句结束才会 drop, 这意味着我们在处理项目时, 保持了不必要的锁定  \n\n令人惊讶的是, 对于类似的 if 语句, 这种情况不会发生:  \n\n```rust\nif list.lock().unwrap().pop() == Some(1) {\n    do_something();\n}\n```\n\n在这里, 不像先前的 `if let` 语句, 临时的 guard 确实在执行 if 语句的主体前就被 drop 了  \n原因是: 常规 if 语句的条件始终是普通 bool 值, 不会借用任何东西  \n因此, 没有理由将临时变量的 lifetime 从条件延长到语句结束  \n\n但是, 对于 `if let` 语句, 情况可能并非如此  \n例如, 如果我们使用 `front()` 而不是 `pop()`, 则 item 将从列表中借用, 因此有必要保持警惕  \n\n因为使用 `if let` 语句时可能会产生借用  \n于是在此情况下, 被创建的临时变量的生命周期, 被规定将会被延长到 `if let` 的主体结束  \n因此就算当我们使用 `pop()` 而非 `front()` 时, 也会发生同样的情况, 即使这不是必需的  \n故 guard 不会在第一时间被 drop 掉  \n\n我们可以通过将 `pop` 操作移动到单独的 let 语句, 来避免这种情况  \n因此, 在该语句的末尾, 在 if let 之前, 被临时创建的 guard 将会被 drop:  \n\n```rust\nlet item = list.lock().unwrap().pop();\nif let Some(item) = item {\n    process_item(item);\n}\n```\n\n## RwLock\n\n互斥锁只涉及独占访问, MutexGuard 将为我们提供对受保护数据的独占引用(&mut T)  \n即使我们只想查看数据, 并使用已经足够满足需求的共享引用(&T)  \n\n读写锁(RwLock)是互斥锁的一个稍微复杂点的版本, 它了解独占访问和共享访问之间的区别, 并且可以提供两者之一  \n它有三种状态: 解锁, 由单个写入器(writer)锁定(用于独占访问), 被任意数量的读取器(reader)锁定(用于共享访问)  \n它通常用于经常由多个线程读取但仅偶尔更新一次的数据  \n\nRust 标准库通过 `std::sync::RwLock<T>` 类型提供此锁  \n它的工作方式与 `Mutex` 类似, 只是它的接口主要分为两部分  \n它不是单个 `lock()` 方法, 而是具有用于锁定为 writer 或 reader 的 `read()` 和 `write()` 方法  \n它有两种 guard 类型, 一种用于 reader, 一种用于writer: `RwLockReadGuard` 和 `RwLockWriteGuard`  \n两者都实现了 `Deref` 以表现为对受保护数据的引用, 前者的表现类似于共享引用, 而后者的表现类似于独占引用  \n\n它实际上是 `RefCell` 的多线程版本, 动态跟踪引用的数量, 以确保遵守借用规则  \n\n`Mutex<T>` 和 `RwLock<T>` 都要求 T 为 `Send`, 因为它们可用于将 `T` 发送到另一个线程  \n`RwLock<T>` 还需要 T 来实现 `Sync`, 因为它允许多个线程保存对受保护数据的共享引用(&T)  \n严格来说, 您可以为不满足这些要求的 T 创建一个锁, 但您将无法在线程之间共享它, 因为锁本身不会实现 `Sync`  \n\nRust 标准库只提供一种通用的 `RwLock` 类型, 但其实现取决于操作系统, 其实现之间存在许多细微差异  \n当有 writer 等待时, 大多数实现都会选择阻塞新的 reader, 即使锁已经 read-locked 也是如此  \n这是为了防止 `writer starvation(写饿死/写入器匮乏`), 即一种 \"readers 过多导致锁一直无法被解锁, 导致 writer 无法更新数据\" 的情况  \n\n**Mutexes in Other Languages:**  \nRust 标准库中的 `Mutex` 和 `RwLock` 类型, 看起来与 C 或 C++ 等其他语言中的实现略有不同  \n最大的区别是 Rust 的 Mutex<T> 包含它正在保护的数据  \n\n例如, 在 C++ 中, `std::mutex` 不包含它保护的数据, 甚至不知道它在保护什么  \n这意味着, 用户有责任记住哪些数据受到保护, 以及由哪个互斥锁保护, 并确保每次访问 \"受保护数据\" 时, 都锁定正确的互斥锁  \n在阅读涉及其他语言互斥体的代码时, 或者与不熟悉 Rust 的程序员交流时, 记住这一点很有用  \n一个 Rust 程序员可能会谈论 \"互斥锁中的数据\", 或者 \"将其包装在互斥锁中\" 之类的话, 这可能会让那些只熟悉其他语言互斥锁的人感到困惑  \n\n如果您确实需要一个不包含任何数据的独立互斥锁, 例如保护某些外部硬件, 则可使用 `Mutex<()>`  \n但即使在这种情况下, 您最好定义一个(可能是零大小的)类型来与该硬件接口, 并将其包装在 `Mutex` 中  \n这样, 您仍然被迫锁定互斥锁, 然后才能与硬件交互  \n\n- - -\n\n# 线程等待\n当数据被多个线程改变时, 它们可能需要进行等待, 等到某些条件变为真再继续执行  \n例如, 如果我们有一个保护 `Vec` 的互斥锁, 我们可能需要等到它非空(被放入东西后再继续)  \n\n互斥锁确实允许线程等待它被解锁, 但它不提供这种 \"等待到某个条件成立\" 的功能  \n如果我们只有一个互斥锁, 我们将不得不继续锁定互斥锁, 以反复检查 `Vec` 中是否有任何东西  \n\n## Thread Parking\n等待来自另一个线程的通知的一种方法, 称为 `thread parking(线程停放)`  \n线程可以自行 park, 使其进入睡眠状态, 从而防止 CPU 空耗, 然后，另一个线程可以将线程唤醒/解除停放(unpark), 使其继续  \n\n**译者注:**  \npark 的意思就是把车停放下来, 对应让线程进入睡眠  \nunpark 的意思就是把车开走, 对应让线程继续  \n\npark 的行为, 可通过 `std::thread::park()` 函数表示  \nunpark 的行为, 您可以在要被唤醒的线程的 `Thread` 类型的对象上, 调用 `unpark()` 方法表示  \n`Thread` 对象可以从 `spawn` 返回的 `JoinHandle` 获取, 也可以通过 `std::thread::current()` 从线程本身获取  \n\n让我们深入了解一个使用互斥锁, 在两个线程之间共享队列的示例  \n在以下示例中, 新生成的线程将消耗队列中的元素(consumer), 而主线程将每秒将一个新元素插入到队列(producter)  \npark 被用于让 comsumer 线程在队列为空时进行等待  \n\n```rust\nuse std::collections::VecDeque;\n\nfn main() {\n    let queue = Mutex::new(VecDeque::new());\n\n    thread::scope(|s| {\n        // Consuming thread\n        let t = s.spawn(|| loop {\n            let item = queue.lock().unwrap().pop_front();\n            if let Some(item) = item {\n                dbg!(item);\n            } else {\n                thread::park();\n            }\n        });\n\n        // Producing thread\n        for i in 0.. {\n            queue.lock().unwrap().push_back(i);\n            t.thread().unpark();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n}\n```\n\n这是一个无限循环进行的例子, 在该循环中, 当元素不为空时, 它将元素从队列中弹出, 使用 `dbg!` 显示它们  \n当队列为空时, 它将调用 `park()`, 使线程进入睡眠状态, 防止 CPU 空耗  \n如果它被 unpark, 则先前调用的 `park()` 方法将会 return, 随后循环继续, 再次从队列中弹出元素, 直到它为空, 重复  \n\nconsumer 线程每秒生成一个新数字, 然后将其 push 到队列中  \n每次添加时, 都会在代表着 consumer 线程的 Thread 对象上, 调用 unpark() 方法来 unpark 它  \n这样, consumer 线程就会被唤醒, 以处理新的元素  \n\n这里要提出的一个重要观察是, 如果我们删除对 park() 的调用, 这个程序在理论上仍然正确, 但效率低下  \n这非常重要, 因为 `park()` 不能保证它会只因为相匹配的 `unpark()` 而返回  \n虽然罕见, 但它可能会虚假的唤醒(spurious wake-ups)  \n\n我们的示例很好地处理了这个问题, 因为 consumer 线程将锁定保护着队列的互斥锁, producter 线程将因此阻塞  \n随后, consumer 线程将检测队列是否为空, 当队列为空时, 就再次调用 `park()` 让自己进入睡眠状态  \nproducter 线程因此得以锁定互斥锁, 并对队列 push 新的元素, 随后调用 `unpark()` 唤醒 consumer 线程让其处理新元素  \n\n\n`Thread Parking` 的一个重要属性是, 对 `unpark()` 的调用在线程 park 自身之前, 不会丢失  \n对 unpark 的请求仍然会被记录, 下次线程尝试 park 时, 它会认识到该请求, 随后清除该请求后直接继续, 而不会实际进入睡眠  \n为了去了解为何这对正确性至关重要, 让我们来看看两个线程的执行步骤的可能顺序(从一开始观察):  \n\n1. consumer 线程(简写为C)锁定了队列\n2. C 尝试从队列中 pop 一个元素, 但它是空的, 结果为 None, 模式匹配后进去 else 分支 \n3. C 解锁队列\n4. producter 线程(简写为P)锁定了队列\n5. P 将新元素 push 到队列中\n6. P 再次解锁队列\n7. P 调用 `unpark()` 通知 C 有新元素\n8. C 调用 `park()` 进入睡眠, 等待更多元素\n\n# 以下内容为机翻还在改别着急\n\n虽然在步骤 3 中解锁队列和在步骤 8 中 unpark 之间很可能只有非常短暂的时刻，但步骤 4 到 7 可能会在线程 pack 之前的那一刻发生  \n如果 `unpark()` 在线程未停放时不执行任何操作, 则通知将丢失, 使用线程仍将在等待, 即使队列中有项目也是如此  \n由于取消寄存请求被保存以供将来调用 park()我们不必担心这一点  \n\n但是，取消寄存请求不会叠加。调用 unpark() 两次，然后调用 park() 两次仍会导致线程进入睡眠状态。前 park() 个清除请求并直接返回，但第二个像往常一样进入睡眠状态。  \n\n这意味着在上面的示例中，重要的是，只有在看到队列为空时才停放线程，而不是在每个处理的项目之后停放它。虽然由于睡眠时间巨大（一秒），此示例中极不可能发生，但多个 unpark() 调用可能只唤醒一个 park() 调用。  \n\n不幸的是，这确实意味着，如果在 park() 返回后立即调用 unpark() ，但在队列被锁定和清空之前，则 unpark() 调用是不必要的，但仍会导致下一个 park() 调用立即返回。这会导致（空）队列被锁定并解锁额外的时间。虽然这不会影响程序的正确性，但它确实会影响其效率和性能。  \n\n此机制适用于像我们示例中这样的简单情况，但当事情变得更加复杂时，很快就会崩溃。例如，如果我们有多个使用者线程从同一队列中获取项目，则生产者线程将无法知道哪个使用者实际上正在等待并且应该被唤醒。生产者必须确切地知道消费者何时在等待，以及它正在等待什么条件。  \n\n## Condvar\n条件变量是更常用的选项，用于等待受互斥锁保护的数据出现问题。它们有两个基本操作：等待和通知。线程可以等待条件变量，之后当另一个线程通知相同的条件变量时，它们可以被唤醒。多个线程可以等待同一个条件变量，通知可以发送到一个等待线程，也可以发送到所有线程。  \n\n这意味着我们可以为我们感兴趣的特定事件或条件创建一个条件变量，例如队列为非空，并等待该条件。然后，导致该事件或条件发生的任何线程都会通知条件变量，而不必知道哪些线程或有多少线程对该通知感兴趣。  \n\n为了避免在解锁互斥锁和等待条件变量之间的短暂时刻丢失通知的问题，条件变量提供了一种以原子方式解锁互斥锁并开始等待的方法。这意味着通知根本不可能丢失。  \n\nRust 标准库提供了一个条件变量为 std::sync::Condvar 。它的 wait 方法需要 MutexGuard 来证明我们已经锁定了互斥锁。它首先解锁互斥锁并进入睡眠状态。稍后，当唤醒时，它会重新锁定互斥锁并返回新的 MutexGuard （这证明互斥锁再次被锁定）。  \n\n它有两个通知函数： notify_one 只唤醒一个等待线程（如果有）， notify_all 唤醒它们。  \n\n让我们修改用于线程停放的示例，改用 Condvar ：   \n","slug":"rust/rust-atomics-and-locks/p2-基础概念","published":1,"updated":"2023-06-23T11:04:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh7002hj1s6dk5fgrrg","content":"<blockquote>\n<p>本节我们将学习线程、互斥锁、条件变量、线程安全、共享和独占引用、内部可变性等内容</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-atomics-and-locks\">rust-atomics-and-locks</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>早在多核处理器普及之前, 操作系统就允许一台计算机同时运行许多程序<br>\n这是通过在进程间快速切换来实现的, 允许每个进程一个接一个地重复取得一点进展<br>\n如今, 几乎所有的计算机, 甚至我们的手机和手表都有多核处理器, 可以真正并行执行多个进程</p>\n<p>操作系统尽可能将进程彼此隔离, 允许程序在完全不知道其他进程在做什么的情况下, 做自己的事情<br>\n例如, 一个进程在不询问操作系统的内核之前, 通常无法访问另一个进程的内存, 也无法以任何方式与之通信</p>\n<p>但是, 程序可以生成额外的名为线程之物, 作为同一进程下的一部分<br>\n同一进程中的线程彼此之间不隔离, 线程共享内存, 并且可以通过该内存相互交互</p>\n<p>本章将解释线程在 Rust 中是如何生成的, 以及围绕它们的所有基本概念, 例如如何在多个线程之间安全地共享数据<br>\n本章中解释的概念是本系列中其余部分的基础</p>\n<hr>\n<h1 id=\"rust-zhong-de-xian-cheng\">Rust 中的线程</h1>\n<p>每个程序都只能从主线程开始, 即 <code>main</code> 函数所在的线程<br>\n该线程将执行您的 <code>main</code> 函数，并可以生成更多子线程</p>\n<p><strong>当主线程结束之后, 由其派生的子线程也将直接提前结束</strong></p>\n<p>在 Rust 中, 新线程是通过 <code>std::thread::spawn</code> 函数生成的, 它需要一个参数, 代表将执行的函数<br>\n此函数返回/结束后, 该线程将停止</p>\n<p>来看个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    thread::spawn(f);</span><br><span class=\"line\">    thread::spawn(f);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello from the main thread.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello from another thread!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id = thread::current().id();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This is my thread id: &#123;id:?&#125;&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们生成(spawn)了两个线程, 它们都将执行 <code>f</code> 作为其主要函数<br>\n这两个线程都将打印一条消息, 并显示其 <code>线程ID</code>, 而主线程也将打印自己的消息</p>\n<p><strong>Thread ID:</strong><br>\nRust 标准库为每个线程分配一个唯一的标识符, 此标识符可通过 Thread::id() 访问, 类型为 ThreadId<br>\n除了复制它们并检查相等性之外, 您对 ThreadId 无能为力, 不能保证这些 ID 将连续分配, 只是每个线程的 ID 会有所不同</p>\n<p>如果您多次运行上面的示例程序, 您可能会注意到两次运行之间的输出不同, 这是我在一次特定运行期间在机器上获得的输出:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello from the main thread.</span><br><span class=\"line\">Hello from another thread!</span><br><span class=\"line\">This is my thread id:</span><br></pre></td></tr></table></figure>\n<p>令人惊讶的是, 部分输出似乎丢失了<br>\n这是因为, 在新生成的线程完成其传入的函数之前, 主线程就已经完成了 main 函数<br>\n从 main 返回将退出整个程序, 即使其他线程仍在运行</p>\n<p>在该示例中, 在程序被主线程关闭前, 其中一个新生成的线程只发生了一半的消息<br>\n如果我们想确保, 线程在从 main 返回之前完成, 我们可以通过 <code>join</code> 来等待它们<br>\n为此, 我们要使用 <code>spawn</code> 函数返回的 <code>JoinHandle</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t1 = thread::spawn(f);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t2 = thread::spawn(f);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello from the main thread.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.join().unwrap();</span><br><span class=\"line\">    t2.join().unwrap();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>.join()</code> 方法将等待线程完成执行, 并返回 <code>std::thread::Result</code><br>\n若线程由于死机而未成功完成其功能, 这将包含死机消息, 我们可以尝试处理这种情况, 或者在加入恐慌线程时只调用 <code>.unwrap()</code> 以恐慌</p>\n<p>运行此版本的代码将不再导致输出的截断:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello from the main thread.</span><br><span class=\"line\">Hello from another thread!</span><br><span class=\"line\">This is my thread id: ThreadId(3)</span><br><span class=\"line\">Hello from another thread!</span><br><span class=\"line\">This is my thread id: ThreadId(2)</span><br></pre></td></tr></table></figure>\n<p>运行之间仍然更改的是消息们的打印顺序, 因为是并发, 所以无法保证先后顺序</p>\n<p><strong>Output Locking:</strong><br>\n<code>println!</code> 使用 <code>std::io::Stdout::lock()</code>, 来确保其输出不会因线程间的并发而交替<br>\n<code>println!()</code> 将等到任何并发运行的表达式完成, 然后再写入任何输出<br>\n如果不是这种情况, 我们可能会得到更多交错的混乱的输出:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello fromHello from another thread!</span><br><span class=\"line\"> another This is my threthreadHello fromthread id: ThreadId!</span><br><span class=\"line\">( the main thread.</span><br><span class=\"line\">2)This is my thread</span><br><span class=\"line\">id: ThreadId(3)</span><br></pre></td></tr></table></figure>\n<p>与其将函数传递给 <code>std::thread::spawn</code>, 不如将闭包传递给它, 这允许我们捕获值, 并将其移动到新线程中:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> &amp;numbers &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;n&#125;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).join().unwrap();</span><br></pre></td></tr></table></figure>\n<p>此处, <code>numbers</code> 的所有权转移到了新生成的线程中, 因为我们使用了 <code>move</code> 闭包<br>\n若我们未使用 <code>move</code> 关键字, 闭包将通过引用捕获 <code>numbers</code>, 这将导致编译错误, 因为新线程的寿命可能超过该变量</p>\n<p>由于线程可能一直运行到程序执行结束, 因此 <code>spawn</code> 函数的参数类型具有 'static 约束<br>\n换句话说, 它只接受永远存在的函数, 而通过引用捕获局部变量的闭包, 闭包可能不会永远有效<br>\n因为, 当局部变量不复存在时，对该变量的引用自然变得无效, 闭包也因此变得无效</p>\n<p>从线程中获取的返回值, 实际上就是传入的闭包的返回值, 它可以从 <code>join</code> 方法返回的 <code>Result</code> 中获取:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = <span class=\"built_in\">Vec</span>::from_iter(<span class=\"number\">0</span>..=<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = numbers.len();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = numbers.iter().sum::&lt;<span class=\"built_in\">usize</span>&gt;();</span><br><span class=\"line\">    sum / len  <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> average = t.join().unwrap(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;average: &#123;average&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里, 闭包 (1) 返回的值通过 join 方法 (2) 的返回值获取<br>\n若 numbers 为空，则新线程会尝试除以零 (1), 这将导致 panic, 而 <code>join</code> 则会返回 Err, 导致主线程也因为 unwrap 而 panic</p>\n<p><strong>Thread Builder:</strong>*<br>\n<code>std::thread::spawn()</code> 实际上只是 <code>std::thread::Builder::new().spawn().unwrap()</code> 的一个简写<br>\n<code>std::thread::Builder</code> 允许您在生成新线程之前, 为其进行一些设置<br>\n您可以使用它来配置新线程的堆栈大小, 为新线程命名<br>\n通过 <code>std::thread::current().name()</code> 可以获取当前线程的名称, 这将在 panic 的消息中使用, 并将在大多数平台上的 debug 工具中可见</p>\n<p>此外, <code>Builder</code> 的 <code>spawn</code> 函数返回 <code>std::io::Result</code>, 允许您处理生成新线程失败的情况<br>\n比如操作系统内存不足，或者对您应用的资源限制(resource limit), 则可能会发生该情况<br>\n(若 <code>spawn</code> 函数无法生成新线程, 它只会产生 panic)</p>\n<hr>\n<h1 id=\"zuo-yong-yu-xian-cheng\">作用域线程</h1>\n<p>有一个问题就是, 默认的 <code>spawn</code> 会要求一个具有 'static 约束的闭包, 在编译器就确保了不会发生生命周期上的问题<br>\n但如果我们真的确定, 生成的线程肯定不会超过某个作用域, 那么该线程理论上就应该可以安全地借用局部变量, 只要它们比该作用域活得久</p>\n<p>Rust 标准库提供了 <code>std::thread::scope</code> 函数, 来生成这样的作用域线程<br>\n它允许我们生成 “不超过我们传递给该函数的闭包范围” 的线程, 从而安全地借用局部变量</p>\n<p>一个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::scope(|s| &#123; <span class=\"comment\">// 1</span></span><br><span class=\"line\">    s.spawn(|| &#123; <span class=\"comment\">// 2</span></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;length: &#123;&#125;&quot;</span>, numbers.len());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    s.spawn(|| &#123; <span class=\"comment\">// 2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> &amp;numbers &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;n&#125;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 (1) 处: 我们调用 <code>std::thread::scope</code> 函数, 我们的闭包将在传入后立刻执行, 参数 <code>s</code>，代表 <code>Scope</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (2) 处: 我们通过 <code>s</code> 参数, 生成了 作用域线程(Scoped Threads), 其传入的闭包可以借用局部变量, 如 <code>numbers</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (3) 处: 我们生成的所有 <code>Scoped-Thread</code>, 若还没有 <code>join</code>, 将自动 <code>join</code></p>\n</li>\n</ul>\n<p>它保证了作用域内生成的任何线程, 都不会超过作用域<br>\n正因如此, 这个 <code>spawn</code> 方法的参数类型上没有 'static 约束，允许我们引用任何内容，只要它比作用域长寿，例如 <code>numbers</code></p>\n<p>在上面的示例中, 两个新线程同时访问 <code>numbers</code>, 这很好, 因为所有都不会修改它<br>\n若我们要将第一个线程更改为修改 <code>numbers</code>, 编译器将不允许我们生成另一个也修改 <code>numbers</code> 的线程:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> numbers = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::scope(|s| &#123;</span><br><span class=\"line\">    s.spawn(|| &#123;</span><br><span class=\"line\">        numbers.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    s.spawn(|| &#123;</span><br><span class=\"line\">        numbers.push(<span class=\"number\">2</span>); <span class=\"comment\">// Error!</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>确切的错误消息取决于 Rust 编译器的版本, 因为它通常会得到改进, 以产生更好的报错，目前的报错信息如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0499]: cannot borrow `numbers` as mutable more than once at a time</span><br><span class=\"line\"> --&gt; example.rs:7:13</span><br><span class=\"line\">4 |     s.spawn(|| &#123;</span><br><span class=\"line\">  |             -- first mutable borrow occurs here</span><br><span class=\"line\">5 |         numbers.push(1);</span><br><span class=\"line\">  |         ------- first borrow occurs due to use of `numbers` in closure</span><br><span class=\"line\"></span><br><span class=\"line\">7 |     s.spawn(|| &#123;</span><br><span class=\"line\">  |             ^^ second mutable borrow occurs here</span><br><span class=\"line\">8 |         numbers.push(2);</span><br><span class=\"line\">  |         ------- second borrow occurs due to use of `numbers` in closure</span><br></pre></td></tr></table></figure>\n<p><strong>来自译者的题外话, 帮你更好地理解下作用域线程:</strong><br>\n如果你观察一下 <code>std::thread::scope</code>, 会发现其 lifetime 的关系如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">scope</span></span>&lt;<span class=\"symbol\">&#x27;env</span>, F, T&gt;(f: F) -&gt; T</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    F: <span class=\"keyword\">for</span>&lt;<span class=\"symbol\">&#x27;scope</span>&gt; <span class=\"built_in\">FnOnce</span>(&amp;<span class=\"symbol\">&#x27;scope</span> Scope&lt;<span class=\"symbol\">&#x27;scope</span>, <span class=\"symbol\">&#x27;env</span>&gt;) -&gt; T,</span><br></pre></td></tr></table></figure>\n<p>根据文档所述, 'scope 表示作用域本身的 lfetime, 'env 表示作用域内线程借用的任何变量的 lifetime</p>\n<p>'scope 的 lifetime 在 <code>scope</code> 函数开始之后开始，位于 <code>f (传入的闭包参数)</code> 之前, 其 lifetime 在 <code>f</code> 结束之后结束<br>\n该 lifetime 结束后, 所有生成的作用域线程都将被自动 <code>join</code></p>\n<p>关系如下:</p>\n<pre style=\"width: 534px; margin: 0px\">\n┌──fn_scope(f: F)────────────────────┐\n│                                    │\n│  'scope                            │\n│     |                              │\n│     |  'f  // is your closure      │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |  'f                          │\n│     |                              │\n│     | // join scoped threads here  │\n│     |                              │\n│  'scope                            │\n│                                    │\n└────────────────────────────────────┘\n</pre>\n<p>而 'env 的约束是 'env: 'scope, 表示了作用域线程借用的任何变量的 lifetime 一定得小于作用域本身的 lifetime</p>\n<p><strong>The Leakpocalypse:</strong><br>\n在 Rust 1.0 之前, 标准库有个名为 <code>std::thread::scoped</code> 的函数, 它会直接生成一个线程, 如同 <code>std::thread::spawn</code><br>\n它允许非 'static 的闭包, 因为它返回的不是 <code>JoinHandle</code>, 而是个在 drop 时会 join 线程的 <code>JoinGuard</code><br>\n任何借用的数据只需要比这 JoinGuard 存在更长的时间, 这似乎是安全的, 只要 JoinGuard 在某个时候被丢弃</p>\n<p>但就在 Rust 1.0 发布之前, 很多事情慢慢变得清楚, 你不能保证某些东西一定会被丢弃, 这有很多办法<br>\n例如创建引用计数节点的循环, 或者 leak 它, 这都不会 drop 它</p>\n<p>最终, 在一些人所说的 “泄漏启示录(Leakpocalypse)” 中, 得出的结论是:<br>\n安全接口的设计, 不能依赖于对象在其生命周期结束时总是会被丢弃的假设<br>\n泄漏对象可能会合理地导致泄漏更多对象(例如，泄漏 Vec 也会泄漏其元素), 但可能不会导致未定义的行为</p>\n<p>由于这个结论, <code>std::thread::scoped</code> 不再被认为是安全的, 并从标准库中删除<br>\n此外, <code>std::mem::forget</code> 从 unsafe 变成了 safec, 以强调 forget/leak 始终是可能的</p>\n<p><strong>老生常谈的话: Rust 并不会阻止 内存泄漏, 内存泄漏 不归到 内存安全 的范畴里</strong></p>\n<p>直到很久以后, 在 Rust 1.63 中, 添加了一个新的 <code>std::thread::scope</code> 函数, 其中包含一个不依赖 Drop 来表示正确性的新设计</p>\n<hr>\n<h1 id=\"gong-xiang-suo-you-quan\">共享所有权</h1>\n<p>到目前为止, 我们已经研究了使用 move 闭包, 将值的所有权转移到线程, 并从寿命更长的父线程借用数据<br>\n当在两个线程之间共享数据时, 当两个线程都不能保证比另一个线程活得久, 则它们都不能成为该数据的所有者<br>\n它们之间共享的任何数据的 lifetime, 都需要与活的最长的线程一样长或更长</p>\n<h2 id=\"static\" id=\"Static\">Static</h2>\n<p>有几种方法可以创建不属于单个线程的内容, 其中最简单的是使用 static 关键字<br>\n它由整个程序 “拥有”, 而不是单个线程</p>\n<p>在以下示例中, 两个线程都可以访问 X , 但它们都不拥有它:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> X: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(|| dbg!(&amp;X));</span><br><span class=\"line\">thread::spawn(|| dbg!(&amp;X));</span><br></pre></td></tr></table></figure>\n<p>一个 static 项, 其以 const 字面量作为初始值, 永远不会 drop<br>\n且在 main 函数启动之前, 它就已经存在, 每个线程都能借用它, 毕竟它保证永远存在</p>\n<h2 id=\"leak\" id=\"Leak\">Leak</h2>\n<p>共享所有权的另一种方法是leak, 使用 <code>Box::leak</code><br>\n它可以释放 Box 的所有权, 承诺永远不会 drop 它, 从那时起, Box 将永远存在, 没有所有者, 只要程序运行, 它就可以被任何线程借用</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x: &amp;<span class=\"symbol\">&#x27;static</span> [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>] = <span class=\"built_in\">Box</span>::leak(<span class=\"built_in\">Box</span>::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">    thread::spawn(<span class=\"keyword\">move</span> || dbg!(x));</span><br><span class=\"line\">    thread::spawn(<span class=\"keyword\">move</span> || dbg!(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可能看上去, 在 move 闭包, 我们将所有权转移到了线程中<br>\n但仔细观察 x 的类型, 你会发现, 我们只是为线程提供了对数据的引用, 而不是数据本身的所有权</p>\n<p><strong>注意:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>独享引用(&amp;T) 实现了 Copy 这个 trait, 这意味着当您 move 它时, 原始值仍然存在, 就像整数或布尔值一样</p>\n</li>\n<li class=\"lvl-2\">\n<p>'static 生命周期并不意味着 “该值自程序开始以来一直存在”, 而只是 “它一直存在到程序结束”, 过去的经历并不在乎</p>\n</li>\n</ul>\n<p>泄漏 Box 的缺点是, 我们正在泄漏内存, 我们分配一些东西, 但从不丢弃和解除分配它<br>\n如果这只发生有限的少量次数, 可能会达成很棒的效果, 但如果我们继续, 程序将慢慢耗尽内存</p>\n<h2 id=\"yin-yong-ji-shu\" id=\"引用计数\">引用计数</h2>\n<p>为了确保共享的数据被 drop , 使得其内存被释放, 我们不能完全放弃其所有权<br>\n相反, 我们可以分享所有权, 通过跟踪所有者的数量, 我们可以确保仅在没有所有者时才丢弃该值</p>\n<p>Rust 标准库通过 <code>std::rc::Rc</code> 类型提供此功能, 这是 “引用计数(References Counting)” 的缩写<br>\n它与 <code>Box</code> 非常相似, 除了 clone 它时并不会真的 clone 其包含的值, 而只是增加计数器的值<br>\n原来的 Rc 与克隆的 Rc,  都将引用相同的分配, 因此, 它们可以共享所有权</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = Rc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.clone();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>(a.as_ptr(), b.as_ptr()); <span class=\"comment\">// Same allocation!</span></span><br></pre></td></tr></table></figure>\n<p>drop 一个 Rc 将减少计数器, 当最后一个 Rc 被 drop 时(计数器将降至零), 将 drop 其包含的值并释放内存</p>\n<p>但是, 当我们尝试将 Rc 发送到另一个线程, 我们将遇到以下编译器错误:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0277]: `Rc` cannot be sent between threads safely</span><br><span class=\"line\">    |</span><br><span class=\"line\"><span class=\"number\">8</span>   |     thread::spawn(<span class=\"keyword\">move</span> || dbg!(b));</span><br><span class=\"line\">    |                   ^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>\n<p>事实证明, Rc 不是线程安全的, 因为它没有实现 <code>Send</code> 这个 tait<br>\n未实现 <code>Send</code> 的类型, 表示其实现可能并没有考虑多线程, 导致不能将其 move 进其他线程<br>\n因此如果将 Rc 分配给多个线程, 则它们可能会尝试同时修改引用计数器, 这可能会产生不可预知的结果</p>\n<p>但编译器阻止了我们</p>\n<p>相反, 我们可以使用 <code>std::sync::Arc</code>, 它代表“原子引用计数(Atomic References Counting)”<br>\n它与 Rc 相同, 只是它保证对引用计数器的修改是不可分割的原子操作, 因此可以安全地将其用于多个线程</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::Arc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.clone(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || dbg!(a)); <span class=\"comment\">// 3</span></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || dbg!(b)); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>在上述代码中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 (1) 处: 我们将数组放进了一个 <code>Arc</code> 中进行包装, 其引用计数器从 1 开始</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (2) 处: 克隆了 <code>Arc</code>, 使得引用计数增加到 2, 并为我们提供另一个 <code>Arc</code>, 指向相同的资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (3) 处: 两个线程都获得自己的 <code>Arc</code>, 可以访问共享数组, 两者都在 <code>drop</code> 使得计数器减 1</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (3) 处: 最后一个 <code>drop</code> 了 <code>Arc</code> 的线程, 使得计数器减小到 0, 此时将会 drop 被包装的数组, 释放资源</p>\n</li>\n</ul>\n<p><strong>Naming Clones:</strong><br>\n必须给 <code>Arc</code> 的每个克隆一个不同的名称, 会很快使代码变得非常混乱且难以理解<br>\n虽然 <code>Arc</code> 的每个克隆都是单独的对象, 但每个克隆都表示相同的共享值, 我们可以通过 <code>Shadow</code> 语法来处理</p>\n<p>Rust 允许(并鼓励)你通过定义一个同名的新变量来隐藏变量, 如果在同一作用域内执行此操作, 则无法再使用原始变量<br>\n但是通过打开一个新作用域, 可以使用像 <code>let a = a.clone();</code> 这样的语句, 在该作用域内重用名称, 同时将原始变量保留在作用域之外</p>\n<p>通过将闭包包装在新作用域(使用 <code>&#123;&#125;</code>)中, 我们可以在将变量移动到闭包之前克隆变量, 而无需重命名它们:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">    dbg!(b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dbg!(a);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = a.clone();</span><br><span class=\"line\">    <span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">        dbg!(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dbg!(a);</span><br></pre></td></tr></table></figure>\n<p>由于所有权是共享的, 因此引用计数指针 (<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>) 与共享引用 (<code>&amp;T</code>) 具有相同限制<br>\n它们不允许您对其包含的值进行可变访问, 因为该值可能同时被其他代码借用<br>\n例如, 当我们尝试对 <code>Arc&lt;[i32]&gt;</code> 中的整数切片进行排序, 编译器会阻止我们, 告诉我们不允许改变数据:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0596]: cannot borrow data in an `Arc` as mutable</span><br><span class=\"line\">  |</span><br><span class=\"line\">6 |     a.sort();</span><br><span class=\"line\">  |     ^^^^^^^^</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"jie-yong-yu-shu-ju-jing-zheng\">借用与数据竞争</h1>\n<p>在 Rust 中, 可以通过两种方式借用值:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不可变借用(Immutable borrowing):<br>\n通过 <code>&amp;</code> 借用, 这得到了一个不可变引用(immutable reference), 可以复制这样的引用<br>\n对被引用数据的访问, 在此类引用的所有副本之间共享, 编译器通常不允许通过这样的引用修改内容, 因为会影响借用了相同数据的其他代码</p>\n</li>\n<li class=\"lvl-2\">\n<p>可变借用(Mutable borrowing):<br>\n通过 <code>&amp;mut</code> 借用, 这得到了一个可变引用(mutable reference), 可变借用保证它是该数据唯一的有效借用(active borrow)<br>\n因此, 这可以确保, 改变数据的内容不会影响到其他代码</p>\n</li>\n</ul>\n<p>这两个概念在一起, 完全防止了数据竞争(data races), 即一个线程正在改变数据, 而另一个线程同时访问数据的情况<br>\n数据竞争通常是未定义的行为(undefined behavior), 这意味着编译器不需考虑这些情况, 因为它只会假设这些情况不会发生</p>\n<p>为阐明这到底意味着什么, 让我们看一个编译器可以使用借用规则做出有用假设的示例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(a: &amp;<span class=\"built_in\">i32</span>, b: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> before = *a;</span><br><span class=\"line\">    *b += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> after = *a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> before != after &#123;</span><br><span class=\"line\">        x(); <span class=\"comment\">// never happens</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 我们得到一个对整数的不可变引用, 并在递增 b 所引用的整数前后, 存储了整数的值<br>\n编译器可以自由地假设有关 “借用和数据竞争的基本规则” 得到维护, 这意味着 b 不可能像 a 一样引用相同的整数<br>\n事实上, 只要 a 还存在, 整个程序中没有任何东西可以可变地借用 a 所指的整数<br>\n因此, 编译器可以很容易地得出结论, *a 不会改变, <code>before</code> 永远等于 <code>after</code><br>\n因此 if 语句永远无法成立, 可以从程序中完全删除对 x 的调用, 进行优化</p>\n<p>编写一个打破编译器假设的 Rust 程序是不可能的, 除非使用 unsafe 块来禁用编译器的某些安全检查</p>\n<p><strong>Undefined Behavior(未定义的行为):</strong><br>\n像 C, C++, Rust 这样的语言有一套规则, 需要遵循这些规则, 以避免所谓的未定义行为(ub)<br>\n例如, Rust 的规则之一是: 对任何对象都不能有多个可变引用</p>\n<p>在 Rust 中, 只有在使用 unsafe 代码时才能违反这些规则中的任何一个<br>\nunsafe 在 Rust 中并不意味着代码不正确或不安全, 而是编译器没为您验证代码是否安全<br>\n如果代码确实违反了这些规则，则称为 unsound(不健全), 因此, 你可以将 unsafe, 等价于 trust_me</p>\n<p>编译器会假设这些规则永远不会被破坏, 当被破坏时, 会导致一种被称为未定义行为的情况发生, 我们需要不惜一切代价避免这种情况<br>\n因为, 若我们允许编译器做出一个实际上不正确的假设, 它很容易导致代码不同部分的更多错误结论, 从而影响整个程序</p>\n<p>作为一个例子, 让我们看一下在切片上使用 <code>get_unchecked</code> 方法的代码实例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"number\">789</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">unsafe</span> &#123; a.get_unchecked(index) &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>get_unchecked</code> 方法, 让我们得到了指定索引位置的切片元素, 如同 <code>a[index]</code> 一样<br>\n但它允许编译器假设索引始终在边界内, 而无需进行任何边界检查</p>\n<p>这意味着, 在此代码段中, 由于 a 的长度为 3, 因此编译器可能会假定 index 小于 3, 我们有责任确保其假设成立<br>\n如果我们打破这个假设, 例如, 如果我们在 index 等于 3 的情况下运行这个假设, 任何事情都可能发生<br>\n这可能会导致, 从内存中读取到了存储在 a 之后的字节中的任何内容, 程序可能会因此崩溃<br>\n比如, 它最终可能会执行你程序中一些完全不相关的部分, 造成各种破坏</p>\n<p>令人惊讶的是, 未定义行为甚至可以 “影响过去”, 导致它之前的代码出现问题<br>\n为了理解这是如何发生的, 假设在先前代码的前面有个 match 语句, 如下所示:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">match</span> index &#123;</span><br><span class=\"line\">   <span class=\"number\">0</span> =&gt; x(),</span><br><span class=\"line\">   <span class=\"number\">1</span> =&gt; y(),</span><br><span class=\"line\">   _ =&gt; z(index),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"number\">789</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">unsafe</span> &#123; a.get_unchecked(index) &#125;;</span><br></pre></td></tr></table></figure>\n<p>由于 unsafe 块, 编译器可以假定 index 只为 0、1 或 2<br>\n从逻辑上讲, 我们可以得出结论, 我们的 match 语句的最后一个分支只会与 2 匹配<br>\n因此 z(index) 只可能是 z(2), 该结论不仅可以用于优化 match, 还可优化 z 本身, 这可能包括删除代码中未使用的部分</p>\n<p>如果我们让 index 为 3 时执行此操作, 我们的程序可能会尝试执行已优化的部分<br>\n这从而导致了完全不可预测的行为, 早于在我们到达最后一行的 unsafe 块之前<br>\n就像这样, 未定义行为可能以一种非常意想不到的方式, 向后和向前传播与污染整个程序</p>\n<p>调用任何 unsafe 函数前, 请仔细阅读文档, 并确保完全了解其安全要求<br>\n作为调用者, 您需要秉承 “避免未定义行为” 的准则</p>\n<hr>\n<h1 id=\"nei-bu-ke-bian-xing\">内部可变性</h1>\n<p>上一节中介绍的借用规则很简单, 但可能非常有限, 尤其是在涉及多个线程时<br>\n遵循这些规则, 将使得线程间的通信被严重限制, 甚至会变得几乎不可能, 因为多线程间可访问的数据不能突变<br>\n幸运的是, 有个逃生舱口: 内部可变性(interior mutability)<br>\n具有内部可变性的数据类型, 会稍微改变其借用规则, 在某些情况下, 这些类型可通过 “不可变引用” 而允许突变</p>\n<p>在先前讲述引用计数时, 我们已看到了个涉及内部可变性的微妙例子:<br>\n<code>Rc</code> 和 <code>Arc</code> 被 clone 与 drop 时, 会改变引用计数器的数值, 即使多个克隆都使用着相同的引用计数器</p>\n<p>一旦涉及内部可变类型, 将引用称为 “不可变” 或 “可变” 会令人困惑和不准确, 因为两者都能够突变数据<br>\n更准确的术语是 “共享” 和 “独占”:<br>\n共享引用(&amp;T)可以复制并与他人共享, 而独占引用(&amp;mut T)保证了它是该 T 的唯一独占借用<br>\n对于大多数类型, 共享引用不允许突变, 但也有例外<br>\n由于在本系列中, 我们将主要处理这些例外, 因此我们将在本系列的其余部分使用更准确的术语</p>\n<p><strong>注意:</strong><br>\n请记住, 内部可变性只会改变共享借用的规则, 以允许共享时的突变, 而不会改变任何关于独占借用的行为<br>\n独占借用仍然保证没有其他独享的有效借用(active borrow)<br>\nunsafe 中对某物的多个有效的独占引用, 将始终导致未定义行为, 不会考虑内部可变性</p>\n<h2 id=\"cell\" id=\"Cell\">Cell</h2>\n<p><code>std::cell::Cell&lt;T&gt;</code> 只是个包裹了 T 类型数据的类型, 但允许通过共享引用进行突变<br>\n为避免未定义行为, 它只允许您复制值(T 必须实现 Copy), 或用另一个值替换已被包裹的值<br>\n此外, 它只能在单个线程中使用</p>\n<p>让我们看个类似上一节中的示例, 但这次使用 Cell<i32> 而不是 i32:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(a: &amp;Cell&lt;<span class=\"built_in\">i32</span>&gt;, b: &amp;Cell&lt;<span class=\"built_in\">i32</span>&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> before = a.get();</span><br><span class=\"line\">    b.set(b.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> after = a.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> before != after &#123;</span><br><span class=\"line\">        x(); <span class=\"comment\">// might happen</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与上次不同, 现在 if 条件可能为真, 因为 <code>Cell&lt;i32&gt;</code> 具有内部可变性, 所以只要我们有对它的共享引用, 编译器就不能再假设它的值不会改变<br>\na 和 b 可能都引用相同的值，因此通过 b 对数据突变, 也可能影响到 a<br>\n但是, 它仍假定没有其他线程同时访问 <code>Cell</code> 类型的 a 与 b</p>\n<p>对 Cell 的限制并不总是那么容易处理, 因为它不能直接让我们借用它所持有的值<br>\n我们要将其值移出, 修改它后再放回去, 以改变它的内容:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(v: &amp;Cell&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> v2 = v.take(); <span class=\"comment\">// Replaces the contents of the Cell with an empty Vec</span></span><br><span class=\"line\">    v2.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    v.set(v2); <span class=\"comment\">// Put the modified Vec back</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ref-cell\" id=\"RefCell\">RefCell</h2>\n<p>与常规 <code>Cell</code> 不同, <code>std::cell::RefCell</code> 允许您以较小的运行时成本借用其值<br>\n<code>RefCell&lt;T&gt;</code> 不仅持有 <code>T</code>, 还持有引用计数器, 用于在运行时, 跟踪对被包裹数据的借用的情况<br>\n当你试图以不可变地借用它, 而它已经被可变借用了(反之亦然), 它会 panic, 从而避免未定义的行为<br>\n像 <code>Cell</code> 一样, <code>RefCell</code> 只能在单个线程中使用</p>\n<p>借用 <code>RefCell</code> 包裹的值, 是通过调用 <code>borrow</code> 或 <code>borrow_mut</code> 来完成的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(v: &amp;RefCell&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;) &#123;</span><br><span class=\"line\">    v.borrow_mut().push(<span class=\"number\">1</span>); <span class=\"comment\">// We can modify the `Vec` directly.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>译者注:</strong><br>\n<code>Cell/RefCell</code>, 简单来说, 属于在编译时欺骗了编译器, 将借用规则从编译器挪动到运行期, 以便于放宽要求<br>\n但借用规则还是满足的, 只是晚了一个阶段而已, 如果违背了借用规则, 依旧会报错</p>\n<p>虽然 <code>Cell</code> 和 <code>RefCell</code> 非常有用, 但当我们处于多线程并发的环境时, 它们变得没啥用<br>\n因此, 让我们转到与并发相关的类型</p>\n<h2 id=\"mutex-rw-lock\" id=\"Mutex-RwLock\">Mutex/RwLock</h2>\n<p><code>RwLock (reader-writer lock)</code>, 是 <code>RefCell</code> 的并发版本<br>\n一个 <code>RwLock&lt;T&gt;</code>, 持有 T 并跟踪借用的情况<br>\n但与 <code>RefCell</code> 不同的是, 它不会在借用冲突时 panic, 而是阻塞当前线程(使其进入睡眠状态), 同时等待冲突的借用消失<br>\n我们只需耐心地等待其他线程完成, 然后处理数据即可</p>\n<p>借用被 <code>RwLock</code> 包裹的值, 称为锁定(lcok), 通过锁定它, 我们可以暂时阻止并发的冲突借用, 以允许我们借用它而不会引起数据竞争<br>\n<code>Mutex</code> 非常相似, 但在概念上稍微简单些, 它不像 <code>RwLock</code> 那样跟踪共享借用和独占借用的数量, 而只允许独占借用</p>\n<p>我们将在本节之后, 更加详细地介绍这些类型</p>\n<h2 id=\"atomic\" id=\"Atomic\">Atomic</h2>\n<p><code>Atomic(原子)</code>, 该类型是 <code>Cell</code> 的并发版本, 是之后第 2 章和第 3 章的主题<br>\n像 <code>Cell</code> 一样, 它们通过将值作为一个整体, 复制进来和传出来, 以避免未定义行为, 而不让我们直接借用内容</p>\n<p>但与 <code>Cell</code> 不同, 它们不能是任意大小<br>\n因此没有通用的 <code>Atomic&lt;T&gt;</code> 类型, 而只有特定的原子类型, 例如 <code>AtomicU32</code> 和 <code>AtomicPtr&lt;T&gt;</code><br>\n哪些可用取决于平台, 因为它们需要处理器的支持以避免数据竞争(我们将在之后的第 7 章中深入探讨)</p>\n<p>由于它们的大小非常有限, 因此原子通常不直接包含需要在线程之间共享的信息<br>\n相反, 它们通常被用作一种工具, 以便在线程之间共享其他(通常是更大的)数据, 此时事情可能会变得非常复杂</p>\n<h2 id=\"unsafe-cell\" id=\"UnsafeCell\">UnsafeCell</h2>\n<p><code>UnsafeCell</code> 是内部可变性的原始的构建块<br>\n<code>UnsafeCell&lt;T&gt;</code> 包装 <code>T</code>, 但不附带任何条件或限制以避免未定义行为<br>\n相反, 它的 <code>get()</code> 方法只是给出一个包装值的原始指针, 该值只能在 <code>unsafe</code> 块中使用<br>\n它让用户以不会导致任何未定义行为的方式使用它</p>\n<p>最常见的是, <code>UnsafeCell</code> 不直接使用, 而是包装在另一类型中, 该类型通过有限的接口(例如 <code>Cell</code> 或 <code>Mutex</code>)提供安全性<br>\n所有具有内部可变性的类型(包括上面讨论的所有类型)都建立在 <code>UnsafeCell</code> 之上</p>\n<hr>\n<h1 id=\"xian-cheng-an-quan\">线程安全</h1>\n<p>在本章中, 我们看到了几种非线程安全的类型, 这些类型只能在单个线程上使用, 例如 <code>Rc</code>. <code>Cell</code><br>\n由于需要限制以避免未定义行为, 因此编译器需要去理解并检查, 以便于知晓使用这些类型时无需使用 unsafe 块</p>\n<p>Rust 语言使用两个特殊的 Trait 来跟踪哪些类型可以跨线程安全使用:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Send:<br>\n如果一个类型可以被发送到另一个线程, 则该类型为 Send, 即该类型的值的所有权, 可以转移到另一个线程<br>\n例如, <code>Arc&lt;i32&gt;</code> 实现了 Send, 但 <code>Rc&lt;i32&gt;</code> 没有</p>\n</li>\n<li class=\"lvl-2\">\n<p>Sync:<br>\n如果一个类型可以与其他线程共享, 则类型为 Sync, 即当且仅当 &amp;T 是 Send 时, T 实现了 Sync<br>\n例如, <code>i32</code> 是 Sync, 因为 &amp;i32 是 Send, 但 <code>Cell&lt;i32&gt;</code> 不是 (不过 <code>Cell&lt;i32&gt;</code> 是 Send)</p>\n</li>\n</ul>\n<p>所有基础类型, 如 i32, bool, str, 都是 Send 和 Sync</p>\n<p>这两个 Trait 都是 auto 的, 这意味着它们会根据类型的字段而自动实现<br>\n比如, 当字段均为 Send 和 Sync 时, 该 struct 本身也是 Send 和 Sync</p>\n<p>选择主动避免实现其中任何一个 Trait 的方法, 是向类型添加一个未实现相关 Trait 的字段<br>\n为此, 特殊的 <code>std::marker::PhantomData&lt;T&gt;</code> 类型通常会派上用场, 编译器将该类型视为 T. 但它在运行时实际上并不存在<br>\n这是一个零大小的类型, 不占用空间</p>\n<p>我们来看看下面的 struct:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span> &#123;</span><br><span class=\"line\">    handle: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    _not_sync: PhantomData&lt;Cell&lt;()&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在此示例中, 若 handle 是其唯一字段, 则 X 将是 Send 和 Sync<br>\n但是, 我们添加了一个大小为零的 <code>PhantomData&lt;Cell&lt;()&gt;&gt;</code> 字段, 该字段被视为 <code>Cell&lt;()&gt;</code><br>\n因为 <code>Cell&lt;()&gt;</code> 不是 Sync, 所以 X 也不是, 但它仍然是 Send, 因为它的所有字段都实现了 Send</p>\n<p>原始指针 (*const T 和 *mut T) 既不是 Send 也不是 Sync, 因为编译器对它们表示的数据知之甚少</p>\n<p>选择手动实现其中任何一个 Trait , 都需要用 unsafe 进行标明:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span> &#123;</span><br><span class=\"line\">    p: *<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsafe</span> <span class=\"keyword\">impl</span> <span class=\"built_in\">Send</span> <span class=\"keyword\">for</span> X &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">unsafe</span> <span class=\"keyword\">impl</span> <span class=\"built_in\">Sync</span> <span class=\"keyword\">for</span> X &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>实现这些特征之所以需要 unsafe 关键字, 是因为编译器无法为您检查它是否正确, 这是你对编译器的承诺, 它只需信任你</p>\n<p>如果您尝试将某些内容移动到另一个非 Send 的线程中, 编译器会礼貌地阻止您这样做, 下面是个小示例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = Rc::new(<span class=\"number\">123</span>);</span><br><span class=\"line\">    thread::spawn(<span class=\"keyword\">move</span> || &#123; <span class=\"comment\">// Error!</span></span><br><span class=\"line\">        dbg!(a);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 我们尝试将 <code>Rc&lt;i32&gt;</code> 发送到新线程, 但 <code>Rc&lt;i32&gt;</code> 与 <code>Arc&lt;i32&gt;</code> 不同, 它没实现 Send<br>\n如果我们尝试编译上面的示例，我们将面临如下所示的错误:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0277]: `Rc&lt;i32&gt;` cannot be sent between threads safely</span><br><span class=\"line\">   --&gt; src/main.rs:3:5</span><br><span class=\"line\">    |</span><br><span class=\"line\">3   |     thread::spawn(move || &#123;</span><br><span class=\"line\">    |     ^^^^^^^^^^^^^ `Rc&lt;i32&gt;` cannot be sent between threads safely</span><br><span class=\"line\">    |</span><br><span class=\"line\">    = help: within `[closure]`, the trait `Send` is not implemented for `Rc&lt;i32&gt;`</span><br><span class=\"line\">note: required because it&#x27;s used within this closure</span><br><span class=\"line\">   --&gt; src/main.rs:3:19</span><br><span class=\"line\">    |</span><br><span class=\"line\">3   |     thread::spawn(move || &#123;</span><br><span class=\"line\">    |                   ^^^^^^^</span><br><span class=\"line\">note: required by a bound in `spawn`</span><br></pre></td></tr></table></figure>\n<p><code>thread::spawn</code> 函数要求其参数为 Send, 如果闭包的所有捕获都为 Send, 则闭包也为 Send<br>\n如果我们试图捕捉不是 Send 的东西, 那么我们的错误就会被抓住, 编译器会保护我们免受未定义行为的影响</p>\n<hr>\n<h1 id=\"hu-chi-suo\">互斥锁</h1>\n<p>在线程间共享不可变或可变的数据, 最常用的工具是 Mutex, 它是 互斥(mutual exclusion) 的缩写<br>\n互斥锁的工作是, 通过暂时阻塞尝试同时访问某些数据的其他线程, 来确保线程对某些数据具有独占访问权限</p>\n<p>从概念上讲, 互斥锁只有两种状态: 锁定和解锁(lock and unlock)</p>\n<p>当线程锁定了未锁定的互斥锁时, 互斥锁将标记为锁定, 线程可以立即继续<br>\n当线程尝试锁定已锁定的互斥锁时, 该操作将阻塞, 线程在等待互斥锁解锁时进入睡眠状态</p>\n<p>解锁只能在锁定的互斥锁上进行, 并且应该由锁定它的同一线程完成<br>\n如果其他线程正在等待锁定互斥锁, 则解锁互斥锁将导致其中一个线程被唤醒, 被唤醒的线程可以尝试再次锁定互斥锁<br>\n该过程可以一直重复</p>\n<p>使用互斥锁保护数据, 只是所有线程间的协议, 即它们仅在锁定互斥锁时访问数据<br>\n这样, 没有两个线程可以同时访问该数据, 避免了数据竞争</p>\n<h2 id=\"rusts-mutex\" id=\"Rust’s-Mutex\">Rust’s Mutex</h2>\n<p>Rust 标准库通过 <code>std::sync::Mutex&lt;T&gt;</code> 提供此功能<br>\n类型 T 是互斥锁保护的数据类型, 通过将 T 类型的数据作为互斥锁的一部分, 数据将只能通过互斥锁访问<br>\n这允许了一个安全的接口, 可以保证所有线程都将遵守协议</p>\n<p>为了确保锁定的互斥锁只能由锁定它的线程解锁, 它没有 <code>unlock()</code> 方法<br>\n相反, 它的 <code>lock()</code> 方法返回一个名为 <code>MutexGuard</code> 的特殊类型, 表示我们已锁定互斥锁的保证<br>\n它的行为类似于一个通过 <code>DerefMut</code> 获取的独占引用, 使我们能独占地访问互斥锁保护的数据<br>\n解锁互斥锁是通过 drop 这个 <code>MutexGuard</code> 类型的变量来完成的, 当我们放下 guard 时, 我们放弃了访问数据的能力, guard 的 Drop 实现将解锁互斥锁</p>\n<p>让我们看一个例子, 看看互斥锁在实践中的运用:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::Mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = Mutex::new(<span class=\"number\">0</span>);</span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            s.spawn(|| &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> guard = n.lock().unwrap();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">                    *guard += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(n.into_inner().unwrap(), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 我们有一个 <code>Mutex&lt;i32&gt;</code>, 一个保护整数的互斥锁, 我们生成十个线程, 每个线程将整数递增一百次<br>\n每个线程将首先锁定互斥锁, 以获取 <code>MutexGuard</code>, 然后使用该 guard 访问整数并对其进行修改<br>\n当 guard 超出作用域后, 其将立即被隐式地 drop</p>\n<p>线程完成后, 我们可以安全地从通过 <code>into_inner()</code> 方法以删除互斥保护<br>\n<code>into_inner</code> 方法获取了互斥锁的所有权, 这保证了没有其他任何东西可以再引用互斥锁, 因此不需要锁定</p>\n<p>即使增量以 1 为步长发生, 但观察整数的线程也只能看到 100 的倍数, 因为它只能在互斥锁解锁时查看整数<br>\n实际上, 由于互斥锁, 一百个增量现在是一个不可分割的操作, 这样不可分割的操作也称为原子操作</p>\n<p>为了清楚地看到互斥锁的效果, 我们可以让每个线程在解锁互斥锁之前等待一秒钟:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::time::Duration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = Mutex::new(<span class=\"number\">0</span>);</span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            s.spawn(|| &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> guard = n.lock().unwrap();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">                    *guard += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                thread::sleep(Duration::from_secs(<span class=\"number\">1</span>)); <span class=\"comment\">// New!</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(n.into_inner().unwrap(), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当您现在运行该程序时, 您将看到大约需要 10 秒才能完成, 每个线程只等待一秒钟, 但互斥锁会确保一次只有一个线程可以这样做</p>\n<p>如果我们在 sleep 前, 就 drop 掉 guard, 从而解锁互斥锁, 我们将看到它并行发生:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = Mutex::new(<span class=\"number\">0</span>);</span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            s.spawn(|| &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> guard = n.lock().unwrap();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">                    *guard += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">drop</span>(guard); <span class=\"comment\">// New: drop the guard before sleeping!</span></span><br><span class=\"line\">                thread::sleep(Duration::from_secs(<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(n.into_inner().unwrap(), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过此更改, 该程序只需大约一秒钟, 因为现在 10 个线程可以同时执行一秒钟的睡眠, 这表明尽可能缩短互斥锁锁定时间的重要性<br>\n当互斥锁锁定的时间超过必要的时间, 可能会完全抵消并行性的任何好处, 从而有效地强制所有内容按顺序发生</p>\n<h2 id=\"suo-zhong-du\" id=\"锁中毒\">锁中毒</h2>\n<p>上面示例中的 <code>unwrap()</code> 调用与锁中毒(Lock Poisoning)有关</p>\n<p>当线程在 lock 锁时发生 panic, <code>Mutex</code> 会被标记为中毒(Poisoned)<br>\n发生这种情况时, <code>Mutex</code> 将不再被锁定, 但调用其 <code>lock</code> 方法将导致得到一个 <code>Err</code>, 表示它已经中毒</p>\n<p>这是一种 “防止受互斥锁保护的数据处于不一致状态” 的机制<br>\n在上面的示例中, 若线程在将整数递增不到 100 次后出现 panic, 则互斥锁将解锁<br>\n此时整数将处于意外状态, 不再是 100 的倍数, 这可能会破坏其他线程的假设<br>\n在这种情况下, 自动将互斥锁标记为中毒, 会强制用户处理这种可能性</p>\n<p>在中毒的互斥锁上调用 <code>lock()</code> 仍会锁定互斥锁<br>\n<code>lock()</code> 返回的 <code>Err</code> 包含 <code>MutexGuard</code>, 允许我们在必要时更正不一致的状态</p>\n<p>虽然锁中毒似乎是种强大的机制, 但在实践中并不经常从潜在的不一致状态中恢复<br>\n大多数代码要么忽略锁中毒, 要么在锁中毒时使用 <code>unwrap()</code> 进行 panic, 从而有效地将 panic 传播给互斥锁的所有用户</p>\n<p><strong>Lifetime of the MutexGuard:</strong><br>\n虽然隐式地 drop 掉 guard 变量, 可以方便地解锁互斥锁, 但有时会导致微妙的意外<br>\n如果我们用 let 语句给 guard 分配一个名称(如上面的例子), 将会很直接地知晓它何时 drop, 因为局部变量在其作用域的末尾会自动被 drop<br>\n尽管如此, 不显式 drop 掉 guard, 可能会导致将互斥锁锁定的时间不必要的延长, 如上面的示例所示</p>\n<p>使用无名称的 guard 也是可能的, 有时甚至非常方便<br>\n由于 MutexGuard 的行为, 类似于对受保护数据的独占引用, 因此我们可以直接使用它, 而无需先为 guard 分配名称<br>\n例如, 如果您有 Mutex&lt;Vec<i32>&gt;, 则可在单个语句中, 锁定互斥锁, 进行 push, 最后再次解锁互斥锁(drop):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">list.lock().unwrap().push(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>这是因为, 在表达式中生成的任何临时变量(例如通过 lock() 返回的守卫)都将在语句末尾删除<br>\n虽然这看起来是显而易见且合理的, 但它会导致一个常见的陷阱, 通常涉及 <code>match</code>, <code>if let</code>, <code>while let</code> 语句<br>\n下面是遇到此陷阱的示例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(item) = list.lock().unwrap().pop() &#123;</span><br><span class=\"line\">    process_item(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的意图, 是锁定 list, 随后 pop 一个元素并解锁 list, 最后处理该元素, 但我们在这犯了个微妙但重要的错误<br>\n临时生成 guard, 将会直到整个 if let 语句结束才会 drop, 这意味着我们在处理项目时, 保持了不必要的锁定</p>\n<p>令人惊讶的是, 对于类似的 if 语句, 这种情况不会发生:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> list.lock().unwrap().pop() == <span class=\"literal\">Some</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    do_something();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 不像先前的 <code>if let</code> 语句, 临时的 guard 确实在执行 if 语句的主体前就被 drop 了<br>\n原因是: 常规 if 语句的条件始终是普通 bool 值, 不会借用任何东西<br>\n因此, 没有理由将临时变量的 lifetime 从条件延长到语句结束</p>\n<p>但是, 对于 <code>if let</code> 语句, 情况可能并非如此<br>\n例如, 如果我们使用 <code>front()</code> 而不是 <code>pop()</code>, 则 item 将从列表中借用, 因此有必要保持警惕</p>\n<p>因为使用 <code>if let</code> 语句时可能会产生借用<br>\n于是在此情况下, 被创建的临时变量的生命周期, 被规定将会被延长到 <code>if let</code> 的主体结束<br>\n因此就算当我们使用 <code>pop()</code> 而非 <code>front()</code> 时, 也会发生同样的情况, 即使这不是必需的<br>\n故 guard 不会在第一时间被 drop 掉</p>\n<p>我们可以通过将 <code>pop</code> 操作移动到单独的 let 语句, 来避免这种情况<br>\n因此, 在该语句的末尾, 在 if let 之前, 被临时创建的 guard 将会被 drop:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = list.lock().unwrap().pop();</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(item) = item &#123;</span><br><span class=\"line\">    process_item(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"rw-lock\" id=\"RwLock\">RwLock</h2>\n<p>互斥锁只涉及独占访问, MutexGuard 将为我们提供对受保护数据的独占引用(&amp;mut T)<br>\n即使我们只想查看数据, 并使用已经足够满足需求的共享引用(&amp;T)</p>\n<p>读写锁(RwLock)是互斥锁的一个稍微复杂点的版本, 它了解独占访问和共享访问之间的区别, 并且可以提供两者之一<br>\n它有三种状态: 解锁, 由单个写入器(writer)锁定(用于独占访问), 被任意数量的读取器(reader)锁定(用于共享访问)<br>\n它通常用于经常由多个线程读取但仅偶尔更新一次的数据</p>\n<p>Rust 标准库通过 <code>std::sync::RwLock&lt;T&gt;</code> 类型提供此锁<br>\n它的工作方式与 <code>Mutex</code> 类似, 只是它的接口主要分为两部分<br>\n它不是单个 <code>lock()</code> 方法, 而是具有用于锁定为 writer 或 reader 的 <code>read()</code> 和 <code>write()</code> 方法<br>\n它有两种 guard 类型, 一种用于 reader, 一种用于writer: <code>RwLockReadGuard</code> 和 <code>RwLockWriteGuard</code><br>\n两者都实现了 <code>Deref</code> 以表现为对受保护数据的引用, 前者的表现类似于共享引用, 而后者的表现类似于独占引用</p>\n<p>它实际上是 <code>RefCell</code> 的多线程版本, 动态跟踪引用的数量, 以确保遵守借用规则</p>\n<p><code>Mutex&lt;T&gt;</code> 和 <code>RwLock&lt;T&gt;</code> 都要求 T 为 <code>Send</code>, 因为它们可用于将 <code>T</code> 发送到另一个线程<br>\n<code>RwLock&lt;T&gt;</code> 还需要 T 来实现 <code>Sync</code>, 因为它允许多个线程保存对受保护数据的共享引用(&amp;T)<br>\n严格来说, 您可以为不满足这些要求的 T 创建一个锁, 但您将无法在线程之间共享它, 因为锁本身不会实现 <code>Sync</code></p>\n<p>Rust 标准库只提供一种通用的 <code>RwLock</code> 类型, 但其实现取决于操作系统, 其实现之间存在许多细微差异<br>\n当有 writer 等待时, 大多数实现都会选择阻塞新的 reader, 即使锁已经 read-locked 也是如此<br>\n这是为了防止 <code>writer starvation(写饿死/写入器匮乏</code>), 即一种 “readers 过多导致锁一直无法被解锁, 导致 writer 无法更新数据” 的情况</p>\n<p><strong>Mutexes in Other Languages:</strong><br>\nRust 标准库中的 <code>Mutex</code> 和 <code>RwLock</code> 类型, 看起来与 C 或 C++ 等其他语言中的实现略有不同<br>\n最大的区别是 Rust 的 Mutex<T> 包含它正在保护的数据</p>\n<p>例如, 在 C++ 中, <code>std::mutex</code> 不包含它保护的数据, 甚至不知道它在保护什么<br>\n这意味着, 用户有责任记住哪些数据受到保护, 以及由哪个互斥锁保护, 并确保每次访问 “受保护数据” 时, 都锁定正确的互斥锁<br>\n在阅读涉及其他语言互斥体的代码时, 或者与不熟悉 Rust 的程序员交流时, 记住这一点很有用<br>\n一个 Rust 程序员可能会谈论 “互斥锁中的数据”, 或者 “将其包装在互斥锁中” 之类的话, 这可能会让那些只熟悉其他语言互斥锁的人感到困惑</p>\n<p>如果您确实需要一个不包含任何数据的独立互斥锁, 例如保护某些外部硬件, 则可使用 <code>Mutex&lt;()&gt;</code><br>\n但即使在这种情况下, 您最好定义一个(可能是零大小的)类型来与该硬件接口, 并将其包装在 <code>Mutex</code> 中<br>\n这样, 您仍然被迫锁定互斥锁, 然后才能与硬件交互</p>\n<hr>\n<h1 id=\"xian-cheng-deng-dai\">线程等待</h1>\n<p>当数据被多个线程改变时, 它们可能需要进行等待, 等到某些条件变为真再继续执行<br>\n例如, 如果我们有一个保护 <code>Vec</code> 的互斥锁, 我们可能需要等到它非空(被放入东西后再继续)</p>\n<p>互斥锁确实允许线程等待它被解锁, 但它不提供这种 “等待到某个条件成立” 的功能<br>\n如果我们只有一个互斥锁, 我们将不得不继续锁定互斥锁, 以反复检查 <code>Vec</code> 中是否有任何东西</p>\n<h2 id=\"thread-parking\" id=\"Thread-Parking\">Thread Parking</h2>\n<p>等待来自另一个线程的通知的一种方法, 称为 <code>thread parking(线程停放)</code><br>\n线程可以自行 park, 使其进入睡眠状态, 从而防止 CPU 空耗, 然后，另一个线程可以将线程唤醒/解除停放(unpark), 使其继续</p>\n<p><strong>译者注:</strong><br>\npark 的意思就是把车停放下来, 对应让线程进入睡眠<br>\nunpark 的意思就是把车开走, 对应让线程继续</p>\n<p>park 的行为, 可通过 <code>std::thread::park()</code> 函数表示<br>\nunpark 的行为, 您可以在要被唤醒的线程的 <code>Thread</code> 类型的对象上, 调用 <code>unpark()</code> 方法表示<br>\n<code>Thread</code> 对象可以从 <code>spawn</code> 返回的 <code>JoinHandle</code> 获取, 也可以通过 <code>std::thread::current()</code> 从线程本身获取</p>\n<p>让我们深入了解一个使用互斥锁, 在两个线程之间共享队列的示例<br>\n在以下示例中, 新生成的线程将消耗队列中的元素(consumer), 而主线程将每秒将一个新元素插入到队列(producter)<br>\npark 被用于让 comsumer 线程在队列为空时进行等待</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::VecDeque;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> queue = Mutex::new(VecDeque::new());</span><br><span class=\"line\"></span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Consuming thread</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> t = s.spawn(|| <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> item = queue.lock().unwrap().pop_front();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(item) = item &#123;</span><br><span class=\"line\">                dbg!(item);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                thread::park();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Producing thread</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>.. &#123;</span><br><span class=\"line\">            queue.lock().unwrap().push_back(i);</span><br><span class=\"line\">            t.thread().unpark();</span><br><span class=\"line\">            thread::sleep(Duration::from_secs(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个无限循环进行的例子, 在该循环中, 当元素不为空时, 它将元素从队列中弹出, 使用 <code>dbg!</code> 显示它们<br>\n当队列为空时, 它将调用 <code>park()</code>, 使线程进入睡眠状态, 防止 CPU 空耗<br>\n如果它被 unpark, 则先前调用的 <code>park()</code> 方法将会 return, 随后循环继续, 再次从队列中弹出元素, 直到它为空, 重复</p>\n<p>consumer 线程每秒生成一个新数字, 然后将其 push 到队列中<br>\n每次添加时, 都会在代表着 consumer 线程的 Thread 对象上, 调用 unpark() 方法来 unpark 它<br>\n这样, consumer 线程就会被唤醒, 以处理新的元素</p>\n<p>这里要提出的一个重要观察是, 如果我们删除对 park() 的调用, 这个程序在理论上仍然正确, 但效率低下<br>\n这非常重要, 因为 <code>park()</code> 不能保证它会只因为相匹配的 <code>unpark()</code> 而返回<br>\n虽然罕见, 但它可能会虚假的唤醒(spurious wake-ups)</p>\n<p>我们的示例很好地处理了这个问题, 因为 consumer 线程将锁定保护着队列的互斥锁, producter 线程将因此阻塞<br>\n随后, consumer 线程将检测队列是否为空, 当队列为空时, 就再次调用 <code>park()</code> 让自己进入睡眠状态<br>\nproducter 线程因此得以锁定互斥锁, 并对队列 push 新的元素, 随后调用 <code>unpark()</code> 唤醒 consumer 线程让其处理新元素</p>\n<p><code>Thread Parking</code> 的一个重要属性是, 对 <code>unpark()</code> 的调用在线程 park 自身之前, 不会丢失<br>\n对 unpark 的请求仍然会被记录, 下次线程尝试 park 时, 它会认识到该请求, 随后清除该请求后直接继续, 而不会实际进入睡眠<br>\n为了去了解为何这对正确性至关重要, 让我们来看看两个线程的执行步骤的可能顺序(从一开始观察):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>consumer 线程(简写为C)锁定了队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>C 尝试从队列中 pop 一个元素, 但它是空的, 结果为 None, 模式匹配后进去 else 分支</p>\n</li>\n<li class=\"lvl-3\">\n<p>C 解锁队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>producter 线程(简写为P)锁定了队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>P 将新元素 push 到队列中</p>\n</li>\n<li class=\"lvl-3\">\n<p>P 再次解锁队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>P 调用 <code>unpark()</code> 通知 C 有新元素</p>\n</li>\n<li class=\"lvl-3\">\n<p>C 调用 <code>park()</code> 进入睡眠, 等待更多元素</p>\n</li>\n</ol>\n<h1 id=\"yi-xia-nei-rong-wei-ji-fan-huan-zai-gai-bie-zhao-ji\">以下内容为机翻还在改别着急</h1>\n<p>虽然在步骤 3 中解锁队列和在步骤 8 中 unpark 之间很可能只有非常短暂的时刻，但步骤 4 到 7 可能会在线程 pack 之前的那一刻发生<br>\n如果 <code>unpark()</code> 在线程未停放时不执行任何操作, 则通知将丢失, 使用线程仍将在等待, 即使队列中有项目也是如此<br>\n由于取消寄存请求被保存以供将来调用 park()我们不必担心这一点</p>\n<p>但是，取消寄存请求不会叠加。调用 unpark() 两次，然后调用 park() 两次仍会导致线程进入睡眠状态。前 park() 个清除请求并直接返回，但第二个像往常一样进入睡眠状态。</p>\n<p>这意味着在上面的示例中，重要的是，只有在看到队列为空时才停放线程，而不是在每个处理的项目之后停放它。虽然由于睡眠时间巨大（一秒），此示例中极不可能发生，但多个 unpark() 调用可能只唤醒一个 park() 调用。</p>\n<p>不幸的是，这确实意味着，如果在 park() 返回后立即调用 unpark() ，但在队列被锁定和清空之前，则 unpark() 调用是不必要的，但仍会导致下一个 park() 调用立即返回。这会导致（空）队列被锁定并解锁额外的时间。虽然这不会影响程序的正确性，但它确实会影响其效率和性能。</p>\n<p>此机制适用于像我们示例中这样的简单情况，但当事情变得更加复杂时，很快就会崩溃。例如，如果我们有多个使用者线程从同一队列中获取项目，则生产者线程将无法知道哪个使用者实际上正在等待并且应该被唤醒。生产者必须确切地知道消费者何时在等待，以及它正在等待什么条件。</p>\n<h2 id=\"condvar\" id=\"Condvar\">Condvar</h2>\n<p>条件变量是更常用的选项，用于等待受互斥锁保护的数据出现问题。它们有两个基本操作：等待和通知。线程可以等待条件变量，之后当另一个线程通知相同的条件变量时，它们可以被唤醒。多个线程可以等待同一个条件变量，通知可以发送到一个等待线程，也可以发送到所有线程。</p>\n<p>这意味着我们可以为我们感兴趣的特定事件或条件创建一个条件变量，例如队列为非空，并等待该条件。然后，导致该事件或条件发生的任何线程都会通知条件变量，而不必知道哪些线程或有多少线程对该通知感兴趣。</p>\n<p>为了避免在解锁互斥锁和等待条件变量之间的短暂时刻丢失通知的问题，条件变量提供了一种以原子方式解锁互斥锁并开始等待的方法。这意味着通知根本不可能丢失。</p>\n<p>Rust 标准库提供了一个条件变量为 std::sync::Condvar 。它的 wait 方法需要 MutexGuard 来证明我们已经锁定了互斥锁。它首先解锁互斥锁并进入睡眠状态。稍后，当唤醒时，它会重新锁定互斥锁并返回新的 MutexGuard （这证明互斥锁再次被锁定）。</p>\n<p>它有两个通知函数： notify_one 只唤醒一个等待线程（如果有）， notify_all 唤醒它们。</p>\n<p>让我们修改用于线程停放的示例，改用 Condvar ：</p>\n","site":{"data":{}},"length":22694,"excerpt":"<blockquote>\n<p>本节我们将学习线程、互斥锁、条件变量、线程安全、共享和独占引用、内部可变性等内容</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-atomics-and-locks\">rust-atomics-and-locks</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>早在多核处理器普及之前, 操作系统就允许一台计算机同时运行许多程序<br>\n这是通过在进程间快速切换来实现的, 允许每个进程一个接一个地重复取得一点进展<br>\n如今, 几乎所有的计算机, 甚至我们的手机和手表都有多核处理器, 可以真正并行执行多个进程</p>\n<p>操作系统尽可能将进程彼此隔离, 允许程序在完全不知道其他进程在做什么的情况下, 做自己的事情<br>\n例如, 一个进程在不询问操作系统的内核之前, 通常无法访问另一个进程的内存, 也无法以任何方式与之通信</p>\n<p>但是, 程序可以生成额外的名为线程之物, 作为同一进程下的一部分<br>\n同一进程中的线程彼此之间不隔离, 线程共享内存, 并且可以通过该内存相互交互</p>\n<p>本章将解释线程在 Rust 中是如何生成的, 以及围绕它们的所有基本概念, 例如如何在多个线程之间安全地共享数据<br>\n本章中解释的概念是本系列中其余部分的基础</p>\n<hr>\n<h1 id=\"rust-zhong-de-xian-cheng\">Rust 中的线程</h1>\n<p>每个程序都只能从主线程开始, 即 <code>main</code> 函数所在的线程<br>\n该线程将执行您的 <code>main</code> 函数，并可以生成更多子线程</p>\n<p><strong>当主线程结束之后, 由其派生的子线程也将直接提前结束</strong></p>\n<p>在 Rust 中, 新线程是通过 <code>std::thread::spawn</code> 函数生成的, 它需要一个参数, 代表将执行的函数<br>\n此函数返回/结束后, 该线程将停止</p>\n<p>来看个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    thread::spawn(f);</span><br><span class=\"line\">    thread::spawn(f);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello from the main thread.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello from another thread!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id = thread::current().id();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This is my thread id: &#123;id:?&#125;&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们生成(spawn)了两个线程, 它们都将执行 <code>f</code> 作为其主要函数<br>\n这两个线程都将打印一条消息, 并显示其 <code>线程ID</code>, 而主线程也将打印自己的消息</p>\n<p><strong>Thread ID:</strong><br>\nRust 标准库为每个线程分配一个唯一的标识符, 此标识符可通过 Thread::id() 访问, 类型为 ThreadId<br>\n除了复制它们并检查相等性之外, 您对 ThreadId 无能为力, 不能保证这些 ID 将连续分配, 只是每个线程的 ID 会有所不同</p>\n<p>如果您多次运行上面的示例程序, 您可能会注意到两次运行之间的输出不同, 这是我在一次特定运行期间在机器上获得的输出:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello from the main thread.</span><br><span class=\"line\">Hello from another thread!</span><br><span class=\"line\">This is my thread id:</span><br></pre></td></tr></table></figure>\n<p>令人惊讶的是, 部分输出似乎丢失了<br>\n这是因为, 在新生成的线程完成其传入的函数之前, 主线程就已经完成了 main 函数<br>\n从 main 返回将退出整个程序, 即使其他线程仍在运行</p>\n<p>在该示例中, 在程序被主线程关闭前, 其中一个新生成的线程只发生了一半的消息<br>\n如果我们想确保, 线程在从 main 返回之前完成, 我们可以通过 <code>join</code> 来等待它们<br>\n为此, 我们要使用 <code>spawn</code> 函数返回的 <code>JoinHandle</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t1 = thread::spawn(f);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> t2 = thread::spawn(f);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello from the main thread.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.join().unwrap();</span><br><span class=\"line\">    t2.join().unwrap();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>.join()</code> 方法将等待线程完成执行, 并返回 <code>std::thread::Result</code><br>\n若线程由于死机而未成功完成其功能, 这将包含死机消息, 我们可以尝试处理这种情况, 或者在加入恐慌线程时只调用 <code>.unwrap()</code> 以恐慌</p>\n<p>运行此版本的代码将不再导致输出的截断:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello from the main thread.</span><br><span class=\"line\">Hello from another thread!</span><br><span class=\"line\">This is my thread id: ThreadId(3)</span><br><span class=\"line\">Hello from another thread!</span><br><span class=\"line\">This is my thread id: ThreadId(2)</span><br></pre></td></tr></table></figure>\n<p>运行之间仍然更改的是消息们的打印顺序, 因为是并发, 所以无法保证先后顺序</p>\n<p><strong>Output Locking:</strong><br>\n<code>println!</code> 使用 <code>std::io::Stdout::lock()</code>, 来确保其输出不会因线程间的并发而交替<br>\n<code>println!()</code> 将等到任何并发运行的表达式完成, 然后再写入任何输出<br>\n如果不是这种情况, 我们可能会得到更多交错的混乱的输出:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello fromHello from another thread!</span><br><span class=\"line\"> another This is my threthreadHello fromthread id: ThreadId!</span><br><span class=\"line\">( the main thread.</span><br><span class=\"line\">2)This is my thread</span><br><span class=\"line\">id: ThreadId(3)</span><br></pre></td></tr></table></figure>\n<p>与其将函数传递给 <code>std::thread::spawn</code>, 不如将闭包传递给它, 这允许我们捕获值, 并将其移动到新线程中:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> &amp;numbers &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;n&#125;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).join().unwrap();</span><br></pre></td></tr></table></figure>\n<p>此处, <code>numbers</code> 的所有权转移到了新生成的线程中, 因为我们使用了 <code>move</code> 闭包<br>\n若我们未使用 <code>move</code> 关键字, 闭包将通过引用捕获 <code>numbers</code>, 这将导致编译错误, 因为新线程的寿命可能超过该变量</p>\n<p>由于线程可能一直运行到程序执行结束, 因此 <code>spawn</code> 函数的参数类型具有 'static 约束<br>\n换句话说, 它只接受永远存在的函数, 而通过引用捕获局部变量的闭包, 闭包可能不会永远有效<br>\n因为, 当局部变量不复存在时，对该变量的引用自然变得无效, 闭包也因此变得无效</p>\n<p>从线程中获取的返回值, 实际上就是传入的闭包的返回值, 它可以从 <code>join</code> 方法返回的 <code>Result</code> 中获取:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = <span class=\"built_in\">Vec</span>::from_iter(<span class=\"number\">0</span>..=<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> t = thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = numbers.len();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = numbers.iter().sum::&lt;<span class=\"built_in\">usize</span>&gt;();</span><br><span class=\"line\">    sum / len  <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> average = t.join().unwrap(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;average: &#123;average&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里, 闭包 (1) 返回的值通过 join 方法 (2) 的返回值获取<br>\n若 numbers 为空，则新线程会尝试除以零 (1), 这将导致 panic, 而 <code>join</code> 则会返回 Err, 导致主线程也因为 unwrap 而 panic</p>\n<p><strong>Thread Builder:</strong>*<br>\n<code>std::thread::spawn()</code> 实际上只是 <code>std::thread::Builder::new().spawn().unwrap()</code> 的一个简写<br>\n<code>std::thread::Builder</code> 允许您在生成新线程之前, 为其进行一些设置<br>\n您可以使用它来配置新线程的堆栈大小, 为新线程命名<br>\n通过 <code>std::thread::current().name()</code> 可以获取当前线程的名称, 这将在 panic 的消息中使用, 并将在大多数平台上的 debug 工具中可见</p>\n<p>此外, <code>Builder</code> 的 <code>spawn</code> 函数返回 <code>std::io::Result</code>, 允许您处理生成新线程失败的情况<br>\n比如操作系统内存不足，或者对您应用的资源限制(resource limit), 则可能会发生该情况<br>\n(若 <code>spawn</code> 函数无法生成新线程, 它只会产生 panic)</p>\n<hr>\n<h1 id=\"zuo-yong-yu-xian-cheng\">作用域线程</h1>\n<p>有一个问题就是, 默认的 <code>spawn</code> 会要求一个具有 'static 约束的闭包, 在编译器就确保了不会发生生命周期上的问题<br>\n但如果我们真的确定, 生成的线程肯定不会超过某个作用域, 那么该线程理论上就应该可以安全地借用局部变量, 只要它们比该作用域活得久</p>\n<p>Rust 标准库提供了 <code>std::thread::scope</code> 函数, 来生成这样的作用域线程<br>\n它允许我们生成 “不超过我们传递给该函数的闭包范围” 的线程, 从而安全地借用局部变量</p>\n<p>一个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::scope(|s| &#123; <span class=\"comment\">// 1</span></span><br><span class=\"line\">    s.spawn(|| &#123; <span class=\"comment\">// 2</span></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;length: &#123;&#125;&quot;</span>, numbers.len());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    s.spawn(|| &#123; <span class=\"comment\">// 2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> &amp;numbers &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;n&#125;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 (1) 处: 我们调用 <code>std::thread::scope</code> 函数, 我们的闭包将在传入后立刻执行, 参数 <code>s</code>，代表 <code>Scope</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (2) 处: 我们通过 <code>s</code> 参数, 生成了 作用域线程(Scoped Threads), 其传入的闭包可以借用局部变量, 如 <code>numbers</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (3) 处: 我们生成的所有 <code>Scoped-Thread</code>, 若还没有 <code>join</code>, 将自动 <code>join</code></p>\n</li>\n</ul>\n<p>它保证了作用域内生成的任何线程, 都不会超过作用域<br>\n正因如此, 这个 <code>spawn</code> 方法的参数类型上没有 'static 约束，允许我们引用任何内容，只要它比作用域长寿，例如 <code>numbers</code></p>\n<p>在上面的示例中, 两个新线程同时访问 <code>numbers</code>, 这很好, 因为所有都不会修改它<br>\n若我们要将第一个线程更改为修改 <code>numbers</code>, 编译器将不允许我们生成另一个也修改 <code>numbers</code> 的线程:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> numbers = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::scope(|s| &#123;</span><br><span class=\"line\">    s.spawn(|| &#123;</span><br><span class=\"line\">        numbers.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    s.spawn(|| &#123;</span><br><span class=\"line\">        numbers.push(<span class=\"number\">2</span>); <span class=\"comment\">// Error!</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>确切的错误消息取决于 Rust 编译器的版本, 因为它通常会得到改进, 以产生更好的报错，目前的报错信息如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0499]: cannot borrow `numbers` as mutable more than once at a time</span><br><span class=\"line\"> --&gt; example.rs:7:13</span><br><span class=\"line\">4 |     s.spawn(|| &#123;</span><br><span class=\"line\">  |             -- first mutable borrow occurs here</span><br><span class=\"line\">5 |         numbers.push(1);</span><br><span class=\"line\">  |         ------- first borrow occurs due to use of `numbers` in closure</span><br><span class=\"line\"></span><br><span class=\"line\">7 |     s.spawn(|| &#123;</span><br><span class=\"line\">  |             ^^ second mutable borrow occurs here</span><br><span class=\"line\">8 |         numbers.push(2);</span><br><span class=\"line\">  |         ------- second borrow occurs due to use of `numbers` in closure</span><br></pre></td></tr></table></figure>\n<p><strong>来自译者的题外话, 帮你更好地理解下作用域线程:</strong><br>\n如果你观察一下 <code>std::thread::scope</code>, 会发现其 lifetime 的关系如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">scope</span></span>&lt;<span class=\"symbol\">&#x27;env</span>, F, T&gt;(f: F) -&gt; T</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    F: <span class=\"keyword\">for</span>&lt;<span class=\"symbol\">&#x27;scope</span>&gt; <span class=\"built_in\">FnOnce</span>(&amp;<span class=\"symbol\">&#x27;scope</span> Scope&lt;<span class=\"symbol\">&#x27;scope</span>, <span class=\"symbol\">&#x27;env</span>&gt;) -&gt; T,</span><br></pre></td></tr></table></figure>\n<p>根据文档所述, 'scope 表示作用域本身的 lfetime, 'env 表示作用域内线程借用的任何变量的 lifetime</p>\n<p>'scope 的 lifetime 在 <code>scope</code> 函数开始之后开始，位于 <code>f (传入的闭包参数)</code> 之前, 其 lifetime 在 <code>f</code> 结束之后结束<br>\n该 lifetime 结束后, 所有生成的作用域线程都将被自动 <code>join</code></p>\n<p>关系如下:</p>\n<pre style=\"width: 534px; margin: 0px\">\n┌──fn_scope(f: F)────────────────────┐\n│                                    │\n│  'scope                            │\n│     |                              │\n│     |  'f  // is your closure      │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |   |                          │\n│     |  'f                          │\n│     |                              │\n│     | // join scoped threads here  │\n│     |                              │\n│  'scope                            │\n│                                    │\n└────────────────────────────────────┘\n</pre>\n<p>而 'env 的约束是 'env: 'scope, 表示了作用域线程借用的任何变量的 lifetime 一定得小于作用域本身的 lifetime</p>\n<p><strong>The Leakpocalypse:</strong><br>\n在 Rust 1.0 之前, 标准库有个名为 <code>std::thread::scoped</code> 的函数, 它会直接生成一个线程, 如同 <code>std::thread::spawn</code><br>\n它允许非 'static 的闭包, 因为它返回的不是 <code>JoinHandle</code>, 而是个在 drop 时会 join 线程的 <code>JoinGuard</code><br>\n任何借用的数据只需要比这 JoinGuard 存在更长的时间, 这似乎是安全的, 只要 JoinGuard 在某个时候被丢弃</p>\n<p>但就在 Rust 1.0 发布之前, 很多事情慢慢变得清楚, 你不能保证某些东西一定会被丢弃, 这有很多办法<br>\n例如创建引用计数节点的循环, 或者 leak 它, 这都不会 drop 它</p>\n<p>最终, 在一些人所说的 “泄漏启示录(Leakpocalypse)” 中, 得出的结论是:<br>\n安全接口的设计, 不能依赖于对象在其生命周期结束时总是会被丢弃的假设<br>\n泄漏对象可能会合理地导致泄漏更多对象(例如，泄漏 Vec 也会泄漏其元素), 但可能不会导致未定义的行为</p>\n<p>由于这个结论, <code>std::thread::scoped</code> 不再被认为是安全的, 并从标准库中删除<br>\n此外, <code>std::mem::forget</code> 从 unsafe 变成了 safec, 以强调 forget/leak 始终是可能的</p>\n<p><strong>老生常谈的话: Rust 并不会阻止 内存泄漏, 内存泄漏 不归到 内存安全 的范畴里</strong></p>\n<p>直到很久以后, 在 Rust 1.63 中, 添加了一个新的 <code>std::thread::scope</code> 函数, 其中包含一个不依赖 Drop 来表示正确性的新设计</p>\n<hr>\n<h1 id=\"gong-xiang-suo-you-quan\">共享所有权</h1>\n<p>到目前为止, 我们已经研究了使用 move 闭包, 将值的所有权转移到线程, 并从寿命更长的父线程借用数据<br>\n当在两个线程之间共享数据时, 当两个线程都不能保证比另一个线程活得久, 则它们都不能成为该数据的所有者<br>\n它们之间共享的任何数据的 lifetime, 都需要与活的最长的线程一样长或更长</p>\n<h2 id=\"static\" id=\"Static\">Static</h2>\n<p>有几种方法可以创建不属于单个线程的内容, 其中最简单的是使用 static 关键字<br>\n它由整个程序 “拥有”, 而不是单个线程</p>\n<p>在以下示例中, 两个线程都可以访问 X , 但它们都不拥有它:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> X: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(|| dbg!(&amp;X));</span><br><span class=\"line\">thread::spawn(|| dbg!(&amp;X));</span><br></pre></td></tr></table></figure>\n<p>一个 static 项, 其以 const 字面量作为初始值, 永远不会 drop<br>\n且在 main 函数启动之前, 它就已经存在, 每个线程都能借用它, 毕竟它保证永远存在</p>\n<h2 id=\"leak\" id=\"Leak\">Leak</h2>\n<p>共享所有权的另一种方法是leak, 使用 <code>Box::leak</code><br>\n它可以释放 Box 的所有权, 承诺永远不会 drop 它, 从那时起, Box 将永远存在, 没有所有者, 只要程序运行, 它就可以被任何线程借用</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x: &amp;<span class=\"symbol\">&#x27;static</span> [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>] = <span class=\"built_in\">Box</span>::leak(<span class=\"built_in\">Box</span>::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">    thread::spawn(<span class=\"keyword\">move</span> || dbg!(x));</span><br><span class=\"line\">    thread::spawn(<span class=\"keyword\">move</span> || dbg!(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可能看上去, 在 move 闭包, 我们将所有权转移到了线程中<br>\n但仔细观察 x 的类型, 你会发现, 我们只是为线程提供了对数据的引用, 而不是数据本身的所有权</p>\n<p><strong>注意:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>独享引用(&amp;T) 实现了 Copy 这个 trait, 这意味着当您 move 它时, 原始值仍然存在, 就像整数或布尔值一样</p>\n</li>\n<li class=\"lvl-2\">\n<p>'static 生命周期并不意味着 “该值自程序开始以来一直存在”, 而只是 “它一直存在到程序结束”, 过去的经历并不在乎</p>\n</li>\n</ul>\n<p>泄漏 Box 的缺点是, 我们正在泄漏内存, 我们分配一些东西, 但从不丢弃和解除分配它<br>\n如果这只发生有限的少量次数, 可能会达成很棒的效果, 但如果我们继续, 程序将慢慢耗尽内存</p>\n<h2 id=\"yin-yong-ji-shu\" id=\"引用计数\">引用计数</h2>\n<p>为了确保共享的数据被 drop , 使得其内存被释放, 我们不能完全放弃其所有权<br>\n相反, 我们可以分享所有权, 通过跟踪所有者的数量, 我们可以确保仅在没有所有者时才丢弃该值</p>\n<p>Rust 标准库通过 <code>std::rc::Rc</code> 类型提供此功能, 这是 “引用计数(References Counting)” 的缩写<br>\n它与 <code>Box</code> 非常相似, 除了 clone 它时并不会真的 clone 其包含的值, 而只是增加计数器的值<br>\n原来的 Rc 与克隆的 Rc,  都将引用相同的分配, 因此, 它们可以共享所有权</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = Rc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.clone();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>(a.as_ptr(), b.as_ptr()); <span class=\"comment\">// Same allocation!</span></span><br></pre></td></tr></table></figure>\n<p>drop 一个 Rc 将减少计数器, 当最后一个 Rc 被 drop 时(计数器将降至零), 将 drop 其包含的值并释放内存</p>\n<p>但是, 当我们尝试将 Rc 发送到另一个线程, 我们将遇到以下编译器错误:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0277]: `Rc` cannot be sent between threads safely</span><br><span class=\"line\">    |</span><br><span class=\"line\"><span class=\"number\">8</span>   |     thread::spawn(<span class=\"keyword\">move</span> || dbg!(b));</span><br><span class=\"line\">    |                   ^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>\n<p>事实证明, Rc 不是线程安全的, 因为它没有实现 <code>Send</code> 这个 tait<br>\n未实现 <code>Send</code> 的类型, 表示其实现可能并没有考虑多线程, 导致不能将其 move 进其他线程<br>\n因此如果将 Rc 分配给多个线程, 则它们可能会尝试同时修改引用计数器, 这可能会产生不可预知的结果</p>\n<p>但编译器阻止了我们</p>\n<p>相反, 我们可以使用 <code>std::sync::Arc</code>, 它代表“原子引用计数(Atomic References Counting)”<br>\n它与 Rc 相同, 只是它保证对引用计数器的修改是不可分割的原子操作, 因此可以安全地将其用于多个线程</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::Arc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.clone(); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || dbg!(a)); <span class=\"comment\">// 3</span></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || dbg!(b)); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>在上述代码中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在 (1) 处: 我们将数组放进了一个 <code>Arc</code> 中进行包装, 其引用计数器从 1 开始</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (2) 处: 克隆了 <code>Arc</code>, 使得引用计数增加到 2, 并为我们提供另一个 <code>Arc</code>, 指向相同的资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (3) 处: 两个线程都获得自己的 <code>Arc</code>, 可以访问共享数组, 两者都在 <code>drop</code> 使得计数器减 1</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 (3) 处: 最后一个 <code>drop</code> 了 <code>Arc</code> 的线程, 使得计数器减小到 0, 此时将会 drop 被包装的数组, 释放资源</p>\n</li>\n</ul>\n<p><strong>Naming Clones:</strong><br>\n必须给 <code>Arc</code> 的每个克隆一个不同的名称, 会很快使代码变得非常混乱且难以理解<br>\n虽然 <code>Arc</code> 的每个克隆都是单独的对象, 但每个克隆都表示相同的共享值, 我们可以通过 <code>Shadow</code> 语法来处理</p>\n<p>Rust 允许(并鼓励)你通过定义一个同名的新变量来隐藏变量, 如果在同一作用域内执行此操作, 则无法再使用原始变量<br>\n但是通过打开一个新作用域, 可以使用像 <code>let a = a.clone();</code> 这样的语句, 在该作用域内重用名称, 同时将原始变量保留在作用域之外</p>\n<p>通过将闭包包装在新作用域(使用 <code>&#123;&#125;</code>)中, 我们可以在将变量移动到闭包之前克隆变量, 而无需重命名它们:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">    dbg!(b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dbg!(a);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">thread::spawn(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = a.clone();</span><br><span class=\"line\">    <span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">        dbg!(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dbg!(a);</span><br></pre></td></tr></table></figure>\n<p>由于所有权是共享的, 因此引用计数指针 (<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code>) 与共享引用 (<code>&amp;T</code>) 具有相同限制<br>\n它们不允许您对其包含的值进行可变访问, 因为该值可能同时被其他代码借用<br>\n例如, 当我们尝试对 <code>Arc&lt;[i32]&gt;</code> 中的整数切片进行排序, 编译器会阻止我们, 告诉我们不允许改变数据:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0596]: cannot borrow data in an `Arc` as mutable</span><br><span class=\"line\">  |</span><br><span class=\"line\">6 |     a.sort();</span><br><span class=\"line\">  |     ^^^^^^^^</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"jie-yong-yu-shu-ju-jing-zheng\">借用与数据竞争</h1>\n<p>在 Rust 中, 可以通过两种方式借用值:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>不可变借用(Immutable borrowing):<br>\n通过 <code>&amp;</code> 借用, 这得到了一个不可变引用(immutable reference), 可以复制这样的引用<br>\n对被引用数据的访问, 在此类引用的所有副本之间共享, 编译器通常不允许通过这样的引用修改内容, 因为会影响借用了相同数据的其他代码</p>\n</li>\n<li class=\"lvl-2\">\n<p>可变借用(Mutable borrowing):<br>\n通过 <code>&amp;mut</code> 借用, 这得到了一个可变引用(mutable reference), 可变借用保证它是该数据唯一的有效借用(active borrow)<br>\n因此, 这可以确保, 改变数据的内容不会影响到其他代码</p>\n</li>\n</ul>\n<p>这两个概念在一起, 完全防止了数据竞争(data races), 即一个线程正在改变数据, 而另一个线程同时访问数据的情况<br>\n数据竞争通常是未定义的行为(undefined behavior), 这意味着编译器不需考虑这些情况, 因为它只会假设这些情况不会发生</p>\n<p>为阐明这到底意味着什么, 让我们看一个编译器可以使用借用规则做出有用假设的示例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(a: &amp;<span class=\"built_in\">i32</span>, b: &amp;<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> before = *a;</span><br><span class=\"line\">    *b += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> after = *a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> before != after &#123;</span><br><span class=\"line\">        x(); <span class=\"comment\">// never happens</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 我们得到一个对整数的不可变引用, 并在递增 b 所引用的整数前后, 存储了整数的值<br>\n编译器可以自由地假设有关 “借用和数据竞争的基本规则” 得到维护, 这意味着 b 不可能像 a 一样引用相同的整数<br>\n事实上, 只要 a 还存在, 整个程序中没有任何东西可以可变地借用 a 所指的整数<br>\n因此, 编译器可以很容易地得出结论, *a 不会改变, <code>before</code> 永远等于 <code>after</code><br>\n因此 if 语句永远无法成立, 可以从程序中完全删除对 x 的调用, 进行优化</p>\n<p>编写一个打破编译器假设的 Rust 程序是不可能的, 除非使用 unsafe 块来禁用编译器的某些安全检查</p>\n<p><strong>Undefined Behavior(未定义的行为):</strong><br>\n像 C, C++, Rust 这样的语言有一套规则, 需要遵循这些规则, 以避免所谓的未定义行为(ub)<br>\n例如, Rust 的规则之一是: 对任何对象都不能有多个可变引用</p>\n<p>在 Rust 中, 只有在使用 unsafe 代码时才能违反这些规则中的任何一个<br>\nunsafe 在 Rust 中并不意味着代码不正确或不安全, 而是编译器没为您验证代码是否安全<br>\n如果代码确实违反了这些规则，则称为 unsound(不健全), 因此, 你可以将 unsafe, 等价于 trust_me</p>\n<p>编译器会假设这些规则永远不会被破坏, 当被破坏时, 会导致一种被称为未定义行为的情况发生, 我们需要不惜一切代价避免这种情况<br>\n因为, 若我们允许编译器做出一个实际上不正确的假设, 它很容易导致代码不同部分的更多错误结论, 从而影响整个程序</p>\n<p>作为一个例子, 让我们看一下在切片上使用 <code>get_unchecked</code> 方法的代码实例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"number\">789</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">unsafe</span> &#123; a.get_unchecked(index) &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>get_unchecked</code> 方法, 让我们得到了指定索引位置的切片元素, 如同 <code>a[index]</code> 一样<br>\n但它允许编译器假设索引始终在边界内, 而无需进行任何边界检查</p>\n<p>这意味着, 在此代码段中, 由于 a 的长度为 3, 因此编译器可能会假定 index 小于 3, 我们有责任确保其假设成立<br>\n如果我们打破这个假设, 例如, 如果我们在 index 等于 3 的情况下运行这个假设, 任何事情都可能发生<br>\n这可能会导致, 从内存中读取到了存储在 a 之后的字节中的任何内容, 程序可能会因此崩溃<br>\n比如, 它最终可能会执行你程序中一些完全不相关的部分, 造成各种破坏</p>\n<p>令人惊讶的是, 未定义行为甚至可以 “影响过去”, 导致它之前的代码出现问题<br>\n为了理解这是如何发生的, 假设在先前代码的前面有个 match 语句, 如下所示:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">match</span> index &#123;</span><br><span class=\"line\">   <span class=\"number\">0</span> =&gt; x(),</span><br><span class=\"line\">   <span class=\"number\">1</span> =&gt; y(),</span><br><span class=\"line\">   _ =&gt; z(index),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"number\">789</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">unsafe</span> &#123; a.get_unchecked(index) &#125;;</span><br></pre></td></tr></table></figure>\n<p>由于 unsafe 块, 编译器可以假定 index 只为 0、1 或 2<br>\n从逻辑上讲, 我们可以得出结论, 我们的 match 语句的最后一个分支只会与 2 匹配<br>\n因此 z(index) 只可能是 z(2), 该结论不仅可以用于优化 match, 还可优化 z 本身, 这可能包括删除代码中未使用的部分</p>\n<p>如果我们让 index 为 3 时执行此操作, 我们的程序可能会尝试执行已优化的部分<br>\n这从而导致了完全不可预测的行为, 早于在我们到达最后一行的 unsafe 块之前<br>\n就像这样, 未定义行为可能以一种非常意想不到的方式, 向后和向前传播与污染整个程序</p>\n<p>调用任何 unsafe 函数前, 请仔细阅读文档, 并确保完全了解其安全要求<br>\n作为调用者, 您需要秉承 “避免未定义行为” 的准则</p>\n<hr>\n<h1 id=\"nei-bu-ke-bian-xing\">内部可变性</h1>\n<p>上一节中介绍的借用规则很简单, 但可能非常有限, 尤其是在涉及多个线程时<br>\n遵循这些规则, 将使得线程间的通信被严重限制, 甚至会变得几乎不可能, 因为多线程间可访问的数据不能突变<br>\n幸运的是, 有个逃生舱口: 内部可变性(interior mutability)<br>\n具有内部可变性的数据类型, 会稍微改变其借用规则, 在某些情况下, 这些类型可通过 “不可变引用” 而允许突变</p>\n<p>在先前讲述引用计数时, 我们已看到了个涉及内部可变性的微妙例子:<br>\n<code>Rc</code> 和 <code>Arc</code> 被 clone 与 drop 时, 会改变引用计数器的数值, 即使多个克隆都使用着相同的引用计数器</p>\n<p>一旦涉及内部可变类型, 将引用称为 “不可变” 或 “可变” 会令人困惑和不准确, 因为两者都能够突变数据<br>\n更准确的术语是 “共享” 和 “独占”:<br>\n共享引用(&amp;T)可以复制并与他人共享, 而独占引用(&amp;mut T)保证了它是该 T 的唯一独占借用<br>\n对于大多数类型, 共享引用不允许突变, 但也有例外<br>\n由于在本系列中, 我们将主要处理这些例外, 因此我们将在本系列的其余部分使用更准确的术语</p>\n<p><strong>注意:</strong><br>\n请记住, 内部可变性只会改变共享借用的规则, 以允许共享时的突变, 而不会改变任何关于独占借用的行为<br>\n独占借用仍然保证没有其他独享的有效借用(active borrow)<br>\nunsafe 中对某物的多个有效的独占引用, 将始终导致未定义行为, 不会考虑内部可变性</p>\n<h2 id=\"cell\" id=\"Cell\">Cell</h2>\n<p><code>std::cell::Cell&lt;T&gt;</code> 只是个包裹了 T 类型数据的类型, 但允许通过共享引用进行突变<br>\n为避免未定义行为, 它只允许您复制值(T 必须实现 Copy), 或用另一个值替换已被包裹的值<br>\n此外, 它只能在单个线程中使用</p>\n<p>让我们看个类似上一节中的示例, 但这次使用 Cell<i32> 而不是 i32:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(a: &amp;Cell&lt;<span class=\"built_in\">i32</span>&gt;, b: &amp;Cell&lt;<span class=\"built_in\">i32</span>&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> before = a.get();</span><br><span class=\"line\">    b.set(b.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> after = a.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> before != after &#123;</span><br><span class=\"line\">        x(); <span class=\"comment\">// might happen</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与上次不同, 现在 if 条件可能为真, 因为 <code>Cell&lt;i32&gt;</code> 具有内部可变性, 所以只要我们有对它的共享引用, 编译器就不能再假设它的值不会改变<br>\na 和 b 可能都引用相同的值，因此通过 b 对数据突变, 也可能影响到 a<br>\n但是, 它仍假定没有其他线程同时访问 <code>Cell</code> 类型的 a 与 b</p>\n<p>对 Cell 的限制并不总是那么容易处理, 因为它不能直接让我们借用它所持有的值<br>\n我们要将其值移出, 修改它后再放回去, 以改变它的内容:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(v: &amp;Cell&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> v2 = v.take(); <span class=\"comment\">// Replaces the contents of the Cell with an empty Vec</span></span><br><span class=\"line\">    v2.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    v.set(v2); <span class=\"comment\">// Put the modified Vec back</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ref-cell\" id=\"RefCell\">RefCell</h2>\n<p>与常规 <code>Cell</code> 不同, <code>std::cell::RefCell</code> 允许您以较小的运行时成本借用其值<br>\n<code>RefCell&lt;T&gt;</code> 不仅持有 <code>T</code>, 还持有引用计数器, 用于在运行时, 跟踪对被包裹数据的借用的情况<br>\n当你试图以不可变地借用它, 而它已经被可变借用了(反之亦然), 它会 panic, 从而避免未定义的行为<br>\n像 <code>Cell</code> 一样, <code>RefCell</code> 只能在单个线程中使用</p>\n<p>借用 <code>RefCell</code> 包裹的值, 是通过调用 <code>borrow</code> 或 <code>borrow_mut</code> 来完成的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">f</span></span>(v: &amp;RefCell&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt;&gt;) &#123;</span><br><span class=\"line\">    v.borrow_mut().push(<span class=\"number\">1</span>); <span class=\"comment\">// We can modify the `Vec` directly.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>译者注:</strong><br>\n<code>Cell/RefCell</code>, 简单来说, 属于在编译时欺骗了编译器, 将借用规则从编译器挪动到运行期, 以便于放宽要求<br>\n但借用规则还是满足的, 只是晚了一个阶段而已, 如果违背了借用规则, 依旧会报错</p>\n<p>虽然 <code>Cell</code> 和 <code>RefCell</code> 非常有用, 但当我们处于多线程并发的环境时, 它们变得没啥用<br>\n因此, 让我们转到与并发相关的类型</p>\n<h2 id=\"mutex-rw-lock\" id=\"Mutex-RwLock\">Mutex/RwLock</h2>\n<p><code>RwLock (reader-writer lock)</code>, 是 <code>RefCell</code> 的并发版本<br>\n一个 <code>RwLock&lt;T&gt;</code>, 持有 T 并跟踪借用的情况<br>\n但与 <code>RefCell</code> 不同的是, 它不会在借用冲突时 panic, 而是阻塞当前线程(使其进入睡眠状态), 同时等待冲突的借用消失<br>\n我们只需耐心地等待其他线程完成, 然后处理数据即可</p>\n<p>借用被 <code>RwLock</code> 包裹的值, 称为锁定(lcok), 通过锁定它, 我们可以暂时阻止并发的冲突借用, 以允许我们借用它而不会引起数据竞争<br>\n<code>Mutex</code> 非常相似, 但在概念上稍微简单些, 它不像 <code>RwLock</code> 那样跟踪共享借用和独占借用的数量, 而只允许独占借用</p>\n<p>我们将在本节之后, 更加详细地介绍这些类型</p>\n<h2 id=\"atomic\" id=\"Atomic\">Atomic</h2>\n<p><code>Atomic(原子)</code>, 该类型是 <code>Cell</code> 的并发版本, 是之后第 2 章和第 3 章的主题<br>\n像 <code>Cell</code> 一样, 它们通过将值作为一个整体, 复制进来和传出来, 以避免未定义行为, 而不让我们直接借用内容</p>\n<p>但与 <code>Cell</code> 不同, 它们不能是任意大小<br>\n因此没有通用的 <code>Atomic&lt;T&gt;</code> 类型, 而只有特定的原子类型, 例如 <code>AtomicU32</code> 和 <code>AtomicPtr&lt;T&gt;</code><br>\n哪些可用取决于平台, 因为它们需要处理器的支持以避免数据竞争(我们将在之后的第 7 章中深入探讨)</p>\n<p>由于它们的大小非常有限, 因此原子通常不直接包含需要在线程之间共享的信息<br>\n相反, 它们通常被用作一种工具, 以便在线程之间共享其他(通常是更大的)数据, 此时事情可能会变得非常复杂</p>\n<h2 id=\"unsafe-cell\" id=\"UnsafeCell\">UnsafeCell</h2>\n<p><code>UnsafeCell</code> 是内部可变性的原始的构建块<br>\n<code>UnsafeCell&lt;T&gt;</code> 包装 <code>T</code>, 但不附带任何条件或限制以避免未定义行为<br>\n相反, 它的 <code>get()</code> 方法只是给出一个包装值的原始指针, 该值只能在 <code>unsafe</code> 块中使用<br>\n它让用户以不会导致任何未定义行为的方式使用它</p>\n<p>最常见的是, <code>UnsafeCell</code> 不直接使用, 而是包装在另一类型中, 该类型通过有限的接口(例如 <code>Cell</code> 或 <code>Mutex</code>)提供安全性<br>\n所有具有内部可变性的类型(包括上面讨论的所有类型)都建立在 <code>UnsafeCell</code> 之上</p>\n<hr>\n<h1 id=\"xian-cheng-an-quan\">线程安全</h1>\n<p>在本章中, 我们看到了几种非线程安全的类型, 这些类型只能在单个线程上使用, 例如 <code>Rc</code>. <code>Cell</code><br>\n由于需要限制以避免未定义行为, 因此编译器需要去理解并检查, 以便于知晓使用这些类型时无需使用 unsafe 块</p>\n<p>Rust 语言使用两个特殊的 Trait 来跟踪哪些类型可以跨线程安全使用:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Send:<br>\n如果一个类型可以被发送到另一个线程, 则该类型为 Send, 即该类型的值的所有权, 可以转移到另一个线程<br>\n例如, <code>Arc&lt;i32&gt;</code> 实现了 Send, 但 <code>Rc&lt;i32&gt;</code> 没有</p>\n</li>\n<li class=\"lvl-2\">\n<p>Sync:<br>\n如果一个类型可以与其他线程共享, 则类型为 Sync, 即当且仅当 &amp;T 是 Send 时, T 实现了 Sync<br>\n例如, <code>i32</code> 是 Sync, 因为 &amp;i32 是 Send, 但 <code>Cell&lt;i32&gt;</code> 不是 (不过 <code>Cell&lt;i32&gt;</code> 是 Send)</p>\n</li>\n</ul>\n<p>所有基础类型, 如 i32, bool, str, 都是 Send 和 Sync</p>\n<p>这两个 Trait 都是 auto 的, 这意味着它们会根据类型的字段而自动实现<br>\n比如, 当字段均为 Send 和 Sync 时, 该 struct 本身也是 Send 和 Sync</p>\n<p>选择主动避免实现其中任何一个 Trait 的方法, 是向类型添加一个未实现相关 Trait 的字段<br>\n为此, 特殊的 <code>std::marker::PhantomData&lt;T&gt;</code> 类型通常会派上用场, 编译器将该类型视为 T. 但它在运行时实际上并不存在<br>\n这是一个零大小的类型, 不占用空间</p>\n<p>我们来看看下面的 struct:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::marker::PhantomData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span> &#123;</span><br><span class=\"line\">    handle: <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">    _not_sync: PhantomData&lt;Cell&lt;()&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在此示例中, 若 handle 是其唯一字段, 则 X 将是 Send 和 Sync<br>\n但是, 我们添加了一个大小为零的 <code>PhantomData&lt;Cell&lt;()&gt;&gt;</code> 字段, 该字段被视为 <code>Cell&lt;()&gt;</code><br>\n因为 <code>Cell&lt;()&gt;</code> 不是 Sync, 所以 X 也不是, 但它仍然是 Send, 因为它的所有字段都实现了 Send</p>\n<p>原始指针 (*const T 和 *mut T) 既不是 Send 也不是 Sync, 因为编译器对它们表示的数据知之甚少</p>\n<p>选择手动实现其中任何一个 Trait , 都需要用 unsafe 进行标明:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">X</span></span> &#123;</span><br><span class=\"line\">    p: *<span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsafe</span> <span class=\"keyword\">impl</span> <span class=\"built_in\">Send</span> <span class=\"keyword\">for</span> X &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">unsafe</span> <span class=\"keyword\">impl</span> <span class=\"built_in\">Sync</span> <span class=\"keyword\">for</span> X &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>实现这些特征之所以需要 unsafe 关键字, 是因为编译器无法为您检查它是否正确, 这是你对编译器的承诺, 它只需信任你</p>\n<p>如果您尝试将某些内容移动到另一个非 Send 的线程中, 编译器会礼貌地阻止您这样做, 下面是个小示例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = Rc::new(<span class=\"number\">123</span>);</span><br><span class=\"line\">    thread::spawn(<span class=\"keyword\">move</span> || &#123; <span class=\"comment\">// Error!</span></span><br><span class=\"line\">        dbg!(a);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 我们尝试将 <code>Rc&lt;i32&gt;</code> 发送到新线程, 但 <code>Rc&lt;i32&gt;</code> 与 <code>Arc&lt;i32&gt;</code> 不同, 它没实现 Send<br>\n如果我们尝试编译上面的示例，我们将面临如下所示的错误:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">error[E0277]: `Rc&lt;i32&gt;` cannot be sent between threads safely</span><br><span class=\"line\">   --&gt; src/main.rs:3:5</span><br><span class=\"line\">    |</span><br><span class=\"line\">3   |     thread::spawn(move || &#123;</span><br><span class=\"line\">    |     ^^^^^^^^^^^^^ `Rc&lt;i32&gt;` cannot be sent between threads safely</span><br><span class=\"line\">    |</span><br><span class=\"line\">    = help: within `[closure]`, the trait `Send` is not implemented for `Rc&lt;i32&gt;`</span><br><span class=\"line\">note: required because it&#x27;s used within this closure</span><br><span class=\"line\">   --&gt; src/main.rs:3:19</span><br><span class=\"line\">    |</span><br><span class=\"line\">3   |     thread::spawn(move || &#123;</span><br><span class=\"line\">    |                   ^^^^^^^</span><br><span class=\"line\">note: required by a bound in `spawn`</span><br></pre></td></tr></table></figure>\n<p><code>thread::spawn</code> 函数要求其参数为 Send, 如果闭包的所有捕获都为 Send, 则闭包也为 Send<br>\n如果我们试图捕捉不是 Send 的东西, 那么我们的错误就会被抓住, 编译器会保护我们免受未定义行为的影响</p>\n<hr>\n<h1 id=\"hu-chi-suo\">互斥锁</h1>\n<p>在线程间共享不可变或可变的数据, 最常用的工具是 Mutex, 它是 互斥(mutual exclusion) 的缩写<br>\n互斥锁的工作是, 通过暂时阻塞尝试同时访问某些数据的其他线程, 来确保线程对某些数据具有独占访问权限</p>\n<p>从概念上讲, 互斥锁只有两种状态: 锁定和解锁(lock and unlock)</p>\n<p>当线程锁定了未锁定的互斥锁时, 互斥锁将标记为锁定, 线程可以立即继续<br>\n当线程尝试锁定已锁定的互斥锁时, 该操作将阻塞, 线程在等待互斥锁解锁时进入睡眠状态</p>\n<p>解锁只能在锁定的互斥锁上进行, 并且应该由锁定它的同一线程完成<br>\n如果其他线程正在等待锁定互斥锁, 则解锁互斥锁将导致其中一个线程被唤醒, 被唤醒的线程可以尝试再次锁定互斥锁<br>\n该过程可以一直重复</p>\n<p>使用互斥锁保护数据, 只是所有线程间的协议, 即它们仅在锁定互斥锁时访问数据<br>\n这样, 没有两个线程可以同时访问该数据, 避免了数据竞争</p>\n<h2 id=\"rusts-mutex\" id=\"Rust’s-Mutex\">Rust’s Mutex</h2>\n<p>Rust 标准库通过 <code>std::sync::Mutex&lt;T&gt;</code> 提供此功能<br>\n类型 T 是互斥锁保护的数据类型, 通过将 T 类型的数据作为互斥锁的一部分, 数据将只能通过互斥锁访问<br>\n这允许了一个安全的接口, 可以保证所有线程都将遵守协议</p>\n<p>为了确保锁定的互斥锁只能由锁定它的线程解锁, 它没有 <code>unlock()</code> 方法<br>\n相反, 它的 <code>lock()</code> 方法返回一个名为 <code>MutexGuard</code> 的特殊类型, 表示我们已锁定互斥锁的保证<br>\n它的行为类似于一个通过 <code>DerefMut</code> 获取的独占引用, 使我们能独占地访问互斥锁保护的数据<br>\n解锁互斥锁是通过 drop 这个 <code>MutexGuard</code> 类型的变量来完成的, 当我们放下 guard 时, 我们放弃了访问数据的能力, guard 的 Drop 实现将解锁互斥锁</p>\n<p>让我们看一个例子, 看看互斥锁在实践中的运用:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::Mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = Mutex::new(<span class=\"number\">0</span>);</span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            s.spawn(|| &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> guard = n.lock().unwrap();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">                    *guard += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(n.into_inner().unwrap(), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 我们有一个 <code>Mutex&lt;i32&gt;</code>, 一个保护整数的互斥锁, 我们生成十个线程, 每个线程将整数递增一百次<br>\n每个线程将首先锁定互斥锁, 以获取 <code>MutexGuard</code>, 然后使用该 guard 访问整数并对其进行修改<br>\n当 guard 超出作用域后, 其将立即被隐式地 drop</p>\n<p>线程完成后, 我们可以安全地从通过 <code>into_inner()</code> 方法以删除互斥保护<br>\n<code>into_inner</code> 方法获取了互斥锁的所有权, 这保证了没有其他任何东西可以再引用互斥锁, 因此不需要锁定</p>\n<p>即使增量以 1 为步长发生, 但观察整数的线程也只能看到 100 的倍数, 因为它只能在互斥锁解锁时查看整数<br>\n实际上, 由于互斥锁, 一百个增量现在是一个不可分割的操作, 这样不可分割的操作也称为原子操作</p>\n<p>为了清楚地看到互斥锁的效果, 我们可以让每个线程在解锁互斥锁之前等待一秒钟:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::time::Duration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = Mutex::new(<span class=\"number\">0</span>);</span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            s.spawn(|| &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> guard = n.lock().unwrap();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">                    *guard += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                thread::sleep(Duration::from_secs(<span class=\"number\">1</span>)); <span class=\"comment\">// New!</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(n.into_inner().unwrap(), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当您现在运行该程序时, 您将看到大约需要 10 秒才能完成, 每个线程只等待一秒钟, 但互斥锁会确保一次只有一个线程可以这样做</p>\n<p>如果我们在 sleep 前, 就 drop 掉 guard, 从而解锁互斥锁, 我们将看到它并行发生:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = Mutex::new(<span class=\"number\">0</span>);</span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            s.spawn(|| &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> guard = n.lock().unwrap();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">                    *guard += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">drop</span>(guard); <span class=\"comment\">// New: drop the guard before sleeping!</span></span><br><span class=\"line\">                thread::sleep(Duration::from_secs(<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(n.into_inner().unwrap(), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过此更改, 该程序只需大约一秒钟, 因为现在 10 个线程可以同时执行一秒钟的睡眠, 这表明尽可能缩短互斥锁锁定时间的重要性<br>\n当互斥锁锁定的时间超过必要的时间, 可能会完全抵消并行性的任何好处, 从而有效地强制所有内容按顺序发生</p>\n<h2 id=\"suo-zhong-du\" id=\"锁中毒\">锁中毒</h2>\n<p>上面示例中的 <code>unwrap()</code> 调用与锁中毒(Lock Poisoning)有关</p>\n<p>当线程在 lock 锁时发生 panic, <code>Mutex</code> 会被标记为中毒(Poisoned)<br>\n发生这种情况时, <code>Mutex</code> 将不再被锁定, 但调用其 <code>lock</code> 方法将导致得到一个 <code>Err</code>, 表示它已经中毒</p>\n<p>这是一种 “防止受互斥锁保护的数据处于不一致状态” 的机制<br>\n在上面的示例中, 若线程在将整数递增不到 100 次后出现 panic, 则互斥锁将解锁<br>\n此时整数将处于意外状态, 不再是 100 的倍数, 这可能会破坏其他线程的假设<br>\n在这种情况下, 自动将互斥锁标记为中毒, 会强制用户处理这种可能性</p>\n<p>在中毒的互斥锁上调用 <code>lock()</code> 仍会锁定互斥锁<br>\n<code>lock()</code> 返回的 <code>Err</code> 包含 <code>MutexGuard</code>, 允许我们在必要时更正不一致的状态</p>\n<p>虽然锁中毒似乎是种强大的机制, 但在实践中并不经常从潜在的不一致状态中恢复<br>\n大多数代码要么忽略锁中毒, 要么在锁中毒时使用 <code>unwrap()</code> 进行 panic, 从而有效地将 panic 传播给互斥锁的所有用户</p>\n<p><strong>Lifetime of the MutexGuard:</strong><br>\n虽然隐式地 drop 掉 guard 变量, 可以方便地解锁互斥锁, 但有时会导致微妙的意外<br>\n如果我们用 let 语句给 guard 分配一个名称(如上面的例子), 将会很直接地知晓它何时 drop, 因为局部变量在其作用域的末尾会自动被 drop<br>\n尽管如此, 不显式 drop 掉 guard, 可能会导致将互斥锁锁定的时间不必要的延长, 如上面的示例所示</p>\n<p>使用无名称的 guard 也是可能的, 有时甚至非常方便<br>\n由于 MutexGuard 的行为, 类似于对受保护数据的独占引用, 因此我们可以直接使用它, 而无需先为 guard 分配名称<br>\n例如, 如果您有 Mutex&lt;Vec<i32>&gt;, 则可在单个语句中, 锁定互斥锁, 进行 push, 最后再次解锁互斥锁(drop):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">list.lock().unwrap().push(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>这是因为, 在表达式中生成的任何临时变量(例如通过 lock() 返回的守卫)都将在语句末尾删除<br>\n虽然这看起来是显而易见且合理的, 但它会导致一个常见的陷阱, 通常涉及 <code>match</code>, <code>if let</code>, <code>while let</code> 语句<br>\n下面是遇到此陷阱的示例:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(item) = list.lock().unwrap().pop() &#123;</span><br><span class=\"line\">    process_item(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的意图, 是锁定 list, 随后 pop 一个元素并解锁 list, 最后处理该元素, 但我们在这犯了个微妙但重要的错误<br>\n临时生成 guard, 将会直到整个 if let 语句结束才会 drop, 这意味着我们在处理项目时, 保持了不必要的锁定</p>\n<p>令人惊讶的是, 对于类似的 if 语句, 这种情况不会发生:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> list.lock().unwrap().pop() == <span class=\"literal\">Some</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    do_something();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里, 不像先前的 <code>if let</code> 语句, 临时的 guard 确实在执行 if 语句的主体前就被 drop 了<br>\n原因是: 常规 if 语句的条件始终是普通 bool 值, 不会借用任何东西<br>\n因此, 没有理由将临时变量的 lifetime 从条件延长到语句结束</p>\n<p>但是, 对于 <code>if let</code> 语句, 情况可能并非如此<br>\n例如, 如果我们使用 <code>front()</code> 而不是 <code>pop()</code>, 则 item 将从列表中借用, 因此有必要保持警惕</p>\n<p>因为使用 <code>if let</code> 语句时可能会产生借用<br>\n于是在此情况下, 被创建的临时变量的生命周期, 被规定将会被延长到 <code>if let</code> 的主体结束<br>\n因此就算当我们使用 <code>pop()</code> 而非 <code>front()</code> 时, 也会发生同样的情况, 即使这不是必需的<br>\n故 guard 不会在第一时间被 drop 掉</p>\n<p>我们可以通过将 <code>pop</code> 操作移动到单独的 let 语句, 来避免这种情况<br>\n因此, 在该语句的末尾, 在 if let 之前, 被临时创建的 guard 将会被 drop:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> item = list.lock().unwrap().pop();</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(item) = item &#123;</span><br><span class=\"line\">    process_item(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"rw-lock\" id=\"RwLock\">RwLock</h2>\n<p>互斥锁只涉及独占访问, MutexGuard 将为我们提供对受保护数据的独占引用(&amp;mut T)<br>\n即使我们只想查看数据, 并使用已经足够满足需求的共享引用(&amp;T)</p>\n<p>读写锁(RwLock)是互斥锁的一个稍微复杂点的版本, 它了解独占访问和共享访问之间的区别, 并且可以提供两者之一<br>\n它有三种状态: 解锁, 由单个写入器(writer)锁定(用于独占访问), 被任意数量的读取器(reader)锁定(用于共享访问)<br>\n它通常用于经常由多个线程读取但仅偶尔更新一次的数据</p>\n<p>Rust 标准库通过 <code>std::sync::RwLock&lt;T&gt;</code> 类型提供此锁<br>\n它的工作方式与 <code>Mutex</code> 类似, 只是它的接口主要分为两部分<br>\n它不是单个 <code>lock()</code> 方法, 而是具有用于锁定为 writer 或 reader 的 <code>read()</code> 和 <code>write()</code> 方法<br>\n它有两种 guard 类型, 一种用于 reader, 一种用于writer: <code>RwLockReadGuard</code> 和 <code>RwLockWriteGuard</code><br>\n两者都实现了 <code>Deref</code> 以表现为对受保护数据的引用, 前者的表现类似于共享引用, 而后者的表现类似于独占引用</p>\n<p>它实际上是 <code>RefCell</code> 的多线程版本, 动态跟踪引用的数量, 以确保遵守借用规则</p>\n<p><code>Mutex&lt;T&gt;</code> 和 <code>RwLock&lt;T&gt;</code> 都要求 T 为 <code>Send</code>, 因为它们可用于将 <code>T</code> 发送到另一个线程<br>\n<code>RwLock&lt;T&gt;</code> 还需要 T 来实现 <code>Sync</code>, 因为它允许多个线程保存对受保护数据的共享引用(&amp;T)<br>\n严格来说, 您可以为不满足这些要求的 T 创建一个锁, 但您将无法在线程之间共享它, 因为锁本身不会实现 <code>Sync</code></p>\n<p>Rust 标准库只提供一种通用的 <code>RwLock</code> 类型, 但其实现取决于操作系统, 其实现之间存在许多细微差异<br>\n当有 writer 等待时, 大多数实现都会选择阻塞新的 reader, 即使锁已经 read-locked 也是如此<br>\n这是为了防止 <code>writer starvation(写饿死/写入器匮乏</code>), 即一种 “readers 过多导致锁一直无法被解锁, 导致 writer 无法更新数据” 的情况</p>\n<p><strong>Mutexes in Other Languages:</strong><br>\nRust 标准库中的 <code>Mutex</code> 和 <code>RwLock</code> 类型, 看起来与 C 或 C++ 等其他语言中的实现略有不同<br>\n最大的区别是 Rust 的 Mutex<T> 包含它正在保护的数据</p>\n<p>例如, 在 C++ 中, <code>std::mutex</code> 不包含它保护的数据, 甚至不知道它在保护什么<br>\n这意味着, 用户有责任记住哪些数据受到保护, 以及由哪个互斥锁保护, 并确保每次访问 “受保护数据” 时, 都锁定正确的互斥锁<br>\n在阅读涉及其他语言互斥体的代码时, 或者与不熟悉 Rust 的程序员交流时, 记住这一点很有用<br>\n一个 Rust 程序员可能会谈论 “互斥锁中的数据”, 或者 “将其包装在互斥锁中” 之类的话, 这可能会让那些只熟悉其他语言互斥锁的人感到困惑</p>\n<p>如果您确实需要一个不包含任何数据的独立互斥锁, 例如保护某些外部硬件, 则可使用 <code>Mutex&lt;()&gt;</code><br>\n但即使在这种情况下, 您最好定义一个(可能是零大小的)类型来与该硬件接口, 并将其包装在 <code>Mutex</code> 中<br>\n这样, 您仍然被迫锁定互斥锁, 然后才能与硬件交互</p>\n<hr>\n<h1 id=\"xian-cheng-deng-dai\">线程等待</h1>\n<p>当数据被多个线程改变时, 它们可能需要进行等待, 等到某些条件变为真再继续执行<br>\n例如, 如果我们有一个保护 <code>Vec</code> 的互斥锁, 我们可能需要等到它非空(被放入东西后再继续)</p>\n<p>互斥锁确实允许线程等待它被解锁, 但它不提供这种 “等待到某个条件成立” 的功能<br>\n如果我们只有一个互斥锁, 我们将不得不继续锁定互斥锁, 以反复检查 <code>Vec</code> 中是否有任何东西</p>\n<h2 id=\"thread-parking\" id=\"Thread-Parking\">Thread Parking</h2>\n<p>等待来自另一个线程的通知的一种方法, 称为 <code>thread parking(线程停放)</code><br>\n线程可以自行 park, 使其进入睡眠状态, 从而防止 CPU 空耗, 然后，另一个线程可以将线程唤醒/解除停放(unpark), 使其继续</p>\n<p><strong>译者注:</strong><br>\npark 的意思就是把车停放下来, 对应让线程进入睡眠<br>\nunpark 的意思就是把车开走, 对应让线程继续</p>\n<p>park 的行为, 可通过 <code>std::thread::park()</code> 函数表示<br>\nunpark 的行为, 您可以在要被唤醒的线程的 <code>Thread</code> 类型的对象上, 调用 <code>unpark()</code> 方法表示<br>\n<code>Thread</code> 对象可以从 <code>spawn</code> 返回的 <code>JoinHandle</code> 获取, 也可以通过 <code>std::thread::current()</code> 从线程本身获取</p>\n<p>让我们深入了解一个使用互斥锁, 在两个线程之间共享队列的示例<br>\n在以下示例中, 新生成的线程将消耗队列中的元素(consumer), 而主线程将每秒将一个新元素插入到队列(producter)<br>\npark 被用于让 comsumer 线程在队列为空时进行等待</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::VecDeque;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> queue = Mutex::new(VecDeque::new());</span><br><span class=\"line\"></span><br><span class=\"line\">    thread::scope(|s| &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Consuming thread</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> t = s.spawn(|| <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> item = queue.lock().unwrap().pop_front();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">Some</span>(item) = item &#123;</span><br><span class=\"line\">                dbg!(item);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                thread::park();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Producing thread</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>.. &#123;</span><br><span class=\"line\">            queue.lock().unwrap().push_back(i);</span><br><span class=\"line\">            t.thread().unpark();</span><br><span class=\"line\">            thread::sleep(Duration::from_secs(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个无限循环进行的例子, 在该循环中, 当元素不为空时, 它将元素从队列中弹出, 使用 <code>dbg!</code> 显示它们<br>\n当队列为空时, 它将调用 <code>park()</code>, 使线程进入睡眠状态, 防止 CPU 空耗<br>\n如果它被 unpark, 则先前调用的 <code>park()</code> 方法将会 return, 随后循环继续, 再次从队列中弹出元素, 直到它为空, 重复</p>\n<p>consumer 线程每秒生成一个新数字, 然后将其 push 到队列中<br>\n每次添加时, 都会在代表着 consumer 线程的 Thread 对象上, 调用 unpark() 方法来 unpark 它<br>\n这样, consumer 线程就会被唤醒, 以处理新的元素</p>\n<p>这里要提出的一个重要观察是, 如果我们删除对 park() 的调用, 这个程序在理论上仍然正确, 但效率低下<br>\n这非常重要, 因为 <code>park()</code> 不能保证它会只因为相匹配的 <code>unpark()</code> 而返回<br>\n虽然罕见, 但它可能会虚假的唤醒(spurious wake-ups)</p>\n<p>我们的示例很好地处理了这个问题, 因为 consumer 线程将锁定保护着队列的互斥锁, producter 线程将因此阻塞<br>\n随后, consumer 线程将检测队列是否为空, 当队列为空时, 就再次调用 <code>park()</code> 让自己进入睡眠状态<br>\nproducter 线程因此得以锁定互斥锁, 并对队列 push 新的元素, 随后调用 <code>unpark()</code> 唤醒 consumer 线程让其处理新元素</p>\n<p><code>Thread Parking</code> 的一个重要属性是, 对 <code>unpark()</code> 的调用在线程 park 自身之前, 不会丢失<br>\n对 unpark 的请求仍然会被记录, 下次线程尝试 park 时, 它会认识到该请求, 随后清除该请求后直接继续, 而不会实际进入睡眠<br>\n为了去了解为何这对正确性至关重要, 让我们来看看两个线程的执行步骤的可能顺序(从一开始观察):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>consumer 线程(简写为C)锁定了队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>C 尝试从队列中 pop 一个元素, 但它是空的, 结果为 None, 模式匹配后进去 else 分支</p>\n</li>\n<li class=\"lvl-3\">\n<p>C 解锁队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>producter 线程(简写为P)锁定了队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>P 将新元素 push 到队列中</p>\n</li>\n<li class=\"lvl-3\">\n<p>P 再次解锁队列</p>\n</li>\n<li class=\"lvl-3\">\n<p>P 调用 <code>unpark()</code> 通知 C 有新元素</p>\n</li>\n<li class=\"lvl-3\">\n<p>C 调用 <code>park()</code> 进入睡眠, 等待更多元素</p>\n</li>\n</ol>\n<h1 id=\"yi-xia-nei-rong-wei-ji-fan-huan-zai-gai-bie-zhao-ji\">以下内容为机翻还在改别着急</h1>\n<p>虽然在步骤 3 中解锁队列和在步骤 8 中 unpark 之间很可能只有非常短暂的时刻，但步骤 4 到 7 可能会在线程 pack 之前的那一刻发生<br>\n如果 <code>unpark()</code> 在线程未停放时不执行任何操作, 则通知将丢失, 使用线程仍将在等待, 即使队列中有项目也是如此<br>\n由于取消寄存请求被保存以供将来调用 park()我们不必担心这一点</p>\n<p>但是，取消寄存请求不会叠加。调用 unpark() 两次，然后调用 park() 两次仍会导致线程进入睡眠状态。前 park() 个清除请求并直接返回，但第二个像往常一样进入睡眠状态。</p>\n<p>这意味着在上面的示例中，重要的是，只有在看到队列为空时才停放线程，而不是在每个处理的项目之后停放它。虽然由于睡眠时间巨大（一秒），此示例中极不可能发生，但多个 unpark() 调用可能只唤醒一个 park() 调用。</p>\n<p>不幸的是，这确实意味着，如果在 park() 返回后立即调用 unpark() ，但在队列被锁定和清空之前，则 unpark() 调用是不必要的，但仍会导致下一个 park() 调用立即返回。这会导致（空）队列被锁定并解锁额外的时间。虽然这不会影响程序的正确性，但它确实会影响其效率和性能。</p>\n<p>此机制适用于像我们示例中这样的简单情况，但当事情变得更加复杂时，很快就会崩溃。例如，如果我们有多个使用者线程从同一队列中获取项目，则生产者线程将无法知道哪个使用者实际上正在等待并且应该被唤醒。生产者必须确切地知道消费者何时在等待，以及它正在等待什么条件。</p>\n<h2 id=\"condvar\" id=\"Condvar\">Condvar</h2>\n<p>条件变量是更常用的选项，用于等待受互斥锁保护的数据出现问题。它们有两个基本操作：等待和通知。线程可以等待条件变量，之后当另一个线程通知相同的条件变量时，它们可以被唤醒。多个线程可以等待同一个条件变量，通知可以发送到一个等待线程，也可以发送到所有线程。</p>\n<p>这意味着我们可以为我们感兴趣的特定事件或条件创建一个条件变量，例如队列为非空，并等待该条件。然后，导致该事件或条件发生的任何线程都会通知条件变量，而不必知道哪些线程或有多少线程对该通知感兴趣。</p>\n<p>为了避免在解锁互斥锁和等待条件变量之间的短暂时刻丢失通知的问题，条件变量提供了一种以原子方式解锁互斥锁并开始等待的方法。这意味着通知根本不可能丢失。</p>\n<p>Rust 标准库提供了一个条件变量为 std::sync::Condvar 。它的 wait 方法需要 MutexGuard 来证明我们已经锁定了互斥锁。它首先解锁互斥锁并进入睡眠状态。稍后，当唤醒时，它会重新锁定互斥锁并返回新的 MutexGuard （这证明互斥锁再次被锁定）。</p>\n<p>它有两个通知函数： notify_one 只唤醒一个等待线程（如果有）， notify_all 唤醒它们。</p>\n<p>让我们修改用于线程停放的示例，改用 Condvar ：</p>"},{"title":"rust-gtk4-p1~> 系列说明","abbrlink":"posts/rust-gtk4/p1","date":"2021-10-23T12:18:17.000Z","top":98999,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","next_post":["posts/rust-gtk4/p2","创建窗口"],"_content":"> 欢迎大家来到 Rust 的 gkt-rs 系列\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 系列说明\n[Gtk](https://www.gtk.org/), 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序  \n\nRust语言自是其中之一, 具有相关的绑定库: [gtk-rs](https://gtk-rs.org/) (gtk官方网页所指定)  \n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了  \n\n不定期更新, 毕竟我只有周末才能碰到电脑  \n~~(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)~~\n\n- - -\n# 参考资料\n资料正在持续更新ing. . .\n1. 书籍\n- [GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/) (官方书籍)\n\n- [Gtk4 Tutorial](https://toshiocp.github.io/Gtk4-tutorial/) (由社区编写的gtk4教学书籍)\n\n2. 博客/文档\n- [Rust Vs GUI](https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html)\n- [GObject Introspection](https://gi.readthedocs.io/en/latest/#gobject-introspection)\n- [GNOME Developer Doc/Tutorials](https://developer.gnome.org/documentation/tutorials.html)\n- - -\n# 环境配置\n首先请参照 [GTK官方页面](https://www.gtk.org/docs/installations/) , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:  \n\n- Fedora, 及其衍生:  \n\n```bash\nsudo dnf install gtk4-devel gcc libadwaita-devel\n```\n\n- Debian, 及其衍生:\n\n```bash\nsudo apt install libgtk-4-dev build-essential libadwaita-1-dev\n```\n\n- Arch, 及其衍生:\n\n```bash\nsudo pacman -S gtk4 base-devel libadwaita\n```\n\nWindows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 ~~(无视即可)~~  \n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可  \n\n请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk  \n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","source":"_posts/rust/gui/gtk4/p1-系列说明.md","raw":"---\ntitle: \"rust-gtk4-p1~> 系列说明\"\nabbrlink: posts/rust-gtk4/p1\ndate: 2021-10-23 20:18:17\ntop: 98999\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nnext_post: [posts/rust-gtk4/p2, 创建窗口]\n---\n> 欢迎大家来到 Rust 的 gkt-rs 系列\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 系列说明\n[Gtk](https://www.gtk.org/), 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序  \n\nRust语言自是其中之一, 具有相关的绑定库: [gtk-rs](https://gtk-rs.org/) (gtk官方网页所指定)  \n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了  \n\n不定期更新, 毕竟我只有周末才能碰到电脑  \n~~(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)~~\n\n- - -\n# 参考资料\n资料正在持续更新ing. . .\n1. 书籍\n- [GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/) (官方书籍)\n\n- [Gtk4 Tutorial](https://toshiocp.github.io/Gtk4-tutorial/) (由社区编写的gtk4教学书籍)\n\n2. 博客/文档\n- [Rust Vs GUI](https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html)\n- [GObject Introspection](https://gi.readthedocs.io/en/latest/#gobject-introspection)\n- [GNOME Developer Doc/Tutorials](https://developer.gnome.org/documentation/tutorials.html)\n- - -\n# 环境配置\n首先请参照 [GTK官方页面](https://www.gtk.org/docs/installations/) , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:  \n\n- Fedora, 及其衍生:  \n\n```bash\nsudo dnf install gtk4-devel gcc libadwaita-devel\n```\n\n- Debian, 及其衍生:\n\n```bash\nsudo apt install libgtk-4-dev build-essential libadwaita-1-dev\n```\n\n- Arch, 及其衍生:\n\n```bash\nsudo pacman -S gtk4 base-devel libadwaita\n```\n\nWindows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 ~~(无视即可)~~  \n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可  \n\n请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk  \n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","slug":"rust/gui/gtk4/p1-系列说明","published":1,"updated":"2021-10-23T12:18:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh9002jj1s69jts57i7","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p><a href=\"https://www.gtk.org/\">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序</p>\n<p>Rust语言自是其中之一, 具有相关的绑定库: <a href=\"https://gtk-rs.org/\">gtk-rs</a> (gtk官方网页所指定)<br>\n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了</p>\n<p>不定期更新, 毕竟我只有周末才能碰到电脑<br>\n<s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<p>资料正在持续更新ing. . .</p>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://gtk-rs.org/gtk4-rs/stable/latest/book/\">GUI development with Rust and GTK 4</a> (官方书籍)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://toshiocp.github.io/Gtk4-tutorial/\">Gtk4 Tutorial</a> (由社区编写的gtk4教学书籍)</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客/文档</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html\">Rust Vs GUI</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://gi.readthedocs.io/en/latest/#gobject-introspection\">GObject Introspection</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials.html\">GNOME Developer Doc/Tutorials</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-jing-pei-zhi\">环境配置</h1>\n<p>首先请参照 <a href=\"https://www.gtk.org/docs/installations/\">GTK官方页面</a> , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Fedora, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf install gtk4-devel gcc libadwaita-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Debian, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install libgtk-4-dev build-essential libadwaita-1-dev</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Arch, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gtk4 base-devel libadwaita</span><br></pre></td></tr></table></figure>\n<p>Windows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 <s>(无视即可)</s><br>\n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可</p>\n<p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":785,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p><a href=\"https://www.gtk.org/\">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序</p>\n<p>Rust语言自是其中之一, 具有相关的绑定库: <a href=\"https://gtk-rs.org/\">gtk-rs</a> (gtk官方网页所指定)<br>\n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了</p>\n<p>不定期更新, 毕竟我只有周末才能碰到电脑<br>\n<s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<p>资料正在持续更新ing. . .</p>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://gtk-rs.org/gtk4-rs/stable/latest/book/\">GUI development with Rust and GTK 4</a> (官方书籍)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://toshiocp.github.io/Gtk4-tutorial/\">Gtk4 Tutorial</a> (由社区编写的gtk4教学书籍)</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客/文档</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html\">Rust Vs GUI</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://gi.readthedocs.io/en/latest/#gobject-introspection\">GObject Introspection</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials.html\">GNOME Developer Doc/Tutorials</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-jing-pei-zhi\">环境配置</h1>\n<p>首先请参照 <a href=\"https://www.gtk.org/docs/installations/\">GTK官方页面</a> , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Fedora, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf install gtk4-devel gcc libadwaita-devel</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Debian, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install libgtk-4-dev build-essential libadwaita-1-dev</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Arch, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gtk4 base-devel libadwaita</span><br></pre></td></tr></table></figure>\n<p>Windows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 <s>(无视即可)</s><br>\n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可</p>\n<p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"},{"title":"rust-gtk4-p2~> 创建窗口","abbrlink":"posts/rust-gtk4/p2","date":"2021-11-07T02:16:57.000Z","top":98998,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p1","系列说明"],"next_post":["posts/rust-gtk4/p3","GObject: 内存管理"],"_content":"> 让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧  \n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 背景了解  \n## GTK\nGTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n在gtk3后, 由于GI([GObject Introspection](https://gi.readthedocs.io/en/latest/)) 的应用, 可以轻松地, 创建其他语言的绑定  \n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript... ~~(不会真的有人用C语言写Gtk吧?)~~  \n\n基本上名气稍微大点的语言, 都有对应的GTK绑定    \n\n## gtk-rs\n目前有个项目, 叫做 [gtk-rs](https://gtk-rs.org/), 负责GTK的Rust绑定, 在 [crates.io](https://crates.io/) 上搜索 gtk, 所看到的 [gtk](https://crates.io/crates/gtk) 与 [gtk4](https://crates.io/crates/gtk4), 就属于gtk-rs\n\ngtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身  \n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上  \n\n- - -\n\n# 项目配置\n首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 请输入以下命令:  \n\n```toml\ncargo add gtk4@0.5.2 --rename gtk\ncargo add libadwaita@0.2 --rename adw\n```\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4/libadwaita, 如 [p1](/posts/rust-gtk4/p1) 中所述)  \n(adw 这个库之后会提的, 现在先忽略掉即可)\n下面就是正式的编码环节了\n\n- - -\n\n# 加速编译\n有个非常快速的名为 [mold (github.com/rui314/mold)](https://github.com/rui314/mold) 的链接器, 非常适合加速 gtk 项目的编译, 以便快速调试  \n直接用你的包管理器下载 `mold`, 或者根据 github 的指示获取, 随后像下面这样简单的添加前缀即可:  \n\n```rust\nmold -run cargo run\n```\n\n- - -\n\n# 基础知识\n一个GTK4应用的创建, 需要用到 `gtk::Application`  \n同时还需 `use gtk::prelude::*`, 原因与 [std::prelude](https://doc.rust-lang.org/std/prelude/index.html) 一样  \n\n先创建一个应用, 它目前连窗口也没有:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.run();\n}\n```\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\n- [application_id](https://developer.gnome.org/documentation/tutorials/application-id.html):  \n每个GTK应用, 都带有一个id, 即 `application_id`, 它必须是全世界唯一的, 一般使用反域名作为id, 如 \"org.gnome.gedit\"  \n`app_id` 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!  \n\n- [Builder Pattern (一种Rust中常见的设计模式)](http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html):  \n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: `application_id(id: &str)`  \n在gtk4中, 它被高频次地使用, 最后调用的 `build` 会生成比如窗口, 按钮等部件的实例  \n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话\n\n- - -\n\n# 信号量\n当你跃跃欲试, `mold -run cargo run` 之后, 会看到:  \n\n```bash\nGLib-GIO-WARNING : Your application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal.  \nIt should do one of these.\n```\n\n靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n当然, 现在还无法执行, 请注意 `build_ui` 函数中的 `todo!()`, 我们还没有填充这个函数!  \n因为我想逐步地讲解一下... 先来讲什么是 signal 吗:  \n\n当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度  \n比如窗口打开, 按钮被点击, 拖动控件...这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了  \n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了  \n\n- 我们把处理函数, 称之为 `handler`\n- 我们将为 signal 绑定一个 handler 的过程, 称之为 `connect`\n\nGtk 的理念是: App只关心在特定的时候需要做的事情  \n`事件发送的时间` , 即 signal 什么时候发送已经定好了, 至于 `事情的内容`, 即 handler 的具体实现, 由开发者自己负责    \n\n下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:  \n\n- startup: \n在App第一次启动时被调用, 用于与UI显示无关的初始化任务  \n- shutdown: \n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C\n- activate:\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口  \n- open\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件  \n\n正如上面第三个信号所说, 一个GtkApp至少得有一个窗口  \n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口  \n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化  \n\n这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象\n\n- - - \n\n# 创建空白窗口\n\n回到之前的代码, 如下:\n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n```\nYour application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal. \n```\n\n现在你应该明白, 为什么之前会报出这个警告了吧? `connect_xxxx`, 代表着连接某个 signal , 即实现对应的虚函数/handler  \n\n`connect_activate`, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 `&Application`  \n我们创建的这个函数, 名为 `build_ui`, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这...啧, 不太聪明?  \n\n直接上 `build_ui` 的代码, 注意 use 那边多了东西:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .build();\n    win.present();\n}\n```\n\n我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它  \n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 `My App`  \n\n在App启动之后的某时刻, `activate` 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现  \n但现在, 我们已经将它覆盖成自己的 `build_ui` 了, 因此警告不再出现  \n\n- - -\n\n# 新增按钮\n\n让我们再创建一个按钮, 提示信息是 `Press me!`, 在按下之后, 变成显示 `Hello World!`:  \n\n```rust\nuse gtk::{prelude::*, Button};\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let btn = Button::builder().label(\"Press me!\").build();\n    btn.connect_clicked(|btn| btn.set_label(\"Hello World!\"));\n\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .child(&btn)\n        .build();\n\n    win.present();\n}\n```\n\n我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已  \n\n之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler  \n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理  \n\n然后, 我们在使用 `Builder Pattern` 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中  \n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲  \n\n- - - \n\n# 常见设置\n~~稍微再水一点字数~~  \n\n- 设置间距:  \n运行先前的代码, 你会发现按钮占满了整个窗口  \n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:\n\n```rust\nlet btn = Button::builder()\n    .label(\"Press me!\")\n    .margin_top(12)\n    .margin_bottom(12)\n    .margin_start(12)\n    .margin_end(12)\n    .build();\n```\n\n- 透明设置:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .opacity(0.8)         // 窗口不透明度, 越低越透明, 越高越不透明\n    .build();\n```\n\n- 默认高宽:\n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .default_height(100)\n    .default_width(200)\n    .build();\n```\n\n\n至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 :)  ","source":"_posts/rust/gui/gtk4/p2-创建窗口.md","raw":"---\ntitle: \"rust-gtk4-p2~> 创建窗口\"\nabbrlink: posts/rust-gtk4/p2\ndate: 2021-11-07 10:16:57\ntop: 98998\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p1, 系列说明]\nnext_post: [posts/rust-gtk4/p3, \"GObject: 内存管理\"]\n---\n> 让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧  \n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 背景了解  \n## GTK\nGTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n在gtk3后, 由于GI([GObject Introspection](https://gi.readthedocs.io/en/latest/)) 的应用, 可以轻松地, 创建其他语言的绑定  \n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript... ~~(不会真的有人用C语言写Gtk吧?)~~  \n\n基本上名气稍微大点的语言, 都有对应的GTK绑定    \n\n## gtk-rs\n目前有个项目, 叫做 [gtk-rs](https://gtk-rs.org/), 负责GTK的Rust绑定, 在 [crates.io](https://crates.io/) 上搜索 gtk, 所看到的 [gtk](https://crates.io/crates/gtk) 与 [gtk4](https://crates.io/crates/gtk4), 就属于gtk-rs\n\ngtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身  \n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上  \n\n- - -\n\n# 项目配置\n首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 请输入以下命令:  \n\n```toml\ncargo add gtk4@0.5.2 --rename gtk\ncargo add libadwaita@0.2 --rename adw\n```\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4/libadwaita, 如 [p1](/posts/rust-gtk4/p1) 中所述)  \n(adw 这个库之后会提的, 现在先忽略掉即可)\n下面就是正式的编码环节了\n\n- - -\n\n# 加速编译\n有个非常快速的名为 [mold (github.com/rui314/mold)](https://github.com/rui314/mold) 的链接器, 非常适合加速 gtk 项目的编译, 以便快速调试  \n直接用你的包管理器下载 `mold`, 或者根据 github 的指示获取, 随后像下面这样简单的添加前缀即可:  \n\n```rust\nmold -run cargo run\n```\n\n- - -\n\n# 基础知识\n一个GTK4应用的创建, 需要用到 `gtk::Application`  \n同时还需 `use gtk::prelude::*`, 原因与 [std::prelude](https://doc.rust-lang.org/std/prelude/index.html) 一样  \n\n先创建一个应用, 它目前连窗口也没有:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.run();\n}\n```\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\n- [application_id](https://developer.gnome.org/documentation/tutorials/application-id.html):  \n每个GTK应用, 都带有一个id, 即 `application_id`, 它必须是全世界唯一的, 一般使用反域名作为id, 如 \"org.gnome.gedit\"  \n`app_id` 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!  \n\n- [Builder Pattern (一种Rust中常见的设计模式)](http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html):  \n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: `application_id(id: &str)`  \n在gtk4中, 它被高频次地使用, 最后调用的 `build` 会生成比如窗口, 按钮等部件的实例  \n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话\n\n- - -\n\n# 信号量\n当你跃跃欲试, `mold -run cargo run` 之后, 会看到:  \n\n```bash\nGLib-GIO-WARNING : Your application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal.  \nIt should do one of these.\n```\n\n靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n当然, 现在还无法执行, 请注意 `build_ui` 函数中的 `todo!()`, 我们还没有填充这个函数!  \n因为我想逐步地讲解一下... 先来讲什么是 signal 吗:  \n\n当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度  \n比如窗口打开, 按钮被点击, 拖动控件...这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了  \n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了  \n\n- 我们把处理函数, 称之为 `handler`\n- 我们将为 signal 绑定一个 handler 的过程, 称之为 `connect`\n\nGtk 的理念是: App只关心在特定的时候需要做的事情  \n`事件发送的时间` , 即 signal 什么时候发送已经定好了, 至于 `事情的内容`, 即 handler 的具体实现, 由开发者自己负责    \n\n下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:  \n\n- startup: \n在App第一次启动时被调用, 用于与UI显示无关的初始化任务  \n- shutdown: \n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C\n- activate:\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口  \n- open\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件  \n\n正如上面第三个信号所说, 一个GtkApp至少得有一个窗口  \n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口  \n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化  \n\n这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象\n\n- - - \n\n# 创建空白窗口\n\n回到之前的代码, 如下:\n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n```\nYour application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal. \n```\n\n现在你应该明白, 为什么之前会报出这个警告了吧? `connect_xxxx`, 代表着连接某个 signal , 即实现对应的虚函数/handler  \n\n`connect_activate`, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 `&Application`  \n我们创建的这个函数, 名为 `build_ui`, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这...啧, 不太聪明?  \n\n直接上 `build_ui` 的代码, 注意 use 那边多了东西:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .build();\n    win.present();\n}\n```\n\n我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它  \n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 `My App`  \n\n在App启动之后的某时刻, `activate` 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现  \n但现在, 我们已经将它覆盖成自己的 `build_ui` 了, 因此警告不再出现  \n\n- - -\n\n# 新增按钮\n\n让我们再创建一个按钮, 提示信息是 `Press me!`, 在按下之后, 变成显示 `Hello World!`:  \n\n```rust\nuse gtk::{prelude::*, Button};\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let btn = Button::builder().label(\"Press me!\").build();\n    btn.connect_clicked(|btn| btn.set_label(\"Hello World!\"));\n\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .child(&btn)\n        .build();\n\n    win.present();\n}\n```\n\n我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已  \n\n之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler  \n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理  \n\n然后, 我们在使用 `Builder Pattern` 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中  \n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲  \n\n- - - \n\n# 常见设置\n~~稍微再水一点字数~~  \n\n- 设置间距:  \n运行先前的代码, 你会发现按钮占满了整个窗口  \n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:\n\n```rust\nlet btn = Button::builder()\n    .label(\"Press me!\")\n    .margin_top(12)\n    .margin_bottom(12)\n    .margin_start(12)\n    .margin_end(12)\n    .build();\n```\n\n- 透明设置:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .opacity(0.8)         // 窗口不透明度, 越低越透明, 越高越不透明\n    .build();\n```\n\n- 默认高宽:\n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .default_height(100)\n    .default_width(200)\n    .build();\n```\n\n\n至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 :)  ","slug":"rust/gui/gtk4/p2-创建窗口","published":1,"updated":"2021-11-07T02:16:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oh9002lj1s6h7276thr","content":"<blockquote>\n<p>让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"bei-jing-liao-jie\">背景了解</h1>\n<h2 id=\"gtk\" id=\"GTK\">GTK</h2>\n<p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写<br>\n在gtk3后, 由于GI(<a href=\"https://gi.readthedocs.io/en/latest/\">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定<br>\n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript… <s>(不会真的有人用C语言写Gtk吧?)</s></p>\n<p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p>\n<h2 id=\"gtk-rs\" id=\"gtk-rs\">gtk-rs</h2>\n<p>目前有个项目, 叫做 <a href=\"https://gtk-rs.org/\">gtk-rs</a>, 负责GTK的Rust绑定, 在 <a href=\"https://crates.io/\">crates.io</a> 上搜索 gtk, 所看到的 <a href=\"https://crates.io/crates/gtk\">gtk</a> 与 <a href=\"https://crates.io/crates/gtk4\">gtk4</a>, 就属于gtk-rs</p>\n<p>gtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身<br>\n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上</p>\n<hr>\n<h1 id=\"xiang-mu-pei-zhi\">项目配置</h1>\n<p>首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 请输入以下命令:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo add gtk4@0.5.2 --rename gtk</span><br><span class=\"line\">cargo add libadwaita@0.2 --rename adw</span><br></pre></td></tr></table></figure>\n<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4/libadwaita, 如 <a href=\"/posts/rust-gtk4/p1\">p1</a> 中所述)<br>\n(adw 这个库之后会提的, 现在先忽略掉即可)<br>\n下面就是正式的编码环节了</p>\n<hr>\n<h1 id=\"jia-su-bian-yi\">加速编译</h1>\n<p>有个非常快速的名为 <a href=\"https://github.com/rui314/mold\">mold (github.com/rui314/mold)</a> 的链接器, 非常适合加速 gtk 项目的编译, 以便快速调试<br>\n直接用你的包管理器下载 <code>mold</code>, 或者根据 github 的指示获取, 随后像下面这样简单的添加前缀即可:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">mold -run cargo run</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ji-chu-zhi-shi\">基础知识</h1>\n<p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>\n同时还需 <code>use gtk::prelude::*</code>, 原因与 <a href=\"https://doc.rust-lang.org/std/prelude/index.html\">std::prelude</a> 一样</p>\n<p>先创建一个应用, 它目前连窗口也没有:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单吧? 但别急着运行, 先看看下面两处:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials/application-id.html\">application_id</a>:<br>\n每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的, 一般使用反域名作为id, 如 “org.gnome.gedit”<br>\n<code>app_id</code> 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html\">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>\n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: <code>application_id(id: &amp;str)</code><br>\n在gtk4中, 它被高频次地使用, 最后调用的 <code>build</code> 会生成比如窗口, 按钮等部件的实例<br>\n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"xin-hao-liang\">信号量</h1>\n<p>当你跃跃欲试, <code>mold -run cargo run</code> 之后, 会看到:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLib-GIO-WARNING : Your application does not implement g_application_activate()</span><br><span class=\"line\">and has no handlers connected to the <span class=\"string\">&#x27;activate&#x27;</span> signal.  </span><br><span class=\"line\">It should <span class=\"keyword\">do</span> one of these.</span><br></pre></td></tr></table></figure>\n<p>靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然, 现在还无法执行, 请注意 <code>build_ui</code> 函数中的 <code>todo!()</code>, 我们还没有填充这个函数!<br>\n因为我想逐步地讲解一下… 先来讲什么是 signal 吗:</p>\n<p>当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度<br>\n比如窗口打开, 按钮被点击, 拖动控件…这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了<br>\n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们把处理函数, 称之为 <code>handler</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>我们将为 signal 绑定一个 handler 的过程, 称之为 <code>connect</code></p>\n</li>\n</ul>\n<p>Gtk 的理念是: App只关心在特定的时候需要做的事情<br>\n<code>事件发送的时间</code> , 即 signal 什么时候发送已经定好了, 至于 <code>事情的内容</code>, 即 handler 的具体实现, 由开发者自己负责</p>\n<p>下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>startup:<br>\n在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>shutdown:<br>\n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p>\n</li>\n<li class=\"lvl-2\">\n<p>activate:<br>\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p>open<br>\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p>\n</li>\n</ul>\n<p>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>\n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口<br>\n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化</p>\n<p>这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象</p>\n<hr>\n<h1 id=\"chuang-jian-kong-bai-chuang-kou\">创建空白窗口</h1>\n<p>回到之前的代码, 如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Your <span class=\"built_in\">application</span> <span class=\"keyword\">does</span> <span class=\"keyword\">not</span> implement g_application_activate()</span><br><span class=\"line\"><span class=\"keyword\">and</span> has no handlers connected <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> &#x27;<span class=\"built_in\">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure>\n<p>现在你应该明白, 为什么之前会报出这个警告了吧? <code>connect_xxxx</code>, 代表着连接某个 signal , 即实现对应的虚函数/handler</p>\n<p><code>connect_activate</code>, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 <code>&amp;Application</code><br>\n我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这…啧, 不太聪明?</p>\n<p>直接上 <code>build_ui</code> 的代码, 注意 use 那边多了东西:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它<br>\n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 <code>My App</code></p>\n<p>在App启动之后的某时刻, <code>activate</code> 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现<br>\n但现在, 我们已经将它覆盖成自己的 <code>build_ui</code> 了, 因此警告不再出现</p>\n<hr>\n<h1 id=\"xin-zeng-an-niu\">新增按钮</h1>\n<p>让我们再创建一个按钮, 提示信息是 <code>Press me!</code>, 在按下之后, 变成显示 <code>Hello World!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;prelude::*, Button&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn = Button::builder().label(<span class=\"string\">&quot;Press me!&quot;</span>).build();</span><br><span class=\"line\">    btn.connect_clicked(|btn| btn.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;btn)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已</p>\n<p>之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler<br>\n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理</p>\n<p>然后, 我们在使用 <code>Builder Pattern</code> 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中<br>\n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲</p>\n<hr>\n<h1 id=\"chang-jian-she-zhi\">常见设置</h1>\n<p><s>稍微再水一点字数</s></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设置间距:<br>\n运行先前的代码, 你会发现按钮占满了整个窗口<br>\n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = Button::builder()</span><br><span class=\"line\">    .label(<span class=\"string\">&quot;Press me!&quot;</span>)</span><br><span class=\"line\">    .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_bottom(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>透明设置:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .opacity(<span class=\"number\">0.8</span>)         <span class=\"comment\">// 窗口不透明度, 越低越透明, 越高越不透明</span></span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认高宽:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .default_height(<span class=\"number\">100</span>)</span><br><span class=\"line\">    .default_width(<span class=\"number\">200</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<p>至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 😃</p>\n","site":{"data":{}},"length":5150,"excerpt":"<blockquote>\n<p>让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"bei-jing-liao-jie\">背景了解</h1>\n<h2 id=\"gtk\" id=\"GTK\">GTK</h2>\n<p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写<br>\n在gtk3后, 由于GI(<a href=\"https://gi.readthedocs.io/en/latest/\">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定<br>\n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript… <s>(不会真的有人用C语言写Gtk吧?)</s></p>\n<p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p>\n<h2 id=\"gtk-rs\" id=\"gtk-rs\">gtk-rs</h2>\n<p>目前有个项目, 叫做 <a href=\"https://gtk-rs.org/\">gtk-rs</a>, 负责GTK的Rust绑定, 在 <a href=\"https://crates.io/\">crates.io</a> 上搜索 gtk, 所看到的 <a href=\"https://crates.io/crates/gtk\">gtk</a> 与 <a href=\"https://crates.io/crates/gtk4\">gtk4</a>, 就属于gtk-rs</p>\n<p>gtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身<br>\n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上</p>\n<hr>\n<h1 id=\"xiang-mu-pei-zhi\">项目配置</h1>\n<p>首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 请输入以下命令:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo add gtk4@0.5.2 --rename gtk</span><br><span class=\"line\">cargo add libadwaita@0.2 --rename adw</span><br></pre></td></tr></table></figure>\n<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4/libadwaita, 如 <a href=\"/posts/rust-gtk4/p1\">p1</a> 中所述)<br>\n(adw 这个库之后会提的, 现在先忽略掉即可)<br>\n下面就是正式的编码环节了</p>\n<hr>\n<h1 id=\"jia-su-bian-yi\">加速编译</h1>\n<p>有个非常快速的名为 <a href=\"https://github.com/rui314/mold\">mold (github.com/rui314/mold)</a> 的链接器, 非常适合加速 gtk 项目的编译, 以便快速调试<br>\n直接用你的包管理器下载 <code>mold</code>, 或者根据 github 的指示获取, 随后像下面这样简单的添加前缀即可:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">mold -run cargo run</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ji-chu-zhi-shi\">基础知识</h1>\n<p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>\n同时还需 <code>use gtk::prelude::*</code>, 原因与 <a href=\"https://doc.rust-lang.org/std/prelude/index.html\">std::prelude</a> 一样</p>\n<p>先创建一个应用, 它目前连窗口也没有:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单吧? 但别急着运行, 先看看下面两处:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials/application-id.html\">application_id</a>:<br>\n每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的, 一般使用反域名作为id, 如 “org.gnome.gedit”<br>\n<code>app_id</code> 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html\">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>\n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: <code>application_id(id: &amp;str)</code><br>\n在gtk4中, 它被高频次地使用, 最后调用的 <code>build</code> 会生成比如窗口, 按钮等部件的实例<br>\n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"xin-hao-liang\">信号量</h1>\n<p>当你跃跃欲试, <code>mold -run cargo run</code> 之后, 会看到:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLib-GIO-WARNING : Your application does not implement g_application_activate()</span><br><span class=\"line\">and has no handlers connected to the <span class=\"string\">&#x27;activate&#x27;</span> signal.  </span><br><span class=\"line\">It should <span class=\"keyword\">do</span> one of these.</span><br></pre></td></tr></table></figure>\n<p>靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然, 现在还无法执行, 请注意 <code>build_ui</code> 函数中的 <code>todo!()</code>, 我们还没有填充这个函数!<br>\n因为我想逐步地讲解一下… 先来讲什么是 signal 吗:</p>\n<p>当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度<br>\n比如窗口打开, 按钮被点击, 拖动控件…这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了<br>\n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们把处理函数, 称之为 <code>handler</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>我们将为 signal 绑定一个 handler 的过程, 称之为 <code>connect</code></p>\n</li>\n</ul>\n<p>Gtk 的理念是: App只关心在特定的时候需要做的事情<br>\n<code>事件发送的时间</code> , 即 signal 什么时候发送已经定好了, 至于 <code>事情的内容</code>, 即 handler 的具体实现, 由开发者自己负责</p>\n<p>下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>startup:<br>\n在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>shutdown:<br>\n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p>\n</li>\n<li class=\"lvl-2\">\n<p>activate:<br>\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p>open<br>\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p>\n</li>\n</ul>\n<p>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>\n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口<br>\n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化</p>\n<p>这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象</p>\n<hr>\n<h1 id=\"chuang-jian-kong-bai-chuang-kou\">创建空白窗口</h1>\n<p>回到之前的代码, 如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Your <span class=\"built_in\">application</span> <span class=\"keyword\">does</span> <span class=\"keyword\">not</span> implement g_application_activate()</span><br><span class=\"line\"><span class=\"keyword\">and</span> has no handlers connected <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> &#x27;<span class=\"built_in\">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure>\n<p>现在你应该明白, 为什么之前会报出这个警告了吧? <code>connect_xxxx</code>, 代表着连接某个 signal , 即实现对应的虚函数/handler</p>\n<p><code>connect_activate</code>, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 <code>&amp;Application</code><br>\n我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这…啧, 不太聪明?</p>\n<p>直接上 <code>build_ui</code> 的代码, 注意 use 那边多了东西:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它<br>\n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 <code>My App</code></p>\n<p>在App启动之后的某时刻, <code>activate</code> 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现<br>\n但现在, 我们已经将它覆盖成自己的 <code>build_ui</code> 了, 因此警告不再出现</p>\n<hr>\n<h1 id=\"xin-zeng-an-niu\">新增按钮</h1>\n<p>让我们再创建一个按钮, 提示信息是 <code>Press me!</code>, 在按下之后, 变成显示 <code>Hello World!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;prelude::*, Button&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn = Button::builder().label(<span class=\"string\">&quot;Press me!&quot;</span>).build();</span><br><span class=\"line\">    btn.connect_clicked(|btn| btn.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;btn)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已</p>\n<p>之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler<br>\n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理</p>\n<p>然后, 我们在使用 <code>Builder Pattern</code> 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中<br>\n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲</p>\n<hr>\n<h1 id=\"chang-jian-she-zhi\">常见设置</h1>\n<p><s>稍微再水一点字数</s></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设置间距:<br>\n运行先前的代码, 你会发现按钮占满了整个窗口<br>\n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = Button::builder()</span><br><span class=\"line\">    .label(<span class=\"string\">&quot;Press me!&quot;</span>)</span><br><span class=\"line\">    .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_bottom(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>透明设置:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .opacity(<span class=\"number\">0.8</span>)         <span class=\"comment\">// 窗口不透明度, 越低越透明, 越高越不透明</span></span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认高宽:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .default_height(<span class=\"number\">100</span>)</span><br><span class=\"line\">    .default_width(<span class=\"number\">200</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<p>至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 😃</p>"},{"title":"rust-gtk4-p3~> GObject: 内存管理","abbrlink":"posts/rust-gtk4/p3","date":"2022-03-30T04:01:22.000Z","top":98997,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p2","创建窗口"],"next_post":["posts/rust-gtk4/p4","GObject: 子类化"],"_content":"> 来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏  \n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# Widget\n任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念  \n再比如, `Button(按钮)`, `Container(容器)`, 都属于 `Widget`  \n\n[Widget Gallery](https://docs.gtk.org/gtk4/visual_index.html) 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 `Widget`  \n\n我们甚至能自定义出新的Widget, 通过`继承/子类化`, 因为 Gtk 是面向对象的GUI框架  \n例如 `Button`, 其继承树如下:  \n\n```\nGObject\n└── Widget\n    └── Button\n```\n\nGObject, 也就是 `gtk::glib::object::Object`, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性  \n举个例子, GObject 具有 `引用计数` 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存  \n\n接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n- - -\n\n# 错误实现\n首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 :)  \n\n为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?  \n下面是代码, 已经讲过的概念不再重复:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow, Button, Orientation};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    // 创建两个按钮, 设置Label\n    let btn_inc = Button::builder()\n        .label(\"Increase\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n    let btn_dec = Button::builder()\n        .label(\"Decrease\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n\n    // `Clicked` 事件发生后的处理函数\n    // 出于简单演示的目的, 这里只是单纯的加减数字而已\n    let mut num = 0;\n    btn_inc.connect_clicked(|_| {\n        num += 1;\n    });\n    btn_dec.connect_clicked(|_| {\n        num -= 1;\n    });\n\n    // 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下\n    // 因此, 从上往下第一个是btn_inc, 第二个是btn_dec\n    let gtk_box = gtk::Box::builder()\n        .orientation(Orientation::Vertical)\n        .build();\n    gtk_box.append(&btn_inc);\n    gtk_box.append(&btn_dec);\n\n    // 窗口只能设置一个child, 因此把容器添加进去\n    // 随后在容器中添加很多 widget, 达到全添加进去的目的\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My Gtk App\")\n        .child(&gtk_box)\n        .build();\n    win.present();\n}\n```\n\n显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错  \n如果看下 `connect_clicked` 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime  \n\n道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?  \n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量  \n\n我们可以选择为闭包添加前缀, 即添加关键字 `move`, 让被闭包捕获的变量, 其所有权转移到闭包中  \n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?  \n\n但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!  \n有没有什么办法, 让这两个闭包都能拥有num的所有权?  \n\n请看下面的正确实现, 通过引用计数的方式 :)\n- - -\n\n# 引用计数\n\n嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 ~~(GUI框架好像都是单线程的?)~~  \n那就可以使用 `std::rc::Rc` 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权  \n\n多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 `std::cell::Cell`  \n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 `Rc<Cell<i32>>`  \n\n**提示**  \n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell  \n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解\n\n下面是代码, 请务必记得use一下:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nlet num_clone = num.clone();\n\nbtn_inc.connect_clicked(|_| {\n    num_clone.set(num_clone.get() + 1);\n});\nbtn_dec.connect_clicked(|_| {\n    num.set(num.get() - 1);\n});\n```\n\n感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过  \n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?  \n\n让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全  \n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值  \n\n在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T>  \n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量  \n\n但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?  \n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作  \n\n- - -\n\n# clone!\nYeah, 这个宏的名字就叫clone: `glib::clone`, 你可以查看对应的文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n请务必注意use必须像下面这样写, 你得先 `use gtk::glib`, 随后 `use glib::clone`:  \n\n```rust\nuse std::cell::Cell;\nuse std::rc::Rc;\n\nuse glib::clone;\nuse gtk::prelude::*;   // 这里\nuse gtk::{glib, Application, ApplicationWindow, Button, Orientation};  // 这里\n```\n\n如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n使用 `clone!` 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)  \n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存  \n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回  \n\n懂了基础的原理后 ~~(我个人喜欢把读者当傻子, 因此尽量提一嘴)~~, 我们来看看上面这段代码:  \n\n- 在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建  \n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num  \n\n- 两个闭包中, 我们都创建了另一个按钮的 strong-ref  \n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec  \n\n**注意:**  \n`clone!`, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 `()` 值  \n详情请见文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n\n\n至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:  \n循环引用导致内存泄漏!  \n\n- - -\n\n# 循环引用\nRust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在  \n~~(大佬们可能一眼就看出来哪里循环引用了...)~~\n\n贴一份刚刚的代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref  \n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存  \n这就是 `循环引用`\n\n由于 `循环引用`, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 `内存泄漏`  \n\n如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @weak btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@weak btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 `btn_inc`/`btn_dec`  \n在闭包中, 对这两个btn都是弱引用, 当 `build_ui` 调用完毕后, 它们应该会自动drop掉 (因为作用域)  \n\n但若改成 weak-ref, `btn_inc`/`btn_dec` 不会因缺少 strong-ref 而出现问题吗?  \n答案是不会, 原因是以下两段代码  \n\n\n- 第一段:  \n\n```rust\nlet gtk_box = gtk::Box::builder()\n    .orientation(Orientation::Vertical)\n    .build();\ngtk_box.append(&btn_inc);\ngtk_box.append(&btn_dec);\n```\n\n- 第二段:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .child(&gtk_box)\n    .build();\nwin.present();\n```\n\n第一段中, `btn_inc`/`btn_dec` 的引用交给了 `append()`  \n第二段中, `gtk_box` 的引用交给了 `child()`  \n\n还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性  \n`append()`, `child()`, 都保持了对这些 Widget 的强引用, 保持了它们的活性:  \n`gtk_box` 持有对 `btn` 的 strong-ref, `win` 持有对 `gtk_box` 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着  \nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着  \n\n总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已  \n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!  \n\n本节到此结束, 要鸽一会了, 我们下节见 :)","source":"_posts/rust/gui/gtk4/p3-GObject-内存管理.md","raw":"---\ntitle: \"rust-gtk4-p3~> GObject: 内存管理\"\nabbrlink: posts/rust-gtk4/p3\ndate: 2022-03-30 12:01:22\ntop: 98997\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p2, 创建窗口]\nnext_post: [posts/rust-gtk4/p4, \"GObject: 子类化\"]\n---\n> 来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏  \n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# Widget\n任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念  \n再比如, `Button(按钮)`, `Container(容器)`, 都属于 `Widget`  \n\n[Widget Gallery](https://docs.gtk.org/gtk4/visual_index.html) 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 `Widget`  \n\n我们甚至能自定义出新的Widget, 通过`继承/子类化`, 因为 Gtk 是面向对象的GUI框架  \n例如 `Button`, 其继承树如下:  \n\n```\nGObject\n└── Widget\n    └── Button\n```\n\nGObject, 也就是 `gtk::glib::object::Object`, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性  \n举个例子, GObject 具有 `引用计数` 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存  \n\n接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n- - -\n\n# 错误实现\n首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 :)  \n\n为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?  \n下面是代码, 已经讲过的概念不再重复:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow, Button, Orientation};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    // 创建两个按钮, 设置Label\n    let btn_inc = Button::builder()\n        .label(\"Increase\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n    let btn_dec = Button::builder()\n        .label(\"Decrease\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n\n    // `Clicked` 事件发生后的处理函数\n    // 出于简单演示的目的, 这里只是单纯的加减数字而已\n    let mut num = 0;\n    btn_inc.connect_clicked(|_| {\n        num += 1;\n    });\n    btn_dec.connect_clicked(|_| {\n        num -= 1;\n    });\n\n    // 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下\n    // 因此, 从上往下第一个是btn_inc, 第二个是btn_dec\n    let gtk_box = gtk::Box::builder()\n        .orientation(Orientation::Vertical)\n        .build();\n    gtk_box.append(&btn_inc);\n    gtk_box.append(&btn_dec);\n\n    // 窗口只能设置一个child, 因此把容器添加进去\n    // 随后在容器中添加很多 widget, 达到全添加进去的目的\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My Gtk App\")\n        .child(&gtk_box)\n        .build();\n    win.present();\n}\n```\n\n显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错  \n如果看下 `connect_clicked` 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime  \n\n道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?  \n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量  \n\n我们可以选择为闭包添加前缀, 即添加关键字 `move`, 让被闭包捕获的变量, 其所有权转移到闭包中  \n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?  \n\n但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!  \n有没有什么办法, 让这两个闭包都能拥有num的所有权?  \n\n请看下面的正确实现, 通过引用计数的方式 :)\n- - -\n\n# 引用计数\n\n嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 ~~(GUI框架好像都是单线程的?)~~  \n那就可以使用 `std::rc::Rc` 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权  \n\n多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 `std::cell::Cell`  \n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 `Rc<Cell<i32>>`  \n\n**提示**  \n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell  \n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解\n\n下面是代码, 请务必记得use一下:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nlet num_clone = num.clone();\n\nbtn_inc.connect_clicked(|_| {\n    num_clone.set(num_clone.get() + 1);\n});\nbtn_dec.connect_clicked(|_| {\n    num.set(num.get() - 1);\n});\n```\n\n感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过  \n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?  \n\n让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全  \n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值  \n\n在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T>  \n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量  \n\n但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?  \n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作  \n\n- - -\n\n# clone!\nYeah, 这个宏的名字就叫clone: `glib::clone`, 你可以查看对应的文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n请务必注意use必须像下面这样写, 你得先 `use gtk::glib`, 随后 `use glib::clone`:  \n\n```rust\nuse std::cell::Cell;\nuse std::rc::Rc;\n\nuse glib::clone;\nuse gtk::prelude::*;   // 这里\nuse gtk::{glib, Application, ApplicationWindow, Button, Orientation};  // 这里\n```\n\n如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n使用 `clone!` 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)  \n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存  \n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回  \n\n懂了基础的原理后 ~~(我个人喜欢把读者当傻子, 因此尽量提一嘴)~~, 我们来看看上面这段代码:  \n\n- 在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建  \n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num  \n\n- 两个闭包中, 我们都创建了另一个按钮的 strong-ref  \n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec  \n\n**注意:**  \n`clone!`, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 `()` 值  \n详情请见文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n\n\n至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:  \n循环引用导致内存泄漏!  \n\n- - -\n\n# 循环引用\nRust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在  \n~~(大佬们可能一眼就看出来哪里循环引用了...)~~\n\n贴一份刚刚的代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref  \n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存  \n这就是 `循环引用`\n\n由于 `循环引用`, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 `内存泄漏`  \n\n如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @weak btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@weak btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 `btn_inc`/`btn_dec`  \n在闭包中, 对这两个btn都是弱引用, 当 `build_ui` 调用完毕后, 它们应该会自动drop掉 (因为作用域)  \n\n但若改成 weak-ref, `btn_inc`/`btn_dec` 不会因缺少 strong-ref 而出现问题吗?  \n答案是不会, 原因是以下两段代码  \n\n\n- 第一段:  \n\n```rust\nlet gtk_box = gtk::Box::builder()\n    .orientation(Orientation::Vertical)\n    .build();\ngtk_box.append(&btn_inc);\ngtk_box.append(&btn_dec);\n```\n\n- 第二段:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .child(&gtk_box)\n    .build();\nwin.present();\n```\n\n第一段中, `btn_inc`/`btn_dec` 的引用交给了 `append()`  \n第二段中, `gtk_box` 的引用交给了 `child()`  \n\n还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性  \n`append()`, `child()`, 都保持了对这些 Widget 的强引用, 保持了它们的活性:  \n`gtk_box` 持有对 `btn` 的 strong-ref, `win` 持有对 `gtk_box` 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着  \nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着  \n\n总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已  \n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!  \n\n本节到此结束, 要鸽一会了, 我们下节见 :)","slug":"rust/gui/gtk4/p3-GObject-内存管理","published":1,"updated":"2022-03-30T04:01:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oha002nj1s654a51edw","content":"<blockquote>\n<p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"widget\">Widget</h1>\n<p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>\n再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p>\n<p><a href=\"https://docs.gtk.org/gtk4/visual_index.html\">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p>\n<p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>\n例如 <code>Button</code>, 其继承树如下:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">GObject</span><br><span class=\"line\">└── Widget</span><br><span class=\"line\">    └── <span class=\"selector-tag\">Button</span></span><br></pre></td></tr></table></figure>\n<p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>\n举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p>\n<p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"cuo-wu-shi-xian\">错误实现</h1>\n<p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p>\n<p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>\n下面是代码, 已经讲过的概念不再重复:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建两个按钮, 设置Label</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_inc = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Increase&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_dec = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Decrease&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// `Clicked` 事件发生后的处理函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">        .orientation(Orientation::Vertical)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">    gtk_box.append(&amp;btn_dec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class=\"line\">    <span class=\"comment\">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;gtk_box)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>\n如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p>\n<p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>\n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p>\n<p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>\n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p>\n<p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>\n有没有什么办法, 让这两个闭包都能拥有num的所有权?</p>\n<p>请看下面的正确实现, 通过引用计数的方式 😃</p>\n<hr>\n<h1 id=\"yin-yong-ji-shu\">引用计数</h1>\n<p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>\n那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p>\n<p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>\n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p>\n<p><strong>提示</strong><br>\n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>\n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p>\n<p>下面是代码, 请务必记得use一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> num_clone = num.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num_clone.set(num_clone.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>\n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p>\n<p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>\n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p>\n<p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>\n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p>\n<p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>\n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p>\n<hr>\n<h1 id=\"clone\">clone!</h1>\n<p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a><br>\n请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> glib::clone;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;   <span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class=\"comment\">// 这里</span></span><br></pre></td></tr></table></figure>\n<p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>\n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>\n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p>\n<p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>\n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p>\n</li>\n<li class=\"lvl-2\">\n<p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>\n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p>\n</li>\n</ul>\n<p><strong>注意:</strong><br>\n<code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>\n详情请见文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a></p>\n<p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>\n循环引用导致内存泄漏!</p>\n<hr>\n<h1 id=\"xun-huan-yin-yong\">循环引用</h1>\n<p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br>\n<s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p>\n<p>贴一份刚刚的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>\n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>\n这就是 <code>循环引用</code></p>\n<p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p>\n<p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>\n在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p>\n<p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>\n答案是不会, 原因是以下两段代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">    .orientation(Orientation::Vertical)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .child(&amp;gtk_box)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">win.present();</span><br></pre></td></tr></table></figure>\n<p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>\n第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p>\n<p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br>\n<code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br>\n<code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>\nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p>\n<p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>\n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p>\n<p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>\n","site":{"data":{}},"length":6003,"excerpt":"<blockquote>\n<p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"widget\">Widget</h1>\n<p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>\n再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p>\n<p><a href=\"https://docs.gtk.org/gtk4/visual_index.html\">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p>\n<p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>\n例如 <code>Button</code>, 其继承树如下:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">GObject</span><br><span class=\"line\">└── Widget</span><br><span class=\"line\">    └── <span class=\"selector-tag\">Button</span></span><br></pre></td></tr></table></figure>\n<p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>\n举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p>\n<p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"cuo-wu-shi-xian\">错误实现</h1>\n<p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p>\n<p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>\n下面是代码, 已经讲过的概念不再重复:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建两个按钮, 设置Label</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_inc = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Increase&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_dec = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Decrease&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// `Clicked` 事件发生后的处理函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">        .orientation(Orientation::Vertical)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">    gtk_box.append(&amp;btn_dec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class=\"line\">    <span class=\"comment\">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;gtk_box)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>\n如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p>\n<p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>\n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p>\n<p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>\n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p>\n<p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>\n有没有什么办法, 让这两个闭包都能拥有num的所有权?</p>\n<p>请看下面的正确实现, 通过引用计数的方式 😃</p>\n<hr>\n<h1 id=\"yin-yong-ji-shu\">引用计数</h1>\n<p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>\n那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p>\n<p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>\n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p>\n<p><strong>提示</strong><br>\n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>\n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p>\n<p>下面是代码, 请务必记得use一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> num_clone = num.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num_clone.set(num_clone.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>\n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p>\n<p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>\n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p>\n<p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>\n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p>\n<p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>\n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p>\n<hr>\n<h1 id=\"clone\">clone!</h1>\n<p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a><br>\n请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> glib::clone;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;   <span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class=\"comment\">// 这里</span></span><br></pre></td></tr></table></figure>\n<p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>\n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>\n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p>\n<p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>\n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p>\n</li>\n<li class=\"lvl-2\">\n<p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>\n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p>\n</li>\n</ul>\n<p><strong>注意:</strong><br>\n<code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>\n详情请见文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a></p>\n<p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>\n循环引用导致内存泄漏!</p>\n<hr>\n<h1 id=\"xun-huan-yin-yong\">循环引用</h1>\n<p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br>\n<s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p>\n<p>贴一份刚刚的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>\n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>\n这就是 <code>循环引用</code></p>\n<p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p>\n<p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>\n在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p>\n<p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>\n答案是不会, 原因是以下两段代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">    .orientation(Orientation::Vertical)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .child(&amp;gtk_box)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">win.present();</span><br></pre></td></tr></table></figure>\n<p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>\n第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p>\n<p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br>\n<code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br>\n<code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>\nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p>\n<p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>\n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p>\n<p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>"},{"title":"rust-gtk4-p4~> GObject: 子类化","abbrlink":"posts/rust-gtk4/p4","hidden":false,"date":"2022-10-09T14:52:26.000Z","top":98996,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p3","GObject: 内存管理"],"next_post":["posts/rust-gtk4/p5","GObject: 通用类型"],"_content":"> 本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 目录结构\ngtk 基于 glib, 而 glib 最让人印象深刻的地方, 又是其 `Gobject System`  \n众所周知, C 是一套面向过程的语言, 但基于 C 的 glib库, 却通过高超的思想, 提供了面向对象的支持  \n\n在这样一个面向对象, 依赖继承的体系中, 我们可以通过子类化(Subclassing)来创建新的自定义的 GObject  \n让我们保持这样子的目录结构:  \n\n```\nsrc\n├── custom_button\n│   ├── imp.rs\n│   └── mod.rs\n└── main.rs\n```\n\n在 glib 中, 我们将通过创建两个结构体来创建一个子类  \n我们将会创建一个新的 GObject, 通过继承成为 `gtk::Button` 的子类, 以此添加一些自定义的功能  \n\n- - -\n\n# 子类化\n\n如上面的目录结构所示, 我们定义了一个叫 `custom_button` 的模块, 在 `mod.rs` 中将 `CustomButton` 暴露给外部  \n其实这就是 C 语言中实现子类化的模板, 我们将遵循这个规则, 通过定义两个 struct 来描述子类:  \n\n- `imp.rs` 被用来存储自定义的状态, 存储继承自父类待 override 的虚函数  \n- `custom_button::imp` 是私有模块, `custom_button::imp::CustomButton` 也是私有的  \n- `custom_button::imp::CustomButton` 将被暴露给外界的 `custom_button::CustomButton` 使用, 作为其养料\n\n简单来说, 我们正在利用模块, 对子类化的 GObject 的功能进行分门别类, 让其定义更加清晰罢了  \n\n下面是具体代码, 直接抄书:  \n\n```rust src/custom_button/imp.rs\nuse gtk::glib;\nuse gtk::subclass::prelude::*;\n\n// Object holding the state\n#[derive(Default)]\npub struct CustomButton;\n\n// The central trait for subclassing a GObject\n#[glib::object_subclass]\nimpl ObjectSubclass for CustomButton {\n    const NAME: &'static str = \"MyGtkAppCustomButton\";\n    type Type = super::CustomButton;\n    type ParentType = gtk::Button;\n}\n\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {}\n\n// Trait shared by all widgets\nimpl WidgetImpl for CustomButton {}\n\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {}\n```\n\n先前也说了, 模块 `imp.rs` 的作用便是描述一个子类, 负责新添加的状态与待覆写的虚函数  \n对于某个子类 GObject 的描述, 在 `ObjectSubclass` 中:  \n- `NAME`: 该 GObject 的名字  \n- `Type`: 指之后将被创建的, 实际的 GObject  \n- `ParentType`: 我们继承的那个父类 GObject  \n\n你可能会疑惑, 这个 `Name` 与 `Type` 是什么鬼, 就不能直接用 `Type (我们在Rust中实际创建的类型)` 作为 `NAME` 吗?  \n\n别忘了, gtk 是一套跨语言的通用 GUI 框架, 拥有几十种语言的绑定, 设计必然不能拘泥在一种语言上  \n不同语言自有不同命名规范, 必然得先统一风格, 比如之后会学习的 `.ui` 为后缀的 xml 文件, 可以用来描述界面, 不管哪个语言都是通用的  \n\n因此, `NAME` 是用来描述其名字, 是统一的, 为避免命名冲突, 应使用 crate-name 与 object-name 组成 (UpperCamelCase)  \n而 `Type/ParentType` 则是特定于语言的某个具体类型, 此处是Rust中的 `CustomButton`/`gtk::Button`  \n\n再提一嘴, 之后将学习的以 `.ui` 为后缀的 xml 文件, 可以创建 GtkBuilder template class(模板类), 像下面这样去描述界面:  \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <template class=\"GtkAppWindow\" parent=\"GtkApplicationWindow\">\n    <property name=\"title\">My GTK App</property>\n    <child>\n      <!-- 此处使用 `CustomButton` 指定 widget 的类型 -->\n      <object class=\"CustomButton\" id=\"button_1\">\n        <property name=\"label\">Press me!</property>\n        <property name=\"margin-top\">12</property>\n        <property name=\"margin-bottom\">12</property>\n        <property name=\"margin-start\">12</property>\n        <property name=\"margin-end\">12</property>  \n      </object>\n    </child>\n  </template>\n</interface>\n```\n\n\n\n你可能还会在之后对 gtk 框架的一些地方感到疑惑, 因此请记住: gtk 是一套通用的 gui 框架, 不止是为一种语言服务的  \n\n接下来是将暴露给外界的 `CustomButton`:  \n\n```rust src/custom_button/mod.rs\nmod imp;\n\nuse glib::Object;\nuse gtk::glib;\n\nglib::wrapper! {\n    pub struct CustomButton(ObjectSubclass<imp::CustomButton>)\n        @extends gtk::Button, gtk::Widget,\n        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;\n}\n\nimpl CustomButton {\n    pub fn with_label(label: &str) -> Self {\n        Object::new(&[(\"label\", &label)])\n    }\n}\n```\n\n`glib::wrapper!` 顾名思义, 能帮我们将 `imp::CustomButton` 进行包装, 自动生成相关实现, 避免大量样例代码, 我们只需指明其继承情况即可:  \n- `@extends`: 指明所有父类 GObject\n- `@implements`: 指明所有实现的 Interface (在 Rust 中是 Trait)\n- `imp::CustomButton`: 经过宏成为了被暴露的 `CustomButton` 的 inner 成员\n- `with_label`: 添加了自己的将被暴露的新方法, 设置了 GObject 的 property (`Object::new` 的返回值是泛型, 此处会自动推导为 `Self`)\n\n我们可以通过 [docs/gtk/hierarchy](https://docs.gtk.org/gtk4/class.Button.html#hierarchy) 来查看某个 GObject 的继承链情况  \n\n现在, `CustomButton` 实际上已经与 `gtk::Button` 一样了, 因此我们可以直接用其替换 `Button`:  \n\n```rust src/main.rs\nmod custom_button;\n\nuse custom_button::CustomButton;\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let button = CustomButton::with_label(\"Press me!\");\n    button.set_margin_top(12);\n    button.set_margin_bottom(12);\n    button.set_margin_start(12);\n    button.set_margin_end(12);\n\n    let window = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My GTK App\")\n        .child(&button)\n        .build();\n\n    window.present();\n}\n```\n\n执行 `mold -run cargo run`, 你会见识一模一样的效果 :)  \n\n- - -\n\n# 自定义\n没错, 这还不够, 如果费劲心思搞出来的子类只是和父类一般, 那就没必要搞了, 很简单的道理不是吗?  \n令人兴奋的是, 我们还可以保存状态, 覆写虚函数!  \n\n下面是例子, 直接抄书, 我们将只覆写其中两个虚函数:  \n\n```rust src/custom_button/imp.rs\nuse std::cell::Cell;\n\nuse gtk::glib;\nuse gtk::prelude::*;\nuse gtk::subclass::prelude::*;\n\n// Object holding the state\n#[derive(Default)]\npub struct CustomButton {\n    number: Cell<i32>,\n}\n\n// The central trait for subclassing a GObject\n#[glib::object_subclass]\nimpl ObjectSubclass for CustomButton {\n    const NAME: &'static str = \"MyGtkAppCustomButton\";\n    type Type = super::CustomButton;\n    type ParentType = gtk::Button;\n}\n\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {\n    fn constructed(&self) {\n        self.parent_constructed();\n        self.obj().set_label(&self.number.get().to_string());\n    }\n}\n\n// Trait shared by all widgets\nimpl WidgetImpl for CustomButton {}\n\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {\n    fn clicked(&self) {\n        self.number.set(self.number.get() + 1);\n        self.obj().set_label(&self.number.get().to_string())\n    }\n}\n```\n\n我们为 `imp::CustomButton` 添加了一个状态, 也就是其成员 `number`, 随后覆写了两个虚函数  \n(覆写构造函数时, 还得记得调用一下父类的构造函数, 完成整个构造链)  \n\n在被覆写的函数中, 我们都调用了 `self.obj()`, 你可以观察一下其签名:  \n\n```rust glib::subclass::types::obj\nfn obj(&self) -> crate::BorrowedObject<Self::Type>\n```\n\n还记得 `Self::Type` 是什么吗? 没错, 就是被暴露的那个 `CustomButton`, 而非 `imp::CustomButton`, 它才是被使用的真正实例(instance)  \n此处的 `obj()` 方法, 其别名就是 `instance()`, 得到的是在 `main.rs` 中被创建的那个真正实例的引用  \n\n总而言之, 我们的所谓 `子类化`, 在rust中其实就是一个 warpper, 包装了一个来自gtk的部件  \n随后通过实现诸如 `ObjectImpl` 之类的 trait, 修改了父部件原本的行为  \n\n顺便再复习一下, 防止有人看见这里而感疑惑: 为什么是 `clicked(&self)` 而非 `clicked(&mut self)`, 这样不应该更方便吗?  \n这是因为每个 GObject 都是引用计数的, 所以能绕过编译器的检查(全是不可变借用), 之前提到过了  \n\n经过覆写虚函数, `CustomButton` 终于出现了有别于父类 `Button` 的新特性:  \n- 被构造时: 初始化 label 为自己存储的状态数字  \n- 被点击时: 会让存储的状态数字+1, 随后更新 label\n\n现在调用 `mold -run cargo run`, 你将得到一个按钮, 按钮的 label 初始时为 0, 被点击后不断+1  \n\n- - -\n\n# 使用情况\n什么情况下适合使用 `glib::wrapper` 来模拟继承呢 (Rust 语言层面上不支持继承, 因此叫模拟)  \n\n- 使用一个 widget, 其添加了自定义状态与覆写虚函数\n- 将 Rust 对象传递给要求参数是 GObject 的函数 (因为 gtk 不只是 Rust 的GUI框架, 还是其他许多语言的 GUI 框架)\n- 为某个对象添加 property 或 signal, 继承 glib 体系下的强大力量 (下面几节会讲)  ","source":"_posts/rust/gui/gtk4/p4-GObject-子类化.md","raw":"---\ntitle: \"rust-gtk4-p4~> GObject: 子类化\"\nabbrlink: posts/rust-gtk4/p4\nhidden: false\ndate: 2022-10-09 22:52:26\ntop: 98996\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p3, \"GObject: 内存管理\"]\nnext_post: [posts/rust-gtk4/p5, \"GObject: 通用类型\"]\n---\n> 本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 目录结构\ngtk 基于 glib, 而 glib 最让人印象深刻的地方, 又是其 `Gobject System`  \n众所周知, C 是一套面向过程的语言, 但基于 C 的 glib库, 却通过高超的思想, 提供了面向对象的支持  \n\n在这样一个面向对象, 依赖继承的体系中, 我们可以通过子类化(Subclassing)来创建新的自定义的 GObject  \n让我们保持这样子的目录结构:  \n\n```\nsrc\n├── custom_button\n│   ├── imp.rs\n│   └── mod.rs\n└── main.rs\n```\n\n在 glib 中, 我们将通过创建两个结构体来创建一个子类  \n我们将会创建一个新的 GObject, 通过继承成为 `gtk::Button` 的子类, 以此添加一些自定义的功能  \n\n- - -\n\n# 子类化\n\n如上面的目录结构所示, 我们定义了一个叫 `custom_button` 的模块, 在 `mod.rs` 中将 `CustomButton` 暴露给外部  \n其实这就是 C 语言中实现子类化的模板, 我们将遵循这个规则, 通过定义两个 struct 来描述子类:  \n\n- `imp.rs` 被用来存储自定义的状态, 存储继承自父类待 override 的虚函数  \n- `custom_button::imp` 是私有模块, `custom_button::imp::CustomButton` 也是私有的  \n- `custom_button::imp::CustomButton` 将被暴露给外界的 `custom_button::CustomButton` 使用, 作为其养料\n\n简单来说, 我们正在利用模块, 对子类化的 GObject 的功能进行分门别类, 让其定义更加清晰罢了  \n\n下面是具体代码, 直接抄书:  \n\n```rust src/custom_button/imp.rs\nuse gtk::glib;\nuse gtk::subclass::prelude::*;\n\n// Object holding the state\n#[derive(Default)]\npub struct CustomButton;\n\n// The central trait for subclassing a GObject\n#[glib::object_subclass]\nimpl ObjectSubclass for CustomButton {\n    const NAME: &'static str = \"MyGtkAppCustomButton\";\n    type Type = super::CustomButton;\n    type ParentType = gtk::Button;\n}\n\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {}\n\n// Trait shared by all widgets\nimpl WidgetImpl for CustomButton {}\n\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {}\n```\n\n先前也说了, 模块 `imp.rs` 的作用便是描述一个子类, 负责新添加的状态与待覆写的虚函数  \n对于某个子类 GObject 的描述, 在 `ObjectSubclass` 中:  \n- `NAME`: 该 GObject 的名字  \n- `Type`: 指之后将被创建的, 实际的 GObject  \n- `ParentType`: 我们继承的那个父类 GObject  \n\n你可能会疑惑, 这个 `Name` 与 `Type` 是什么鬼, 就不能直接用 `Type (我们在Rust中实际创建的类型)` 作为 `NAME` 吗?  \n\n别忘了, gtk 是一套跨语言的通用 GUI 框架, 拥有几十种语言的绑定, 设计必然不能拘泥在一种语言上  \n不同语言自有不同命名规范, 必然得先统一风格, 比如之后会学习的 `.ui` 为后缀的 xml 文件, 可以用来描述界面, 不管哪个语言都是通用的  \n\n因此, `NAME` 是用来描述其名字, 是统一的, 为避免命名冲突, 应使用 crate-name 与 object-name 组成 (UpperCamelCase)  \n而 `Type/ParentType` 则是特定于语言的某个具体类型, 此处是Rust中的 `CustomButton`/`gtk::Button`  \n\n再提一嘴, 之后将学习的以 `.ui` 为后缀的 xml 文件, 可以创建 GtkBuilder template class(模板类), 像下面这样去描述界面:  \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <template class=\"GtkAppWindow\" parent=\"GtkApplicationWindow\">\n    <property name=\"title\">My GTK App</property>\n    <child>\n      <!-- 此处使用 `CustomButton` 指定 widget 的类型 -->\n      <object class=\"CustomButton\" id=\"button_1\">\n        <property name=\"label\">Press me!</property>\n        <property name=\"margin-top\">12</property>\n        <property name=\"margin-bottom\">12</property>\n        <property name=\"margin-start\">12</property>\n        <property name=\"margin-end\">12</property>  \n      </object>\n    </child>\n  </template>\n</interface>\n```\n\n\n\n你可能还会在之后对 gtk 框架的一些地方感到疑惑, 因此请记住: gtk 是一套通用的 gui 框架, 不止是为一种语言服务的  \n\n接下来是将暴露给外界的 `CustomButton`:  \n\n```rust src/custom_button/mod.rs\nmod imp;\n\nuse glib::Object;\nuse gtk::glib;\n\nglib::wrapper! {\n    pub struct CustomButton(ObjectSubclass<imp::CustomButton>)\n        @extends gtk::Button, gtk::Widget,\n        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;\n}\n\nimpl CustomButton {\n    pub fn with_label(label: &str) -> Self {\n        Object::new(&[(\"label\", &label)])\n    }\n}\n```\n\n`glib::wrapper!` 顾名思义, 能帮我们将 `imp::CustomButton` 进行包装, 自动生成相关实现, 避免大量样例代码, 我们只需指明其继承情况即可:  \n- `@extends`: 指明所有父类 GObject\n- `@implements`: 指明所有实现的 Interface (在 Rust 中是 Trait)\n- `imp::CustomButton`: 经过宏成为了被暴露的 `CustomButton` 的 inner 成员\n- `with_label`: 添加了自己的将被暴露的新方法, 设置了 GObject 的 property (`Object::new` 的返回值是泛型, 此处会自动推导为 `Self`)\n\n我们可以通过 [docs/gtk/hierarchy](https://docs.gtk.org/gtk4/class.Button.html#hierarchy) 来查看某个 GObject 的继承链情况  \n\n现在, `CustomButton` 实际上已经与 `gtk::Button` 一样了, 因此我们可以直接用其替换 `Button`:  \n\n```rust src/main.rs\nmod custom_button;\n\nuse custom_button::CustomButton;\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let button = CustomButton::with_label(\"Press me!\");\n    button.set_margin_top(12);\n    button.set_margin_bottom(12);\n    button.set_margin_start(12);\n    button.set_margin_end(12);\n\n    let window = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My GTK App\")\n        .child(&button)\n        .build();\n\n    window.present();\n}\n```\n\n执行 `mold -run cargo run`, 你会见识一模一样的效果 :)  \n\n- - -\n\n# 自定义\n没错, 这还不够, 如果费劲心思搞出来的子类只是和父类一般, 那就没必要搞了, 很简单的道理不是吗?  \n令人兴奋的是, 我们还可以保存状态, 覆写虚函数!  \n\n下面是例子, 直接抄书, 我们将只覆写其中两个虚函数:  \n\n```rust src/custom_button/imp.rs\nuse std::cell::Cell;\n\nuse gtk::glib;\nuse gtk::prelude::*;\nuse gtk::subclass::prelude::*;\n\n// Object holding the state\n#[derive(Default)]\npub struct CustomButton {\n    number: Cell<i32>,\n}\n\n// The central trait for subclassing a GObject\n#[glib::object_subclass]\nimpl ObjectSubclass for CustomButton {\n    const NAME: &'static str = \"MyGtkAppCustomButton\";\n    type Type = super::CustomButton;\n    type ParentType = gtk::Button;\n}\n\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {\n    fn constructed(&self) {\n        self.parent_constructed();\n        self.obj().set_label(&self.number.get().to_string());\n    }\n}\n\n// Trait shared by all widgets\nimpl WidgetImpl for CustomButton {}\n\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {\n    fn clicked(&self) {\n        self.number.set(self.number.get() + 1);\n        self.obj().set_label(&self.number.get().to_string())\n    }\n}\n```\n\n我们为 `imp::CustomButton` 添加了一个状态, 也就是其成员 `number`, 随后覆写了两个虚函数  \n(覆写构造函数时, 还得记得调用一下父类的构造函数, 完成整个构造链)  \n\n在被覆写的函数中, 我们都调用了 `self.obj()`, 你可以观察一下其签名:  \n\n```rust glib::subclass::types::obj\nfn obj(&self) -> crate::BorrowedObject<Self::Type>\n```\n\n还记得 `Self::Type` 是什么吗? 没错, 就是被暴露的那个 `CustomButton`, 而非 `imp::CustomButton`, 它才是被使用的真正实例(instance)  \n此处的 `obj()` 方法, 其别名就是 `instance()`, 得到的是在 `main.rs` 中被创建的那个真正实例的引用  \n\n总而言之, 我们的所谓 `子类化`, 在rust中其实就是一个 warpper, 包装了一个来自gtk的部件  \n随后通过实现诸如 `ObjectImpl` 之类的 trait, 修改了父部件原本的行为  \n\n顺便再复习一下, 防止有人看见这里而感疑惑: 为什么是 `clicked(&self)` 而非 `clicked(&mut self)`, 这样不应该更方便吗?  \n这是因为每个 GObject 都是引用计数的, 所以能绕过编译器的检查(全是不可变借用), 之前提到过了  \n\n经过覆写虚函数, `CustomButton` 终于出现了有别于父类 `Button` 的新特性:  \n- 被构造时: 初始化 label 为自己存储的状态数字  \n- 被点击时: 会让存储的状态数字+1, 随后更新 label\n\n现在调用 `mold -run cargo run`, 你将得到一个按钮, 按钮的 label 初始时为 0, 被点击后不断+1  \n\n- - -\n\n# 使用情况\n什么情况下适合使用 `glib::wrapper` 来模拟继承呢 (Rust 语言层面上不支持继承, 因此叫模拟)  \n\n- 使用一个 widget, 其添加了自定义状态与覆写虚函数\n- 将 Rust 对象传递给要求参数是 GObject 的函数 (因为 gtk 不只是 Rust 的GUI框架, 还是其他许多语言的 GUI 框架)\n- 为某个对象添加 property 或 signal, 继承 glib 体系下的强大力量 (下面几节会讲)  ","slug":"rust/gui/gtk4/p4-GObject-子类化","published":1,"updated":"2022-10-09T14:52:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohb002pj1s6cb9l28zy","content":"<blockquote>\n<p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"mu-lu-jie-gou\">目录结构</h1>\n<p>gtk 基于 glib, 而 glib 最让人印象深刻的地方, 又是其 <code>Gobject System</code><br>\n众所周知, C 是一套面向过程的语言, 但基于 C 的 glib库, 却通过高超的思想, 提供了面向对象的支持</p>\n<p>在这样一个面向对象, 依赖继承的体系中, 我们可以通过子类化(Subclassing)来创建新的自定义的 GObject<br>\n让我们保持这样子的目录结构:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">src</span></span><br><span class=\"line\">├── custom_button</span><br><span class=\"line\">│   ├── imp<span class=\"selector-class\">.rs</span></span><br><span class=\"line\">│   └── mod<span class=\"selector-class\">.rs</span></span><br><span class=\"line\">└── <span class=\"selector-tag\">main</span>.rs</span><br></pre></td></tr></table></figure>\n<p>在 glib 中, 我们将通过创建两个结构体来创建一个子类<br>\n我们将会创建一个新的 GObject, 通过继承成为 <code>gtk::Button</code> 的子类, 以此添加一些自定义的功能</p>\n<hr>\n<h1 id=\"zi-lei-hua\">子类化</h1>\n<p>如上面的目录结构所示, 我们定义了一个叫 <code>custom_button</code> 的模块, 在 <code>mod.rs</code> 中将 <code>CustomButton</code> 暴露给外部<br>\n其实这就是 C 语言中实现子类化的模板, 我们将遵循这个规则, 通过定义两个 struct 来描述子类:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>imp.rs</code> 被用来存储自定义的状态, 存储继承自父类待 override 的虚函数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>custom_button::imp</code> 是私有模块, <code>custom_button::imp::CustomButton</code> 也是私有的</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>custom_button::imp::CustomButton</code> 将被暴露给外界的 <code>custom_button::CustomButton</code> 使用, 作为其养料</p>\n</li>\n</ul>\n<p>简单来说, 我们正在利用模块, 对子类化的 GObject 的功能进行分门别类, 让其定义更加清晰罢了</p>\n<p>下面是具体代码, 直接抄书:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::glib;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::subclass::prelude::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object holding the state</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Default)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CustomButton</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The central trait for subclassing a GObject</span></span><br><span class=\"line\"><span class=\"meta\">#[glib::object_subclass]</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectSubclass <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> NAME: &amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span> = <span class=\"string\">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Type</span></span> = super::CustomButton;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">ParentType</span></span> = gtk::Button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all widgets</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WidgetImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>先前也说了, 模块 <code>imp.rs</code> 的作用便是描述一个子类, 负责新添加的状态与待覆写的虚函数<br>\n对于某个子类 GObject 的描述, 在 <code>ObjectSubclass</code> 中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>NAME</code>: 该 GObject 的名字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Type</code>: 指之后将被创建的, 实际的 GObject</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ParentType</code>: 我们继承的那个父类 GObject</p>\n</li>\n</ul>\n<p>你可能会疑惑, 这个 <code>Name</code> 与 <code>Type</code> 是什么鬼, 就不能直接用 <code>Type (我们在Rust中实际创建的类型)</code> 作为 <code>NAME</code> 吗?</p>\n<p>别忘了, gtk 是一套跨语言的通用 GUI 框架, 拥有几十种语言的绑定, 设计必然不能拘泥在一种语言上<br>\n不同语言自有不同命名规范, 必然得先统一风格, 比如之后会学习的 <code>.ui</code> 为后缀的 xml 文件, 可以用来描述界面, 不管哪个语言都是通用的</p>\n<p>因此, <code>NAME</code> 是用来描述其名字, 是统一的, 为避免命名冲突, 应使用 crate-name 与 object-name 组成 (UpperCamelCase)<br>\n而 <code>Type/ParentType</code> 则是特定于语言的某个具体类型, 此处是Rust中的 <code>CustomButton</code>/<code>gtk::Button</code></p>\n<p>再提一嘴, 之后将学习的以 <code>.ui</code> 为后缀的 xml 文件, 可以创建 GtkBuilder template class(模板类), 像下面这样去描述界面:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">interface</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;GtkAppWindow&quot;</span> <span class=\"attr\">parent</span>=<span class=\"string\">&quot;GtkApplicationWindow&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;title&quot;</span>&gt;</span>My GTK App<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 此处使用 `CustomButton` 指定 widget 的类型 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">object</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;CustomButton&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;button_1&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;label&quot;</span>&gt;</span>Press me!<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-top&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-bottom&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-start&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-end&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">object</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">interface</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>你可能还会在之后对 gtk 框架的一些地方感到疑惑, 因此请记住: gtk 是一套通用的 gui 框架, 不止是为一种语言服务的</p>\n<p>接下来是将暴露给外界的 <code>CustomButton</code>:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/mod.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> imp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> glib::Object;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::glib;</span><br><span class=\"line\"></span><br><span class=\"line\">glib::wrapper! &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CustomButton</span></span>(ObjectSubclass&lt;imp::CustomButton&gt;)</span><br><span class=\"line\">        @extends gtk::Button, gtk::Widget,</span><br><span class=\"line\">        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_label</span></span>(label: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        Object::new(&amp;[(<span class=\"string\">&quot;label&quot;</span>, &amp;label)])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glib::wrapper!</code> 顾名思义, 能帮我们将 <code>imp::CustomButton</code> 进行包装, 自动生成相关实现, 避免大量样例代码, 我们只需指明其继承情况即可:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>@extends</code>: 指明所有父类 GObject</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>@implements</code>: 指明所有实现的 Interface (在 Rust 中是 Trait)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>imp::CustomButton</code>: 经过宏成为了被暴露的 <code>CustomButton</code> 的 inner 成员</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>with_label</code>: 添加了自己的将被暴露的新方法, 设置了 GObject 的 property (<code>Object::new</code> 的返回值是泛型, 此处会自动推导为 <code>Self</code>)</p>\n</li>\n</ul>\n<p>我们可以通过 <a href=\"https://docs.gtk.org/gtk4/class.Button.html#hierarchy\">docs/gtk/hierarchy</a> 来查看某个 GObject 的继承链情况</p>\n<p>现在, <code>CustomButton</code> 实际上已经与 <code>gtk::Button</code> 一样了, 因此我们可以直接用其替换 <code>Button</code>:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> custom_button;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> custom_button::CustomButton;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = CustomButton::with_label(<span class=\"string\">&quot;Press me!&quot;</span>);</span><br><span class=\"line\">    button.set_margin_top(<span class=\"number\">12</span>);</span><br><span class=\"line\">    button.set_margin_bottom(<span class=\"number\">12</span>);</span><br><span class=\"line\">    button.set_margin_start(<span class=\"number\">12</span>);</span><br><span class=\"line\">    button.set_margin_end(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> window = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My GTK App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;button)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    window.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>mold -run cargo run</code>, 你会见识一模一样的效果 😃</p>\n<hr>\n<h1 id=\"zi-ding-yi\">自定义</h1>\n<p>没错, 这还不够, 如果费劲心思搞出来的子类只是和父类一般, 那就没必要搞了, 很简单的道理不是吗?<br>\n令人兴奋的是, 我们还可以保存状态, 覆写虚函数!</p>\n<p>下面是例子, 直接抄书, 我们将只覆写其中两个虚函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::glib;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::subclass::prelude::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object holding the state</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Default)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CustomButton</span></span> &#123;</span><br><span class=\"line\">    number: Cell&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The central trait for subclassing a GObject</span></span><br><span class=\"line\"><span class=\"meta\">#[glib::object_subclass]</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectSubclass <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> NAME: &amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span> = <span class=\"string\">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Type</span></span> = super::CustomButton;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">ParentType</span></span> = gtk::Button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_label(&amp;<span class=\"keyword\">self</span>.number.get().to_string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all widgets</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WidgetImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">clicked</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.number.set(<span class=\"keyword\">self</span>.number.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_label(&amp;<span class=\"keyword\">self</span>.number.get().to_string())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们为 <code>imp::CustomButton</code> 添加了一个状态, 也就是其成员 <code>number</code>, 随后覆写了两个虚函数<br>\n(覆写构造函数时, 还得记得调用一下父类的构造函数, 完成整个构造链)</p>\n<p>在被覆写的函数中, 我们都调用了 <code>self.obj()</code>, 你可以观察一下其签名:</p>\n<figure class=\"highlight rust\"><figcaption><span>glib::subclass::types::obj</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">obj</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; crate::BorrowedObject&lt;Self::Type&gt;</span><br></pre></td></tr></table></figure>\n<p>还记得 <code>Self::Type</code> 是什么吗? 没错, 就是被暴露的那个 <code>CustomButton</code>, 而非 <code>imp::CustomButton</code>, 它才是被使用的真正实例(instance)<br>\n此处的 <code>obj()</code> 方法, 其别名就是 <code>instance()</code>, 得到的是在 <code>main.rs</code> 中被创建的那个真正实例的引用</p>\n<p>总而言之, 我们的所谓 <code>子类化</code>, 在rust中其实就是一个 warpper, 包装了一个来自gtk的部件<br>\n随后通过实现诸如 <code>ObjectImpl</code> 之类的 trait, 修改了父部件原本的行为</p>\n<p>顺便再复习一下, 防止有人看见这里而感疑惑: 为什么是 <code>clicked(&amp;self)</code> 而非 <code>clicked(&amp;mut self)</code>, 这样不应该更方便吗?<br>\n这是因为每个 GObject 都是引用计数的, 所以能绕过编译器的检查(全是不可变借用), 之前提到过了</p>\n<p>经过覆写虚函数, <code>CustomButton</code> 终于出现了有别于父类 <code>Button</code> 的新特性:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>被构造时: 初始化 label 为自己存储的状态数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>被点击时: 会让存储的状态数字+1, 随后更新 label</p>\n</li>\n</ul>\n<p>现在调用 <code>mold -run cargo run</code>, 你将得到一个按钮, 按钮的 label 初始时为 0, 被点击后不断+1</p>\n<hr>\n<h1 id=\"shi-yong-qing-kuang\">使用情况</h1>\n<p>什么情况下适合使用 <code>glib::wrapper</code> 来模拟继承呢 (Rust 语言层面上不支持继承, 因此叫模拟)</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用一个 widget, 其添加了自定义状态与覆写虚函数</p>\n</li>\n<li class=\"lvl-2\">\n<p>将 Rust 对象传递给要求参数是 GObject 的函数 (因为 gtk 不只是 Rust 的GUI框架, 还是其他许多语言的 GUI 框架)</p>\n</li>\n<li class=\"lvl-2\">\n<p>为某个对象添加 property 或 signal, 继承 glib 体系下的强大力量 (下面几节会讲)</p>\n</li>\n</ul>\n","site":{"data":{}},"length":5858,"excerpt":"<blockquote>\n<p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"mu-lu-jie-gou\">目录结构</h1>\n<p>gtk 基于 glib, 而 glib 最让人印象深刻的地方, 又是其 <code>Gobject System</code><br>\n众所周知, C 是一套面向过程的语言, 但基于 C 的 glib库, 却通过高超的思想, 提供了面向对象的支持</p>\n<p>在这样一个面向对象, 依赖继承的体系中, 我们可以通过子类化(Subclassing)来创建新的自定义的 GObject<br>\n让我们保持这样子的目录结构:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">src</span></span><br><span class=\"line\">├── custom_button</span><br><span class=\"line\">│   ├── imp<span class=\"selector-class\">.rs</span></span><br><span class=\"line\">│   └── mod<span class=\"selector-class\">.rs</span></span><br><span class=\"line\">└── <span class=\"selector-tag\">main</span>.rs</span><br></pre></td></tr></table></figure>\n<p>在 glib 中, 我们将通过创建两个结构体来创建一个子类<br>\n我们将会创建一个新的 GObject, 通过继承成为 <code>gtk::Button</code> 的子类, 以此添加一些自定义的功能</p>\n<hr>\n<h1 id=\"zi-lei-hua\">子类化</h1>\n<p>如上面的目录结构所示, 我们定义了一个叫 <code>custom_button</code> 的模块, 在 <code>mod.rs</code> 中将 <code>CustomButton</code> 暴露给外部<br>\n其实这就是 C 语言中实现子类化的模板, 我们将遵循这个规则, 通过定义两个 struct 来描述子类:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>imp.rs</code> 被用来存储自定义的状态, 存储继承自父类待 override 的虚函数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>custom_button::imp</code> 是私有模块, <code>custom_button::imp::CustomButton</code> 也是私有的</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>custom_button::imp::CustomButton</code> 将被暴露给外界的 <code>custom_button::CustomButton</code> 使用, 作为其养料</p>\n</li>\n</ul>\n<p>简单来说, 我们正在利用模块, 对子类化的 GObject 的功能进行分门别类, 让其定义更加清晰罢了</p>\n<p>下面是具体代码, 直接抄书:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::glib;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::subclass::prelude::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object holding the state</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Default)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CustomButton</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The central trait for subclassing a GObject</span></span><br><span class=\"line\"><span class=\"meta\">#[glib::object_subclass]</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectSubclass <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> NAME: &amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span> = <span class=\"string\">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Type</span></span> = super::CustomButton;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">ParentType</span></span> = gtk::Button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all widgets</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WidgetImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>先前也说了, 模块 <code>imp.rs</code> 的作用便是描述一个子类, 负责新添加的状态与待覆写的虚函数<br>\n对于某个子类 GObject 的描述, 在 <code>ObjectSubclass</code> 中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>NAME</code>: 该 GObject 的名字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Type</code>: 指之后将被创建的, 实际的 GObject</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ParentType</code>: 我们继承的那个父类 GObject</p>\n</li>\n</ul>\n<p>你可能会疑惑, 这个 <code>Name</code> 与 <code>Type</code> 是什么鬼, 就不能直接用 <code>Type (我们在Rust中实际创建的类型)</code> 作为 <code>NAME</code> 吗?</p>\n<p>别忘了, gtk 是一套跨语言的通用 GUI 框架, 拥有几十种语言的绑定, 设计必然不能拘泥在一种语言上<br>\n不同语言自有不同命名规范, 必然得先统一风格, 比如之后会学习的 <code>.ui</code> 为后缀的 xml 文件, 可以用来描述界面, 不管哪个语言都是通用的</p>\n<p>因此, <code>NAME</code> 是用来描述其名字, 是统一的, 为避免命名冲突, 应使用 crate-name 与 object-name 组成 (UpperCamelCase)<br>\n而 <code>Type/ParentType</code> 则是特定于语言的某个具体类型, 此处是Rust中的 <code>CustomButton</code>/<code>gtk::Button</code></p>\n<p>再提一嘴, 之后将学习的以 <code>.ui</code> 为后缀的 xml 文件, 可以创建 GtkBuilder template class(模板类), 像下面这样去描述界面:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">interface</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;GtkAppWindow&quot;</span> <span class=\"attr\">parent</span>=<span class=\"string\">&quot;GtkApplicationWindow&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;title&quot;</span>&gt;</span>My GTK App<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 此处使用 `CustomButton` 指定 widget 的类型 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">object</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;CustomButton&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;button_1&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;label&quot;</span>&gt;</span>Press me!<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-top&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-bottom&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-start&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;margin-end&quot;</span>&gt;</span>12<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">object</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">interface</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>你可能还会在之后对 gtk 框架的一些地方感到疑惑, 因此请记住: gtk 是一套通用的 gui 框架, 不止是为一种语言服务的</p>\n<p>接下来是将暴露给外界的 <code>CustomButton</code>:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/mod.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> imp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> glib::Object;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::glib;</span><br><span class=\"line\"></span><br><span class=\"line\">glib::wrapper! &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CustomButton</span></span>(ObjectSubclass&lt;imp::CustomButton&gt;)</span><br><span class=\"line\">        @extends gtk::Button, gtk::Widget,</span><br><span class=\"line\">        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">with_label</span></span>(label: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        Object::new(&amp;[(<span class=\"string\">&quot;label&quot;</span>, &amp;label)])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>glib::wrapper!</code> 顾名思义, 能帮我们将 <code>imp::CustomButton</code> 进行包装, 自动生成相关实现, 避免大量样例代码, 我们只需指明其继承情况即可:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>@extends</code>: 指明所有父类 GObject</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>@implements</code>: 指明所有实现的 Interface (在 Rust 中是 Trait)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>imp::CustomButton</code>: 经过宏成为了被暴露的 <code>CustomButton</code> 的 inner 成员</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>with_label</code>: 添加了自己的将被暴露的新方法, 设置了 GObject 的 property (<code>Object::new</code> 的返回值是泛型, 此处会自动推导为 <code>Self</code>)</p>\n</li>\n</ul>\n<p>我们可以通过 <a href=\"https://docs.gtk.org/gtk4/class.Button.html#hierarchy\">docs/gtk/hierarchy</a> 来查看某个 GObject 的继承链情况</p>\n<p>现在, <code>CustomButton</code> 实际上已经与 <code>gtk::Button</code> 一样了, 因此我们可以直接用其替换 <code>Button</code>:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> custom_button;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> custom_button::CustomButton;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = CustomButton::with_label(<span class=\"string\">&quot;Press me!&quot;</span>);</span><br><span class=\"line\">    button.set_margin_top(<span class=\"number\">12</span>);</span><br><span class=\"line\">    button.set_margin_bottom(<span class=\"number\">12</span>);</span><br><span class=\"line\">    button.set_margin_start(<span class=\"number\">12</span>);</span><br><span class=\"line\">    button.set_margin_end(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> window = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My GTK App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;button)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    window.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行 <code>mold -run cargo run</code>, 你会见识一模一样的效果 😃</p>\n<hr>\n<h1 id=\"zi-ding-yi\">自定义</h1>\n<p>没错, 这还不够, 如果费劲心思搞出来的子类只是和父类一般, 那就没必要搞了, 很简单的道理不是吗?<br>\n令人兴奋的是, 我们还可以保存状态, 覆写虚函数!</p>\n<p>下面是例子, 直接抄书, 我们将只覆写其中两个虚函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::glib;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::subclass::prelude::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object holding the state</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Default)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CustomButton</span></span> &#123;</span><br><span class=\"line\">    number: Cell&lt;<span class=\"built_in\">i32</span>&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The central trait for subclassing a GObject</span></span><br><span class=\"line\"><span class=\"meta\">#[glib::object_subclass]</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectSubclass <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> NAME: &amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span> = <span class=\"string\">&quot;MyGtkAppCustomButton&quot;</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Type</span></span> = super::CustomButton;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">ParentType</span></span> = gtk::Button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_label(&amp;<span class=\"keyword\">self</span>.number.get().to_string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all widgets</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WidgetImpl <span class=\"keyword\">for</span> CustomButton &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">clicked</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.number.set(<span class=\"keyword\">self</span>.number.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_label(&amp;<span class=\"keyword\">self</span>.number.get().to_string())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们为 <code>imp::CustomButton</code> 添加了一个状态, 也就是其成员 <code>number</code>, 随后覆写了两个虚函数<br>\n(覆写构造函数时, 还得记得调用一下父类的构造函数, 完成整个构造链)</p>\n<p>在被覆写的函数中, 我们都调用了 <code>self.obj()</code>, 你可以观察一下其签名:</p>\n<figure class=\"highlight rust\"><figcaption><span>glib::subclass::types::obj</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">obj</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; crate::BorrowedObject&lt;Self::Type&gt;</span><br></pre></td></tr></table></figure>\n<p>还记得 <code>Self::Type</code> 是什么吗? 没错, 就是被暴露的那个 <code>CustomButton</code>, 而非 <code>imp::CustomButton</code>, 它才是被使用的真正实例(instance)<br>\n此处的 <code>obj()</code> 方法, 其别名就是 <code>instance()</code>, 得到的是在 <code>main.rs</code> 中被创建的那个真正实例的引用</p>\n<p>总而言之, 我们的所谓 <code>子类化</code>, 在rust中其实就是一个 warpper, 包装了一个来自gtk的部件<br>\n随后通过实现诸如 <code>ObjectImpl</code> 之类的 trait, 修改了父部件原本的行为</p>\n<p>顺便再复习一下, 防止有人看见这里而感疑惑: 为什么是 <code>clicked(&amp;self)</code> 而非 <code>clicked(&amp;mut self)</code>, 这样不应该更方便吗?<br>\n这是因为每个 GObject 都是引用计数的, 所以能绕过编译器的检查(全是不可变借用), 之前提到过了</p>\n<p>经过覆写虚函数, <code>CustomButton</code> 终于出现了有别于父类 <code>Button</code> 的新特性:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>被构造时: 初始化 label 为自己存储的状态数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>被点击时: 会让存储的状态数字+1, 随后更新 label</p>\n</li>\n</ul>\n<p>现在调用 <code>mold -run cargo run</code>, 你将得到一个按钮, 按钮的 label 初始时为 0, 被点击后不断+1</p>\n<hr>\n<h1 id=\"shi-yong-qing-kuang\">使用情况</h1>\n<p>什么情况下适合使用 <code>glib::wrapper</code> 来模拟继承呢 (Rust 语言层面上不支持继承, 因此叫模拟)</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>使用一个 widget, 其添加了自定义状态与覆写虚函数</p>\n</li>\n<li class=\"lvl-2\">\n<p>将 Rust 对象传递给要求参数是 GObject 的函数 (因为 gtk 不只是 Rust 的GUI框架, 还是其他许多语言的 GUI 框架)</p>\n</li>\n<li class=\"lvl-2\">\n<p>为某个对象添加 property 或 signal, 继承 glib 体系下的强大力量 (下面几节会讲)</p>\n</li>\n</ul>"},{"title":"rust-gtk4-p5~> GObject: 通用类型","abbrlink":"posts/rust-gtk4/p5","hidden":false,"date":"2022-11-20T05:51:26.000Z","top":98995,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p4","GObject: 子类化"],"next_post":["posts/rust-gtk4/p6","GObject: 属性"],"_content":"> 本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 说明\n之前说过, gnome体系依赖于 glib, 以C语言为核心的实现, 通过 Gobject-Introspection 为大量语言提供绑定  \n这是一套以C为核心, 支持多语言互相交互的运行时系统, 自然要有套完整且够通用的数据类型  \n\n在为Rust提供的绑定中, 有两套这样的数据类型, 分别是:  \n- `glib::Value`: 作用于 rust 与 glib 之间数据类型的互相转换\n- `glib::Variant`: 作用于数据类型的序列化/反序列化, 以使应用与外部世界(比如某个进程)交互, 或存储数据到本地磁盘\n\n之后学习属性与信号时, 我们将会用到 `glib::Value`, 即 `GValue`, 让 rust 中的数据类型 能与 glib 的库函数互相交互  \n之后学习偏好持久化/设置保存时, 我们将会用到 `glib::Variant`, 即 `GVariant`, 进行数据的序列化与反序列化  \n\n搞清楚以上的说明之后, 接下来的难度便是一马平川, 只需稍微看几眼有个印象, 到时候多查查文档就 ok 了  \n接下来的代码直接抄官方书籍了, 不过加了大量解释, 希望有助于你理解它们\n\n- - -\n\n# Value\n你可以简单地将 `glib::Value` 理解为一个 Wrapper 类型, 如果用 rust 中的 enum 来表示, 它可以是这样的:  \n\n\n```rust\nenum Value<T> {\n    bool(bool),\n    i8(i8),\n    i32(i32),\n    u32(u32),\n    i64(i64),\n    u64(u64),\n    f32(f32),\n    f64(f64),\n    // boxed-types\n    String(Option<String>),\n    Object(Option<dyn IsA<glib::Object>>),\n}\n```\n\n你会观察到 `boxed-types(装箱类型)` 这几个字, 它包装一个 rust 中的 `Option<T>` 类型  \n即, boxed-types, 可接受包装 `Option<T>::None`, 以此来表示可空这个概念  \n\n此时, 装箱所得的结果, 是个代表着C语言中 `null` 概念的东西, 而其他的如数字/布尔类型的 GValue, 则不允许包装 `None`  \n\n\n听着云里雾里的? 那就直接看代码吧, 下面是一些例子, 或许能帮助你更好地理解:\n\n```rust non-boxed-types example:\nuse gtk::prelude::*;\nfn main() {\n    // Store `i32` as `Value`\n    let integer_value = 10.to_value();\n\n    // Retrieve `i32` from `Value`\n    let integer = integer_value\n        .get::<i32>()\n        .expect(\"The value needs to be of type `i32`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(integer, 10);\n}\n```\n\n```rust boxed-types example:\nuse gtk::prelude::*;\nfn main() {\n    // Store `Option<String>` as `Value`\n    let string_some_value = \"Hello!\".to_value();\n    let string_none_value = None::<String>.to_value();\n\n    // Retrieve `String` from `Value`\n    let string_some = string_some_value\n        .get::<Option<String>>()\n        .expect(\"The value needs to be of type `Option<String>`.\");\n    let string_none = string_none_value\n        .get::<Option<String>>()\n        .expect(\"The value needs to be of type `Option<String>`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(string_some, Some(\"Hello!\".to_string()));\n    assert_eq!(string_none, None);\n}\n```\n\n当你希望区分可以表示空的Value, 只需将 `get::<String>` 换成 `get::<Option<String>>` 即可, 函数会自动帮你进行转换\n\n```rust directly use `get::&lt;String&gt;` instead of `get::&lt;Option&lt;String&gt;&gt;` if you are sure it is not none:\nuse gtk::prelude::*\nfn main() {\n    // Store string as `Value`\n    let string_value = \"Hello!\".to_value();\n\n    // Retrieve `String` from `Value`\n    let string = string_value\n        .get::<String>()\n        .expect(\"The value needs to be of type `String`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(string, \"Hello!\".to_string());\n}\n```\n\n我们将在之后学习 信号(signal) 与 属性(property) 时, 使用到 `glib::Value`\n\n- - -\n\n# Variant\n数据要发送到某个进程或网络, 或想将数据存储在磁盘上时, 就可以使用 `glib::Variant`  \n你可以将 `glib::Variant` 想象为 json 文本, 那是一种非常通用的文件格式  \n\n根据文档所述:  \nglib 中的 Variant, 被设计为与 dbus 体系有着基本相同的格式, 能够方便与 dbus 集成  \nVariant 在处理序列化形式的数据方面进行了大量优化, 可在很短的常量时间内, 执行几乎所有的反序列化操作，且占用非常小的内存  \n序列化的 Variant 数据也可以通过网络发送  \n\n因此你希望更深入学习, 可以查找 dbus 的相关资料, 这不在接下来的文章范围内\n\n与使用 `glib::Value` 的经验非常相似, 我们只需要将 `to_value()` 替换为 `to_variant()`:  \n\n```rust\nuse gtk::prelude::*;\nfn main() {\n    // Store `i32` as `Variant`\n    let integer_variant = 10.to_variant();\n\n    // Retrieve `i32` from `Variant`\n    let integer = integer_variant\n        .get::<i32>()\n        .expect(\"The variant needs to be of type `i32`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(integer, 10);\n}\n```\n\n更多例子, 以下代码将实现 `Vec<T>` 与 `glib::Variant` 间的互相转化:  \n\n```rust\nuse gtk::prelude::*;\nfn main() {\n    let variant = vec![\"Hello\", \"there!\"].to_variant();\n    assert_eq!(variant.n_children(), 2);\n\n    let vec = &variant\n        .get::<Vec<String>>()\n        .expect(\"The variant needs to be of type `String`.\");\n    assert_eq!(vec[0], \"Hello\");\n}\n```\n\n我们将在使用 `gio::Settings` 保存设置, 或使用 `gio::Action` 激活操作时，用到 `glib::Variant`\n","source":"_posts/rust/gui/gtk4/p5-GObject-通用类型.md","raw":"---\ntitle: \"rust-gtk4-p5~> GObject: 通用类型\"\nabbrlink: posts/rust-gtk4/p5\nhidden: false\ndate: 2022-11-20 13:51:26\ntop: 98995\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p4, \"GObject: 子类化\"]\nnext_post: [posts/rust-gtk4/p6, \"GObject: 属性\"]\n---\n> 本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 说明\n之前说过, gnome体系依赖于 glib, 以C语言为核心的实现, 通过 Gobject-Introspection 为大量语言提供绑定  \n这是一套以C为核心, 支持多语言互相交互的运行时系统, 自然要有套完整且够通用的数据类型  \n\n在为Rust提供的绑定中, 有两套这样的数据类型, 分别是:  \n- `glib::Value`: 作用于 rust 与 glib 之间数据类型的互相转换\n- `glib::Variant`: 作用于数据类型的序列化/反序列化, 以使应用与外部世界(比如某个进程)交互, 或存储数据到本地磁盘\n\n之后学习属性与信号时, 我们将会用到 `glib::Value`, 即 `GValue`, 让 rust 中的数据类型 能与 glib 的库函数互相交互  \n之后学习偏好持久化/设置保存时, 我们将会用到 `glib::Variant`, 即 `GVariant`, 进行数据的序列化与反序列化  \n\n搞清楚以上的说明之后, 接下来的难度便是一马平川, 只需稍微看几眼有个印象, 到时候多查查文档就 ok 了  \n接下来的代码直接抄官方书籍了, 不过加了大量解释, 希望有助于你理解它们\n\n- - -\n\n# Value\n你可以简单地将 `glib::Value` 理解为一个 Wrapper 类型, 如果用 rust 中的 enum 来表示, 它可以是这样的:  \n\n\n```rust\nenum Value<T> {\n    bool(bool),\n    i8(i8),\n    i32(i32),\n    u32(u32),\n    i64(i64),\n    u64(u64),\n    f32(f32),\n    f64(f64),\n    // boxed-types\n    String(Option<String>),\n    Object(Option<dyn IsA<glib::Object>>),\n}\n```\n\n你会观察到 `boxed-types(装箱类型)` 这几个字, 它包装一个 rust 中的 `Option<T>` 类型  \n即, boxed-types, 可接受包装 `Option<T>::None`, 以此来表示可空这个概念  \n\n此时, 装箱所得的结果, 是个代表着C语言中 `null` 概念的东西, 而其他的如数字/布尔类型的 GValue, 则不允许包装 `None`  \n\n\n听着云里雾里的? 那就直接看代码吧, 下面是一些例子, 或许能帮助你更好地理解:\n\n```rust non-boxed-types example:\nuse gtk::prelude::*;\nfn main() {\n    // Store `i32` as `Value`\n    let integer_value = 10.to_value();\n\n    // Retrieve `i32` from `Value`\n    let integer = integer_value\n        .get::<i32>()\n        .expect(\"The value needs to be of type `i32`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(integer, 10);\n}\n```\n\n```rust boxed-types example:\nuse gtk::prelude::*;\nfn main() {\n    // Store `Option<String>` as `Value`\n    let string_some_value = \"Hello!\".to_value();\n    let string_none_value = None::<String>.to_value();\n\n    // Retrieve `String` from `Value`\n    let string_some = string_some_value\n        .get::<Option<String>>()\n        .expect(\"The value needs to be of type `Option<String>`.\");\n    let string_none = string_none_value\n        .get::<Option<String>>()\n        .expect(\"The value needs to be of type `Option<String>`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(string_some, Some(\"Hello!\".to_string()));\n    assert_eq!(string_none, None);\n}\n```\n\n当你希望区分可以表示空的Value, 只需将 `get::<String>` 换成 `get::<Option<String>>` 即可, 函数会自动帮你进行转换\n\n```rust directly use `get::&lt;String&gt;` instead of `get::&lt;Option&lt;String&gt;&gt;` if you are sure it is not none:\nuse gtk::prelude::*\nfn main() {\n    // Store string as `Value`\n    let string_value = \"Hello!\".to_value();\n\n    // Retrieve `String` from `Value`\n    let string = string_value\n        .get::<String>()\n        .expect(\"The value needs to be of type `String`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(string, \"Hello!\".to_string());\n}\n```\n\n我们将在之后学习 信号(signal) 与 属性(property) 时, 使用到 `glib::Value`\n\n- - -\n\n# Variant\n数据要发送到某个进程或网络, 或想将数据存储在磁盘上时, 就可以使用 `glib::Variant`  \n你可以将 `glib::Variant` 想象为 json 文本, 那是一种非常通用的文件格式  \n\n根据文档所述:  \nglib 中的 Variant, 被设计为与 dbus 体系有着基本相同的格式, 能够方便与 dbus 集成  \nVariant 在处理序列化形式的数据方面进行了大量优化, 可在很短的常量时间内, 执行几乎所有的反序列化操作，且占用非常小的内存  \n序列化的 Variant 数据也可以通过网络发送  \n\n因此你希望更深入学习, 可以查找 dbus 的相关资料, 这不在接下来的文章范围内\n\n与使用 `glib::Value` 的经验非常相似, 我们只需要将 `to_value()` 替换为 `to_variant()`:  \n\n```rust\nuse gtk::prelude::*;\nfn main() {\n    // Store `i32` as `Variant`\n    let integer_variant = 10.to_variant();\n\n    // Retrieve `i32` from `Variant`\n    let integer = integer_variant\n        .get::<i32>()\n        .expect(\"The variant needs to be of type `i32`.\");\n\n    // Check if the retrieved value is correct\n    assert_eq!(integer, 10);\n}\n```\n\n更多例子, 以下代码将实现 `Vec<T>` 与 `glib::Variant` 间的互相转化:  \n\n```rust\nuse gtk::prelude::*;\nfn main() {\n    let variant = vec![\"Hello\", \"there!\"].to_variant();\n    assert_eq!(variant.n_children(), 2);\n\n    let vec = &variant\n        .get::<Vec<String>>()\n        .expect(\"The variant needs to be of type `String`.\");\n    assert_eq!(vec[0], \"Hello\");\n}\n```\n\n我们将在使用 `gio::Settings` 保存设置, 或使用 `gio::Action` 激活操作时，用到 `glib::Variant`\n","slug":"rust/gui/gtk4/p5-GObject-通用类型","published":1,"updated":"2022-11-20T05:51:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohc002rj1s60or60zo4","content":"<blockquote>\n<p>本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"shuo-ming\">说明</h1>\n<p>之前说过, gnome体系依赖于 glib, 以C语言为核心的实现, 通过 Gobject-Introspection 为大量语言提供绑定<br>\n这是一套以C为核心, 支持多语言互相交互的运行时系统, 自然要有套完整且够通用的数据类型</p>\n<p>在为Rust提供的绑定中, 有两套这样的数据类型, 分别是:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>glib::Value</code>: 作用于 rust 与 glib 之间数据类型的互相转换</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>glib::Variant</code>: 作用于数据类型的序列化/反序列化, 以使应用与外部世界(比如某个进程)交互, 或存储数据到本地磁盘</p>\n</li>\n</ul>\n<p>之后学习属性与信号时, 我们将会用到 <code>glib::Value</code>, 即 <code>GValue</code>, 让 rust 中的数据类型 能与 glib 的库函数互相交互<br>\n之后学习偏好持久化/设置保存时, 我们将会用到 <code>glib::Variant</code>, 即 <code>GVariant</code>, 进行数据的序列化与反序列化</p>\n<p>搞清楚以上的说明之后, 接下来的难度便是一马平川, 只需稍微看几眼有个印象, 到时候多查查文档就 ok 了<br>\n接下来的代码直接抄官方书籍了, 不过加了大量解释, 希望有助于你理解它们</p>\n<hr>\n<h1 id=\"value\">Value</h1>\n<p>你可以简单地将 <code>glib::Value</code> 理解为一个 Wrapper 类型, 如果用 rust 中的 enum 来表示, 它可以是这样的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Value</span></span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span>(<span class=\"built_in\">bool</span>),</span><br><span class=\"line\">    <span class=\"built_in\">i8</span>(<span class=\"built_in\">i8</span>),</span><br><span class=\"line\">    <span class=\"built_in\">i32</span>(<span class=\"built_in\">i32</span>),</span><br><span class=\"line\">    <span class=\"built_in\">u32</span>(<span class=\"built_in\">u32</span>),</span><br><span class=\"line\">    <span class=\"built_in\">i64</span>(<span class=\"built_in\">i64</span>),</span><br><span class=\"line\">    <span class=\"built_in\">u64</span>(<span class=\"built_in\">u64</span>),</span><br><span class=\"line\">    <span class=\"built_in\">f32</span>(<span class=\"built_in\">f32</span>),</span><br><span class=\"line\">    <span class=\"built_in\">f64</span>(<span class=\"built_in\">f64</span>),</span><br><span class=\"line\">    <span class=\"comment\">// boxed-types</span></span><br><span class=\"line\">    <span class=\"built_in\">String</span>(<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt;),</span><br><span class=\"line\">    Object(<span class=\"built_in\">Option</span>&lt;<span class=\"keyword\">dyn</span> IsA&lt;glib::Object&gt;&gt;),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你会观察到 <code>boxed-types(装箱类型)</code> 这几个字, 它包装一个 rust 中的 <code>Option&lt;T&gt;</code> 类型<br>\n即, boxed-types, 可接受包装 <code>Option&lt;T&gt;::None</code>, 以此来表示可空这个概念</p>\n<p>此时, 装箱所得的结果, 是个代表着C语言中 <code>null</code> 概念的东西, 而其他的如数字/布尔类型的 GValue, 则不允许包装 <code>None</code></p>\n<p>听着云里雾里的? 那就直接看代码吧, 下面是一些例子, 或许能帮助你更好地理解:</p>\n<figure class=\"highlight rust\"><figcaption><span>non-boxed-types example:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store `i32` as `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer_value = <span class=\"number\">10</span>.to_value();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `i32` from `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer = integer_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">i32</span>&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `i32`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(integer, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><figcaption><span>boxed-types example:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store `Option&lt;String&gt;` as `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_some_value = <span class=\"string\">&quot;Hello!&quot;</span>.to_value();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_none_value = None::&lt;<span class=\"built_in\">String</span>&gt;.to_value();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `String` from `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_some = string_some_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt;&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_none = string_none_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt;&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(string_some, <span class=\"literal\">Some</span>(<span class=\"string\">&quot;Hello!&quot;</span>.to_string()));</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(string_none, <span class=\"literal\">None</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你希望区分可以表示空的Value, 只需将 <code>get::&lt;String&gt;</code> 换成 <code>get::&lt;Option&lt;String&gt;&gt;</code> 即可, 函数会自动帮你进行转换</p>\n<figure class=\"highlight rust\"><figcaption><span>directly use `get::&lt;String&gt;` instead of `get::&lt;Option&lt;String&gt;&gt;` if you are sure it is not none:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store string as `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_value = <span class=\"string\">&quot;Hello!&quot;</span>.to_value();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `String` from `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string = string_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">String</span>&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `String`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(string, <span class=\"string\">&quot;Hello!&quot;</span>.to_string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在之后学习 信号(signal) 与 属性(property) 时, 使用到 <code>glib::Value</code></p>\n<hr>\n<h1 id=\"variant\">Variant</h1>\n<p>数据要发送到某个进程或网络, 或想将数据存储在磁盘上时, 就可以使用 <code>glib::Variant</code><br>\n你可以将 <code>glib::Variant</code> 想象为 json 文本, 那是一种非常通用的文件格式</p>\n<p>根据文档所述:<br>\nglib 中的 Variant, 被设计为与 dbus 体系有着基本相同的格式, 能够方便与 dbus 集成<br>\nVariant 在处理序列化形式的数据方面进行了大量优化, 可在很短的常量时间内, 执行几乎所有的反序列化操作，且占用非常小的内存<br>\n序列化的 Variant 数据也可以通过网络发送</p>\n<p>因此你希望更深入学习, 可以查找 dbus 的相关资料, 这不在接下来的文章范围内</p>\n<p>与使用 <code>glib::Value</code> 的经验非常相似, 我们只需要将 <code>to_value()</code> 替换为 <code>to_variant()</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store `i32` as `Variant`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer_variant = <span class=\"number\">10</span>.to_variant();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `i32` from `Variant`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer = integer_variant</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">i32</span>&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The variant needs to be of type `i32`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(integer, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多例子, 以下代码将实现 <code>Vec&lt;T&gt;</code> 与 <code>glib::Variant</code> 间的互相转化:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> variant = <span class=\"built_in\">vec!</span>[<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;there!&quot;</span>].to_variant();</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(variant.n_children(), <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> vec = &amp;variant</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">String</span>&gt;&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The variant needs to be of type `String`.&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(vec[<span class=\"number\">0</span>], <span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在使用 <code>gio::Settings</code> 保存设置, 或使用 <code>gio::Action</code> 激活操作时，用到 <code>glib::Variant</code></p>\n","site":{"data":{}},"length":3439,"excerpt":"<blockquote>\n<p>本节将学习 GObject 的 generic-values(通用值), 了解 glib 的通用体系, 与序列化的代码</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"shuo-ming\">说明</h1>\n<p>之前说过, gnome体系依赖于 glib, 以C语言为核心的实现, 通过 Gobject-Introspection 为大量语言提供绑定<br>\n这是一套以C为核心, 支持多语言互相交互的运行时系统, 自然要有套完整且够通用的数据类型</p>\n<p>在为Rust提供的绑定中, 有两套这样的数据类型, 分别是:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>glib::Value</code>: 作用于 rust 与 glib 之间数据类型的互相转换</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>glib::Variant</code>: 作用于数据类型的序列化/反序列化, 以使应用与外部世界(比如某个进程)交互, 或存储数据到本地磁盘</p>\n</li>\n</ul>\n<p>之后学习属性与信号时, 我们将会用到 <code>glib::Value</code>, 即 <code>GValue</code>, 让 rust 中的数据类型 能与 glib 的库函数互相交互<br>\n之后学习偏好持久化/设置保存时, 我们将会用到 <code>glib::Variant</code>, 即 <code>GVariant</code>, 进行数据的序列化与反序列化</p>\n<p>搞清楚以上的说明之后, 接下来的难度便是一马平川, 只需稍微看几眼有个印象, 到时候多查查文档就 ok 了<br>\n接下来的代码直接抄官方书籍了, 不过加了大量解释, 希望有助于你理解它们</p>\n<hr>\n<h1 id=\"value\">Value</h1>\n<p>你可以简单地将 <code>glib::Value</code> 理解为一个 Wrapper 类型, 如果用 rust 中的 enum 来表示, 它可以是这样的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Value</span></span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span>(<span class=\"built_in\">bool</span>),</span><br><span class=\"line\">    <span class=\"built_in\">i8</span>(<span class=\"built_in\">i8</span>),</span><br><span class=\"line\">    <span class=\"built_in\">i32</span>(<span class=\"built_in\">i32</span>),</span><br><span class=\"line\">    <span class=\"built_in\">u32</span>(<span class=\"built_in\">u32</span>),</span><br><span class=\"line\">    <span class=\"built_in\">i64</span>(<span class=\"built_in\">i64</span>),</span><br><span class=\"line\">    <span class=\"built_in\">u64</span>(<span class=\"built_in\">u64</span>),</span><br><span class=\"line\">    <span class=\"built_in\">f32</span>(<span class=\"built_in\">f32</span>),</span><br><span class=\"line\">    <span class=\"built_in\">f64</span>(<span class=\"built_in\">f64</span>),</span><br><span class=\"line\">    <span class=\"comment\">// boxed-types</span></span><br><span class=\"line\">    <span class=\"built_in\">String</span>(<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt;),</span><br><span class=\"line\">    Object(<span class=\"built_in\">Option</span>&lt;<span class=\"keyword\">dyn</span> IsA&lt;glib::Object&gt;&gt;),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你会观察到 <code>boxed-types(装箱类型)</code> 这几个字, 它包装一个 rust 中的 <code>Option&lt;T&gt;</code> 类型<br>\n即, boxed-types, 可接受包装 <code>Option&lt;T&gt;::None</code>, 以此来表示可空这个概念</p>\n<p>此时, 装箱所得的结果, 是个代表着C语言中 <code>null</code> 概念的东西, 而其他的如数字/布尔类型的 GValue, 则不允许包装 <code>None</code></p>\n<p>听着云里雾里的? 那就直接看代码吧, 下面是一些例子, 或许能帮助你更好地理解:</p>\n<figure class=\"highlight rust\"><figcaption><span>non-boxed-types example:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store `i32` as `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer_value = <span class=\"number\">10</span>.to_value();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `i32` from `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer = integer_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">i32</span>&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `i32`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(integer, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><figcaption><span>boxed-types example:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store `Option&lt;String&gt;` as `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_some_value = <span class=\"string\">&quot;Hello!&quot;</span>.to_value();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_none_value = None::&lt;<span class=\"built_in\">String</span>&gt;.to_value();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `String` from `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_some = string_some_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt;&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_none = string_none_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt;&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `Option&lt;String&gt;`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(string_some, <span class=\"literal\">Some</span>(<span class=\"string\">&quot;Hello!&quot;</span>.to_string()));</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(string_none, <span class=\"literal\">None</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你希望区分可以表示空的Value, 只需将 <code>get::&lt;String&gt;</code> 换成 <code>get::&lt;Option&lt;String&gt;&gt;</code> 即可, 函数会自动帮你进行转换</p>\n<figure class=\"highlight rust\"><figcaption><span>directly use `get::&lt;String&gt;` instead of `get::&lt;Option&lt;String&gt;&gt;` if you are sure it is not none:</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store string as `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string_value = <span class=\"string\">&quot;Hello!&quot;</span>.to_value();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `String` from `Value`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> string = string_value</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">String</span>&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The value needs to be of type `String`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(string, <span class=\"string\">&quot;Hello!&quot;</span>.to_string());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在之后学习 信号(signal) 与 属性(property) 时, 使用到 <code>glib::Value</code></p>\n<hr>\n<h1 id=\"variant\">Variant</h1>\n<p>数据要发送到某个进程或网络, 或想将数据存储在磁盘上时, 就可以使用 <code>glib::Variant</code><br>\n你可以将 <code>glib::Variant</code> 想象为 json 文本, 那是一种非常通用的文件格式</p>\n<p>根据文档所述:<br>\nglib 中的 Variant, 被设计为与 dbus 体系有着基本相同的格式, 能够方便与 dbus 集成<br>\nVariant 在处理序列化形式的数据方面进行了大量优化, 可在很短的常量时间内, 执行几乎所有的反序列化操作，且占用非常小的内存<br>\n序列化的 Variant 数据也可以通过网络发送</p>\n<p>因此你希望更深入学习, 可以查找 dbus 的相关资料, 这不在接下来的文章范围内</p>\n<p>与使用 <code>glib::Value</code> 的经验非常相似, 我们只需要将 <code>to_value()</code> 替换为 <code>to_variant()</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Store `i32` as `Variant`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer_variant = <span class=\"number\">10</span>.to_variant();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retrieve `i32` from `Variant`</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> integer = integer_variant</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">i32</span>&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The variant needs to be of type `i32`.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if the retrieved value is correct</span></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(integer, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多例子, 以下代码将实现 <code>Vec&lt;T&gt;</code> 与 <code>glib::Variant</code> 间的互相转化:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> variant = <span class=\"built_in\">vec!</span>[<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;there!&quot;</span>].to_variant();</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(variant.n_children(), <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> vec = &amp;variant</span><br><span class=\"line\">        .get::&lt;<span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">String</span>&gt;&gt;()</span><br><span class=\"line\">        .expect(<span class=\"string\">&quot;The variant needs to be of type `String`.&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(vec[<span class=\"number\">0</span>], <span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将在使用 <code>gio::Settings</code> 保存设置, 或使用 <code>gio::Action</code> 激活操作时，用到 <code>glib::Variant</code></p>"},{"title":"rust-gtk4-p6~> GObject: 属性","abbrlink":"posts/rust-gtk4/p6","hidden":false,"date":"2022-12-10T15:39:26.000Z","top":98994,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p5","GObject: 通用类型"],"next_post":["posts/rust-gtk4/p7","GObject: 信号"],"_content":"> 本节将学习 GObject 的 property(属性), 探索其强大且灵活的运行时\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 说明  \n属性(Property), 让我们能够访问 GObject 的状态(state)  \n\nglib 虽然以面向过程的 C 为核心, 但却具有面向对象的思想, 属性自然是其中重要的一环  \n通过库为我们提供的运行时, 我们得到了一个灵活的, 动态的运行时  \n\n得益于此, 我们可以在程序的运行过程中, 动态地修改其属性, 比如:  \n- 动态注册某个新的属性  \n- 进行属性间的自动绑定  \n- 属性变更时将执行操作 \n\n- - -\n\n# 常规使用\n\n如下的代码是一个修改 `Switch` 部件的 `state` 属性, 并在下一行获取其值的例子:  \n(记得use一下相关的路径, 这里为了简略就没有写出来, 本节之后的代码也是同理)  \n\n```rust src/main.rs\nfn build_ui(app: &Application) {\n    // Create the switch\n    let switch = Switch::new();\n\n    // Set and then immediately obtain state\n    switch.set_state(true);\n    let current_state = switch.state();\n\n    // This prints: \"The current state is true\"\n    println!(\"The current state is {}\", current_state);\n}\n```\n\n我们还可以用 `general-property` 来设置与获取属性, 与上一节的[通用类型](/posts/rust-gtk4/p5)相对应  \n例子如下, 在获取属性时用 `turbofish` 语法来推导其类型:  \n\n```rust src/main.rs\nfn build_ui(app_&Application) {\n    // Create the switch\n    let switch = Switch::new();\n\n    // Set and then immediately obtain state\n    switch.set_property(\"state\", &true);\n    let current_state = switch.property::<bool>(\"state\");\n\n    // This prints: \"The current state is true\"\n    println!(\"The current state is {}\", current_state);\n}\n```\n\n如果属性不存在/类型不正确/属性不可写(无write权限)等, 都会导致 `property`/`set_property` 恐慌(panic), 在大部分如上的硬编码情况下是可行的  \n同样的, 如果你想设置多个属性, 可以用 `properties`/`set_properties`  \n\n现在已经不存在 `try_property`/`try_set_property`, 因为导致错误的情况, 只是仅为上一段所述的几种而已  \n不过截止目前, 官方教程还没有更新, 我已经提交了一个pr  \n\n值得注意的是, 当你使用这种以字符串的方式来访问属性时, 需要遵循 `kebab-case(烤肉串式)`, 比如 `user-name`, `person-age`  \n在本节后面, 我们为自定义对象创建自定义属性时, 也需要遵循这种命名方式  \n\n- - -\n\n# 属性绑定\n\n属性不仅可以通过 `getter`/`setter` 进行访问与修改, 还可以彼此进行绑定:  \n\n```rust src/main.rs\nfn build_ui(app: &Application) {\n    // Create the switches\n    let switch_1 = Switch::new();\n    let switch_2 = Switch::new();\n\n    switch_1\n        .bind_property(\"state\", &switch_2, \"state\")\n        .flags(BindingFlags::BIDIRECTIONAL)\n        .build();\n}\n```\n\n`bi-directional` 的意思是 `双向`, 我们在这里进行了双向绑定, `switch_1` 的 `state` 已经与 `switch_2` 的 `state` 绑在了一起  \n于是, 两个 `switch` 的 `state` 属性会一直保持一样, 修改其中一个, 另外一个也会被自动修改  \n\n如果你不添加任何 `BindingFlags`, 则为默认的 `BindingFlags::DEFAULT`, 作用是由源属性向目标属性进行更新  \n\n可以看下来自官方教程的动图, 当我们切换其中一个按钮的状态时, 另外一个会自动保持相同:  \n\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/bidirectional_switches.webm\" type=\"video/webm\">\n</video>\n\n- - -\n\n# 为自定义对象添加属性\n\n我们还可以为 `CustomObject` 添加属性, 以 [p4](/posts/rust-gtk4/p4) 中所讲述的 `CustomButton` 为例  \n(没印象的赶紧再去看看, 毕竟本篇p6是写完p4好久后才更新的...当然如果你是未来来的, 不是追着看的话, 问题也不大, 那时本系列应该写完了, 吧?)  \n\n我们为 `CustomButton` 实现 `ObjectImpl` 这个 trait, 覆写对应的虚函数:  \n```rust src/custom_button/imp.rs\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {\n    fn properties() -> &'static [ParamSpec] {\n        static PROPERTIES: Lazy<Vec<ParamSpec>> =\n            Lazy::new(|| vec![ParamSpecInt::builder(\"number\").build()]);\n        PROPERTIES.as_ref()\n    }\n    fn set_property(&self, _id: usize, value: &Value, pspec: &ParamSpec) {\n        match pspec.name() {\n            \"number\" => {\n                let input_number =\n                    value.get().expect(\"The value needs to be of type `i32`.\");\n                self.number.replace(input_number);\n            }\n            _ => unimplemented!(),\n        }\n    }\n    fn property(&self, _id: usize, pspec: &ParamSpec) -> Value {\n        match pspec.name() {\n            \"number\" => self.number.get().to_value(),\n            _ => unimplemented!(),\n        }\n    }\n    fn constructed(&self) {\n        self.parent_constructed();\n\n        // Bind label to number\n        // `SYNC_CREATE` ensures that the label will be immediately set\n        let obj = self.obj();\n        obj.bind_property(\"number\", obj.as_ref(), \"label\")\n            .flags(BindingFlags::SYNC_CREATE)\n            .build();\n    }\n}\n```\n\n看见 `fn properties` 里面的 `Lazy` 没有? 这是为了延迟创建资源的过程  \n每次访问都会检查是否已经创建了资源, 没有的话就调用闭包进行创建并访问, 不然就直接访问已经创建好的资源  \n这样就能避免每一次调用 `properties` 时都需要重新创建资源了  \n\n当然, rust-analyzer 可能无法为你导入 `Lazy` 所在的路径, 因为它可能还没有进标准库  \n在它进标准库之前, 可以使用 `once_cell` crate:  \n\n在项目的根目录执行:  \n\n```bash\ncargo add once_cell\n```\n\n你会看见 `ParamSpec` 这样的类型, 其来自于 `glib`, 按照相应的 [文档](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.ParamSpec.html) 所述, 是一个struct, 封装了指定参数所需的元数据  \n如果将C语言的描述, 换成了看起来稍微轻松一些的rust版本, 它差不多长这样:  \n\n```rust\nstruct ParamSpec<'a> {\n    name: &'a str,             // 属性的名称, 按照 `kebab-case`\n    flags: glib::ParamFlags,   // 比如读写权限\n    value_type: glib::Type,    // 属性对应值的类型\n    owner_type: glib::Type     // 属性所有者的类型\n    // more\n    // more\n}\n```\n\n比如代码中出现的 `ParamSpecInt`, 就是基于 `ParamSpec` 的基础上, 指定了 `value_type`  \n\n接下来讲 `fn constructed`:  \n其中出现了 `BindingFlags::SYNC_CREATE`, 它的作用是, 当创建绑定时会进行一次同步, 方向是 form 源属性 to 目标属性, 作用类似于初始化  \n而之前的 `BindingFlags::BIDIRECTIONAL` 则是当源或目标属性中的一个发生更改时, 才进行同步  \n\n更多的flags, 自己去看 [文档](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.BindingFlags.html)\n\n这几处讲完, 其外的代码就不讲了, 可以当作模板来使用  \n\n敏锐的小伙伴会注意到, `number` 与 `label`, 这两个属性的类型好像不相等吧?  \n之前的 [p4](/posts/rust-gtk4/p4) 里, 可不是这样写的, 没错, 属性与属性的绑定, 其值的类型并不一定要是同类型!  \n\n下面是对比, 两种写法实现了相同的功能, 将 `number` 字符串化之后, 当作按钮的 `label`:  \n\n```rust src/custom_button/imp.rs\nimpl ObjectImpl for CustomButton {\n    // p4:\n    fn constructed(&self) {\n        self.parent_constructed();\n        self.obj().set_label(&self.number.get().to_string());\n    }\n\n    // p6:\n    fn constructed(&self) {\n        self.parent_constructed();\n\n        let obj = self.obj();\n        obj.bind_property(\"number\", obj.as_ref(), \"label\")\n            .flags(BindingFlags::SYNC_CREATE)\n            .build();\n}\n```\n\n- 前一种写法中:  \n你需要自己手动 `get` 内部值, 手动字符串化, 然后当作参数赋给 `set_label`  \n其实这没什么大不了, 关键是你每一次修改 `number`, 都必须记得要同时修改 `label`, 进行重复性的工作\n\n- 后一种写法中:  \n通过绑定属性, 类型间的转化自动进行, 而且写法上更加清晰易懂 (`SYNC_CREATE` 显式地声明了目的)  \n于此同时, 当你修改 `number` 属性的值时, `label` 会自动适应, 你只需关注 `number` 即可 \n\n让我们继续, 接下来重载按钮被点击时的行为:  \n\n```rust src/custom_button/imp.rs\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {\n    fn clicked(&self) {\n        let number_inc = self.number.get() + 1;\n        self.obj().set_property(\"number\", &number_inc);\n    }\n}\n```\n\n瞧, 得益于属性绑定, 你只需修改 `number` 属性的值即可, 不必再重复地添加令人生厌的模板代码, 去手动修改 `label` 了  \n\n- - -\n\n# 控制属性绑定的方向\n接下来, 我们来完成这样一件事: 创建两个按钮, btn_1 初始为零, btn_2 始终比 btn_1 高一, 某个按钮被点击后, 其数值加一  \n其效果如动图所示:  \n\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/transform_buttons.webm\" type=\"video/webm\">\n</video>\n\n这两个按钮的 `number` 属性, 互相之间存在关联, 你可能会想到属性绑定, 没错, 不过相较于之间 `number` to `label` 的例子, 此处粒度会更细:  \n直接看代码:  \n\n```rust src/main.rs\nfn build_ui(app: &Application) {\n    // Create the buttons\n    let btn_1 = Custombtn::new();\n    let btn_2 = Custombtn::new();\n\n    // Assure that \"number\" of `btn_2` is always 1 higher than \"number\" of `btn_1`\n    btn_1\n        .bind_property(\"number\", &btn_2, \"number\")\n        // How to transform \"number\" from `btn_1` to \"number\" of `btn_2`\n        .transform_to(|_, number: i32| {\n            let incremented_number = number + 1;\n            Some(incremented_number.to_value())\n        })\n        // How to transform \"number\" from `btn_2` to \"number\" of `btn_1`\n        .transform_from(|_, number: i32| {\n            let decremented_number = number - 1;\n            Some(decremented_number.to_value())\n        })\n        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)\n        .build();\n}\n```\n\n代码很好理解, `transform_to` 定义了从源属性到目标属性的动作, `transform_from` 则是方向相反  \n\n同时, `BIDIRECTIONAL | SYNC_CREATE` 则分别声明了双向与初始化:\n  \n- 双向: 由于 `BIDIRECTIONAL`, 其中一个发生被click, 数值发生改变后会按照对应方向对应的闭包, 更新另一个\n- 初始化: 立刻进行一次更新, 方向是to\n\n- - -\n\n# 属性更改事件\n\n你可以在属性发生更改时, 执行一个闭包, 比如:  \n\n```rust src/main.rs\n    btn_1.connect_notify_local(Some(\"number\"), move |btn, _| {\n        let number = btn.property::<i32>(\"number\");\n        println!(\"The current number of `btn_1` is {}.\", number);\n    });\n```\n\n当 `number` 属性的值发生更改后, 会在标准输出中, 打印按钮当前显示的数值  \n","source":"_posts/rust/gui/gtk4/p6-GObject-属性.md","raw":"---\ntitle: \"rust-gtk4-p6~> GObject: 属性\"\nabbrlink: posts/rust-gtk4/p6\nhidden: false\ndate: 2022-12-10 23:39:26\ntop: 98994\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p5, \"GObject: 通用类型\"]\nnext_post: [posts/rust-gtk4/p7, \"GObject: 信号\"]\n---\n> 本节将学习 GObject 的 property(属性), 探索其强大且灵活的运行时\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 说明  \n属性(Property), 让我们能够访问 GObject 的状态(state)  \n\nglib 虽然以面向过程的 C 为核心, 但却具有面向对象的思想, 属性自然是其中重要的一环  \n通过库为我们提供的运行时, 我们得到了一个灵活的, 动态的运行时  \n\n得益于此, 我们可以在程序的运行过程中, 动态地修改其属性, 比如:  \n- 动态注册某个新的属性  \n- 进行属性间的自动绑定  \n- 属性变更时将执行操作 \n\n- - -\n\n# 常规使用\n\n如下的代码是一个修改 `Switch` 部件的 `state` 属性, 并在下一行获取其值的例子:  \n(记得use一下相关的路径, 这里为了简略就没有写出来, 本节之后的代码也是同理)  \n\n```rust src/main.rs\nfn build_ui(app: &Application) {\n    // Create the switch\n    let switch = Switch::new();\n\n    // Set and then immediately obtain state\n    switch.set_state(true);\n    let current_state = switch.state();\n\n    // This prints: \"The current state is true\"\n    println!(\"The current state is {}\", current_state);\n}\n```\n\n我们还可以用 `general-property` 来设置与获取属性, 与上一节的[通用类型](/posts/rust-gtk4/p5)相对应  \n例子如下, 在获取属性时用 `turbofish` 语法来推导其类型:  \n\n```rust src/main.rs\nfn build_ui(app_&Application) {\n    // Create the switch\n    let switch = Switch::new();\n\n    // Set and then immediately obtain state\n    switch.set_property(\"state\", &true);\n    let current_state = switch.property::<bool>(\"state\");\n\n    // This prints: \"The current state is true\"\n    println!(\"The current state is {}\", current_state);\n}\n```\n\n如果属性不存在/类型不正确/属性不可写(无write权限)等, 都会导致 `property`/`set_property` 恐慌(panic), 在大部分如上的硬编码情况下是可行的  \n同样的, 如果你想设置多个属性, 可以用 `properties`/`set_properties`  \n\n现在已经不存在 `try_property`/`try_set_property`, 因为导致错误的情况, 只是仅为上一段所述的几种而已  \n不过截止目前, 官方教程还没有更新, 我已经提交了一个pr  \n\n值得注意的是, 当你使用这种以字符串的方式来访问属性时, 需要遵循 `kebab-case(烤肉串式)`, 比如 `user-name`, `person-age`  \n在本节后面, 我们为自定义对象创建自定义属性时, 也需要遵循这种命名方式  \n\n- - -\n\n# 属性绑定\n\n属性不仅可以通过 `getter`/`setter` 进行访问与修改, 还可以彼此进行绑定:  \n\n```rust src/main.rs\nfn build_ui(app: &Application) {\n    // Create the switches\n    let switch_1 = Switch::new();\n    let switch_2 = Switch::new();\n\n    switch_1\n        .bind_property(\"state\", &switch_2, \"state\")\n        .flags(BindingFlags::BIDIRECTIONAL)\n        .build();\n}\n```\n\n`bi-directional` 的意思是 `双向`, 我们在这里进行了双向绑定, `switch_1` 的 `state` 已经与 `switch_2` 的 `state` 绑在了一起  \n于是, 两个 `switch` 的 `state` 属性会一直保持一样, 修改其中一个, 另外一个也会被自动修改  \n\n如果你不添加任何 `BindingFlags`, 则为默认的 `BindingFlags::DEFAULT`, 作用是由源属性向目标属性进行更新  \n\n可以看下来自官方教程的动图, 当我们切换其中一个按钮的状态时, 另外一个会自动保持相同:  \n\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/bidirectional_switches.webm\" type=\"video/webm\">\n</video>\n\n- - -\n\n# 为自定义对象添加属性\n\n我们还可以为 `CustomObject` 添加属性, 以 [p4](/posts/rust-gtk4/p4) 中所讲述的 `CustomButton` 为例  \n(没印象的赶紧再去看看, 毕竟本篇p6是写完p4好久后才更新的...当然如果你是未来来的, 不是追着看的话, 问题也不大, 那时本系列应该写完了, 吧?)  \n\n我们为 `CustomButton` 实现 `ObjectImpl` 这个 trait, 覆写对应的虚函数:  \n```rust src/custom_button/imp.rs\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {\n    fn properties() -> &'static [ParamSpec] {\n        static PROPERTIES: Lazy<Vec<ParamSpec>> =\n            Lazy::new(|| vec![ParamSpecInt::builder(\"number\").build()]);\n        PROPERTIES.as_ref()\n    }\n    fn set_property(&self, _id: usize, value: &Value, pspec: &ParamSpec) {\n        match pspec.name() {\n            \"number\" => {\n                let input_number =\n                    value.get().expect(\"The value needs to be of type `i32`.\");\n                self.number.replace(input_number);\n            }\n            _ => unimplemented!(),\n        }\n    }\n    fn property(&self, _id: usize, pspec: &ParamSpec) -> Value {\n        match pspec.name() {\n            \"number\" => self.number.get().to_value(),\n            _ => unimplemented!(),\n        }\n    }\n    fn constructed(&self) {\n        self.parent_constructed();\n\n        // Bind label to number\n        // `SYNC_CREATE` ensures that the label will be immediately set\n        let obj = self.obj();\n        obj.bind_property(\"number\", obj.as_ref(), \"label\")\n            .flags(BindingFlags::SYNC_CREATE)\n            .build();\n    }\n}\n```\n\n看见 `fn properties` 里面的 `Lazy` 没有? 这是为了延迟创建资源的过程  \n每次访问都会检查是否已经创建了资源, 没有的话就调用闭包进行创建并访问, 不然就直接访问已经创建好的资源  \n这样就能避免每一次调用 `properties` 时都需要重新创建资源了  \n\n当然, rust-analyzer 可能无法为你导入 `Lazy` 所在的路径, 因为它可能还没有进标准库  \n在它进标准库之前, 可以使用 `once_cell` crate:  \n\n在项目的根目录执行:  \n\n```bash\ncargo add once_cell\n```\n\n你会看见 `ParamSpec` 这样的类型, 其来自于 `glib`, 按照相应的 [文档](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.ParamSpec.html) 所述, 是一个struct, 封装了指定参数所需的元数据  \n如果将C语言的描述, 换成了看起来稍微轻松一些的rust版本, 它差不多长这样:  \n\n```rust\nstruct ParamSpec<'a> {\n    name: &'a str,             // 属性的名称, 按照 `kebab-case`\n    flags: glib::ParamFlags,   // 比如读写权限\n    value_type: glib::Type,    // 属性对应值的类型\n    owner_type: glib::Type     // 属性所有者的类型\n    // more\n    // more\n}\n```\n\n比如代码中出现的 `ParamSpecInt`, 就是基于 `ParamSpec` 的基础上, 指定了 `value_type`  \n\n接下来讲 `fn constructed`:  \n其中出现了 `BindingFlags::SYNC_CREATE`, 它的作用是, 当创建绑定时会进行一次同步, 方向是 form 源属性 to 目标属性, 作用类似于初始化  \n而之前的 `BindingFlags::BIDIRECTIONAL` 则是当源或目标属性中的一个发生更改时, 才进行同步  \n\n更多的flags, 自己去看 [文档](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.BindingFlags.html)\n\n这几处讲完, 其外的代码就不讲了, 可以当作模板来使用  \n\n敏锐的小伙伴会注意到, `number` 与 `label`, 这两个属性的类型好像不相等吧?  \n之前的 [p4](/posts/rust-gtk4/p4) 里, 可不是这样写的, 没错, 属性与属性的绑定, 其值的类型并不一定要是同类型!  \n\n下面是对比, 两种写法实现了相同的功能, 将 `number` 字符串化之后, 当作按钮的 `label`:  \n\n```rust src/custom_button/imp.rs\nimpl ObjectImpl for CustomButton {\n    // p4:\n    fn constructed(&self) {\n        self.parent_constructed();\n        self.obj().set_label(&self.number.get().to_string());\n    }\n\n    // p6:\n    fn constructed(&self) {\n        self.parent_constructed();\n\n        let obj = self.obj();\n        obj.bind_property(\"number\", obj.as_ref(), \"label\")\n            .flags(BindingFlags::SYNC_CREATE)\n            .build();\n}\n```\n\n- 前一种写法中:  \n你需要自己手动 `get` 内部值, 手动字符串化, 然后当作参数赋给 `set_label`  \n其实这没什么大不了, 关键是你每一次修改 `number`, 都必须记得要同时修改 `label`, 进行重复性的工作\n\n- 后一种写法中:  \n通过绑定属性, 类型间的转化自动进行, 而且写法上更加清晰易懂 (`SYNC_CREATE` 显式地声明了目的)  \n于此同时, 当你修改 `number` 属性的值时, `label` 会自动适应, 你只需关注 `number` 即可 \n\n让我们继续, 接下来重载按钮被点击时的行为:  \n\n```rust src/custom_button/imp.rs\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {\n    fn clicked(&self) {\n        let number_inc = self.number.get() + 1;\n        self.obj().set_property(\"number\", &number_inc);\n    }\n}\n```\n\n瞧, 得益于属性绑定, 你只需修改 `number` 属性的值即可, 不必再重复地添加令人生厌的模板代码, 去手动修改 `label` 了  \n\n- - -\n\n# 控制属性绑定的方向\n接下来, 我们来完成这样一件事: 创建两个按钮, btn_1 初始为零, btn_2 始终比 btn_1 高一, 某个按钮被点击后, 其数值加一  \n其效果如动图所示:  \n\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/transform_buttons.webm\" type=\"video/webm\">\n</video>\n\n这两个按钮的 `number` 属性, 互相之间存在关联, 你可能会想到属性绑定, 没错, 不过相较于之间 `number` to `label` 的例子, 此处粒度会更细:  \n直接看代码:  \n\n```rust src/main.rs\nfn build_ui(app: &Application) {\n    // Create the buttons\n    let btn_1 = Custombtn::new();\n    let btn_2 = Custombtn::new();\n\n    // Assure that \"number\" of `btn_2` is always 1 higher than \"number\" of `btn_1`\n    btn_1\n        .bind_property(\"number\", &btn_2, \"number\")\n        // How to transform \"number\" from `btn_1` to \"number\" of `btn_2`\n        .transform_to(|_, number: i32| {\n            let incremented_number = number + 1;\n            Some(incremented_number.to_value())\n        })\n        // How to transform \"number\" from `btn_2` to \"number\" of `btn_1`\n        .transform_from(|_, number: i32| {\n            let decremented_number = number - 1;\n            Some(decremented_number.to_value())\n        })\n        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)\n        .build();\n}\n```\n\n代码很好理解, `transform_to` 定义了从源属性到目标属性的动作, `transform_from` 则是方向相反  \n\n同时, `BIDIRECTIONAL | SYNC_CREATE` 则分别声明了双向与初始化:\n  \n- 双向: 由于 `BIDIRECTIONAL`, 其中一个发生被click, 数值发生改变后会按照对应方向对应的闭包, 更新另一个\n- 初始化: 立刻进行一次更新, 方向是to\n\n- - -\n\n# 属性更改事件\n\n你可以在属性发生更改时, 执行一个闭包, 比如:  \n\n```rust src/main.rs\n    btn_1.connect_notify_local(Some(\"number\"), move |btn, _| {\n        let number = btn.property::<i32>(\"number\");\n        println!(\"The current number of `btn_1` is {}.\", number);\n    });\n```\n\n当 `number` 属性的值发生更改后, 会在标准输出中, 打印按钮当前显示的数值  \n","slug":"rust/gui/gtk4/p6-GObject-属性","published":1,"updated":"2022-12-10T15:39:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohc002tj1s685cy2si7","content":"<blockquote>\n<p>本节将学习 GObject 的 property(属性), 探索其强大且灵活的运行时</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"shuo-ming\">说明</h1>\n<p>属性(Property), 让我们能够访问 GObject 的状态(state)</p>\n<p>glib 虽然以面向过程的 C 为核心, 但却具有面向对象的思想, 属性自然是其中重要的一环<br>\n通过库为我们提供的运行时, 我们得到了一个灵活的, 动态的运行时</p>\n<p>得益于此, 我们可以在程序的运行过程中, 动态地修改其属性, 比如:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>动态注册某个新的属性</p>\n</li>\n<li class=\"lvl-2\">\n<p>进行属性间的自动绑定</p>\n</li>\n<li class=\"lvl-2\">\n<p>属性变更时将执行操作</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"chang-gui-shi-yong\">常规使用</h1>\n<p>如下的代码是一个修改 <code>Switch</code> 部件的 <code>state</code> 属性, 并在下一行获取其值的例子:<br>\n(记得use一下相关的路径, 这里为了简略就没有写出来, 本节之后的代码也是同理)</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the switch</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch = Switch::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set and then immediately obtain state</span></span><br><span class=\"line\">    switch.set_state(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current_state = switch.state();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This prints: &quot;The current state is true&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The current state is &#123;&#125;&quot;</span>, current_state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以用 <code>general-property</code> 来设置与获取属性, 与上一节的<a href=\"/posts/rust-gtk4/p5\">通用类型</a>相对应<br>\n例子如下, 在获取属性时用 <code>turbofish</code> 语法来推导其类型:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app_&amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the switch</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch = Switch::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set and then immediately obtain state</span></span><br><span class=\"line\">    switch.set_property(<span class=\"string\">&quot;state&quot;</span>, &amp;<span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current_state = switch.property::&lt;<span class=\"built_in\">bool</span>&gt;(<span class=\"string\">&quot;state&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This prints: &quot;The current state is true&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The current state is &#123;&#125;&quot;</span>, current_state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果属性不存在/类型不正确/属性不可写(无write权限)等, 都会导致 <code>property</code>/<code>set_property</code> 恐慌(panic), 在大部分如上的硬编码情况下是可行的<br>\n同样的, 如果你想设置多个属性, 可以用 <code>properties</code>/<code>set_properties</code></p>\n<p>现在已经不存在 <code>try_property</code>/<code>try_set_property</code>, 因为导致错误的情况, 只是仅为上一段所述的几种而已<br>\n不过截止目前, 官方教程还没有更新, 我已经提交了一个pr</p>\n<p>值得注意的是, 当你使用这种以字符串的方式来访问属性时, 需要遵循 <code>kebab-case(烤肉串式)</code>, 比如 <code>user-name</code>, <code>person-age</code><br>\n在本节后面, 我们为自定义对象创建自定义属性时, 也需要遵循这种命名方式</p>\n<hr>\n<h1 id=\"shu-xing-bang-ding\">属性绑定</h1>\n<p>属性不仅可以通过 <code>getter</code>/<code>setter</code> 进行访问与修改, 还可以彼此进行绑定:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the switches</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch_1 = Switch::new();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch_2 = Switch::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    switch_1</span><br><span class=\"line\">        .bind_property(<span class=\"string\">&quot;state&quot;</span>, &amp;switch_2, <span class=\"string\">&quot;state&quot;</span>)</span><br><span class=\"line\">        .flags(BindingFlags::BIDIRECTIONAL)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>bi-directional</code> 的意思是 <code>双向</code>, 我们在这里进行了双向绑定, <code>switch_1</code> 的 <code>state</code> 已经与 <code>switch_2</code> 的 <code>state</code> 绑在了一起<br>\n于是, 两个 <code>switch</code> 的 <code>state</code> 属性会一直保持一样, 修改其中一个, 另外一个也会被自动修改</p>\n<p>如果你不添加任何 <code>BindingFlags</code>, 则为默认的 <code>BindingFlags::DEFAULT</code>, 作用是由源属性向目标属性进行更新</p>\n<p>可以看下来自官方教程的动图, 当我们切换其中一个按钮的状态时, 另外一个会自动保持相同:</p>\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/bidirectional_switches.webm\" type=\"video/webm\">\n</video>\n<hr>\n<h1 id=\"wei-zi-ding-yi-dui-xiang-tian-jia-shu-xing\">为自定义对象添加属性</h1>\n<p>我们还可以为 <code>CustomObject</code> 添加属性, 以 <a href=\"/posts/rust-gtk4/p4\">p4</a> 中所讲述的 <code>CustomButton</code> 为例<br>\n(没印象的赶紧再去看看, 毕竟本篇p6是写完p4好久后才更新的…当然如果你是未来来的, 不是追着看的话, 问题也不大, 那时本系列应该写完了, 吧?)</p>\n<p>我们为 <code>CustomButton</code> 实现 <code>ObjectImpl</code> 这个 trait, 覆写对应的虚函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">properties</span></span>() -&gt; &amp;<span class=\"symbol\">&#x27;static</span> [ParamSpec] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> PROPERTIES: Lazy&lt;<span class=\"built_in\">Vec</span>&lt;ParamSpec&gt;&gt; =</span><br><span class=\"line\">            Lazy::new(|| <span class=\"built_in\">vec!</span>[ParamSpecInt::builder(<span class=\"string\">&quot;number&quot;</span>).build()]);</span><br><span class=\"line\">        PROPERTIES.as_ref()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set_property</span></span>(&amp;<span class=\"keyword\">self</span>, _id: <span class=\"built_in\">usize</span>, value: &amp;Value, pspec: &amp;ParamSpec) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> pspec.name() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;number&quot;</span> =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> input_number =</span><br><span class=\"line\">                    value.get().expect(<span class=\"string\">&quot;The value needs to be of type `i32`.&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.number.replace(input_number);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            _ =&gt; <span class=\"built_in\">unimplemented!</span>(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">property</span></span>(&amp;<span class=\"keyword\">self</span>, _id: <span class=\"built_in\">usize</span>, pspec: &amp;ParamSpec) -&gt; Value &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> pspec.name() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;number&quot;</span> =&gt; <span class=\"keyword\">self</span>.number.get().to_value(),</span><br><span class=\"line\">            _ =&gt; <span class=\"built_in\">unimplemented!</span>(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Bind label to number</span></span><br><span class=\"line\">        <span class=\"comment\">// `SYNC_CREATE` ensures that the label will be immediately set</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> obj = <span class=\"keyword\">self</span>.obj();</span><br><span class=\"line\">        obj.bind_property(<span class=\"string\">&quot;number&quot;</span>, obj.as_ref(), <span class=\"string\">&quot;label&quot;</span>)</span><br><span class=\"line\">            .flags(BindingFlags::SYNC_CREATE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看见 <code>fn properties</code> 里面的 <code>Lazy</code> 没有? 这是为了延迟创建资源的过程<br>\n每次访问都会检查是否已经创建了资源, 没有的话就调用闭包进行创建并访问, 不然就直接访问已经创建好的资源<br>\n这样就能避免每一次调用 <code>properties</code> 时都需要重新创建资源了</p>\n<p>当然, rust-analyzer 可能无法为你导入 <code>Lazy</code> 所在的路径, 因为它可能还没有进标准库<br>\n在它进标准库之前, 可以使用 <code>once_cell</code> crate:</p>\n<p>在项目的根目录执行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo add once_cell</span><br></pre></td></tr></table></figure>\n<p>你会看见 <code>ParamSpec</code> 这样的类型, 其来自于 <code>glib</code>, 按照相应的 <a href=\"https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.ParamSpec.html\">文档</a> 所述, 是一个struct, 封装了指定参数所需的元数据<br>\n如果将C语言的描述, 换成了看起来稍微轻松一些的rust版本, 它差不多长这样:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ParamSpec</span></span>&lt;<span class=\"symbol\">&#x27;a</span>&gt; &#123;</span><br><span class=\"line\">    name: &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"built_in\">str</span>,             <span class=\"comment\">// 属性的名称, 按照 `kebab-case`</span></span><br><span class=\"line\">    flags: glib::ParamFlags,   <span class=\"comment\">// 比如读写权限</span></span><br><span class=\"line\">    value_type: glib::Type,    <span class=\"comment\">// 属性对应值的类型</span></span><br><span class=\"line\">    owner_type: glib::Type     <span class=\"comment\">// 属性所有者的类型</span></span><br><span class=\"line\">    <span class=\"comment\">// more</span></span><br><span class=\"line\">    <span class=\"comment\">// more</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如代码中出现的 <code>ParamSpecInt</code>, 就是基于 <code>ParamSpec</code> 的基础上, 指定了 <code>value_type</code></p>\n<p>接下来讲 <code>fn constructed</code>:<br>\n其中出现了 <code>BindingFlags::SYNC_CREATE</code>, 它的作用是, 当创建绑定时会进行一次同步, 方向是 form 源属性 to 目标属性, 作用类似于初始化<br>\n而之前的 <code>BindingFlags::BIDIRECTIONAL</code> 则是当源或目标属性中的一个发生更改时, 才进行同步</p>\n<p>更多的flags, 自己去看 <a href=\"https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.BindingFlags.html\">文档</a></p>\n<p>这几处讲完, 其外的代码就不讲了, 可以当作模板来使用</p>\n<p>敏锐的小伙伴会注意到, <code>number</code> 与 <code>label</code>, 这两个属性的类型好像不相等吧?<br>\n之前的 <a href=\"/posts/rust-gtk4/p4\">p4</a> 里, 可不是这样写的, 没错, 属性与属性的绑定, 其值的类型并不一定要是同类型!</p>\n<p>下面是对比, 两种写法实现了相同的功能, 将 <code>number</code> 字符串化之后, 当作按钮的 <code>label</code>:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"comment\">// p4:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_label(&amp;<span class=\"keyword\">self</span>.number.get().to_string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// p6:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> obj = <span class=\"keyword\">self</span>.obj();</span><br><span class=\"line\">        obj.bind_property(<span class=\"string\">&quot;number&quot;</span>, obj.as_ref(), <span class=\"string\">&quot;label&quot;</span>)</span><br><span class=\"line\">            .flags(BindingFlags::SYNC_CREATE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前一种写法中:<br>\n你需要自己手动 <code>get</code> 内部值, 手动字符串化, 然后当作参数赋给 <code>set_label</code><br>\n其实这没什么大不了, 关键是你每一次修改 <code>number</code>, 都必须记得要同时修改 <code>label</code>, 进行重复性的工作</p>\n</li>\n<li class=\"lvl-2\">\n<p>后一种写法中:<br>\n通过绑定属性, 类型间的转化自动进行, 而且写法上更加清晰易懂 (<code>SYNC_CREATE</code> 显式地声明了目的)<br>\n于此同时, 当你修改 <code>number</code> 属性的值时, <code>label</code> 会自动适应, 你只需关注 <code>number</code> 即可</p>\n</li>\n</ul>\n<p>让我们继续, 接下来重载按钮被点击时的行为:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">clicked</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> number_inc = <span class=\"keyword\">self</span>.number.get() + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_property(<span class=\"string\">&quot;number&quot;</span>, &amp;number_inc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>瞧, 得益于属性绑定, 你只需修改 <code>number</code> 属性的值即可, 不必再重复地添加令人生厌的模板代码, 去手动修改 <code>label</code> 了</p>\n<hr>\n<h1 id=\"kong-zhi-shu-xing-bang-ding-de-fang-xiang\">控制属性绑定的方向</h1>\n<p>接下来, 我们来完成这样一件事: 创建两个按钮, btn_1 初始为零, btn_2 始终比 btn_1 高一, 某个按钮被点击后, 其数值加一<br>\n其效果如动图所示:</p>\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/transform_buttons.webm\" type=\"video/webm\">\n</video>\n<p>这两个按钮的 <code>number</code> 属性, 互相之间存在关联, 你可能会想到属性绑定, 没错, 不过相较于之间 <code>number</code> to <code>label</code> 的例子, 此处粒度会更细:<br>\n直接看代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the buttons</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_1 = Custombtn::new();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_2 = Custombtn::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Assure that &quot;number&quot; of `btn_2` is always 1 higher than &quot;number&quot; of `btn_1`</span></span><br><span class=\"line\">    btn_1</span><br><span class=\"line\">        .bind_property(<span class=\"string\">&quot;number&quot;</span>, &amp;btn_2, <span class=\"string\">&quot;number&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// How to transform &quot;number&quot; from `btn_1` to &quot;number&quot; of `btn_2`</span></span><br><span class=\"line\">        .transform_to(|_, number: <span class=\"built_in\">i32</span>| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> incremented_number = number + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(incremented_number.to_value())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"comment\">// How to transform &quot;number&quot; from `btn_2` to &quot;number&quot; of `btn_1`</span></span><br><span class=\"line\">        .transform_from(|_, number: <span class=\"built_in\">i32</span>| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> decremented_number = number - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(decremented_number.to_value())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很好理解, <code>transform_to</code> 定义了从源属性到目标属性的动作, <code>transform_from</code> 则是方向相反</p>\n<p>同时, <code>BIDIRECTIONAL | SYNC_CREATE</code> 则分别声明了双向与初始化:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>双向: 由于 <code>BIDIRECTIONAL</code>, 其中一个发生被click, 数值发生改变后会按照对应方向对应的闭包, 更新另一个</p>\n</li>\n<li class=\"lvl-2\">\n<p>初始化: 立刻进行一次更新, 方向是to</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"shu-xing-geng-gai-shi-jian\">属性更改事件</h1>\n<p>你可以在属性发生更改时, 执行一个闭包, 比如:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">btn_1.connect_notify_local(<span class=\"literal\">Some</span>(<span class=\"string\">&quot;number&quot;</span>), <span class=\"keyword\">move</span> |btn, _| &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number = btn.property::&lt;<span class=\"built_in\">i32</span>&gt;(<span class=\"string\">&quot;number&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The current number of `btn_1` is &#123;&#125;.&quot;</span>, number);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当 <code>number</code> 属性的值发生更改后, 会在标准输出中, 打印按钮当前显示的数值</p>\n","site":{"data":{}},"length":6119,"excerpt":"<blockquote>\n<p>本节将学习 GObject 的 property(属性), 探索其强大且灵活的运行时</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"shuo-ming\">说明</h1>\n<p>属性(Property), 让我们能够访问 GObject 的状态(state)</p>\n<p>glib 虽然以面向过程的 C 为核心, 但却具有面向对象的思想, 属性自然是其中重要的一环<br>\n通过库为我们提供的运行时, 我们得到了一个灵活的, 动态的运行时</p>\n<p>得益于此, 我们可以在程序的运行过程中, 动态地修改其属性, 比如:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>动态注册某个新的属性</p>\n</li>\n<li class=\"lvl-2\">\n<p>进行属性间的自动绑定</p>\n</li>\n<li class=\"lvl-2\">\n<p>属性变更时将执行操作</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"chang-gui-shi-yong\">常规使用</h1>\n<p>如下的代码是一个修改 <code>Switch</code> 部件的 <code>state</code> 属性, 并在下一行获取其值的例子:<br>\n(记得use一下相关的路径, 这里为了简略就没有写出来, 本节之后的代码也是同理)</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the switch</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch = Switch::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set and then immediately obtain state</span></span><br><span class=\"line\">    switch.set_state(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current_state = switch.state();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This prints: &quot;The current state is true&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The current state is &#123;&#125;&quot;</span>, current_state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以用 <code>general-property</code> 来设置与获取属性, 与上一节的<a href=\"/posts/rust-gtk4/p5\">通用类型</a>相对应<br>\n例子如下, 在获取属性时用 <code>turbofish</code> 语法来推导其类型:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app_&amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the switch</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch = Switch::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set and then immediately obtain state</span></span><br><span class=\"line\">    switch.set_property(<span class=\"string\">&quot;state&quot;</span>, &amp;<span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current_state = switch.property::&lt;<span class=\"built_in\">bool</span>&gt;(<span class=\"string\">&quot;state&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This prints: &quot;The current state is true&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The current state is &#123;&#125;&quot;</span>, current_state);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果属性不存在/类型不正确/属性不可写(无write权限)等, 都会导致 <code>property</code>/<code>set_property</code> 恐慌(panic), 在大部分如上的硬编码情况下是可行的<br>\n同样的, 如果你想设置多个属性, 可以用 <code>properties</code>/<code>set_properties</code></p>\n<p>现在已经不存在 <code>try_property</code>/<code>try_set_property</code>, 因为导致错误的情况, 只是仅为上一段所述的几种而已<br>\n不过截止目前, 官方教程还没有更新, 我已经提交了一个pr</p>\n<p>值得注意的是, 当你使用这种以字符串的方式来访问属性时, 需要遵循 <code>kebab-case(烤肉串式)</code>, 比如 <code>user-name</code>, <code>person-age</code><br>\n在本节后面, 我们为自定义对象创建自定义属性时, 也需要遵循这种命名方式</p>\n<hr>\n<h1 id=\"shu-xing-bang-ding\">属性绑定</h1>\n<p>属性不仅可以通过 <code>getter</code>/<code>setter</code> 进行访问与修改, 还可以彼此进行绑定:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the switches</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch_1 = Switch::new();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> switch_2 = Switch::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    switch_1</span><br><span class=\"line\">        .bind_property(<span class=\"string\">&quot;state&quot;</span>, &amp;switch_2, <span class=\"string\">&quot;state&quot;</span>)</span><br><span class=\"line\">        .flags(BindingFlags::BIDIRECTIONAL)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>bi-directional</code> 的意思是 <code>双向</code>, 我们在这里进行了双向绑定, <code>switch_1</code> 的 <code>state</code> 已经与 <code>switch_2</code> 的 <code>state</code> 绑在了一起<br>\n于是, 两个 <code>switch</code> 的 <code>state</code> 属性会一直保持一样, 修改其中一个, 另外一个也会被自动修改</p>\n<p>如果你不添加任何 <code>BindingFlags</code>, 则为默认的 <code>BindingFlags::DEFAULT</code>, 作用是由源属性向目标属性进行更新</p>\n<p>可以看下来自官方教程的动图, 当我们切换其中一个按钮的状态时, 另外一个会自动保持相同:</p>\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/bidirectional_switches.webm\" type=\"video/webm\">\n</video>\n<hr>\n<h1 id=\"wei-zi-ding-yi-dui-xiang-tian-jia-shu-xing\">为自定义对象添加属性</h1>\n<p>我们还可以为 <code>CustomObject</code> 添加属性, 以 <a href=\"/posts/rust-gtk4/p4\">p4</a> 中所讲述的 <code>CustomButton</code> 为例<br>\n(没印象的赶紧再去看看, 毕竟本篇p6是写完p4好久后才更新的…当然如果你是未来来的, 不是追着看的话, 问题也不大, 那时本系列应该写完了, 吧?)</p>\n<p>我们为 <code>CustomButton</code> 实现 <code>ObjectImpl</code> 这个 trait, 覆写对应的虚函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">properties</span></span>() -&gt; &amp;<span class=\"symbol\">&#x27;static</span> [ParamSpec] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> PROPERTIES: Lazy&lt;<span class=\"built_in\">Vec</span>&lt;ParamSpec&gt;&gt; =</span><br><span class=\"line\">            Lazy::new(|| <span class=\"built_in\">vec!</span>[ParamSpecInt::builder(<span class=\"string\">&quot;number&quot;</span>).build()]);</span><br><span class=\"line\">        PROPERTIES.as_ref()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set_property</span></span>(&amp;<span class=\"keyword\">self</span>, _id: <span class=\"built_in\">usize</span>, value: &amp;Value, pspec: &amp;ParamSpec) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> pspec.name() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;number&quot;</span> =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> input_number =</span><br><span class=\"line\">                    value.get().expect(<span class=\"string\">&quot;The value needs to be of type `i32`.&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.number.replace(input_number);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            _ =&gt; <span class=\"built_in\">unimplemented!</span>(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">property</span></span>(&amp;<span class=\"keyword\">self</span>, _id: <span class=\"built_in\">usize</span>, pspec: &amp;ParamSpec) -&gt; Value &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> pspec.name() &#123;</span><br><span class=\"line\">            <span class=\"string\">&quot;number&quot;</span> =&gt; <span class=\"keyword\">self</span>.number.get().to_value(),</span><br><span class=\"line\">            _ =&gt; <span class=\"built_in\">unimplemented!</span>(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Bind label to number</span></span><br><span class=\"line\">        <span class=\"comment\">// `SYNC_CREATE` ensures that the label will be immediately set</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> obj = <span class=\"keyword\">self</span>.obj();</span><br><span class=\"line\">        obj.bind_property(<span class=\"string\">&quot;number&quot;</span>, obj.as_ref(), <span class=\"string\">&quot;label&quot;</span>)</span><br><span class=\"line\">            .flags(BindingFlags::SYNC_CREATE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看见 <code>fn properties</code> 里面的 <code>Lazy</code> 没有? 这是为了延迟创建资源的过程<br>\n每次访问都会检查是否已经创建了资源, 没有的话就调用闭包进行创建并访问, 不然就直接访问已经创建好的资源<br>\n这样就能避免每一次调用 <code>properties</code> 时都需要重新创建资源了</p>\n<p>当然, rust-analyzer 可能无法为你导入 <code>Lazy</code> 所在的路径, 因为它可能还没有进标准库<br>\n在它进标准库之前, 可以使用 <code>once_cell</code> crate:</p>\n<p>在项目的根目录执行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo add once_cell</span><br></pre></td></tr></table></figure>\n<p>你会看见 <code>ParamSpec</code> 这样的类型, 其来自于 <code>glib</code>, 按照相应的 <a href=\"https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.ParamSpec.html\">文档</a> 所述, 是一个struct, 封装了指定参数所需的元数据<br>\n如果将C语言的描述, 换成了看起来稍微轻松一些的rust版本, 它差不多长这样:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ParamSpec</span></span>&lt;<span class=\"symbol\">&#x27;a</span>&gt; &#123;</span><br><span class=\"line\">    name: &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"built_in\">str</span>,             <span class=\"comment\">// 属性的名称, 按照 `kebab-case`</span></span><br><span class=\"line\">    flags: glib::ParamFlags,   <span class=\"comment\">// 比如读写权限</span></span><br><span class=\"line\">    value_type: glib::Type,    <span class=\"comment\">// 属性对应值的类型</span></span><br><span class=\"line\">    owner_type: glib::Type     <span class=\"comment\">// 属性所有者的类型</span></span><br><span class=\"line\">    <span class=\"comment\">// more</span></span><br><span class=\"line\">    <span class=\"comment\">// more</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比如代码中出现的 <code>ParamSpecInt</code>, 就是基于 <code>ParamSpec</code> 的基础上, 指定了 <code>value_type</code></p>\n<p>接下来讲 <code>fn constructed</code>:<br>\n其中出现了 <code>BindingFlags::SYNC_CREATE</code>, 它的作用是, 当创建绑定时会进行一次同步, 方向是 form 源属性 to 目标属性, 作用类似于初始化<br>\n而之前的 <code>BindingFlags::BIDIRECTIONAL</code> 则是当源或目标属性中的一个发生更改时, 才进行同步</p>\n<p>更多的flags, 自己去看 <a href=\"https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.BindingFlags.html\">文档</a></p>\n<p>这几处讲完, 其外的代码就不讲了, 可以当作模板来使用</p>\n<p>敏锐的小伙伴会注意到, <code>number</code> 与 <code>label</code>, 这两个属性的类型好像不相等吧?<br>\n之前的 <a href=\"/posts/rust-gtk4/p4\">p4</a> 里, 可不是这样写的, 没错, 属性与属性的绑定, 其值的类型并不一定要是同类型!</p>\n<p>下面是对比, 两种写法实现了相同的功能, 将 <code>number</code> 字符串化之后, 当作按钮的 <code>label</code>:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"comment\">// p4:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_label(&amp;<span class=\"keyword\">self</span>.number.get().to_string());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// p6:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">constructed</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent_constructed();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> obj = <span class=\"keyword\">self</span>.obj();</span><br><span class=\"line\">        obj.bind_property(<span class=\"string\">&quot;number&quot;</span>, obj.as_ref(), <span class=\"string\">&quot;label&quot;</span>)</span><br><span class=\"line\">            .flags(BindingFlags::SYNC_CREATE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>前一种写法中:<br>\n你需要自己手动 <code>get</code> 内部值, 手动字符串化, 然后当作参数赋给 <code>set_label</code><br>\n其实这没什么大不了, 关键是你每一次修改 <code>number</code>, 都必须记得要同时修改 <code>label</code>, 进行重复性的工作</p>\n</li>\n<li class=\"lvl-2\">\n<p>后一种写法中:<br>\n通过绑定属性, 类型间的转化自动进行, 而且写法上更加清晰易懂 (<code>SYNC_CREATE</code> 显式地声明了目的)<br>\n于此同时, 当你修改 <code>number</code> 属性的值时, <code>label</code> 会自动适应, 你只需关注 <code>number</code> 即可</p>\n</li>\n</ul>\n<p>让我们继续, 接下来重载按钮被点击时的行为:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">clicked</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> number_inc = <span class=\"keyword\">self</span>.number.get() + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.obj().set_property(<span class=\"string\">&quot;number&quot;</span>, &amp;number_inc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>瞧, 得益于属性绑定, 你只需修改 <code>number</code> 属性的值即可, 不必再重复地添加令人生厌的模板代码, 去手动修改 <code>label</code> 了</p>\n<hr>\n<h1 id=\"kong-zhi-shu-xing-bang-ding-de-fang-xiang\">控制属性绑定的方向</h1>\n<p>接下来, 我们来完成这样一件事: 创建两个按钮, btn_1 初始为零, btn_2 始终比 btn_1 高一, 某个按钮被点击后, 其数值加一<br>\n其效果如动图所示:</p>\n<video id=\"video\" preload=\"auto\" loop=true autoplay=true>\n    <source id=\"webm\" src=\"/images/rust/gtk4/transform_buttons.webm\" type=\"video/webm\">\n</video>\n<p>这两个按钮的 <code>number</code> 属性, 互相之间存在关联, 你可能会想到属性绑定, 没错, 不过相较于之间 <code>number</code> to <code>label</code> 的例子, 此处粒度会更细:<br>\n直接看代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create the buttons</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_1 = Custombtn::new();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_2 = Custombtn::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Assure that &quot;number&quot; of `btn_2` is always 1 higher than &quot;number&quot; of `btn_1`</span></span><br><span class=\"line\">    btn_1</span><br><span class=\"line\">        .bind_property(<span class=\"string\">&quot;number&quot;</span>, &amp;btn_2, <span class=\"string\">&quot;number&quot;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// How to transform &quot;number&quot; from `btn_1` to &quot;number&quot; of `btn_2`</span></span><br><span class=\"line\">        .transform_to(|_, number: <span class=\"built_in\">i32</span>| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> incremented_number = number + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(incremented_number.to_value())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"comment\">// How to transform &quot;number&quot; from `btn_2` to &quot;number&quot; of `btn_1`</span></span><br><span class=\"line\">        .transform_from(|_, number: <span class=\"built_in\">i32</span>| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> decremented_number = number - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(decremented_number.to_value())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .flags(BindingFlags::BIDIRECTIONAL | BindingFlags::SYNC_CREATE)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很好理解, <code>transform_to</code> 定义了从源属性到目标属性的动作, <code>transform_from</code> 则是方向相反</p>\n<p>同时, <code>BIDIRECTIONAL | SYNC_CREATE</code> 则分别声明了双向与初始化:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>双向: 由于 <code>BIDIRECTIONAL</code>, 其中一个发生被click, 数值发生改变后会按照对应方向对应的闭包, 更新另一个</p>\n</li>\n<li class=\"lvl-2\">\n<p>初始化: 立刻进行一次更新, 方向是to</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"shu-xing-geng-gai-shi-jian\">属性更改事件</h1>\n<p>你可以在属性发生更改时, 执行一个闭包, 比如:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">btn_1.connect_notify_local(<span class=\"literal\">Some</span>(<span class=\"string\">&quot;number&quot;</span>), <span class=\"keyword\">move</span> |btn, _| &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number = btn.property::&lt;<span class=\"built_in\">i32</span>&gt;(<span class=\"string\">&quot;number&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The current number of `btn_1` is &#123;&#125;.&quot;</span>, number);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当 <code>number</code> 属性的值发生更改后, 会在标准输出中, 打印按钮当前显示的数值</p>"},{"title":"rust-gtk4-p7~> GObject: 信号","abbrlink":"posts/rust-gtk4/p7","hidden":false,"date":"2022-12-10T15:45:10.000Z","top":98993,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p6","GObject: 属性"],"next_post":["posts/rust-gtk4/p8","主事件循环"],"_content":"> 本节将学习 GObject 的 signal(信号)\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 说明\n本节难度较小, 如果你已经掌握了之前的属性一章, 那么本节将会有非常多的相似之处  \n\n`GObject` 的信号(signal), 是一套为特定事件注册回调函数的系统  \n例如, 当点击按钮时, `clicked` 信号被 发射(emit), 为 `clicked` 信号注册的回调函数会执行  \n\n代码如下:  \n\n```rust\n    // Connect to \"clicked\" signal of `button`\n    button.connect_clicked(|button| {\n        // Set the label to \"Hello World!\" after the button has been clicked on\n        button.set_label(\"Hello World!\");\n    });\n```\n\n或者这样, 类似于使用属性, 可以处理自定义信号:  \n\n```rust\n    // Connect to \"clicked\" signal of `button`\n    button.connect_closure(\n        \"clicked\",\n        false,\n        closure_local!(move |button: Button| {\n            // Set the label to \"Hello World!\" after the button has been clicked on\n            button.set_label(\"Hello World!\");\n        }),\n    );\n```\n\n这里的 `false` 表示该回调在默认处理程序之后调用，否则在之前调用  \n\n- - -\n\n# 为自定义对象添加信号\n\n直接上代码:  \n\n```rust src/custom_button/imp.rs\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {\n    fn signals() -> &'static [Signal] {\n        static SIGNALS: Lazy<Vec<Signal>> = Lazy::new(|| {\n            vec![Signal::builder(\"max-number-reached\")\n                .param_types([i32::static_type()])\n                .build()]\n        });\n        SIGNALS.as_ref()\n    }\n```\n\n这表示, 我们为 `CustomButton` 注册了一个自定义信号, 命为 `max-number-reached`, 当 发射(emit) 时, 发射一个类型为 i32 的数值  \n与命名属性同理, 我们应该遵循 `kebab-case`  \n\n让我们继续, 接下来自定义被点击时的行为, 我们让按钮被点击, 数值达到某个规定的最大值时, 发送该信号:  \n\n```rust src/custom_button/imp.rs\nstatic MAX_NUMBER: i32 = 8;\n\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {\n    fn clicked(&self) {\n        let incremented_number = self.number.get() + 1;\n        let obj = self.obj();\n        // If `number` reached `MAX_NUMBER`,\n        // emit \"max-number-reached\" signal and set `number` back to 0\n        if incremented_number == MAX_NUMBER {\n            obj.emit_by_name::<()>(\"max-number-reached\", &[&incremented_number]);\n            obj.set_property(\"number\", &0);\n        } else {\n            obj.set_property(\"number\", &incremented_number);\n        }\n    }\n}\n```\n\n点击按钮, 数值加一, 直到最大, 发射信号, 然后归零 ~~(好湿好湿!)~~  \n\n现在，你已经知道如何连接信号, 自定义信号  \n如果您想通知 GObject 的使用者, 某个事件已经发生，那么自定义信号特别有用\n","source":"_posts/rust/gui/gtk4/p7-GObject-信号.md","raw":"---\ntitle: \"rust-gtk4-p7~> GObject: 信号\"\nabbrlink: posts/rust-gtk4/p7\nhidden: false\ndate: 2022-12-10 23:45:10\ntop: 98993\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p6, \"GObject: 属性\"]\nnext_post: [posts/rust-gtk4/p8, \"主事件循环\"]\n---\n> 本节将学习 GObject 的 signal(信号)\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n\n# 说明\n本节难度较小, 如果你已经掌握了之前的属性一章, 那么本节将会有非常多的相似之处  \n\n`GObject` 的信号(signal), 是一套为特定事件注册回调函数的系统  \n例如, 当点击按钮时, `clicked` 信号被 发射(emit), 为 `clicked` 信号注册的回调函数会执行  \n\n代码如下:  \n\n```rust\n    // Connect to \"clicked\" signal of `button`\n    button.connect_clicked(|button| {\n        // Set the label to \"Hello World!\" after the button has been clicked on\n        button.set_label(\"Hello World!\");\n    });\n```\n\n或者这样, 类似于使用属性, 可以处理自定义信号:  \n\n```rust\n    // Connect to \"clicked\" signal of `button`\n    button.connect_closure(\n        \"clicked\",\n        false,\n        closure_local!(move |button: Button| {\n            // Set the label to \"Hello World!\" after the button has been clicked on\n            button.set_label(\"Hello World!\");\n        }),\n    );\n```\n\n这里的 `false` 表示该回调在默认处理程序之后调用，否则在之前调用  \n\n- - -\n\n# 为自定义对象添加信号\n\n直接上代码:  \n\n```rust src/custom_button/imp.rs\n// Trait shared by all GObjects\nimpl ObjectImpl for CustomButton {\n    fn signals() -> &'static [Signal] {\n        static SIGNALS: Lazy<Vec<Signal>> = Lazy::new(|| {\n            vec![Signal::builder(\"max-number-reached\")\n                .param_types([i32::static_type()])\n                .build()]\n        });\n        SIGNALS.as_ref()\n    }\n```\n\n这表示, 我们为 `CustomButton` 注册了一个自定义信号, 命为 `max-number-reached`, 当 发射(emit) 时, 发射一个类型为 i32 的数值  \n与命名属性同理, 我们应该遵循 `kebab-case`  \n\n让我们继续, 接下来自定义被点击时的行为, 我们让按钮被点击, 数值达到某个规定的最大值时, 发送该信号:  \n\n```rust src/custom_button/imp.rs\nstatic MAX_NUMBER: i32 = 8;\n\n// Trait shared by all buttons\nimpl ButtonImpl for CustomButton {\n    fn clicked(&self) {\n        let incremented_number = self.number.get() + 1;\n        let obj = self.obj();\n        // If `number` reached `MAX_NUMBER`,\n        // emit \"max-number-reached\" signal and set `number` back to 0\n        if incremented_number == MAX_NUMBER {\n            obj.emit_by_name::<()>(\"max-number-reached\", &[&incremented_number]);\n            obj.set_property(\"number\", &0);\n        } else {\n            obj.set_property(\"number\", &incremented_number);\n        }\n    }\n}\n```\n\n点击按钮, 数值加一, 直到最大, 发射信号, 然后归零 ~~(好湿好湿!)~~  \n\n现在，你已经知道如何连接信号, 自定义信号  \n如果您想通知 GObject 的使用者, 某个事件已经发生，那么自定义信号特别有用\n","slug":"rust/gui/gtk4/p7-GObject-信号","published":1,"updated":"2022-12-10T15:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohd002vj1s62yv55u1r","content":"<blockquote>\n<p>本节将学习 GObject 的 signal(信号)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"shuo-ming\">说明</h1>\n<p>本节难度较小, 如果你已经掌握了之前的属性一章, 那么本节将会有非常多的相似之处</p>\n<p><code>GObject</code> 的信号(signal), 是一套为特定事件注册回调函数的系统<br>\n例如, 当点击按钮时, <code>clicked</code> 信号被 发射(emit), 为 <code>clicked</code> 信号注册的回调函数会执行</p>\n<p>代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Connect to &quot;clicked&quot; signal of `button`</span></span><br><span class=\"line\">button.connect_clicked(|button| &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Set the label to &quot;Hello World!&quot; after the button has been clicked on</span></span><br><span class=\"line\">    button.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>或者这样, 类似于使用属性, 可以处理自定义信号:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Connect to &quot;clicked&quot; signal of `button`</span></span><br><span class=\"line\">button.connect_closure(</span><br><span class=\"line\">    <span class=\"string\">&quot;clicked&quot;</span>,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    closure_local!(<span class=\"keyword\">move</span> |button: Button| &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set the label to &quot;Hello World!&quot; after the button has been clicked on</span></span><br><span class=\"line\">        button.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>false</code> 表示该回调在默认处理程序之后调用，否则在之前调用</p>\n<hr>\n<h1 id=\"wei-zi-ding-yi-dui-xiang-tian-jia-xin-hao\">为自定义对象添加信号</h1>\n<p>直接上代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">signals</span></span>() -&gt; &amp;<span class=\"symbol\">&#x27;static</span> [Signal] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> SIGNALS: Lazy&lt;<span class=\"built_in\">Vec</span>&lt;Signal&gt;&gt; = Lazy::new(|| &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vec!</span>[Signal::builder(<span class=\"string\">&quot;max-number-reached&quot;</span>)</span><br><span class=\"line\">                .param_types([<span class=\"built_in\">i32</span>::static_type()])</span><br><span class=\"line\">                .build()]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        SIGNALS.as_ref()</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这表示, 我们为 <code>CustomButton</code> 注册了一个自定义信号, 命为 <code>max-number-reached</code>, 当 发射(emit) 时, 发射一个类型为 i32 的数值<br>\n与命名属性同理, 我们应该遵循 <code>kebab-case</code></p>\n<p>让我们继续, 接下来自定义被点击时的行为, 我们让按钮被点击, 数值达到某个规定的最大值时, 发送该信号:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> MAX_NUMBER: <span class=\"built_in\">i32</span> = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">clicked</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> incremented_number = <span class=\"keyword\">self</span>.number.get() + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> obj = <span class=\"keyword\">self</span>.obj();</span><br><span class=\"line\">        <span class=\"comment\">// If `number` reached `MAX_NUMBER`,</span></span><br><span class=\"line\">        <span class=\"comment\">// emit &quot;max-number-reached&quot; signal and set `number` back to 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> incremented_number == MAX_NUMBER &#123;</span><br><span class=\"line\">            obj.emit_by_name::&lt;()&gt;(<span class=\"string\">&quot;max-number-reached&quot;</span>, &amp;[&amp;incremented_number]);</span><br><span class=\"line\">            obj.set_property(<span class=\"string\">&quot;number&quot;</span>, &amp;<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            obj.set_property(<span class=\"string\">&quot;number&quot;</span>, &amp;incremented_number);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点击按钮, 数值加一, 直到最大, 发射信号, 然后归零 <s>(好湿好湿!)</s></p>\n<p>现在，你已经知道如何连接信号, 自定义信号<br>\n如果您想通知 GObject 的使用者, 某个事件已经发生，那么自定义信号特别有用</p>\n","site":{"data":{}},"length":1823,"excerpt":"<blockquote>\n<p>本节将学习 GObject 的 signal(信号)</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n<h1 id=\"shuo-ming\">说明</h1>\n<p>本节难度较小, 如果你已经掌握了之前的属性一章, 那么本节将会有非常多的相似之处</p>\n<p><code>GObject</code> 的信号(signal), 是一套为特定事件注册回调函数的系统<br>\n例如, 当点击按钮时, <code>clicked</code> 信号被 发射(emit), 为 <code>clicked</code> 信号注册的回调函数会执行</p>\n<p>代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Connect to &quot;clicked&quot; signal of `button`</span></span><br><span class=\"line\">button.connect_clicked(|button| &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Set the label to &quot;Hello World!&quot; after the button has been clicked on</span></span><br><span class=\"line\">    button.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>或者这样, 类似于使用属性, 可以处理自定义信号:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Connect to &quot;clicked&quot; signal of `button`</span></span><br><span class=\"line\">button.connect_closure(</span><br><span class=\"line\">    <span class=\"string\">&quot;clicked&quot;</span>,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    closure_local!(<span class=\"keyword\">move</span> |button: Button| &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set the label to &quot;Hello World!&quot; after the button has been clicked on</span></span><br><span class=\"line\">        button.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>false</code> 表示该回调在默认处理程序之后调用，否则在之前调用</p>\n<hr>\n<h1 id=\"wei-zi-ding-yi-dui-xiang-tian-jia-xin-hao\">为自定义对象添加信号</h1>\n<p>直接上代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Trait shared by all GObjects</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ObjectImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">signals</span></span>() -&gt; &amp;<span class=\"symbol\">&#x27;static</span> [Signal] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> SIGNALS: Lazy&lt;<span class=\"built_in\">Vec</span>&lt;Signal&gt;&gt; = Lazy::new(|| &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vec!</span>[Signal::builder(<span class=\"string\">&quot;max-number-reached&quot;</span>)</span><br><span class=\"line\">                .param_types([<span class=\"built_in\">i32</span>::static_type()])</span><br><span class=\"line\">                .build()]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        SIGNALS.as_ref()</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这表示, 我们为 <code>CustomButton</code> 注册了一个自定义信号, 命为 <code>max-number-reached</code>, 当 发射(emit) 时, 发射一个类型为 i32 的数值<br>\n与命名属性同理, 我们应该遵循 <code>kebab-case</code></p>\n<p>让我们继续, 接下来自定义被点击时的行为, 我们让按钮被点击, 数值达到某个规定的最大值时, 发送该信号:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/custom_button/imp.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> MAX_NUMBER: <span class=\"built_in\">i32</span> = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Trait shared by all buttons</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> ButtonImpl <span class=\"keyword\">for</span> CustomButton &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">clicked</span></span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> incremented_number = <span class=\"keyword\">self</span>.number.get() + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> obj = <span class=\"keyword\">self</span>.obj();</span><br><span class=\"line\">        <span class=\"comment\">// If `number` reached `MAX_NUMBER`,</span></span><br><span class=\"line\">        <span class=\"comment\">// emit &quot;max-number-reached&quot; signal and set `number` back to 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> incremented_number == MAX_NUMBER &#123;</span><br><span class=\"line\">            obj.emit_by_name::&lt;()&gt;(<span class=\"string\">&quot;max-number-reached&quot;</span>, &amp;[&amp;incremented_number]);</span><br><span class=\"line\">            obj.set_property(<span class=\"string\">&quot;number&quot;</span>, &amp;<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            obj.set_property(<span class=\"string\">&quot;number&quot;</span>, &amp;incremented_number);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>点击按钮, 数值加一, 直到最大, 发射信号, 然后归零 <s>(好湿好湿!)</s></p>\n<p>现在，你已经知道如何连接信号, 自定义信号<br>\n如果您想通知 GObject 的使用者, 某个事件已经发生，那么自定义信号特别有用</p>"},{"title":"rust-gtk4-p8~> 主事件循环","abbrlink":"posts/rust-gtk4/p8","hidden":false,"date":"2023-01-13T09:44:23.000Z","top":98992,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p7","GObject: 信号"],"next_post":["posts/rust-gtk4/p9","设置持久化"],"_content":"> 本节将学习 主事件循环(Main-Event-Loop) 相关的概念\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n","source":"_posts/rust/gui/gtk4/p8-主事件循环.md","raw":"---\ntitle: \"rust-gtk4-p8~> 主事件循环\"\nabbrlink: posts/rust-gtk4/p8\nhidden: false\ndate: 2023-01-13 17:44:23\ntop: 98992\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p7, \"GObject: 信号\"]\nnext_post: [posts/rust-gtk4/p9, \"设置持久化\"]\n---\n> 本节将学习 主事件循环(Main-Event-Loop) 相关的概念\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n","slug":"rust/gui/gtk4/p8-主事件循环","published":1,"updated":"2023-01-13T09:44:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohd002xj1s68bl4huia","content":"<blockquote>\n<p>本节将学习 主事件循环(Main-Event-Loop) 相关的概念</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n","site":{"data":{}},"length":62,"excerpt":"<blockquote>\n<p>本节将学习 主事件循环(Main-Event-Loop) 相关的概念</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>"},{"title":"rust-gtk4-p9~> 设置持久化","abbrlink":"posts/rust-gtk4/p9","hidden":false,"date":"2023-01-16T09:49:06.000Z","top":98991,"keywords":["Rust","GUI","GTK4"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-gtk4/p8","主事件循环"],"next_post":["posts/rust-gtk4/p10","aa"],"_content":"> 本节将学习如何将对应用的设置持久化  \n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n","source":"_posts/rust/gui/gtk4/p9-设置持久化.md","raw":"---\ntitle: \"rust-gtk4-p9~> 设置持久化\"\nabbrlink: posts/rust-gtk4/p9\nhidden: false\ndate: 2023-01-16 17:49:06\ntop: 98991\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, GTK4]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-gtk4/p8, \"主事件循环\"]\nnext_post: [posts/rust-gtk4/p10, \"aa\"]\n---\n> 本节将学习如何将对应用的设置持久化  \n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\nGNOME入坑指南: [gnome](/posts/desktop-beautify/gnome)\n","slug":"rust/gui/gtk4/p9-设置持久化","published":1,"updated":"2023-01-16T09:49:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohe002zj1s6ac83e97c","content":"<blockquote>\n<p>本节将学习如何将对应用的设置持久化</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>\n","site":{"data":{}},"length":47,"excerpt":"<blockquote>\n<p>本节将学习如何将对应用的设置持久化</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a><br>\nGNOME入坑指南: <a href=\"/posts/desktop-beautify/gnome\">gnome</a></p>"},{"title":"rust-iced-p1~> 系列说明","abbrlink":"posts/rust-iced/p1","hidden":false,"date":"2023-01-10T15:19:32.000Z","top":96999,"keywords":["Rust","GUI","Iced"],"is_series":true,"series_link":"rust-gui","next_post":["posts/rust-iced/p2","Elm式架构"],"_content":"> 欢迎大家来到 Rust 的 iced 系列\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","source":"_posts/rust/gui/iced/p1-系列说明.md","raw":"---\ntitle: \"rust-iced-p1~> 系列说明\"\nabbrlink: posts/rust-iced/p1\nhidden: false\ndate: 2023-01-10 23:19:32\ntop: 96999\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Iced]\nis_series: true\nseries_link: rust-gui\nnext_post: [posts/rust-iced/p2, Elm式架构]\n---\n> 欢迎大家来到 Rust 的 iced 系列\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","slug":"rust/gui/iced/p1-系列说明","published":1,"updated":"2023-01-10T15:19:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohf0030j1s6dizy152j","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 iced 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>\n","site":{"data":{}},"length":32,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 iced 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>"},{"title":"rust-iced-p2~> Elm式架构","abbrlink":"posts/rust-iced/p2","hidden":false,"date":"2023-01-12T15:29:30.000Z","top":96998,"keywords":["Rust","GUI","Iced"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-iced/p1","系列说明"],"next_post":["posts/rust-iced/p3","布局"],"_content":"> 本节将学习 Elm 式的架构体系\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","source":"_posts/rust/gui/iced/p2-Elm式架构.md","raw":"---\ntitle: \"rust-iced-p2~> Elm式架构\"\nabbrlink: posts/rust-iced/p2\nhidden: false\ndate: 2023-01-12 23:29:30\ntop: 96998\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Iced]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-iced/p1, 系列说明]\nnext_post: [posts/rust-iced/p3, 布局]\n---\n> 本节将学习 Elm 式的架构体系\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","slug":"rust/gui/iced/p2-Elm式架构","published":1,"updated":"2023-01-12T15:29:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohf0031j1s6b1uzgwmg","content":"<blockquote>\n<p>本节将学习 Elm 式的架构体系</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>\n","site":{"data":{}},"length":29,"excerpt":"<blockquote>\n<p>本节将学习 Elm 式的架构体系</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>"},{"title":"rust-iced-p3~> 布局","abbrlink":"posts/rust-iced/p3","hidden":false,"date":"2023-01-14T15:29:30.000Z","top":96997,"keywords":["Rust","GUI","Iced"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-iced/p2","Elm式架构"],"next_post":["posts/rust-iced/p4","样式"],"_content":"> 让我们来了解如何在 iced 中对部件进行布局\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","source":"_posts/rust/gui/iced/p3-布局.md","raw":"---\ntitle: \"rust-iced-p3~> 布局\"\nabbrlink: posts/rust-iced/p3\nhidden: false\ndate: 2023-01-14 23:29:30\ntop: 96997\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Iced]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-iced/p2,Elm式架构]\nnext_post: [posts/rust-iced/p4,样式]\n---\n> 让我们来了解如何在 iced 中对部件进行布局\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","slug":"rust/gui/iced/p3-布局","published":1,"updated":"2023-01-14T15:29:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8ohg0034j1s65lizeal8","content":"<blockquote>\n<p>让我们来了解如何在 iced 中对部件进行布局</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>\n","site":{"data":{}},"length":36,"excerpt":"<blockquote>\n<p>让我们来了解如何在 iced 中对部件进行布局</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>"},{"title":"rust-iced-p4~> 样式","abbrlink":"posts/rust-iced/p4","hidden":false,"date":"2023-01-19T15:29:30.000Z","top":96996,"keywords":["Rust","GUI","Iced"],"is_series":true,"series_link":"rust-gui","prev_post":["posts/rust-iced/p3","布局"],"_content":"> 学习如何在 iced 中设置部件的样式\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","source":"_posts/rust/gui/iced/p4-样式.md","raw":"---\ntitle: \"rust-iced-p4~> 样式\"\nabbrlink: posts/rust-iced/p4\nhidden: false\ndate: 2023-01-19 23:29:30\ntop: 96996\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Iced]\nis_series: true\nseries_link: rust-gui\nprev_post: [posts/rust-iced/p3, 布局]\n---\n> 学习如何在 iced 中设置部件的样式\n<!-- more -->\n\n同系列传送门: [rust-gui](/categories/rust-gui)\n","slug":"rust/gui/iced/p4-样式","published":1,"updated":"2023-01-19T15:29:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljoa8oi6006zj1s6aw7p778x","content":"<blockquote>\n<p>学习如何在 iced 中设置部件的样式</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>\n","site":{"data":{}},"length":32,"excerpt":"<blockquote>\n<p>学习如何在 iced 中设置部件的样式</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gui\">rust-gui</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cljoa8ofv0001j1s61n20fmll","tag_id":"cljoa8og10004j1s65x1xahxg","_id":"cljoa8ogg000jj1s6fzj43rlk"},{"post_id":"cljoa8ofv0001j1s61n20fmll","tag_id":"cljoa8og40008j1s67hux7h7b","_id":"cljoa8ogh000lj1s65t1q7x9m"},{"post_id":"cljoa8ofv0001j1s61n20fmll","tag_id":"cljoa8og7000bj1s60uvp237z","_id":"cljoa8ogi000oj1s69ndv88lg"},{"post_id":"cljoa8ofv0001j1s61n20fmll","tag_id":"cljoa8ogb000ej1s64cb46dfq","_id":"cljoa8ogi000qj1s6ebl98xzy"},{"post_id":"cljoa8ofz0003j1s6aacmdbgw","tag_id":"cljoa8og10004j1s65x1xahxg","_id":"cljoa8ogn000zj1s68ppvc2s6"},{"post_id":"cljoa8ofz0003j1s6aacmdbgw","tag_id":"cljoa8ogh000mj1s68q5b1pcm","_id":"cljoa8ogo0011j1s62moyf8qk"},{"post_id":"cljoa8ofz0003j1s6aacmdbgw","tag_id":"cljoa8og7000bj1s60uvp237z","_id":"cljoa8ogp0014j1s68o4g4bgg"},{"post_id":"cljoa8ofz0003j1s6aacmdbgw","tag_id":"cljoa8ogb000ej1s64cb46dfq","_id":"cljoa8ogp0016j1s6crragk1i"},{"post_id":"cljoa8og20005j1s65beo3uy4","tag_id":"cljoa8ogm000yj1s6det194x7","_id":"cljoa8ogq0019j1s69jwcbi5h"},{"post_id":"cljoa8og30006j1s63gk00au0","tag_id":"cljoa8ogm000yj1s6det194x7","_id":"cljoa8ogr001bj1s625va8wid"},{"post_id":"cljoa8og40007j1s6b8jq34ua","tag_id":"cljoa8ogm000yj1s6det194x7","_id":"cljoa8ogt001fj1s6btvqgtds"},{"post_id":"cljoa8og50009j1s6gr13brw8","tag_id":"cljoa8ogm000yj1s6det194x7","_id":"cljoa8ogv001jj1s6f2th4uaf"},{"post_id":"cljoa8og6000aj1s662xvgwi2","tag_id":"cljoa8ogm000yj1s6det194x7","_id":"cljoa8ogw001nj1s6560mau8m"},{"post_id":"cljoa8og9000dj1s6dta9ezgu","tag_id":"cljoa8ogv001lj1s60ra40zyb","_id":"cljoa8ogz001uj1s66a41emd5"},{"post_id":"cljoa8og9000dj1s6dta9ezgu","tag_id":"cljoa8ogx001pj1s6heik46bv","_id":"cljoa8ogz001wj1s6b0i9bas8"},{"post_id":"cljoa8ogb000fj1s6327het0t","tag_id":"cljoa8ogv001lj1s60ra40zyb","_id":"cljoa8oh10022j1s6f39j6on5"},{"post_id":"cljoa8ogb000fj1s6327het0t","tag_id":"cljoa8ogz001xj1s69osxcyat","_id":"cljoa8oh20024j1s60w2ndrv1"},{"post_id":"cljoa8oge000ij1s6a1jxf9ev","tag_id":"cljoa8oh10021j1s69uhv8pgf","_id":"cljoa8oh30028j1s62acq1eby"},{"post_id":"cljoa8ogg000kj1s6fpho05dd","tag_id":"cljoa8oh10021j1s69uhv8pgf","_id":"cljoa8oh5002cj1s6cx5a6ceq"},{"post_id":"cljoa8ogh000nj1s63479dgt0","tag_id":"cljoa8oh10021j1s69uhv8pgf","_id":"cljoa8oh7002gj1s65gvd31r6"},{"post_id":"cljoa8ogi000pj1s6esdt2oav","tag_id":"cljoa8oh10021j1s69uhv8pgf","_id":"cljoa8oh9002kj1s680ov9wmx"},{"post_id":"cljoa8ogi000rj1s62qxb2i6k","tag_id":"cljoa8oh10021j1s69uhv8pgf","_id":"cljoa8ohb002oj1s6eehn1dl1"},{"post_id":"cljoa8ogk000tj1s6g4dk81ce","tag_id":"cljoa8oha002mj1s6dq0oc79k","_id":"cljoa8ohc002sj1s625jb8nz1"},{"post_id":"cljoa8ogk000uj1s667yi1deq","tag_id":"cljoa8oha002mj1s6dq0oc79k","_id":"cljoa8ohd002wj1s6hbkh0nun"},{"post_id":"cljoa8ogt001gj1s6c9o261f0","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohg0033j1s62wdv2smu"},{"post_id":"cljoa8ogt001gj1s6c9o261f0","tag_id":"cljoa8ohe002yj1s66hvdc7pv","_id":"cljoa8ohg0035j1s6gaz0d0ej"},{"post_id":"cljoa8ogu001ij1s6e9rvhpqx","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohh0038j1s6ge30e0jh"},{"post_id":"cljoa8ogu001ij1s6e9rvhpqx","tag_id":"cljoa8ohe002yj1s66hvdc7pv","_id":"cljoa8ohh0039j1s60e1lcyk2"},{"post_id":"cljoa8ogv001kj1s63uof7fo9","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohh003cj1s6d1yq54ht"},{"post_id":"cljoa8ogv001kj1s63uof7fo9","tag_id":"cljoa8ohe002yj1s66hvdc7pv","_id":"cljoa8ohi003dj1s60zvl9fri"},{"post_id":"cljoa8ogw001mj1s6hz1h5z7p","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohi003gj1s67fk12zoj"},{"post_id":"cljoa8ogw001mj1s6hz1h5z7p","tag_id":"cljoa8ohe002yj1s66hvdc7pv","_id":"cljoa8ohi003hj1s6aevi8im7"},{"post_id":"cljoa8ogw001oj1s6dnc81aeq","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohj003lj1s69ey5g7mc"},{"post_id":"cljoa8ogw001oj1s6dnc81aeq","tag_id":"cljoa8ohi003ij1s680xp4ifb","_id":"cljoa8ohj003mj1s67odd033v"},{"post_id":"cljoa8ogw001oj1s6dnc81aeq","tag_id":"cljoa8ohi003jj1s6hp2z5f6w","_id":"cljoa8ohj003oj1s6aj159m8f"},{"post_id":"cljoa8ogx001qj1s66ooi5m6b","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohj003qj1s6dzos0jk9"},{"post_id":"cljoa8ogx001qj1s66ooi5m6b","tag_id":"cljoa8ohj003nj1s6ex617xxi","_id":"cljoa8ohj003rj1s6hwexcqrv"},{"post_id":"cljoa8ogx001rj1s68icocttf","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohk003uj1s6blvlhzfr"},{"post_id":"cljoa8ogx001rj1s68icocttf","tag_id":"cljoa8ohj003nj1s6ex617xxi","_id":"cljoa8ohk003vj1s6gxmjctli"},{"post_id":"cljoa8ogy001tj1s6dwn9bwjy","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohl003yj1s602u8f9eu"},{"post_id":"cljoa8ogy001tj1s6dwn9bwjy","tag_id":"cljoa8ohj003nj1s6ex617xxi","_id":"cljoa8ohl003zj1s652k669la"},{"post_id":"cljoa8ogz001vj1s6cps01cs9","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohl0042j1s6e8guey6j"},{"post_id":"cljoa8ogz001vj1s6cps01cs9","tag_id":"cljoa8ohj003nj1s6ex617xxi","_id":"cljoa8ohl0043j1s6fpoyavr6"},{"post_id":"cljoa8oh0001yj1s6a1measal","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohm0046j1s648phcnrm"},{"post_id":"cljoa8oh0001yj1s6a1measal","tag_id":"cljoa8ohj003nj1s6ex617xxi","_id":"cljoa8ohm0047j1s6hxdm948l"},{"post_id":"cljoa8oh0001zj1s6e6l2ex0p","tag_id":"cljoa8ohm0045j1s6h6f30dc5","_id":"cljoa8ohn004cj1s66toc00ib"},{"post_id":"cljoa8oh0001zj1s6e6l2ex0p","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oho004dj1s649y86go8"},{"post_id":"cljoa8oh0001zj1s6e6l2ex0p","tag_id":"cljoa8ohn0049j1s65xtq41iw","_id":"cljoa8oho004fj1s69eqofo9g"},{"post_id":"cljoa8oh0001zj1s6e6l2ex0p","tag_id":"cljoa8ohn004aj1s6c1ajgwyd","_id":"cljoa8oho004gj1s6amtv5g1w"},{"post_id":"cljoa8oh10020j1s6d4i4ctan","tag_id":"cljoa8ohm0045j1s6h6f30dc5","_id":"cljoa8ohp004kj1s6btbkbg8s"},{"post_id":"cljoa8oh10020j1s6d4i4ctan","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohp004lj1s6ei4oc9hm"},{"post_id":"cljoa8oh10020j1s6d4i4ctan","tag_id":"cljoa8ohn0049j1s65xtq41iw","_id":"cljoa8ohp004nj1s6hr6z0956"},{"post_id":"cljoa8oh10020j1s6d4i4ctan","tag_id":"cljoa8ohn004aj1s6c1ajgwyd","_id":"cljoa8ohp004oj1s698xx9bs8"},{"post_id":"cljoa8oh10023j1s6c5ia3bju","tag_id":"cljoa8ohm0045j1s6h6f30dc5","_id":"cljoa8ohq004sj1s6g68ba518"},{"post_id":"cljoa8oh10023j1s6c5ia3bju","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohq004tj1s677efcnu5"},{"post_id":"cljoa8oh10023j1s6c5ia3bju","tag_id":"cljoa8ohn0049j1s65xtq41iw","_id":"cljoa8ohq004vj1s6f51u66e3"},{"post_id":"cljoa8oh10023j1s6c5ia3bju","tag_id":"cljoa8ohn004aj1s6c1ajgwyd","_id":"cljoa8ohq004wj1s6ao8igktf"},{"post_id":"cljoa8oh20025j1s6h6kf8ezl","tag_id":"cljoa8ohm0045j1s6h6f30dc5","_id":"cljoa8ohr0050j1s60vz3fror"},{"post_id":"cljoa8oh20025j1s6h6kf8ezl","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohr0051j1s60dc96kfq"},{"post_id":"cljoa8oh20025j1s6h6kf8ezl","tag_id":"cljoa8ohn0049j1s65xtq41iw","_id":"cljoa8ohs0053j1s6cjya3ipu"},{"post_id":"cljoa8oh20025j1s6h6kf8ezl","tag_id":"cljoa8ohn004aj1s6c1ajgwyd","_id":"cljoa8ohs0054j1s6gb088767"},{"post_id":"cljoa8oh30027j1s6gaqqe98m","tag_id":"cljoa8ohm0045j1s6h6f30dc5","_id":"cljoa8oht0058j1s69b5f4njt"},{"post_id":"cljoa8oh30027j1s6gaqqe98m","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oht0059j1s6hmw32idu"},{"post_id":"cljoa8oh30027j1s6gaqqe98m","tag_id":"cljoa8ohn0049j1s65xtq41iw","_id":"cljoa8oht005bj1s6h3dh7lfb"},{"post_id":"cljoa8oh30027j1s6gaqqe98m","tag_id":"cljoa8ohn004aj1s6c1ajgwyd","_id":"cljoa8oht005cj1s69zqm5254"},{"post_id":"cljoa8oh30029j1s64tsr7lmc","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohu005ej1s6gezrdroz"},{"post_id":"cljoa8oh30029j1s64tsr7lmc","tag_id":"cljoa8oht005aj1s677b9brqi","_id":"cljoa8ohu005fj1s6hesj7dkl"},{"post_id":"cljoa8oh4002bj1s6chny3pbq","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohu005ij1s63r526mfz"},{"post_id":"cljoa8oh4002bj1s6chny3pbq","tag_id":"cljoa8ohu005gj1s65w82gx6m","_id":"cljoa8ohu005jj1s6fpk2d6um"},{"post_id":"cljoa8oh6002dj1s60p56bxs9","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohv005mj1s691ua3yra"},{"post_id":"cljoa8oh6002dj1s60p56bxs9","tag_id":"cljoa8ohu005gj1s65w82gx6m","_id":"cljoa8ohv005nj1s6fuk44c5g"},{"post_id":"cljoa8oh7002fj1s6ec4jcsw7","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohw005pj1s6hxjf589j"},{"post_id":"cljoa8oh7002hj1s6dk5fgrrg","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohx005sj1s6g9uia0tt"},{"post_id":"cljoa8oh7002hj1s6dk5fgrrg","tag_id":"cljoa8oht005aj1s677b9brqi","_id":"cljoa8ohx005tj1s6gy6b763x"},{"post_id":"cljoa8oh9002jj1s69jts57i7","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohx005wj1s6b82l8taj"},{"post_id":"cljoa8oh9002jj1s69jts57i7","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8ohx005xj1s6e0yuhm4y"},{"post_id":"cljoa8oh9002lj1s6h7276thr","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohy0060j1s636s1fxby"},{"post_id":"cljoa8oh9002lj1s6h7276thr","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8ohy0061j1s64r0a4vlz"},{"post_id":"cljoa8oha002nj1s654a51edw","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohy0064j1s6dankd5dd"},{"post_id":"cljoa8oha002nj1s654a51edw","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8ohy0065j1s6b0dh878u"},{"post_id":"cljoa8ohb002pj1s6cb9l28zy","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohz0068j1s6cqlc1727"},{"post_id":"cljoa8ohb002pj1s6cb9l28zy","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8ohz0069j1s6dazh44tk"},{"post_id":"cljoa8ohc002rj1s60or60zo4","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8ohz006cj1s6e7013061"},{"post_id":"cljoa8ohc002rj1s60or60zo4","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8ohz006dj1s6dp3wh9tp"},{"post_id":"cljoa8ohc002tj1s685cy2si7","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi0006gj1s68qk97pcb"},{"post_id":"cljoa8ohc002tj1s685cy2si7","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi0006hj1s6a6zqefqa"},{"post_id":"cljoa8ohd002vj1s62yv55u1r","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi0006jj1s61zpa14mb"},{"post_id":"cljoa8ohd002vj1s62yv55u1r","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi0006kj1s6amdv2jop"},{"post_id":"cljoa8ohd002xj1s68bl4huia","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi0006mj1s68d693umn"},{"post_id":"cljoa8ohd002xj1s68bl4huia","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi0006nj1s67tut11mh"},{"post_id":"cljoa8ohe002zj1s6ac83e97c","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi1006pj1s634ftapjq"},{"post_id":"cljoa8ohe002zj1s6ac83e97c","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi1006qj1s65yey0rsk"},{"post_id":"cljoa8ohf0030j1s6dizy152j","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi1006sj1s670ef98rf"},{"post_id":"cljoa8ohf0030j1s6dizy152j","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi1006tj1s69c18asdw"},{"post_id":"cljoa8ohf0031j1s6b1uzgwmg","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi1006vj1s6963dhuw7"},{"post_id":"cljoa8ohf0031j1s6b1uzgwmg","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi1006wj1s68acn7n5o"},{"post_id":"cljoa8ohg0034j1s65lizeal8","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi1006xj1s62wqjazfw"},{"post_id":"cljoa8ohg0034j1s65lizeal8","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi1006yj1s6f9sw08hf"},{"post_id":"cljoa8oi6006zj1s6aw7p778x","tag_id":"cljoa8ohd002uj1s6bm12f9gr","_id":"cljoa8oi70070j1s6arcbca1h"},{"post_id":"cljoa8oi6006zj1s6aw7p778x","tag_id":"cljoa8ohx005uj1s6eg7s2am6","_id":"cljoa8oi70071j1s6gbdvacm3"}],"Tag":[{"name":"Linux","_id":"cljoa8og10004j1s65x1xahxg"},{"name":"GNOME","_id":"cljoa8og40008j1s67hux7h7b"},{"name":"Waylnad","_id":"cljoa8og7000bj1s60uvp237z"},{"name":"Desktop","_id":"cljoa8ogb000ej1s64cb46dfq"},{"name":"Hyprland","_id":"cljoa8ogh000mj1s68q5b1pcm"},{"name":"高中信息技术","_id":"cljoa8ogm000yj1s6det194x7"},{"name":"Novel","_id":"cljoa8ogv001lj1s60ra40zyb"},{"name":"东方Project","_id":"cljoa8ogx001pj1s6heik46bv"},{"name":"明日方舟","_id":"cljoa8ogz001xj1s69osxcyat"},{"name":"Haskell","_id":"cljoa8oh10021j1s69uhv8pgf"},{"name":"Scala3","_id":"cljoa8oha002mj1s6dq0oc79k"},{"name":"Rust","_id":"cljoa8ohd002uj1s6bm12f9gr"},{"name":"Async","_id":"cljoa8ohe002yj1s66hvdc7pv"},{"name":"Clap","_id":"cljoa8ohi003ij1s680xp4ifb"},{"name":"CLI","_id":"cljoa8ohi003jj1s6hp2z5f6w"},{"name":"Macro","_id":"cljoa8ohj003nj1s6ex617xxi"},{"name":"GStreamer","_id":"cljoa8ohm0045j1s6h6f30dc5"},{"name":"Video","_id":"cljoa8ohn0049j1s65xtq41iw"},{"name":"Audio","_id":"cljoa8ohn004aj1s6c1ajgwyd"},{"name":"Concurrency","_id":"cljoa8oht005aj1s677b9brqi"},{"name":"TUI","_id":"cljoa8ohu005gj1s65w82gx6m"},{"name":"GUI","_id":"cljoa8ohx005uj1s6eg7s2am6"}]}}