{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/FiraCode-Regular.ttf","path":"css/FiraCode-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/css/custom.css","path":"css/custom.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/demo.css","path":"css/demo.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/demo_index.html","path":"css/demo_index.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/download.zip","path":"css/download.zip","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.css","path":"css/iconfont.css","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.css.backup","path":"css/iconfont.css.backup","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.js","path":"css/iconfont.js","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.json","path":"css/iconfont.json","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.ttf","path":"css/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.woff","path":"css/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/css/iconfont.woff2","path":"css/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/cursor/fireworks.js","path":"js/cursor/fireworks.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/default.yaml","path":"lib/fastclick/default.yaml","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/index.js","path":"lib/fastclick/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/package.json","path":"lib/fastclick/package.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/likely.js","path":"lib/fastclick/lib/likely.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/needmoreshare.js","path":"lib/fastclick/lib/needmoreshare.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/sharejs.js","path":"lib/fastclick/lib/sharejs.js","modified":1,"renderable":1},{"_id":"source/404.html","path":"404.html","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/downloads/gnome/kdeconnect.apk","path":"downloads/gnome/kdeconnect.apk","modified":1,"renderable":0},{"_id":"source/downloads/gnome/dconf.settings","path":"downloads/gnome/dconf.settings","modified":1,"renderable":0},{"_id":"source/images/gnome/eye-extended.png","path":"images/gnome/eye-extended.png","modified":1,"renderable":0},{"_id":"source/images/gnome/big-avatar.png","path":"images/gnome/big-avatar.png","modified":1,"renderable":0},{"_id":"source/images/gnome/frequency-boost-switch.png","path":"images/gnome/frequency-boost-switch.png","modified":1,"renderable":0},{"_id":"source/images/gnome/gnome-fuzzy-app-search.png","path":"images/gnome/gnome-fuzzy-app-search.png","modified":1,"renderable":0},{"_id":"source/images/gnome/gsconnect.png","path":"images/gnome/gsconnect.png","modified":1,"renderable":0},{"_id":"source/images/gnome/gnome40-ui-improvements.png","path":"images/gnome/gnome40-ui-improvements.png","modified":1,"renderable":0},{"_id":"source/images/gnome/nothing-to-say.png","path":"images/gnome/nothing-to-say.png","modified":1,"renderable":0},{"_id":"source/images/gnome/overview-navigation.png","path":"images/gnome/overview-navigation.png","modified":1,"renderable":0},{"_id":"source/images/gnome/overview.png","path":"images/gnome/overview.png","modified":1,"renderable":0},{"_id":"source/images/gnome/refresh-wifi-connections.png","path":"images/gnome/refresh-wifi-connections.png","modified":1,"renderable":0},{"_id":"source/images/gnome/right-corner.png","path":"images/gnome/right-corner.png","modified":1,"renderable":0},{"_id":"source/images/gnome/space-bar.png","path":"images/gnome/space-bar.png","modified":1,"renderable":0},{"_id":"source/images/gnome/transparent-window-moving.png","path":"images/gnome/transparent-window-moving.png","modified":1,"renderable":0},{"_id":"source/images/gnome/workspace-switcher-manager.png","path":"images/gnome/workspace-switcher-manager.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"0a0982664414697effe8e4704840261052941402","modified":1659754097480},{"_id":"source/about/index.md","hash":"0356870abbaf7d3b05e523f3a4701c8a5a9cc407","modified":1668439470713},{"_id":"source/404.html","hash":"48c29778a3a2dd66db8d87df42fc9bf9c702dd35","modified":1668320239414},{"_id":"source/categories/index.md","hash":"ae82ae1fd6e58c79072ea11ec1ebca522c83a35f","modified":1668441713681},{"_id":"source/_posts/high-school-it/p1-数据与信息.md","hash":"094619c4ae36e202d2e77f0cbc1c1018ffa348f5","modified":1668254177597},{"_id":"source/_posts/high-school-it/p4-进制的转换与应用.md","hash":"b7b4797af8b385b35476bd703119d827d7c13e9f","modified":1668254273715},{"_id":"source/_posts/high-school-it/p3-python基础语法-part1.md","hash":"965d21a71d71de357e4b9b41ef0c39ca7f2791ff","modified":1668315371709},{"_id":"source/_posts/high-school-it/p2-基础科普.md","hash":"caa0deafe888591613617db27fcd52175637995b","modified":1668246585877},{"_id":"source/images/gnome/eye-extended.png","hash":"cc320a5424d83445eef427da4cfa4e8670f2d839","modified":1659754097510},{"_id":"source/_posts/gnome/guide.md","hash":"99d06ffaad7c81224d2f7084e0139124a660263f","modified":1664799556478},{"_id":"source/downloads/gnome/dconf.settings","hash":"6c26cfbccbdd24352090b3aac92c8594ce50aa91","modified":1659754097484},{"_id":"source/images/gnome/nothing-to-say.png","hash":"2a01d35211519b528c223e9d4454236d24da1dd7","modified":1659754097512},{"_id":"source/images/gnome/gsconnect.png","hash":"b10d2f2c9b9919077cc2c76ee49ddc88af0473b4","modified":1659754097512},{"_id":"source/images/gnome/right-corner.png","hash":"b6af54f899eb811d55eb160ee1875f5e33b698b0","modified":1659754097523},{"_id":"source/images/gnome/space-bar.png","hash":"7dc8558cf55d2ab7dddc13ecfe3bea5a7bd23ac5","modified":1659754097523},{"_id":"source/_posts/categories/GNOME/index.md","hash":"c4a89f399364bfa341584ea6c1443d123cef0ef5","modified":1659754097480},{"_id":"source/_posts/categories/haskell/basic.md","hash":"00bab83dd3b3ecaffc37f043314e7dd690acd896","modified":1665674392489},{"_id":"source/_posts/categories/high-chool-it/index.md","hash":"fa29a5af2633eb3436fdeb1533d0c1e686316735","modified":1668255520566},{"_id":"source/_posts/categories/rust/async.md","hash":"c9649579eb278ae89bd6ce0a00b58716f1b67ce5","modified":1668240269428},{"_id":"source/_posts/categories/rust/gstreamer.md","hash":"11f94567cad0e8e660a14cd49370cb1fe4aa54e1","modified":1668256540828},{"_id":"source/_posts/categories/rust/decl-macro.md","hash":"a21f518efc1d5dec198a12ee260357057804e956","modified":1666449660148},{"_id":"source/_posts/categories/rust/gui.md","hash":"8cdaec194511bb2bcc8a9d2d395253e0c6449e7f","modified":1668441674274},{"_id":"source/_posts/categories/rust/tui.md","hash":"21be8010546290f2678d95c78357efe0cbdcd71c","modified":1666448978522},{"_id":"source/_posts/haskell/basic/p1-系列说明.md","hash":"7af0e030394b55610139c3368217df2665d8f2f2","modified":1666450194729},{"_id":"source/_posts/haskell/basic/p2-环境搭建.md","hash":"29918e60d01cff8f6147b6dc5942a8ff1922124b","modified":1666450225571},{"_id":"source/_posts/haskell/basic/p3-函数式编程.md","hash":"9d6eebf070d07dff31af70cc943ec359725fa9dc","modified":1666450225571},{"_id":"source/_posts/haskell/basic/p5-类型与类型类.md","hash":"b84357f56b56eb311bff484d17d836594abc4fee","modified":1666450224459},{"_id":"source/_posts/haskell/basic/p4-基础语法.md","hash":"b9c07cc8997e624b5772eaa5447378c895795b23","modified":1666450225572},{"_id":"source/_posts/rust/decl-macro/p1-系列说明.md","hash":"6d37b5060032b82c705a4b5c08b276073254078c","modified":1668441524267},{"_id":"source/_posts/rust/decl-macro/p2-从println开始.md","hash":"0f18bbdbb26dd7670c05f3c43991a3d8390750dc","modified":1668441525423},{"_id":"source/_posts/rust/clap/intro.md","hash":"85acb73ad555cb57c3b2fa4cf252cdf9600f11fd","modified":1667496322340},{"_id":"source/_posts/rust/decl-macro/p3-声明与使用.md","hash":"70379b3c5749401743b19209849775c7f93d76b4","modified":1668441525423},{"_id":"source/_posts/rust/decl-macro/p5-卫生性.md","hash":"74550b26327df7654de8dd2f7a609d57663a7e29","modified":1666450401953},{"_id":"source/_posts/rust/decl-macro/p4-重复.md","hash":"807bb51688ded906ed341a8f35ea8b31009c9fe9","modified":1668441525423},{"_id":"source/_posts/rust/gstreamer/p1-系列说明.md","hash":"d5017a1130bebce17670463ecb570bbbf556883d","modified":1668255942351},{"_id":"source/_posts/rust/gstreamer/p2-Basic-管道的基础概念.md","hash":"2fb159368f5dce801f9648547d6f7c770b4c4d4a","modified":1668256332987},{"_id":"source/_posts/rust/gstreamer/p4-Basic-时间管理.md","hash":"ff101e03f3c459dbf2d766dfd7282591c22cd987","modified":1668256429273},{"_id":"source/_posts/rust/gstreamer/p5-Basic-与GUI集成.md","hash":"a0e7cd99aa71b5e1bd023eb9b6a3cfe1c1d1e298","modified":1668256464345},{"_id":"source/_posts/rust/gstreamer/p3-Basic-管道的动态构建.md","hash":"6fb4e18fd0e026f2d7f1e73d6b801203d99ad6ab","modified":1668256369040},{"_id":"source/_posts/rust/async/p1-系列说明.md","hash":"a63dc1c3706becd6bb0bf056efd5db44907f1094","modified":1668441540183},{"_id":"source/_posts/rust/gtk4/p1-系列说明.md","hash":"2724af3b50d280a59d6ffd9b6dd9fe9d09c91619","modified":1660052429915},{"_id":"source/_posts/rust/async/p2-异步简介.md","hash":"50d37bd125c27e4280da2287662fdb198ded2803","modified":1668441490730},{"_id":"source/_posts/rust/gtk4/p2-创建窗口.md","hash":"fc9b725db049fe65ebcbb049b13c0b45fea91477","modified":1660056708041},{"_id":"source/_posts/rust/gtk4/p4-GObject-子类化.md","hash":"c33e668cb1a5cb9e75064ff94b6e5e07d4f9e73b","modified":1668182218457},{"_id":"source/_posts/rust/async/p4-状态的保存与变换.md","hash":"b61a902d0e693836112b3abcade930e7ff62a2db","modified":1668441541591},{"_id":"source/_posts/rust/tui/p1-系列说明.md","hash":"911f2febeec1ac13ea24227e2f0e80c894c56522","modified":1659754097483},{"_id":"source/_posts/rust/gtk4/p3-GObject-内存管理.md","hash":"4d78fd3a3ffb0674521fb98fd3dd6bd60f08c95b","modified":1668182218456},{"_id":"source/_posts/rust/async/p3-Future.md","hash":"92b7f26851c8024639ae00ec6019ac6017fbca34","modified":1668441541591},{"_id":"source/images/gnome/big-avatar.png","hash":"8fca7f2efc0358dd37eb798d106d42355e170b9d","modified":1659754097510},{"_id":"source/images/gnome/refresh-wifi-connections.png","hash":"f94d7390a3749d29da4b724ce951b3db56df4a4c","modified":1659754097523},{"_id":"source/images/gnome/gnome40-ui-improvements.png","hash":"f04061c64f6e0a32a2d2a1f371fc8965cf6e9915","modified":1659754097512},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1659754097528},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1659754097528},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1659754097528},{"_id":"themes/next/_vendors.yml","hash":"5949493e1390c34e094aee96489db37b4c3ad2ee","modified":1659754097529},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1659754097529},{"_id":"themes/next/package.json","hash":"0fdce9f5b80e6757be715953a19c46acfa00f2e7","modified":1659754097535},{"_id":"themes/next/_config.yml","hash":"39af1a3e0939cc835a63ca91fa7ae8fb8c3e461a","modified":1668441155078},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1659754097535},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1659754097529},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1659754097529},{"_id":"themes/next/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1659754097529},{"_id":"themes/next/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1659754097529},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1659754097529},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1659754097529},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1659754097529},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1659754097529},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1659754097530},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1659754097530},{"_id":"themes/next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1659754097530},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1659754097530},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1659754097530},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1659754097530},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1659754097530},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1659754097530},{"_id":"themes/next/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1659754097530},{"_id":"themes/next/languages/zh-CN.yml","hash":"c8354b782482e80c6b3b16918825f8f9c5fb185a","modified":1665675120472},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1659754097530},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1659754097530},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1659754097530},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1659754097535},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1659754097530},{"_id":"themes/next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1659754097535},{"_id":"themes/next/layout/index.njk","hash":"ccc14eea6f8a5bc5b3604461332f5f3b83411045","modified":1668441783780},{"_id":"themes/next/layout/_layout.njk","hash":"8640dadad7505b16451887153bc118ee278ed92e","modified":1659754097530},{"_id":"themes/next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1659754097535},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1659754097535},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1659754097552},{"_id":"themes/next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1659754097535},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1659754097531},{"_id":"themes/next/layout/_custom/custom.njk","hash":"dbd1329789b1c458cd0e2310e67d6bd43d02e991","modified":1659754097530},{"_id":"themes/next/layout/_macro/post.njk","hash":"b92d6c77d4b349c5d56fb8e0a44b578c194ef466","modified":1668099381694},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1659754097531},{"_id":"themes/next/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1659754097531},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1659754097531},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"3b09a1659dcc0b104be8a6b51fb741d3b465a5d9","modified":1668182529724},{"_id":"themes/next/layout/_partials/footer.njk","hash":"cda8c76857633d4110e609efa927a5b247c89d70","modified":1659754097531},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1659754097532},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1659754097532},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1659754097534},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1659754097533},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1659754097534},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1659754097534},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1659754097534},{"_id":"themes/next/scripts/events/index.js","hash":"1ce12eda88fa5df7e76ec7b78b8463fc6618410c","modified":1659754097535},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1659754097536},{"_id":"themes/next/scripts/filters/minify.js","hash":"0af64049db8188d5f8cc226b353e0d7909819feb","modified":1659754097536},{"_id":"themes/next/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1659754097536},{"_id":"themes/next/scripts/filters/post.js","hash":"ab8bb12e4d55640b1ac4252514468ce37ebcb0b0","modified":1659754097536},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1659754097534},{"_id":"themes/next/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1659754097536},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1659754097536},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":1659754097536},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1659754097536},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1659754097536},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1659754097536},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1659754097536},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1659754097536},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1659754097537},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1659754097537},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1659754097537},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1659754097537},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1659754097537},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1659754097537},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1659754097537},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1659754097537},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1659754097537},{"_id":"themes/next/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1659754097543},{"_id":"themes/next/source/css/_colors.styl","hash":"2d464c451fac10669c0c0d25b1694c7cf85bd25e","modified":1659754097537},{"_id":"themes/next/source/css/custom.css","hash":"a568c0b4b9cfe2ca5b471e622bed2c66897d678b","modified":1668315066847},{"_id":"themes/next/source/css/demo_index.html","hash":"eb23998541d481c6923f9c0c8ff694bf7a3e2b6f","modified":1659754097545},{"_id":"themes/next/source/css/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1659754097545},{"_id":"themes/next/source/css/iconfont.css","hash":"8806c405841e1cc582ac0362e5472bb2d72f4e4d","modified":1659754097545},{"_id":"themes/next/source/css/iconfont.css.backup","hash":"83303af46a2b75d4959371be747fb5b3cb79d689","modified":1659754097545},{"_id":"themes/next/source/css/download.zip","hash":"034b20bd8ea91aee04a9fcc713e6f355a8fc7686","modified":1659754097545},{"_id":"themes/next/source/css/iconfont.js","hash":"5f047b5796b11bfd2f2b94d5a1ab54667b7d7396","modified":1659754097546},{"_id":"themes/next/source/css/iconfont.json","hash":"31c866a664f02a2b838aa4b8dab7a97a0b5c8f4f","modified":1659754097546},{"_id":"themes/next/source/css/iconfont.woff","hash":"bcd7471a2ec5e457196f54a51d485bb19daa848b","modified":1659754097546},{"_id":"themes/next/source/css/iconfont.ttf","hash":"9af30b1a4b1405fc5f91464e5902f953b8068512","modified":1659754097546},{"_id":"themes/next/source/css/iconfont.woff2","hash":"ce8162de5535076a601089019d69c3054f986ee6","modified":1659754097546},{"_id":"themes/next/source/css/main.styl","hash":"f763283b1e2e27a3e7e19d3b78ff18f324b7d888","modified":1659754097546},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1659754097546},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1659754097548},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"369c77d4be3efe406ecbbdd7886a6ddafd93a940","modified":1659754097548},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"c587c9e0ad3da71d5d87ec5a17dbb2270c982679","modified":1659754097548},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1659754097548},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1659754097548},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1659754097549},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1659754097549},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1659754097549},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1659754097549},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1668441155078},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1659754097549},{"_id":"themes/next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1659754097549},{"_id":"themes/next/source/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1659754097549},{"_id":"themes/next/source/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1659754097549},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1659754097551},{"_id":"themes/next/source/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1659754097551},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1659754097551},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1659754097552},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1659754097552},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1659754097552},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1659754097552},{"_id":"themes/next/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1659754097552},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1659754097552},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1659754097552},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1659754097552},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1659754097552},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1659754097552},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1659754097552},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1659754097552},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1659754097552},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1659754097552},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"9167e429a459686c9fc140790124a46d677e6b15","modified":1659754097531},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"d3c094aaef1431fbc9df333529a7b1789ccd134c","modified":1668312401418},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1659754097531},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1659754097531},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1659754097531},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1659754097531},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1659754097531},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1659754097531},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1659754097532},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1659754097532},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1659754097532},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"9a6b0ec5befb0950902e12dac0be5808d43cf1e5","modified":1659754097532},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1659754097532},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1659754097532},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1659754097532},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1659754097532},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1659754097532},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1659754097532},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1659754097532},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1659754097532},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"4ca45b8638dbfbb3a1ec633c4e1d078dfa9086dc","modified":1659754097532},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"c2258949708070bfa3539d3b59e0beb4596bf5f0","modified":1659754097532},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1659754097533},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1659754097533},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1659754097533},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1659754097533},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1659754097533},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1659754097533},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1659754097533},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1659754097533},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1659754097533},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1659754097534},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1659754097534},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1659754097534},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1659754097534},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1659754097534},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1659754097534},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1659754097534},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1659754097534},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1659754097534},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1659754097534},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1659754097535},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b0ced2583fdd505da3ef27a9db9c55cc7b936732","modified":1659754097535},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1659754097535},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1659754097535},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1659754097535},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1659754097535},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1659754097536},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"08dac57e15c9f06c7cf54884b045f2362595f9d2","modified":1659754097535},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1659754097536},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1659754097536},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1659754097535},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1659754097536},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1659754097536},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1659754097536},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1659754097544},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1659754097536},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1659754097544},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1659754097544},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"d813aff1c30655ce2832ef2001898ffc6d14dd5c","modified":1663160836647},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ed6765e6e07bff9574fdae97dacf1ab6de169624","modified":1668182550476},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1659754097550},{"_id":"themes/next/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1659754097549},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1659754097550},{"_id":"themes/next/source/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1668181691815},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"9067915a45ab959d5a197bf1ffde4da980146618","modified":1668312393233},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1659754097550},{"_id":"themes/next/source/lib/fastclick/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1659754097551},{"_id":"themes/next/source/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1659754097551},{"_id":"themes/next/source/lib/fastclick/default.yaml","hash":"63abbb8255bab5ea7a4f45de3bcf14b574d41fa6","modified":1659754097551},{"_id":"themes/next/source/lib/fastclick/package.json","hash":"6a30089543e4b639e85d857c4ca70897ae2e1432","modified":1659754097551},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1659754097551},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1659754097551},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1659754097551},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1659754097551},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1659754097538},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1659754097541},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1659754097541},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1659754097541},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1659754097542},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1659754097542},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1659754097542},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1659754097542},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1659754097539},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1659754097544},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1659754097544},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1659754097549},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1659754097549},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1659754097549},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1659754097549},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1659754097550},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1659754097550},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1659754097549},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1659754097550},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1659754097550},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1659754097550},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1659754097550},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1659754097550},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1659754097550},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1659754097550},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1659754097550},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1659754097550},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1659754097550},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1659754097550},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1659754097550},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1659754097550},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1659754097551},{"_id":"themes/next/source/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1659754097551},{"_id":"themes/next/source/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1659754097551},{"_id":"themes/next/source/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1659754097551},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"b7ba7d49f0b6090d1c7621d375bf2f887433292a","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"b1c99f34d65f994c89940bb7cdff4e36779ceb5d","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1659754097537},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"b1bcc5f9357a9f8b8d6f8f285f073aaf3157f9db","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1659754097538},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"c8e95e8ac4cbdba01cb93e9e0569b45603e41bc6","modified":1659754097538},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"0b3e2696eca39781c3524b2c5a2555ebc616e6e8","modified":1659754097542},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1659754097542},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"9b34143aec49e390e18f380026a45096f7477722","modified":1659754097543},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1659754097543},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1659754097539},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1659754097543},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1659754097539},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1659754097540},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1659754097541},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1659754097541},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1659754097541},{"_id":"source/images/gnome/frequency-boost-switch.png","hash":"2851efd8f0fd60fbf084fdf43398b169917667f9","modified":1659754097511},{"_id":"source/images/gnome/gnome-fuzzy-app-search.png","hash":"ad67ce1c81c0ba3476a81abc4e06a73a8a6c3728","modified":1659754097511},{"_id":"source/images/gnome/workspace-switcher-manager.png","hash":"2184be787d2619605775dec6b4be9f89c6b2c1e3","modified":1659754097528},{"_id":"themes/next/source/css/FiraCode-Regular.ttf","hash":"693adff323e9ea4d2275b54ab049f561ef39f0b6","modified":1668314649878},{"_id":"themes/next/source/images/avatar.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1659754097548},{"_id":"source/images/gnome/transparent-window-moving.png","hash":"2171b11d661aaef009ce7e0ed6950bd493713c93","modified":1659754097527},{"_id":"source/images/gnome/overview-navigation.png","hash":"3ebcaf71b468e3cd42914314e4073025770d729a","modified":1659754097516},{"_id":"source/images/gnome/overview.png","hash":"f7a03e8897e0ccd149f569ef98213bbfac51ec26","modified":1659754097522},{"_id":"source/downloads/gnome/kdeconnect.apk","hash":"817e71e04488fd2fd7d59d6e712013d06528e92e","modified":1659754097509}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2022-01-29T12:53:24.000Z","_content":"\n# 冒险者\n曾经...\n我和你一样, 也是个冒险者...\n直到我的膝盖中了一剑\n\n- - -\n\n# 日记\n2022.7.6\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业\n\n2022.7.7\n看番\n\n2022.7.8\n看番\n\n2022.7.9\n看番\n\n2022.7.10\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗?  \n子曰: \"吾日三省吾身\"\n不能再这样下去了!\n\n2022.7.12\n看番\n\n- - -\n# 猪, 四战, 宗教\n2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨  \n\n你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等的尸体而痛哭流涕  \n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索  \n\n一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道  \n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播  \n\n为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻  \n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉  \n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 \"大变革降临的标志\"  \n\n你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实  \n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响  \n\n世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发  \n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾  \n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背  \n\n\"那群疯子\", 你喃喃自语道, 一个伟大的计划在你心中形成  \n\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n\n五十年后  \n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教  \n\"拒绝猪肉\" 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!  \n\n你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音  \n感受到簇拥在你身边, 痛哭着的教徒, 笑着闭上了双眼...\n\n\n这是你回忆起你的一生时, 脑海中最后的念头:\n\n\"哇哈哈哈哈哈哈哈啊哈哈哈哈, 屏幕前的一帮蠢逼, 我TM一直是个生藏不露的素食主义者, 一吃猪肉就恶心!\"  \n\"要不是老爸非逼我继承那千万亿的养猪厂, 我现在肯定就种种花养养草了, 可恶\"  \n\n\"要不是五十年前的那个病毒, 我还真不好意思直接下台啊\"  \n\"那个组织? 我就是幕后的大BOSS哟, 我把整个世界都骗进去了呢, 包括你们这些高维度的 '观众' 们, 哈哈哈哈哈哈哈哈哈哈哈\"  \n\n\"我终于改变了这个猪肉至上, 扭曲且肮脏的世界了...\"  \n\"我做到了...我终于...做到了...\"\n\n你终是停止了呼吸, 一代枭雄就此陨落  \n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-29 20:53:24\n---\n\n# 冒险者\n曾经...\n我和你一样, 也是个冒险者...\n直到我的膝盖中了一剑\n\n- - -\n\n# 日记\n2022.7.6\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业\n\n2022.7.7\n看番\n\n2022.7.8\n看番\n\n2022.7.9\n看番\n\n2022.7.10\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗?  \n子曰: \"吾日三省吾身\"\n不能再这样下去了!\n\n2022.7.12\n看番\n\n- - -\n# 猪, 四战, 宗教\n2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨  \n\n你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等的尸体而痛哭流涕  \n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索  \n\n一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道  \n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播  \n\n为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻  \n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉  \n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 \"大变革降临的标志\"  \n\n你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实  \n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响  \n\n世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发  \n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾  \n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背  \n\n\"那群疯子\", 你喃喃自语道, 一个伟大的计划在你心中形成  \n\n. . . . . . . .\n. . . . . . . .\n. . . . . . . .\n\n五十年后  \n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教  \n\"拒绝猪肉\" 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!  \n\n你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音  \n感受到簇拥在你身边, 痛哭着的教徒, 笑着闭上了双眼...\n\n\n这是你回忆起你的一生时, 脑海中最后的念头:\n\n\"哇哈哈哈哈哈哈哈啊哈哈哈哈, 屏幕前的一帮蠢逼, 我TM一直是个生藏不露的素食主义者, 一吃猪肉就恶心!\"  \n\"要不是老爸非逼我继承那千万亿的养猪厂, 我现在肯定就种种花养养草了, 可恶\"  \n\n\"要不是五十年前的那个病毒, 我还真不好意思直接下台啊\"  \n\"那个组织? 我就是幕后的大BOSS哟, 我把整个世界都骗进去了呢, 包括你们这些高维度的 '观众' 们, 哈哈哈哈哈哈哈哈哈哈哈\"  \n\n\"我终于改变了这个猪肉至上, 扭曲且肮脏的世界了...\"  \n\"我做到了...我终于...做到了...\"\n\n你终是停止了呼吸, 一代枭雄就此陨落  \n\n","updated":"2022-01-29T12:53:24.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"clagz86fe00006aije3jp590x","content":"<h1 id=\"mou-xian-zhe\">冒险者</h1>\n<p>曾经…<br>\n我和你一样, 也是个冒险者…<br>\n直到我的膝盖中了一剑</p>\n<hr>\n<h1 id=\"ri-ji\">日记</h1>\n<p>2022.7.6<br>\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业</p>\n<p>2022.7.7<br>\n看番</p>\n<p>2022.7.8<br>\n看番</p>\n<p>2022.7.9<br>\n看番</p>\n<p>2022.7.10<br>\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗?<br>\n子曰: “吾日三省吾身”<br>\n不能再这样下去了!</p>\n<p>2022.7.12<br>\n看番</p>\n<hr>\n<h1 id=\"zhu-si-zhan-zong-jiao\">猪, 四战, 宗教</h1>\n<p>2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨</p>\n<p>你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等的尸体而痛哭流涕<br>\n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索</p>\n<p>一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道<br>\n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:<br>\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播</p>\n<p>为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻<br>\n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉<br>\n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 “大变革降临的标志”</p>\n<p>你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实<br>\n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响</p>\n<p>世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发<br>\n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾<br>\n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背</p>\n<p>“那群疯子”, 你喃喃自语道, 一个伟大的计划在你心中形成</p>\n<p>. . . . . . . .<br>\n. . . . . . . .<br>\n. . . . . . . .</p>\n<p>五十年后<br>\n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教<br>\n“拒绝猪肉” 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!</p>\n<p>你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音<br>\n感受到簇拥在你身边, 痛哭着的教徒, 笑着闭上了双眼…</p>\n<p>这是你回忆起你的一生时, 脑海中最后的念头:</p>\n<p>“哇哈哈哈哈哈哈哈啊哈哈哈哈, 屏幕前的一帮蠢逼, 我TM一直是个生藏不露的素食主义者, 一吃猪肉就恶心!”<br>\n“要不是老爸非逼我继承那千万亿的养猪厂, 我现在肯定就种种花养养草了, 可恶”</p>\n<p>“要不是五十年前的那个病毒, 我还真不好意思直接下台啊”<br>\n“那个组织? 我就是幕后的大BOSS哟, 我把整个世界都骗进去了呢, 包括你们这些高维度的 ‘观众’ 们, 哈哈哈哈哈哈哈哈哈哈哈”</p>\n<p>“我终于改变了这个猪肉至上, 扭曲且肮脏的世界了…”<br>\n“我做到了…我终于…做到了…”</p>\n<p>你终是停止了呼吸, 一代枭雄就此陨落</p>\n","site":{"data":{}},"length":1216,"excerpt":"","more":"<h1 id=\"mou-xian-zhe\">冒险者</h1>\n<p>曾经…<br>\n我和你一样, 也是个冒险者…<br>\n直到我的膝盖中了一剑</p>\n<hr>\n<h1 id=\"ri-ji\">日记</h1>\n<p>2022.7.6<br>\n新开这本日记, 也为了督促自己好好学习, 下个学期多做苦功, 先要做完暑假作业</p>\n<p>2022.7.7<br>\n看番</p>\n<p>2022.7.8<br>\n看番</p>\n<p>2022.7.9<br>\n看番</p>\n<p>2022.7.10<br>\n混蛋啊混蛋! 你怎么能如此堕落! 先前定下的学习计划你都忘了吗?<br>\n子曰: “吾日三省吾身”<br>\n不能再这样下去了!</p>\n<p>2022.7.12<br>\n看番</p>\n<hr>\n<h1 id=\"zhu-si-zhan-zong-jiao\">猪, 四战, 宗教</h1>\n<p>2xxx年, 由于猪瘟疫的传播, 世界各地的猪厂大规模地倒闭, 猪肉价格暴涨</p>\n<p>你, 世界 Top.1 的养猪厂老板, 此刻看着即将倒闭的猪厂, 看着阿毛, 小红, 李明等的尸体而痛哭流涕<br>\n为了保留这世上最后的猪种, 你利用手上所有的钱, 联合了厂中的猪生物学家, 再配合联合国的 MAGI System, 破译病毒, 调查线索</p>\n<p>一些蛛丝马迹浮出水面, 你们嗅到了阴谋的味道<br>\n聪明如你, 仅仅花了 1/3 秒, 便将所有线索串了起来, 得出一个结论:<br>\n这场猪疫的背后, 存在一个势力通天的组织, 研发出了猪病毒, 在世界各地多点传播</p>\n<p>为什么呢, 他们为什么要这么做呢? 那群躲在幕后的混蛋! 你原地踏步, 忽然灵光一闪, 想起前天的一则新闻<br>\n据报道, X国人民由于支付不起高额的猪价, 纷纷起义造反, 建立了猪国公社, 为了让百姓吃得起新鲜, 健康的猪肉<br>\n仅仅半个月的时间, X国人民便占领了首都, 公社掌握了政权, 世界媒体纷纷称之为 “大变革降临的标志”</p>\n<p>你悟了! 那个研发出猪肉病毒的组织, 意图通过抬高物价, 严重破坏供求关系, 使其失衡, 借此影响现实<br>\n你冷汗直出, X国只是一个先例, 在这场猪肉革命中, 还有更多国家即将因为病毒, 其政权受到影响</p>\n<p>世界上那么极度渴望吃到猪肉的人们, 当进口量远远低于需求时, 时间一长, 心中压抑着的怒火必将爆发<br>\n执政的统治者, 若不想成为下一个X国, 自身政权被夺的话, 必须通过掠夺他国猪肉来转移国内矛盾<br>\n换句话说, 第四次世界大战, 可能因为这场病毒而一触即发!  汗水已经浸湿了你的后背</p>\n<p>“那群疯子”, 你喃喃自语道, 一个伟大的计划在你心中形成</p>\n<p>. . . . . . . .<br>\n. . . . . . . .<br>\n. . . . . . . .</p>\n<p>五十年后<br>\n你创立的伊塔科尔兰斯巴赫克特兰教, 已经成为世界第一的宗教<br>\n“拒绝猪肉” 的理念已经深入人心, 你通过传播这个理念, 拯救了世界!</p>\n<p>你那苍老且模糊的意志, 最后一次清醒起来, 看到了白色的天花板, 与维持生命的仪器运作的声音<br>\n感受到簇拥在你身边, 痛哭着的教徒, 笑着闭上了双眼…</p>\n<p>这是你回忆起你的一生时, 脑海中最后的念头:</p>\n<p>“哇哈哈哈哈哈哈哈啊哈哈哈哈, 屏幕前的一帮蠢逼, 我TM一直是个生藏不露的素食主义者, 一吃猪肉就恶心!”<br>\n“要不是老爸非逼我继承那千万亿的养猪厂, 我现在肯定就种种花养养草了, 可恶”</p>\n<p>“要不是五十年前的那个病毒, 我还真不好意思直接下台啊”<br>\n“那个组织? 我就是幕后的大BOSS哟, 我把整个世界都骗进去了呢, 包括你们这些高维度的 ‘观众’ 们, 哈哈哈哈哈哈哈哈哈哈哈”</p>\n<p>“我终于改变了这个猪肉至上, 扭曲且肮脏的世界了…”<br>\n“我做到了…我终于…做到了…”</p>\n<p>你终是停止了呼吸, 一代枭雄就此陨落</p>\n"},{"title":"分类","abbrlink":"categories","hidden":true,"date":"2021-09-12T06:59:09.000Z","quicklink":true,"_content":"这个博客的更新十分缓慢... 因为我很懒, 也很忙  \n到底有多慢? 举个例子, Rust的声明宏系列, 我B站老早就录完了, 但博客的文章却一直没有写完...\n\n虽然很慢, 但我会尽量保持更新的, 只要有空 ~~(应该吧)~~ :)\n请根据需要进行选择, 善用目录功能\n\n- - -\n\n# Rust\nRust, 是一门高性能, 工具链友善, 类型严格显式的编程语言\n[ ]  [声明宏](/categories/rust-decl-macro)\n[ ]  [异步](/categories/rust-async)\n[ ]  [音视频处理 (gstreamer)](/categories/rust-gstreamer)\n[x]  [命令行 (clap-rs)](/posts/rust-clap/intro)\n[ ]  [GUI (gtk4 && relm4)](/categories/rust-gui)\n[ ]  [TUI (tui-rs)](/categories/rust-tui)\n\n- - -\n\n# GNOME\nGNOME, 是一个简洁, 绚丽, 优雅的桌面环境  \n[x]  [入坑指南](/posts/gnome/guide)\n\n- - -\n\n# 高中信息技术\n[ ]  [导航页](/categories/high-school-it)\n\n- - -\n\n# Haskell\nHaskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言\n[ ]  [基础](/categories/haskell-basic)\n\n- - -\n\n","source":"categories/index.md","raw":"---\ntitle: 分类\nabbrlink: categories\nhidden: true\ndate: 2021-09-12 14:59:09\nquicklink: true\n---\n这个博客的更新十分缓慢... 因为我很懒, 也很忙  \n到底有多慢? 举个例子, Rust的声明宏系列, 我B站老早就录完了, 但博客的文章却一直没有写完...\n\n虽然很慢, 但我会尽量保持更新的, 只要有空 ~~(应该吧)~~ :)\n请根据需要进行选择, 善用目录功能\n\n- - -\n\n# Rust\nRust, 是一门高性能, 工具链友善, 类型严格显式的编程语言\n[ ]  [声明宏](/categories/rust-decl-macro)\n[ ]  [异步](/categories/rust-async)\n[ ]  [音视频处理 (gstreamer)](/categories/rust-gstreamer)\n[x]  [命令行 (clap-rs)](/posts/rust-clap/intro)\n[ ]  [GUI (gtk4 && relm4)](/categories/rust-gui)\n[ ]  [TUI (tui-rs)](/categories/rust-tui)\n\n- - -\n\n# GNOME\nGNOME, 是一个简洁, 绚丽, 优雅的桌面环境  \n[x]  [入坑指南](/posts/gnome/guide)\n\n- - -\n\n# 高中信息技术\n[ ]  [导航页](/categories/high-school-it)\n\n- - -\n\n# Haskell\nHaskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言\n[ ]  [基础](/categories/haskell-basic)\n\n- - -\n\n","updated":"2021-09-12T06:59:09.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clagz86fp00026aij0bqtfpdy","content":"<p>这个博客的更新十分缓慢… 因为我很懒, 也很忙<br>\n到底有多慢? 举个例子, Rust的声明宏系列, 我B站老早就录完了, 但博客的文章却一直没有写完…</p>\n<p>虽然很慢, 但我会尽量保持更新的, 只要有空 <s>(应该吧)</s> 😃<br>\n请根据需要进行选择, 善用目录功能</p>\n<hr>\n<h1 id=\"rust\">Rust</h1>\n<p>Rust, 是一门高性能, 工具链友善, 类型严格显式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox38\"><label for=\"checkbox38\"> </label><a href=\"/categories/rust-decl-macro\">声明宏</a><br>\n<input type=\"checkbox\" id=\"checkbox37\"><label for=\"checkbox37\"> </label><a href=\"/categories/rust-async\">异步</a><br>\n<input type=\"checkbox\" id=\"checkbox36\"><label for=\"checkbox36\"> </label><a href=\"/categories/rust-gstreamer\">音视频处理 (gstreamer)</a><br>\n<input type=\"checkbox\" id=\"checkbox35\" checked=\"true\"><label for=\"checkbox35\"> </label><a href=\"/posts/rust-clap/intro\">命令行 (clap-rs)</a><br>\n<input type=\"checkbox\" id=\"checkbox34\"><label for=\"checkbox34\"> </label><a href=\"/categories/rust-gui\">GUI (gtk4 &amp;&amp; relm4)</a><br>\n<input type=\"checkbox\" id=\"checkbox33\"><label for=\"checkbox33\"> </label><a href=\"/categories/rust-tui\">TUI (tui-rs)</a></p>\n<hr>\n<h1 id=\"gnome\">GNOME</h1>\n<p>GNOME, 是一个简洁, 绚丽, 优雅的桌面环境<br>\n<input type=\"checkbox\" id=\"checkbox39\" checked=\"true\"><label for=\"checkbox39\"> </label><a href=\"/posts/gnome/guide\">入坑指南</a></p>\n<hr>\n<h1 id=\"gao-zhong-xin-xi-ji-zhu\">高中信息技术</h1>\n<p><input type=\"checkbox\" id=\"checkbox40\"><label for=\"checkbox40\"> </label><a href=\"/categories/high-school-it\">导航页</a></p>\n<hr>\n<h1 id=\"haskell\">Haskell</h1>\n<p>Haskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox41\"><label for=\"checkbox41\"> </label><a href=\"/categories/haskell-basic\">基础</a></p>\n<hr>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":296,"excerpt":"","more":"<p>这个博客的更新十分缓慢… 因为我很懒, 也很忙<br>\n到底有多慢? 举个例子, Rust的声明宏系列, 我B站老早就录完了, 但博客的文章却一直没有写完…</p>\n<p>虽然很慢, 但我会尽量保持更新的, 只要有空 <s>(应该吧)</s> 😃<br>\n请根据需要进行选择, 善用目录功能</p>\n<hr>\n<h1 id=\"rust\">Rust</h1>\n<p>Rust, 是一门高性能, 工具链友善, 类型严格显式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox38\"><label for=\"checkbox38\"> </label><a href=\"/categories/rust-decl-macro\">声明宏</a><br>\n<input type=\"checkbox\" id=\"checkbox37\"><label for=\"checkbox37\"> </label><a href=\"/categories/rust-async\">异步</a><br>\n<input type=\"checkbox\" id=\"checkbox36\"><label for=\"checkbox36\"> </label><a href=\"/categories/rust-gstreamer\">音视频处理 (gstreamer)</a><br>\n<input type=\"checkbox\" id=\"checkbox35\" checked=\"true\"><label for=\"checkbox35\"> </label><a href=\"/posts/rust-clap/intro\">命令行 (clap-rs)</a><br>\n<input type=\"checkbox\" id=\"checkbox34\"><label for=\"checkbox34\"> </label><a href=\"/categories/rust-gui\">GUI (gtk4 &amp;&amp; relm4)</a><br>\n<input type=\"checkbox\" id=\"checkbox33\"><label for=\"checkbox33\"> </label><a href=\"/categories/rust-tui\">TUI (tui-rs)</a></p>\n<hr>\n<h1 id=\"gnome\">GNOME</h1>\n<p>GNOME, 是一个简洁, 绚丽, 优雅的桌面环境<br>\n<input type=\"checkbox\" id=\"checkbox39\" checked=\"true\"><label for=\"checkbox39\"> </label><a href=\"/posts/gnome/guide\">入坑指南</a></p>\n<hr>\n<h1 id=\"gao-zhong-xin-xi-ji-zhu\">高中信息技术</h1>\n<p><input type=\"checkbox\" id=\"checkbox40\"><label for=\"checkbox40\"> </label><a href=\"/categories/high-school-it\">导航页</a></p>\n<hr>\n<h1 id=\"haskell\">Haskell</h1>\n<p>Haskell, 是一门静态强类型, 惰性求值, 简易并发, 纯函数式的编程语言<br>\n<input type=\"checkbox\" id=\"checkbox41\"><label for=\"checkbox41\"> </label><a href=\"/categories/haskell-basic\">基础</a></p>\n<hr>\n","sitemap":false}],"Post":[{"title":"GNOME 入坑指南","abbrlink":"posts/gnome/guide","hidden":false,"date":"2022-07-20T03:22:42.000Z","top":20999,"keywords":["GNOME","桌面环境","DE"],"_content":"> 关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境\n<!-- more -->\n\n::: tips\n**注意:**  \n本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式, 炫酷效果, 更多功能的, 请自行配置  \n请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新  \n目前, 该篇文章的GNOME 版本为: **42**  \n:::\n\n# 成品展示\n2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前...  \n我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!  \n\n![按下Super后的Overview](/images/gnome/overview.png)  \n\n- - -\n\n# dconf && gsettings\n- `dconf`:\n是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表  \n\n- `gsettings`:\n是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作  \n \n\n你可能在年份久远的文章中听说过 `gconf`, 这是什么? 与 `dconf` 有啥区别?  \n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 `dconf` 所取代  \n\n接下来的大部分配置, 都会使用 `gsettings`  \n\n- - - \n\n# 触摸板\n触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO ~~(但CS我也能用触摸板玩)~~\n\n## 配置\n有一些 Linux 发行版的 GNOME比较贴近上游, `轻击模拟鼠标点击` 默认未开启  \n这导致触摸板很难用, 得按下去才能模拟鼠标的点击  \n\n你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指...  \n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改...  \n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒...  \n\n你可以在终端输入如下命令进行调整:  \n\n```bash\ngsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true\ngsettings set org.gnome.desktop.peripherals.touchpad speed 0.57\ngsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing false\n```\n\n分别对应:  \n- 轻击模拟鼠标点击, 默认为false\n- 调整触摸板速度, 默认为0\n- 打字时禁用触摸板, 默认为true\n\n## 手势\n- 单指: 移动鼠标\n- 双指上下: 翻页\n- 三指左右: 切换Workspace\n- 三指上: 打开Overview (不常用, 按Super更快)\n- 三指下: 显示任务栏 (当你隐藏任务栏时)\n- - -\n\n# 安装扩展\nGNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之  \n我将先介绍如何安装/使用它们, 因为后面需要用到扩展  \n\n有两种安装方法, 一种从命令行安装, 一种从浏览器安装  \n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍  \n\n## 从命令行\n:::tips\n**提示**  \n请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有...  \n下载成功后, 切记要 logout, 然后再登进来  \n:::\n\n每个GNOME扩展都拥有独一无二的, 名为 `uuid` 的标识符, 我们可以通过 `uuid`, 下载扩展  \n\n你可以在 [Extensions-GNOME](https://extensions.gnome.org/) 这个网站上, 浏览并下载扩展  \n请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 `exts_list`  \n\n下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:  \n\n{% tabs install-extensions%}\n<!-- tab Bash-->\n\n```bash install-extensions.sh\n#!/usr/bin/env bash\ndeclare -a UUID_LIST\nEXTS_DIR=$HOME/.local/share/gnome-shell/extensions\nEXTS_LIST=${1}\nstr_join() {\n  echo \"$*\" | sed 's/\"\"/\",\"/g'\n}\nmkdir -p $EXTS_DIR\nchmod -R 755 $HOME/.local/\nfor EXT in $EXTS_LIST/*.zip\ndo\n  UUID=$(unzip -p $EXT metadata.json | jq -r \".uuid\")\n  mkdir -p $EXTS_DIR/$UUID\n  unzip -q -o $EXT -d $EXTS_DIR/$UUID\n  UUID_LIST+=\"\\\"$UUID\\\"\"\ndone\nUUID_LIST=[$(str_join ${UUID_LIST[@]})]\ngsettings set org.gnome.shell enabled-extensions ${UUID_LIST[@]}\n```\n\n<!-- endtab -->\n\n<!-- tab Fish -->\n\n```bash install-extensions.fish\nset exts_list $argv[1]\nset exts_dir $HOME/.local/share/gnome-shell/extensions/\nset uuid_list\nmkdir -p $exts_dir\nfor ext in exts_list/*.zip\n  set uuid ( unzip -p $ext metadata.json | jq -r \".uuid\" )\n  mkdir -p $ext_dir/$uuid\n  unzip -q -o $ext -d $ext_dir/$uuid\n  set -a uuid_list \\'$uuid\\'\nend\nset uuid_list [( string join \",\" $uuid_list )]\ngsettings set org.gnome.shell enabled-extensions $uuid_list\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n假设使用Bash: 执行 `sh install-extensions.sh exts_list` 下载该目录下的所有插件  \n\n**注意: 先logout, 再登进来**  \n\n也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:  \n\n```bash\nsudo dbus-send --type=method_call --dest=org.gnome.Shell /org/gnome/Shell \\\n  org.gnome.Shell.Extensions.InstallRemoteExtension string:'xxxxx_uuid'\n```\n\n## 从浏览器\n该方法其实也蛮方便的, 但不适合快速部署  \n你需要安装两个玩意, 才能直接从 [Extension-GNOME](https://extensions.gnome.org/) 上直接下载  \n\n- `chrome-gnome-shell`:  \n本地软件, 你可以通过包管理器, 直接搜这个名字  \n\n- `GNOME Shell integration`:  \n浏览器插件, Chrome/Firefox 的浏览器商店都有它  \nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件  \n\n一个在本地, 一个在浏览器,  因此可以支持你从 [网站](https://extensions.gnome.org/) 上 直接安装到本地  \n\n- - -\n\n# 查看/配置扩展\n通过 `gnome-extensions` 这个命令, 我们可以查看/配置当前扩展  \n\n```bash\n# 获取帮助, `Command` 为可选项\ngnome-extensions help [Command]\n\n# 查看扩展列表\ngnome-extensions list --user    # 查看用户级扩展\ngnome-extensions list --system  # 查看系统级扩展\n\n# 查看扩展的信息\ngnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com\n\n# 启用/禁用某个扩展\ngnome-extensions enable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\ngnome-extensions disable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n\n# 配置某个扩展 (打开 GUI 界面)\ngnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n```\n\n或者通过 `gsettings` 来配置某个扩展, 但不推荐, 因为麻烦:  \n\n```bash\n# 查看某个扩展的所有选项\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  list-recursively org.gnome.shell.extensions.nothing-to-say\n  \n# 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  get    org.gnome.shell.extensions.nothing-to-say show-osd\n# reset  org.gnome.shell.extensions.nothing-to-say show-osd\n# set    org.gnome.shell.extensions.nothing-to-say show-osd\n```\n\n你也可以参考或[**直接加载**](#jia-zai-pei-zhi)我博客下的 [**dconf.settings**](/downloads/gnome/dconf.settings)  \n**注意:** 如何你选择直接加载我的配置, 请注意 `picture-uri` 符合自己实际  \n\n- - -\n\n# 推荐的扩展\n以下是我目前正在使用, 推荐的扩展  \n\n- [auto-move-windows](https://extensions.gnome.org/extension/16/auto-move-windows/):  \n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)  \n**无图片**\n\n<br>\n\n- [refresh-wifi-connections](https://extensions.gnome.org/extension/905/refresh-wifi-connections/)\n当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键  \n\n>>> **点击展开/隐藏图片**\n![refresh-wifi-connections](/images/gnome/refresh-wifi-connections.png)\n>>>\n\n<br>\n\n- [transparent-window-moving](https://extensions.gnome.org/extension/1446/transparent-window-moving/)\n在对窗口进行移动/调整大小时, 使窗口变得透明  \n>>> **点击展开/隐藏图片**\n![transparent-window-moving](/images/gnome/transparent-window-moving.png)\n>>>\n\n<br>\n\n- [just-perfection](https://extensions.gnome.org/extension/3843/just-perfection/)\n我最喜欢的一个扩展, 用于对界面进行大量自定义与精简  \n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等  \n>>> **点击展开/隐藏图片**\n![just-perfection](/images/gnome/overview.png)\n>>>\n\n<br>\n\n- [eye-extended](https://extensions.gnome.org/extension/3139/eye-extended/)\n很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场  \n在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈  \n>>> **点击展开/隐藏图片**\n![eye-extended](/images/gnome/eye-extended.png)\n>>>\n\n<br>\n\n- [nothing-to-say](https://extensions.gnome.org/extension/1113/nothing-to-say/)\n用于切断/恢复声音的输入, 对我来说蛮有用的:  \n当与同学打游戏, 撞上爸妈查房, 立刻按下 `Super+\\`, 防止爸妈训我的声音流入同学耳中, 维护尊严 :)  \n>>> **点击展开/隐藏图片**\n![nothing-to-say](/images/gnome/nothing-to-say.png)\n>>>\n\n<br>\n\n- [space-bar](https://extensions.gnome.org/extension/5090/space-bar/)\n模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 `Activities` 替换为 `Workspaces`, 有些类似的扩展, 但这个最好  \n>>> **点击展开/隐藏图片**\n![space-bar](/images/gnome/space-bar.png)\n>>>\n\n<br>\n\n- [static-background-in-overview](https://extensions.gnome.org/extension/4696/static-background-in-overview/)\n在按下 `Super` 进入 `Overview` 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看  \n>>> **点击展开/隐藏图片**\n![static-background-in-overview](/images/gnome/overview.png)\n>>>\n\n<br>\n\n- [workspace-switcher-manager](https://extensions.gnome.org/extension/4788/workspace-switcher-manager/)\n美化通过键盘(我配成了 `Super + 1..9`), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY  \n>>> **点击展开/隐藏图片**\n![workspace-switcher-manager](/images/gnome/workspace-switcher-manager.png)\n>>>\n\n<br>\n\n- [disable-workspace-switch-animation-for-GNOME40+](https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/)\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感  \n**无图片**\n\n<br>\n\n- [gsconnect](https://extensions.gnome.org/extension/1319/gsconnect/)\nGNOME版的 `kdeconnect`, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开  \n手机需安装 `kdeconnect`, 你可以从本博客下载 apk 进行安装: [kdeconnect](/downloads/gnome/kdeconnect.apk)  \n>>> **点击展开/隐藏图片**\n![gsconnect](/images/gnome/gsconnect.png)\n>>>\n\n<br>\n\n- [blur-my-shell](https://extensions.gnome.org/extension/3193/blur-my-shell/)\n用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展  \n>>> **点击展开/隐藏图片**\n![blur-my-shell](/images/gnome/overview.png)\n>>>\n\n<br>\n\n- [big-avatar](https://extensions.gnome.org/extension/3488/big-avatar/)\n让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已  \n>>> **点击展开/隐藏图片**\n![big-avatar](/images/gnome/big-avatar.png)\n>>>\n\n<br>\n\n- [cpudots](https://extensions.gnome.org/extension/4530/cpudots/)\n监视你当前的CPU频率, 以百分数的形式呈现在顶栏  \n>>> **点击展开/隐藏图片**\n![cpudots](/images/gnome/right-corner.png)\n>>>\n\n<br>\n\n- [colorful-battery-indicator](https://extensions.gnome.org/extension/4817/colorful-battery-indicator/)\n让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强  \n>>> **点击展开/隐藏图片**\n![colorful-battery-indicator](/images/gnome/right-corner.png)\n>>>\n\n<br>\n\n- [gnome40-ui-improvements](https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/)\n按下 `Super`, 进入 `Overview` 后, 在中上方显示工作区的内容  \n>>> **点击展开/隐藏图片**\n![gnome40-ui-improvements](/images/gnome/gnome40-ui-improvements.png)\n>>>\n\n<br>\n\n- [gnome-fuzzy-app-search](https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/)\n出于某些目的, 默认的 `GNOME` 在 `Overview` 中不支持模糊查找, 可以通过该扩展修改  \n>>> **点击展开/隐藏图片**\n![gnome-fuzzy-app-search](/images/gnome/gnome-fuzzy-app-search.png)\n>>>\n\n<br>\n\n- [pip-on-top](https://extensions.gnome.org/extension/4691/pip-on-top/)\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口  \n**无图片**\n\n<br>\n\n- [frequency-boost-switch](https://extensions.gnome.org/extension/4792/frequency-boost-switch/)\n在右上角菜单中的 `电池策略` 中添加一个 `Checkox`, 用于切换 `是否允许超频`  \n>>> **点击展开/隐藏图片**\n![frequency-boost-switch](/images/gnome/frequency-boost-switch.png)\n>>>\n\n<br>\n\n- [overview-navigation](https://extensions.gnome.org/extension/1702/overview-navigation/)\n当按下 `Super` 进入 `Overview` 后, 可以按下 `空格键`, 窗口上会出现字母  \n输入小写字母就切换到对应窗口, 按下 `Shift` 会使字母颜色变红, 此时输入字母会关闭对应窗口  \n>>> **点击展开/隐藏图片**\n![overview-navigation](/images/gnome/overview-navigation.png)\n>>>\n\n<br>\n\n- [cleaner-overview](https://extensions.gnome.org/extension/3759/cleaner-overview/)\n进入 `Overview` 时, 将窗口排列整齐, 简单实用  \n>>> **点击展开/隐藏图片**\n![cleaner-overview](/images/gnome/overview-navigation.png)\n>>>\n\n<br>\n\n- [user-theme](https://extensions.gnome.org/extension/19/user-themes/)\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)  \n注意: 还需要使用 `gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com` 指定主题  \n**无图片**\n\n<br>\n\n- [user-syle-sheet](https://extensions.gnome.org/extension/3414/user-stylesheet-font/)\n读取 `~/.local/share/gnome-shell/gnome-shell.css` 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者  \n**无图片**\n- - -\n\n# 美化\n以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等  \n还有很多扩展有帮助, 上面 [推荐的扩展](#tui-jian-de-kuo-zhan) 里有提到, 比如那个更改css的, 这里不说了  \n\n- 启动暗模式:  \n\n```bash\ngsettings set org.gnome.desktop.interface color-scheme \"prefer-dark\"\n```\n\n- 背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下  \n\n```bash\ngsettings set org.gnome.desktop.background picture-uri 'file:///usr/share/backgrounds/aaa.png'\ngsettings set org.gnome.desktop.background picture-uri-dark 'file:///usr/share/backgrounds/aaa.png'\n```\n\n- 头像: 假设用户名是 `Xyz`, 则需要将图片命名为 `Xyz`, 随后放到 `/var/lib/AccountsService/icons/` 下\n\n```bash\nsudo mv ./Xyz /var/lib/AccountsService/icons/\n\n# 或将图片命名为.face, 放到家目录\n# mv ./Xyz ~/.face  \n```\n\n- 主题: 单用户的放 `~/.themes/` , 多用户的放 `/usr/share/themes/`, 可前往 [gnome-look](https://www.gnome-look.org/) 挑选主题  \n\n```bash\n# 以 Nordic 为例子\nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.git\ngsettings set org.gnome.desktop.interface gtk-theme 'Nordic'\ngsettings set org.gnome.desktop.wm.preferences theme 'Nordic'\n\n# 你也可以使用 `user-theme` 这个扩展进行设置:  \nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.gi\ngnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com\n```\n\n- 字体: 将顶栏字体换成 `Fira Code`, 顺便调整下大小  \n\n```bash\ngsettings set org.gnome.desktop.interface font-name 'Fira Code 11.8'\n```\n\n- 隐藏 `Dash` 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了  \n\n```bash\ngsettings set org.gnome.shell favorite-apps \"[]\"\n```\n\n::: tips\n**注意:**  \n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 `Just-perfection` 扩展  \n此扩展得到官方支持, 可以将桌面 `化简`, 包括Dash  \n如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的[禁用快捷键](#jin-yong-kuai-jie-jian)  \n:::\n\n- 去掉左上角的 `Activities`: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: `space-bar` 或 `workspace-bar`)  \n\n```bash\n# 自定义工作区的名称, 不然就是默认的数字\ngsettings set org.gnome.desktop.wm.preferences workspace-names \"['Browser', 'Terminal', 'Game', 'Box', 'Other']\"\n```\n- 隐藏顶栏: 安装 `just-perfection` && `blur-my-shell`, 配置后就是本文 [成品展示](#cheng-pin-zhan-shi) 中的了, 处于 `Overview` 中才显示顶栏  \n\n- - -\n\n# 快捷键\n这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改  \n\n我个人就不喜欢 `Alt+Fn数字`, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 `I3/Sway` 那样  \n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash  \n\n::: tips\n**注意:**  \n快捷键之间有冲突的话, 可能无法生效, 请通过 `gnome-control-center keyboard` 查看快捷键冲突  \n:::\n\n\n## 查找快捷键\n首先, 我们得明白如何查找对应的快捷键  \n\n下面的命令会列出极大部分的快捷键:  \n\n```bash\ngsettings list-recursively | grep -E \"Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left\" | cat\n```\n\n你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语  \n如果实在找不到, 一点点看过去也行 :)  \n\n\n## 禁用快捷键\n某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组  \n想要禁用该快捷键, 将对应的数组设置为空就行了  \n\n举个例子, 禁用Dash的快捷键 (见上文的置空 `favorite-apps`):  \n\n```bash\n# Default: Super+\"1..9\"\nfor i in $(seq 9)\ndo\n    gsettings set org.gnome.shell.keybindings switch-to-application-$i \"[]\"  \ndone    \n```\n\n禁用快捷键还可以让你避免冲突, 比如:  \n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次  \n这时就要借助 GUI 的力量了: 输入 `gnome-control-center keyboard`, 然后进入自定义那栏, 会显示冲突的键  \n\n举个例子, 我想修改 `Super+Esc` 变成锁屏, 我就要这样做:  \n\n```bash\ngsettings set org.gnome.settings-daemon.plugins.media-keys screensaver \"['<Super>Escape']\" #Default: Sup+L\ngsettings set org.gnome.mutter.wayland.keybindings restore-shortcuts \"[]\" # Default: Sup+Esc\n```\n\n## 修改快捷键\n修改, 也就是覆写默认的快捷键, 与下文要讲的 [添加快捷键](#tian-jia-kuai-jie-jian) 不是一个概念  \n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考  \n\n- Vim 式的案件, 改变窗口布局, 替代原有的 `Super+方向键`:  \n\n```bash\n# 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......\n\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-left  \"['<Super>h']\" # 放左边\ngsettings set org.gnome.desktop.wm.keybindings  maximize           \"['<Super>j']\" # 最大化\ngsettings set org.gnome.desktop.wm.keybindings  unmaximize         \"['<Super>k']\" # 最小化\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-right \"['<Super>l']\" # 放右边\n```\n\n对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管...  \n\n- move, resize, kill 一个窗口:  \n\n```bash\n# Move\ngsettings set org.gnome.desktop.wm.keybindings begin-move   \"['<Super>x']\"        #Default: Alt+F7\n\n# Resize\ngsettings set org.gnome.desktop.wm.keybindings begin-resize \"['<Super>r']\"        #Default: Alt+F8\n\n# Kill\ngsettings set org.gnome.desktop.wm.keybindings close        \"['<Super><Shift>q']\" #Default: Alt+F4\n```\n\n- toggle-max, max, min, toggle-fullscreen, show-desktop:  \n\n```bash\n# Toggle max\ngsettings set org.gnome.desktop.wm.keybindings toggle-maximized  \"['<Super>m']\"     #Default: Alt+F10\n\n# Max/Min\ngsettings set org.gnome.desktop.wm.keybindings maximize          \"['<Super>j']\"\ngsettings set org.gnome.desktop.wm.keybindings unmaximize        \"['<Super>k']\"\ngsettings set org.gnome.desktop.wm.keybindings minimize          \"['<Super>comma']\" #Default: Super+H\n\n# Toggle fullscreen\ngsettings set org.gnome.desktop.wm.keybindings toggle-fullscreen \"['<Super>f']\"     #Default: None\n\n# Show desktop\ngsettings set org.gnome.desktop.wm.keybindings show-desktop      \"['<Super>d']\"     #Default: None\n```\n\n- 还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:  \n\n```bash\nfor i in $(seq 9)\ndo\n  gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-$i \"['<Super>$i']\"\n  gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-$i   \"['<Super><Shift>$i']\"\ndone\ngsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-10   \"['<Super>0']\"\ngsettings set org.gnome.desktop.wm.keybindings move-to-workspace-10     \"['<Super><Shift>0']\"\n```\n\n- 再比如, 覆写 `run-dialog` 的快捷键 (默认是按Alt-F2, 但太远了...):  \n\n```bash\ngsettings set org.gnome.desktop.wm.keybindings panel-run-dialog \"['<Super>c']\" #Default: Alt+F2\n```\n\n## 添加快捷键\n此处指的是真正的, 添加自己的快捷键. 不是简单的覆写  \n比如 `Super+Return` 打开一个终端, `Super+B` 打开浏览器, `Super+E` 打开文件管理器...  \n\n废话不多说, 你按下面照猫画虎, 就阔以了:  \n\n```bash\ngp0=\"/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\ngp1=\"org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\\n/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\n\n# Custom Keys\n# 注意!!!!!!!\n# 不要在最后添加逗号\ngsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings \"[     \\\n    '$gp0/custom0/', '$gp0/custom1/', '$gp0/custom2/', '$gp0/custom3/'               \\\n]\"\n\n## Terminal\ngsettings set $gp1/custom0/ name     'Terminal'\ngsettings set $gp1/custom0/ command  'alacritty'\ngsettings set $gp1/custom0/ binding  '<Super>Return'\n\n## Files\ngsettings set $gp1/custom1/ name     'Files'\ngsettings set $gp1/custom1/ command  'nautilus'\ngsettings set $gp1/custom1/ binding  '<Super>e'\n\n## Browser\ngsettings set $gp1/custom2/ name     'Browser'\ngsettings set $gp1/custom2/ command  'microsoft-edge-beta'\ngsettings set $gp1/custom2/ binding  '<Super>b'\n\n## Fcitx5 Reload\ngsettings set $gp1/custom3/ name     'Fcitx5_Reload'\ngsettings set $gp1/custom3/ command  'fcitx5 -r'\ngsettings set $gp1/custom3/ binding  '<Alt>space'\n```\n\n我相信你不会将时间浪费在掉在坑里面了  \n上面的一切已经非常非常全了  \n\n- - -\n\n# 加载配置\n我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件  \n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上  \n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE  \n\n你也可以参考或直接加载我博客下的 [**dconf.settings**](/downloads/gnome/dconf.settings)  \n## 对于非Nixos\n对于普通的Linux发行版, 直接按下面的方式  \n\n- 导出当前的dconf数据到某个文件:  \n\n```bash\ndconf dump / > dconf.settings\n```\n\n- 加载/导入某个dconf文件到当前系统:\n\n```bash\ncat dconf.settings | dconf load -f /\n```\n\n对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置  \n同时确认 `dconf.settings` 中的 `picture-uri` / `picture-uri-dark` 指向对应文件  \n\n## 对于Nixos\n\n如果你使用 Nixos, 请先确保已经安装了 [HomeManager](https://github.com/nix-community/home-manager)  \nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具  \n\n虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档  \n请先下载 `dconf2nix`, 这是一个将 dconf文件, 转换为 nix 表达式的工具  \n随后, 在终端输入以下内容, 得到 `dconf.nix` :  \n\n```bash\ndconf dump / > dconf.settings\ndconf2nix -i dconf.settings -o dconf.nix\n```\n\n在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):  \n\n```\nnixpkgs/\n├── gnome\n│   ├── .background\n│   ├── .face\n│   └── dconf.nix\n└── home.nix\n```\n\n这里的 `dconf.nix` 就是刚刚转换得到的nix表达式, 在 `home.nix` 中导入它:  \n\n```nix\nimports = [\n  ./gnome/dconf.nix\n];\n```\n\n\n介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 `$HOME` 下  \n这里将两个图片放在了 `~/.config/nixpkgs/gnome/` 下, 因此要修改下相应文件  \n\n\n- 对于背景图像, 修改 `dconf.nix` 中的 `picture-uri`:  \n\n```nix\n\"org/gnome/desktop/background\" =\nlet picture = ../.background.png; in\n{\n  picture-uri = \"file://${picture}\";\n  picture-uri-dark = \"file://${picture}\";\n};\n```\n\n- 对于人物头像, 在 `home.nix` 添加以下内容:  \n\n```nix\nhome.file.\".face\".source = ./.face;\n```\n\n大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了  \n\n","source":"_posts/gnome/guide.md","raw":"---\ntitle: \"GNOME 入坑指南\"\nabbrlink: posts/gnome/guide\nhidden: false\ndate: 2022-07-20 11:22:42\ntop: 20999\ntags: [GNOME]\nkeywords: [GNOME, 桌面环境, DE]\n---\n> 关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境\n<!-- more -->\n\n::: tips\n**注意:**  \n本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式, 炫酷效果, 更多功能的, 请自行配置  \n请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新  \n目前, 该篇文章的GNOME 版本为: **42**  \n:::\n\n# 成品展示\n2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前...  \n我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!  \n\n![按下Super后的Overview](/images/gnome/overview.png)  \n\n- - -\n\n# dconf && gsettings\n- `dconf`:\n是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表  \n\n- `gsettings`:\n是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作  \n \n\n你可能在年份久远的文章中听说过 `gconf`, 这是什么? 与 `dconf` 有啥区别?  \n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 `dconf` 所取代  \n\n接下来的大部分配置, 都会使用 `gsettings`  \n\n- - - \n\n# 触摸板\n触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO ~~(但CS我也能用触摸板玩)~~\n\n## 配置\n有一些 Linux 发行版的 GNOME比较贴近上游, `轻击模拟鼠标点击` 默认未开启  \n这导致触摸板很难用, 得按下去才能模拟鼠标的点击  \n\n你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指...  \n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改...  \n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒...  \n\n你可以在终端输入如下命令进行调整:  \n\n```bash\ngsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true\ngsettings set org.gnome.desktop.peripherals.touchpad speed 0.57\ngsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing false\n```\n\n分别对应:  \n- 轻击模拟鼠标点击, 默认为false\n- 调整触摸板速度, 默认为0\n- 打字时禁用触摸板, 默认为true\n\n## 手势\n- 单指: 移动鼠标\n- 双指上下: 翻页\n- 三指左右: 切换Workspace\n- 三指上: 打开Overview (不常用, 按Super更快)\n- 三指下: 显示任务栏 (当你隐藏任务栏时)\n- - -\n\n# 安装扩展\nGNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之  \n我将先介绍如何安装/使用它们, 因为后面需要用到扩展  \n\n有两种安装方法, 一种从命令行安装, 一种从浏览器安装  \n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍  \n\n## 从命令行\n:::tips\n**提示**  \n请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有...  \n下载成功后, 切记要 logout, 然后再登进来  \n:::\n\n每个GNOME扩展都拥有独一无二的, 名为 `uuid` 的标识符, 我们可以通过 `uuid`, 下载扩展  \n\n你可以在 [Extensions-GNOME](https://extensions.gnome.org/) 这个网站上, 浏览并下载扩展  \n请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 `exts_list`  \n\n下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:  \n\n{% tabs install-extensions%}\n<!-- tab Bash-->\n\n```bash install-extensions.sh\n#!/usr/bin/env bash\ndeclare -a UUID_LIST\nEXTS_DIR=$HOME/.local/share/gnome-shell/extensions\nEXTS_LIST=${1}\nstr_join() {\n  echo \"$*\" | sed 's/\"\"/\",\"/g'\n}\nmkdir -p $EXTS_DIR\nchmod -R 755 $HOME/.local/\nfor EXT in $EXTS_LIST/*.zip\ndo\n  UUID=$(unzip -p $EXT metadata.json | jq -r \".uuid\")\n  mkdir -p $EXTS_DIR/$UUID\n  unzip -q -o $EXT -d $EXTS_DIR/$UUID\n  UUID_LIST+=\"\\\"$UUID\\\"\"\ndone\nUUID_LIST=[$(str_join ${UUID_LIST[@]})]\ngsettings set org.gnome.shell enabled-extensions ${UUID_LIST[@]}\n```\n\n<!-- endtab -->\n\n<!-- tab Fish -->\n\n```bash install-extensions.fish\nset exts_list $argv[1]\nset exts_dir $HOME/.local/share/gnome-shell/extensions/\nset uuid_list\nmkdir -p $exts_dir\nfor ext in exts_list/*.zip\n  set uuid ( unzip -p $ext metadata.json | jq -r \".uuid\" )\n  mkdir -p $ext_dir/$uuid\n  unzip -q -o $ext -d $ext_dir/$uuid\n  set -a uuid_list \\'$uuid\\'\nend\nset uuid_list [( string join \",\" $uuid_list )]\ngsettings set org.gnome.shell enabled-extensions $uuid_list\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n假设使用Bash: 执行 `sh install-extensions.sh exts_list` 下载该目录下的所有插件  \n\n**注意: 先logout, 再登进来**  \n\n也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:  \n\n```bash\nsudo dbus-send --type=method_call --dest=org.gnome.Shell /org/gnome/Shell \\\n  org.gnome.Shell.Extensions.InstallRemoteExtension string:'xxxxx_uuid'\n```\n\n## 从浏览器\n该方法其实也蛮方便的, 但不适合快速部署  \n你需要安装两个玩意, 才能直接从 [Extension-GNOME](https://extensions.gnome.org/) 上直接下载  \n\n- `chrome-gnome-shell`:  \n本地软件, 你可以通过包管理器, 直接搜这个名字  \n\n- `GNOME Shell integration`:  \n浏览器插件, Chrome/Firefox 的浏览器商店都有它  \nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件  \n\n一个在本地, 一个在浏览器,  因此可以支持你从 [网站](https://extensions.gnome.org/) 上 直接安装到本地  \n\n- - -\n\n# 查看/配置扩展\n通过 `gnome-extensions` 这个命令, 我们可以查看/配置当前扩展  \n\n```bash\n# 获取帮助, `Command` 为可选项\ngnome-extensions help [Command]\n\n# 查看扩展列表\ngnome-extensions list --user    # 查看用户级扩展\ngnome-extensions list --system  # 查看系统级扩展\n\n# 查看扩展的信息\ngnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com\n\n# 启用/禁用某个扩展\ngnome-extensions enable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\ngnome-extensions disable nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n\n# 配置某个扩展 (打开 GUI 界面)\ngnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee\n```\n\n或者通过 `gsettings` 来配置某个扩展, 但不推荐, 因为麻烦:  \n\n```bash\n# 查看某个扩展的所有选项\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  list-recursively org.gnome.shell.extensions.nothing-to-say\n  \n# 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)\ngsettings --schemadir ~/.local/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\\n  get    org.gnome.shell.extensions.nothing-to-say show-osd\n# reset  org.gnome.shell.extensions.nothing-to-say show-osd\n# set    org.gnome.shell.extensions.nothing-to-say show-osd\n```\n\n你也可以参考或[**直接加载**](#jia-zai-pei-zhi)我博客下的 [**dconf.settings**](/downloads/gnome/dconf.settings)  \n**注意:** 如何你选择直接加载我的配置, 请注意 `picture-uri` 符合自己实际  \n\n- - -\n\n# 推荐的扩展\n以下是我目前正在使用, 推荐的扩展  \n\n- [auto-move-windows](https://extensions.gnome.org/extension/16/auto-move-windows/):  \n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)  \n**无图片**\n\n<br>\n\n- [refresh-wifi-connections](https://extensions.gnome.org/extension/905/refresh-wifi-connections/)\n当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键  \n\n>>> **点击展开/隐藏图片**\n![refresh-wifi-connections](/images/gnome/refresh-wifi-connections.png)\n>>>\n\n<br>\n\n- [transparent-window-moving](https://extensions.gnome.org/extension/1446/transparent-window-moving/)\n在对窗口进行移动/调整大小时, 使窗口变得透明  \n>>> **点击展开/隐藏图片**\n![transparent-window-moving](/images/gnome/transparent-window-moving.png)\n>>>\n\n<br>\n\n- [just-perfection](https://extensions.gnome.org/extension/3843/just-perfection/)\n我最喜欢的一个扩展, 用于对界面进行大量自定义与精简  \n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等  \n>>> **点击展开/隐藏图片**\n![just-perfection](/images/gnome/overview.png)\n>>>\n\n<br>\n\n- [eye-extended](https://extensions.gnome.org/extension/3139/eye-extended/)\n很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场  \n在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈  \n>>> **点击展开/隐藏图片**\n![eye-extended](/images/gnome/eye-extended.png)\n>>>\n\n<br>\n\n- [nothing-to-say](https://extensions.gnome.org/extension/1113/nothing-to-say/)\n用于切断/恢复声音的输入, 对我来说蛮有用的:  \n当与同学打游戏, 撞上爸妈查房, 立刻按下 `Super+\\`, 防止爸妈训我的声音流入同学耳中, 维护尊严 :)  \n>>> **点击展开/隐藏图片**\n![nothing-to-say](/images/gnome/nothing-to-say.png)\n>>>\n\n<br>\n\n- [space-bar](https://extensions.gnome.org/extension/5090/space-bar/)\n模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 `Activities` 替换为 `Workspaces`, 有些类似的扩展, 但这个最好  \n>>> **点击展开/隐藏图片**\n![space-bar](/images/gnome/space-bar.png)\n>>>\n\n<br>\n\n- [static-background-in-overview](https://extensions.gnome.org/extension/4696/static-background-in-overview/)\n在按下 `Super` 进入 `Overview` 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看  \n>>> **点击展开/隐藏图片**\n![static-background-in-overview](/images/gnome/overview.png)\n>>>\n\n<br>\n\n- [workspace-switcher-manager](https://extensions.gnome.org/extension/4788/workspace-switcher-manager/)\n美化通过键盘(我配成了 `Super + 1..9`), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY  \n>>> **点击展开/隐藏图片**\n![workspace-switcher-manager](/images/gnome/workspace-switcher-manager.png)\n>>>\n\n<br>\n\n- [disable-workspace-switch-animation-for-GNOME40+](https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/)\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感  \n**无图片**\n\n<br>\n\n- [gsconnect](https://extensions.gnome.org/extension/1319/gsconnect/)\nGNOME版的 `kdeconnect`, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开  \n手机需安装 `kdeconnect`, 你可以从本博客下载 apk 进行安装: [kdeconnect](/downloads/gnome/kdeconnect.apk)  \n>>> **点击展开/隐藏图片**\n![gsconnect](/images/gnome/gsconnect.png)\n>>>\n\n<br>\n\n- [blur-my-shell](https://extensions.gnome.org/extension/3193/blur-my-shell/)\n用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展  \n>>> **点击展开/隐藏图片**\n![blur-my-shell](/images/gnome/overview.png)\n>>>\n\n<br>\n\n- [big-avatar](https://extensions.gnome.org/extension/3488/big-avatar/)\n让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已  \n>>> **点击展开/隐藏图片**\n![big-avatar](/images/gnome/big-avatar.png)\n>>>\n\n<br>\n\n- [cpudots](https://extensions.gnome.org/extension/4530/cpudots/)\n监视你当前的CPU频率, 以百分数的形式呈现在顶栏  \n>>> **点击展开/隐藏图片**\n![cpudots](/images/gnome/right-corner.png)\n>>>\n\n<br>\n\n- [colorful-battery-indicator](https://extensions.gnome.org/extension/4817/colorful-battery-indicator/)\n让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强  \n>>> **点击展开/隐藏图片**\n![colorful-battery-indicator](/images/gnome/right-corner.png)\n>>>\n\n<br>\n\n- [gnome40-ui-improvements](https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/)\n按下 `Super`, 进入 `Overview` 后, 在中上方显示工作区的内容  \n>>> **点击展开/隐藏图片**\n![gnome40-ui-improvements](/images/gnome/gnome40-ui-improvements.png)\n>>>\n\n<br>\n\n- [gnome-fuzzy-app-search](https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/)\n出于某些目的, 默认的 `GNOME` 在 `Overview` 中不支持模糊查找, 可以通过该扩展修改  \n>>> **点击展开/隐藏图片**\n![gnome-fuzzy-app-search](/images/gnome/gnome-fuzzy-app-search.png)\n>>>\n\n<br>\n\n- [pip-on-top](https://extensions.gnome.org/extension/4691/pip-on-top/)\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口  \n**无图片**\n\n<br>\n\n- [frequency-boost-switch](https://extensions.gnome.org/extension/4792/frequency-boost-switch/)\n在右上角菜单中的 `电池策略` 中添加一个 `Checkox`, 用于切换 `是否允许超频`  \n>>> **点击展开/隐藏图片**\n![frequency-boost-switch](/images/gnome/frequency-boost-switch.png)\n>>>\n\n<br>\n\n- [overview-navigation](https://extensions.gnome.org/extension/1702/overview-navigation/)\n当按下 `Super` 进入 `Overview` 后, 可以按下 `空格键`, 窗口上会出现字母  \n输入小写字母就切换到对应窗口, 按下 `Shift` 会使字母颜色变红, 此时输入字母会关闭对应窗口  \n>>> **点击展开/隐藏图片**\n![overview-navigation](/images/gnome/overview-navigation.png)\n>>>\n\n<br>\n\n- [cleaner-overview](https://extensions.gnome.org/extension/3759/cleaner-overview/)\n进入 `Overview` 时, 将窗口排列整齐, 简单实用  \n>>> **点击展开/隐藏图片**\n![cleaner-overview](/images/gnome/overview-navigation.png)\n>>>\n\n<br>\n\n- [user-theme](https://extensions.gnome.org/extension/19/user-themes/)\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)  \n注意: 还需要使用 `gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com` 指定主题  \n**无图片**\n\n<br>\n\n- [user-syle-sheet](https://extensions.gnome.org/extension/3414/user-stylesheet-font/)\n读取 `~/.local/share/gnome-shell/gnome-shell.css` 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者  \n**无图片**\n- - -\n\n# 美化\n以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等  \n还有很多扩展有帮助, 上面 [推荐的扩展](#tui-jian-de-kuo-zhan) 里有提到, 比如那个更改css的, 这里不说了  \n\n- 启动暗模式:  \n\n```bash\ngsettings set org.gnome.desktop.interface color-scheme \"prefer-dark\"\n```\n\n- 背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下  \n\n```bash\ngsettings set org.gnome.desktop.background picture-uri 'file:///usr/share/backgrounds/aaa.png'\ngsettings set org.gnome.desktop.background picture-uri-dark 'file:///usr/share/backgrounds/aaa.png'\n```\n\n- 头像: 假设用户名是 `Xyz`, 则需要将图片命名为 `Xyz`, 随后放到 `/var/lib/AccountsService/icons/` 下\n\n```bash\nsudo mv ./Xyz /var/lib/AccountsService/icons/\n\n# 或将图片命名为.face, 放到家目录\n# mv ./Xyz ~/.face  \n```\n\n- 主题: 单用户的放 `~/.themes/` , 多用户的放 `/usr/share/themes/`, 可前往 [gnome-look](https://www.gnome-look.org/) 挑选主题  \n\n```bash\n# 以 Nordic 为例子\nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.git\ngsettings set org.gnome.desktop.interface gtk-theme 'Nordic'\ngsettings set org.gnome.desktop.wm.preferences theme 'Nordic'\n\n# 你也可以使用 `user-theme` 这个扩展进行设置:  \nmkdir ~/.themes/ && cd ~/.themes/\ngit clone https://gitee.com/mirror_jedsek/Nordic.gi\ngnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com\n```\n\n- 字体: 将顶栏字体换成 `Fira Code`, 顺便调整下大小  \n\n```bash\ngsettings set org.gnome.desktop.interface font-name 'Fira Code 11.8'\n```\n\n- 隐藏 `Dash` 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了  \n\n```bash\ngsettings set org.gnome.shell favorite-apps \"[]\"\n```\n\n::: tips\n**注意:**  \n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 `Just-perfection` 扩展  \n此扩展得到官方支持, 可以将桌面 `化简`, 包括Dash  \n如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的[禁用快捷键](#jin-yong-kuai-jie-jian)  \n:::\n\n- 去掉左上角的 `Activities`: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: `space-bar` 或 `workspace-bar`)  \n\n```bash\n# 自定义工作区的名称, 不然就是默认的数字\ngsettings set org.gnome.desktop.wm.preferences workspace-names \"['Browser', 'Terminal', 'Game', 'Box', 'Other']\"\n```\n- 隐藏顶栏: 安装 `just-perfection` && `blur-my-shell`, 配置后就是本文 [成品展示](#cheng-pin-zhan-shi) 中的了, 处于 `Overview` 中才显示顶栏  \n\n- - -\n\n# 快捷键\n这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改  \n\n我个人就不喜欢 `Alt+Fn数字`, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 `I3/Sway` 那样  \n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash  \n\n::: tips\n**注意:**  \n快捷键之间有冲突的话, 可能无法生效, 请通过 `gnome-control-center keyboard` 查看快捷键冲突  \n:::\n\n\n## 查找快捷键\n首先, 我们得明白如何查找对应的快捷键  \n\n下面的命令会列出极大部分的快捷键:  \n\n```bash\ngsettings list-recursively | grep -E \"Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left\" | cat\n```\n\n你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语  \n如果实在找不到, 一点点看过去也行 :)  \n\n\n## 禁用快捷键\n某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组  \n想要禁用该快捷键, 将对应的数组设置为空就行了  \n\n举个例子, 禁用Dash的快捷键 (见上文的置空 `favorite-apps`):  \n\n```bash\n# Default: Super+\"1..9\"\nfor i in $(seq 9)\ndo\n    gsettings set org.gnome.shell.keybindings switch-to-application-$i \"[]\"  \ndone    \n```\n\n禁用快捷键还可以让你避免冲突, 比如:  \n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次  \n这时就要借助 GUI 的力量了: 输入 `gnome-control-center keyboard`, 然后进入自定义那栏, 会显示冲突的键  \n\n举个例子, 我想修改 `Super+Esc` 变成锁屏, 我就要这样做:  \n\n```bash\ngsettings set org.gnome.settings-daemon.plugins.media-keys screensaver \"['<Super>Escape']\" #Default: Sup+L\ngsettings set org.gnome.mutter.wayland.keybindings restore-shortcuts \"[]\" # Default: Sup+Esc\n```\n\n## 修改快捷键\n修改, 也就是覆写默认的快捷键, 与下文要讲的 [添加快捷键](#tian-jia-kuai-jie-jian) 不是一个概念  \n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考  \n\n- Vim 式的案件, 改变窗口布局, 替代原有的 `Super+方向键`:  \n\n```bash\n# 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......\n\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-left  \"['<Super>h']\" # 放左边\ngsettings set org.gnome.desktop.wm.keybindings  maximize           \"['<Super>j']\" # 最大化\ngsettings set org.gnome.desktop.wm.keybindings  unmaximize         \"['<Super>k']\" # 最小化\ngsettings set org.gnome.mutter.keybindings      toggle-tiled-right \"['<Super>l']\" # 放右边\n```\n\n对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管...  \n\n- move, resize, kill 一个窗口:  \n\n```bash\n# Move\ngsettings set org.gnome.desktop.wm.keybindings begin-move   \"['<Super>x']\"        #Default: Alt+F7\n\n# Resize\ngsettings set org.gnome.desktop.wm.keybindings begin-resize \"['<Super>r']\"        #Default: Alt+F8\n\n# Kill\ngsettings set org.gnome.desktop.wm.keybindings close        \"['<Super><Shift>q']\" #Default: Alt+F4\n```\n\n- toggle-max, max, min, toggle-fullscreen, show-desktop:  \n\n```bash\n# Toggle max\ngsettings set org.gnome.desktop.wm.keybindings toggle-maximized  \"['<Super>m']\"     #Default: Alt+F10\n\n# Max/Min\ngsettings set org.gnome.desktop.wm.keybindings maximize          \"['<Super>j']\"\ngsettings set org.gnome.desktop.wm.keybindings unmaximize        \"['<Super>k']\"\ngsettings set org.gnome.desktop.wm.keybindings minimize          \"['<Super>comma']\" #Default: Super+H\n\n# Toggle fullscreen\ngsettings set org.gnome.desktop.wm.keybindings toggle-fullscreen \"['<Super>f']\"     #Default: None\n\n# Show desktop\ngsettings set org.gnome.desktop.wm.keybindings show-desktop      \"['<Super>d']\"     #Default: None\n```\n\n- 还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:  \n\n```bash\nfor i in $(seq 9)\ndo\n  gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-$i \"['<Super>$i']\"\n  gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-$i   \"['<Super><Shift>$i']\"\ndone\ngsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-10   \"['<Super>0']\"\ngsettings set org.gnome.desktop.wm.keybindings move-to-workspace-10     \"['<Super><Shift>0']\"\n```\n\n- 再比如, 覆写 `run-dialog` 的快捷键 (默认是按Alt-F2, 但太远了...):  \n\n```bash\ngsettings set org.gnome.desktop.wm.keybindings panel-run-dialog \"['<Super>c']\" #Default: Alt+F2\n```\n\n## 添加快捷键\n此处指的是真正的, 添加自己的快捷键. 不是简单的覆写  \n比如 `Super+Return` 打开一个终端, `Super+B` 打开浏览器, `Super+E` 打开文件管理器...  \n\n废话不多说, 你按下面照猫画虎, 就阔以了:  \n\n```bash\ngp0=\"/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\ngp1=\"org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\\n/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings\"\n\n# Custom Keys\n# 注意!!!!!!!\n# 不要在最后添加逗号\ngsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings \"[     \\\n    '$gp0/custom0/', '$gp0/custom1/', '$gp0/custom2/', '$gp0/custom3/'               \\\n]\"\n\n## Terminal\ngsettings set $gp1/custom0/ name     'Terminal'\ngsettings set $gp1/custom0/ command  'alacritty'\ngsettings set $gp1/custom0/ binding  '<Super>Return'\n\n## Files\ngsettings set $gp1/custom1/ name     'Files'\ngsettings set $gp1/custom1/ command  'nautilus'\ngsettings set $gp1/custom1/ binding  '<Super>e'\n\n## Browser\ngsettings set $gp1/custom2/ name     'Browser'\ngsettings set $gp1/custom2/ command  'microsoft-edge-beta'\ngsettings set $gp1/custom2/ binding  '<Super>b'\n\n## Fcitx5 Reload\ngsettings set $gp1/custom3/ name     'Fcitx5_Reload'\ngsettings set $gp1/custom3/ command  'fcitx5 -r'\ngsettings set $gp1/custom3/ binding  '<Alt>space'\n```\n\n我相信你不会将时间浪费在掉在坑里面了  \n上面的一切已经非常非常全了  \n\n- - -\n\n# 加载配置\n我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件  \n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上  \n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE  \n\n你也可以参考或直接加载我博客下的 [**dconf.settings**](/downloads/gnome/dconf.settings)  \n## 对于非Nixos\n对于普通的Linux发行版, 直接按下面的方式  \n\n- 导出当前的dconf数据到某个文件:  \n\n```bash\ndconf dump / > dconf.settings\n```\n\n- 加载/导入某个dconf文件到当前系统:\n\n```bash\ncat dconf.settings | dconf load -f /\n```\n\n对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置  \n同时确认 `dconf.settings` 中的 `picture-uri` / `picture-uri-dark` 指向对应文件  \n\n## 对于Nixos\n\n如果你使用 Nixos, 请先确保已经安装了 [HomeManager](https://github.com/nix-community/home-manager)  \nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具  \n\n虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档  \n请先下载 `dconf2nix`, 这是一个将 dconf文件, 转换为 nix 表达式的工具  \n随后, 在终端输入以下内容, 得到 `dconf.nix` :  \n\n```bash\ndconf dump / > dconf.settings\ndconf2nix -i dconf.settings -o dconf.nix\n```\n\n在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):  \n\n```\nnixpkgs/\n├── gnome\n│   ├── .background\n│   ├── .face\n│   └── dconf.nix\n└── home.nix\n```\n\n这里的 `dconf.nix` 就是刚刚转换得到的nix表达式, 在 `home.nix` 中导入它:  \n\n```nix\nimports = [\n  ./gnome/dconf.nix\n];\n```\n\n\n介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 `$HOME` 下  \n这里将两个图片放在了 `~/.config/nixpkgs/gnome/` 下, 因此要修改下相应文件  \n\n\n- 对于背景图像, 修改 `dconf.nix` 中的 `picture-uri`:  \n\n```nix\n\"org/gnome/desktop/background\" =\nlet picture = ../.background.png; in\n{\n  picture-uri = \"file://${picture}\";\n  picture-uri-dark = \"file://${picture}\";\n};\n```\n\n- 对于人物头像, 在 `home.nix` 添加以下内容:  \n\n```nix\nhome.file.\".face\".source = ./.face;\n```\n\n大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了  \n\n","slug":"gnome/guide","published":1,"updated":"2022-07-20T03:22:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86fj00016aijdib1h5cv","content":"<blockquote>\n<p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p>\n</blockquote>\n<span id=\"more\"></span>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式, 炫酷效果, 更多功能的, 请自行配置<br>\n请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>\n目前, 该篇文章的GNOME 版本为: <strong>42</strong></p>\n</div>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前…<br>\n我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!</p>\n<p><img data-src=\"/images/gnome/overview.png\" alt=\"按下Super后的Overview\"></p>\n<hr>\n<h1 id=\"dconf-amp-amp-gsettings\">dconf &amp;&amp; gsettings</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>dconf</code>:<br>\n是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>gsettings</code>:<br>\n是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p>\n</li>\n</ul>\n<p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>\n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p>\n<p>接下来的大部分配置, 都会使用 <code>gsettings</code></p>\n<hr>\n<h1 id=\"hong-mo-ban\">触摸板</h1>\n<p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p>\n<h2 id=\"pei-zhi\" id=\"配置\">配置</h2>\n<p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>\n这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p>\n<p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>\n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>\n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p>\n<p>你可以在终端输入如下命令进行调整:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class=\"literal\">true</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>分别对应:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>轻击模拟鼠标点击, 默认为false</p>\n</li>\n<li class=\"lvl-2\">\n<p>调整触摸板速度, 默认为0</p>\n</li>\n<li class=\"lvl-2\">\n<p>打字时禁用触摸板, 默认为true</p>\n</li>\n</ul>\n<h2 id=\"shou-shi\" id=\"手势\">手势</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单指: 移动鼠标</p>\n</li>\n<li class=\"lvl-2\">\n<p>双指上下: 翻页</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指左右: 切换Workspace</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指上: 打开Overview (不常用, 按Super更快)</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指下: 显示任务栏 (当你隐藏任务栏时)</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"an-zhuang-kuo-zhan\">安装扩展</h1>\n<p>GNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之<br>\n我将先介绍如何安装/使用它们, 因为后面需要用到扩展</p>\n<p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>\n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p>\n<h2 id=\"cong-ming-ling-xing\" id=\"从命令行\">从命令行</h2>\n<div class=\"tips\">\n<p><strong>提示</strong><br>\n请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有…<br>\n下载成功后, 切记要 logout, 然后再登进来</p>\n</div>\n<p>每个GNOME扩展都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载扩展</p>\n<p>你可以在 <a href=\"https://extensions.gnome.org/\">Extensions-GNOME</a> 这个网站上, 浏览并下载扩展<br>\n请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 <code>exts_list</code></p>\n<p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p>\n<div class=\"tabs\" id=\"install-extensions\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#install-extensions-1\">Bash</a></li><li class=\"tab\"><a href=\"#install-extensions-2\">Fish</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"install-extensions-1\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a UUID_LIST</span><br><span class=\"line\">EXTS_DIR=<span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions</span><br><span class=\"line\">EXTS_LIST=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">str_join</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;$*&quot;</span> | sed <span class=\"string\">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$EXTS_DIR</span></span><br><span class=\"line\">chmod -R 755 <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/</span><br><span class=\"line\"><span class=\"keyword\">for</span> EXT <span class=\"keyword\">in</span> <span class=\"variable\">$EXTS_LIST</span>/*.zip</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  UUID=$(unzip -p <span class=\"variable\">$EXT</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span>)</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$EXT</span> -d <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  UUID_LIST+=<span class=\"string\">&quot;\\&quot;<span class=\"variable\">$UUID</span>\\&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">UUID_LIST=[$(str_join <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"install-extensions-2\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> exts_list <span class=\"variable\">$argv</span>[1]</span><br><span class=\"line\"><span class=\"built_in\">set</span> exts_dir <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$exts_dir</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ext <span class=\"keyword\">in</span> exts_list/*.zip</span><br><span class=\"line\">  <span class=\"built_in\">set</span> uuid ( unzip -p <span class=\"variable\">$ext</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span> )</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$ext</span> -d <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  <span class=\"built_in\">set</span> -a uuid_list \\<span class=\"string\">&#x27;$uuid\\&#x27;</span></span><br><span class=\"line\">end</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list [( string join <span class=\"string\">&quot;,&quot;</span> <span class=\"variable\">$uuid_list</span> )]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div>\n<p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p>\n<p><strong>注意: 先logout, 再登进来</strong></p>\n<p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dbus-send --<span class=\"built_in\">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \\</span><br><span class=\"line\">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class=\"string\">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"cong-liu-lan-qi\" id=\"从浏览器\">从浏览器</h2>\n<p>该方法其实也蛮方便的, 但不适合快速部署<br>\n你需要安装两个玩意, 才能直接从 <a href=\"https://extensions.gnome.org/\">Extension-GNOME</a> 上直接下载</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>chrome-gnome-shell</code>:<br>\n本地软件, 你可以通过包管理器, 直接搜这个名字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>GNOME Shell integration</code>:<br>\n浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>\nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p>\n</li>\n</ul>\n<p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href=\"https://extensions.gnome.org/\">网站</a> 上 直接安装到本地</p>\n<hr>\n<h1 id=\"cha-kan-pei-zhi-kuo-zhan\">查看/配置扩展</h1>\n<p>通过 <code>gnome-extensions</code> 这个命令, 我们可以查看/配置当前扩展</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取帮助, `Command` 为可选项</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">help</span> [Command]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看扩展列表</span></span><br><span class=\"line\">gnome-extensions list --user    <span class=\"comment\"># 查看用户级扩展</span></span><br><span class=\"line\">gnome-extensions list --system  <span class=\"comment\"># 查看系统级扩展</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看扩展的信息</span></span><br><span class=\"line\">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用/禁用某个扩展</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置某个扩展 (打开 GUI 界面)</span></span><br><span class=\"line\">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure>\n<p>或者通过 <code>gsettings</code> 来配置某个扩展, 但不推荐, 因为麻烦:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看某个扩展的所有选项</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class=\"line\"><span class=\"comment\"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class=\"line\"><span class=\"comment\"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure>\n<p>你也可以参考或<a href=\"#jia-zai-pei-zhi\"><strong>直接加载</strong></a>我博客下的 <a href=\"/downloads/gnome/dconf.settings\"><strong>dconf.settings</strong></a><br>\n<strong>注意:</strong> 如何你选择直接加载我的配置, 请注意 <code>picture-uri</code> 符合自己实际</p>\n<hr>\n<h1 id=\"tui-jian-de-kuo-zhan\">推荐的扩展</h1>\n<p>以下是我目前正在使用, 推荐的扩展</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/16/auto-move-windows/\">auto-move-windows</a>:<br>\n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/905/refresh-wifi-connections/\">refresh-wifi-connections</a><br>\n当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/refresh-wifi-connections.png\" alt=\"refresh-wifi-connections\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1446/transparent-window-moving/\">transparent-window-moving</a><br>\n在对窗口进行移动/调整大小时, 使窗口变得透明</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/transparent-window-moving.png\" alt=\"transparent-window-moving\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3843/just-perfection/\">just-perfection</a><br>\n我最喜欢的一个扩展, 用于对界面进行大量自定义与精简<br>\n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview.png\" alt=\"just-perfection\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3139/eye-extended/\">eye-extended</a><br>\n很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场<br>\n在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/eye-extended.png\" alt=\"eye-extended\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1113/nothing-to-say/\">nothing-to-say</a><br>\n用于切断/恢复声音的输入, 对我来说蛮有用的:<br>\n当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/nothing-to-say.png\" alt=\"nothing-to-say\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5090/space-bar/\">space-bar</a><br>\n模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 <code>Activities</code> 替换为 <code>Workspaces</code>, 有些类似的扩展, 但这个最好</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/space-bar.png\" alt=\"space-bar\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4696/static-background-in-overview/\">static-background-in-overview</a><br>\n在按下 <code>Super</code> 进入 <code>Overview</code> 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview.png\" alt=\"static-background-in-overview\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4788/workspace-switcher-manager/\">workspace-switcher-manager</a><br>\n美化通过键盘(我配成了 <code>Super + 1..9</code>), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/workspace-switcher-manager.png\" alt=\"workspace-switcher-manager\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/\">disable-workspace-switch-animation-for-GNOME40+</a><br>\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1319/gsconnect/\">gsconnect</a><br>\nGNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>\n手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href=\"/downloads/gnome/kdeconnect.apk\">kdeconnect</a></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gsconnect.png\" alt=\"gsconnect\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3193/blur-my-shell/\">blur-my-shell</a><br>\n用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview.png\" alt=\"blur-my-shell\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3488/big-avatar/\">big-avatar</a><br>\n让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/big-avatar.png\" alt=\"big-avatar\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4530/cpudots/\">cpudots</a><br>\n监视你当前的CPU频率, 以百分数的形式呈现在顶栏</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/right-corner.png\" alt=\"cpudots\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4817/colorful-battery-indicator/\">colorful-battery-indicator</a><br>\n让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/right-corner.png\" alt=\"colorful-battery-indicator\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/\">gnome40-ui-improvements</a><br>\n按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区的内容</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gnome40-ui-improvements.png\" alt=\"gnome40-ui-improvements\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/\">gnome-fuzzy-app-search</a><br>\n出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该扩展修改</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gnome-fuzzy-app-search.png\" alt=\"gnome-fuzzy-app-search\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4691/pip-on-top/\">pip-on-top</a><br>\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4792/frequency-boost-switch/\">frequency-boost-switch</a><br>\n在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/frequency-boost-switch.png\" alt=\"frequency-boost-switch\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1702/overview-navigation/\">overview-navigation</a><br>\n当按下 <code>Super</code> 进入 <code>Overview</code> 后, 可以按下 <code>空格键</code>, 窗口上会出现字母<br>\n输入小写字母就切换到对应窗口, 按下 <code>Shift</code> 会使字母颜色变红, 此时输入字母会关闭对应窗口</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview-navigation.png\" alt=\"overview-navigation\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3759/cleaner-overview/\">cleaner-overview</a><br>\n进入 <code>Overview</code> 时, 将窗口排列整齐, 简单实用</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview-navigation.png\" alt=\"cleaner-overview\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/19/user-themes/\">user-theme</a><br>\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>\n注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3414/user-stylesheet-font/\">user-syle-sheet</a><br>\n读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"mei-hua\">美化</h1>\n<p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>\n还有很多扩展有帮助, 上面 <a href=\"#tui-jian-de-kuo-zhan\">推荐的扩展</a> 里有提到, 比如那个更改css的, 这里不说了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动暗模式:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface color-scheme <span class=\"string\">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri-dark <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或将图片命名为.face, 放到家目录</span></span><br><span class=\"line\"><span class=\"comment\"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href=\"https://www.gnome-look.org/\">gnome-look</a> 挑选主题</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以 Nordic 为例子</span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface gtk-theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你也可以使用 `user-theme` 这个扩展进行设置:  </span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class=\"line\">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface font-name <span class=\"string\">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell favorite-apps <span class=\"string\">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 扩展<br>\n此扩展得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>\n如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href=\"#jin-yong-kuai-jie-jian\">禁用快捷键</a></p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: <code>space-bar</code> 或 <code>workspace-bar</code>)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences workspace-names <span class=\"string\">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href=\"#cheng-pin-zhan-shi\">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"kuai-jie-jian\">快捷键</h1>\n<p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p>\n<p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>\n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突</p>\n</div>\n<h2 id=\"cha-zhao-kuai-jie-jian\" id=\"查找快捷键\">查找快捷键</h2>\n<p>首先, 我们得明白如何查找对应的快捷键</p>\n<p>下面的命令会列出极大部分的快捷键:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings list-recursively | grep -E <span class=\"string\">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure>\n<p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>\n如果实在找不到, 一点点看过去也行 😃</p>\n<h2 id=\"jin-yong-kuai-jie-jian\" id=\"禁用快捷键\">禁用快捷键</h2>\n<p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>\n想要禁用该快捷键, 将对应的数组设置为空就行了</p>\n<p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default: Super+&quot;1..9&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    gsettings <span class=\"built_in\">set</span> org.gnome.shell.keybindings switch-to-application-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[]&quot;</span>  </span><br><span class=\"line\"><span class=\"keyword\">done</span>    </span><br></pre></td></tr></table></figure>\n<p>禁用快捷键还可以让你避免冲突, 比如:<br>\n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>\n这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p>\n<p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class=\"string\">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class=\"comment\">#Default: Sup+L</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class=\"string\">&quot;[]&quot;</span> <span class=\"comment\"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"xiu-gai-kuai-jie-jian\" id=\"修改快捷键\">修改快捷键</h2>\n<p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href=\"#tian-jia-kuai-jie-jian\">添加快捷键</a> 不是一个概念<br>\n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Vim 式的案件, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class=\"line\"></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class=\"comment\"># 放左边</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class=\"comment\"># 最大化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class=\"comment\"># 最小化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class=\"string\">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class=\"comment\"># 放右边</span></span><br></pre></td></tr></table></figure>\n<p>对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管…</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>move, resize, kill 一个窗口:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Move</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Resize</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class=\"string\">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Kill</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings close        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Toggle max</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class=\"comment\">#Default: Alt+F10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Max/Min</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings maximize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings minimize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class=\"comment\">#Default: Super+H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Toggle fullscreen</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class=\"string\">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Show desktop</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class=\"string\">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[&#x27;&lt;Super&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class=\"variable\">$i</span>   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class=\"string\">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"tian-jia-kuai-jie-jian\" id=\"添加快捷键\">添加快捷键</h2>\n<p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>\n比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p>\n<p>废话不多说, 你按下面照猫画虎, 就阔以了:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gp0=<span class=\"string\">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\">gp1=<span class=\"string\">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\</span></span><br><span class=\"line\"><span class=\"string\">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Custom Keys</span></span><br><span class=\"line\"><span class=\"comment\"># 注意!!!!!!!</span></span><br><span class=\"line\"><span class=\"comment\"># 不要在最后添加逗号</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class=\"string\">&quot;[     \\</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;<span class=\"variable\">$gp0</span>/custom0/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom1/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom2/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom3/&#x27;               \\</span></span><br><span class=\"line\"><span class=\"string\">]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Terminal</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ name     <span class=\"string\">&#x27;Terminal&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;alacritty&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ binding  <span class=\"string\">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Files</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ name     <span class=\"string\">&#x27;Files&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;nautilus&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ binding  <span class=\"string\">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Browser</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ name     <span class=\"string\">&#x27;Browser&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;microsoft-edge-beta&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ binding  <span class=\"string\">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Fcitx5 Reload</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ name     <span class=\"string\">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;fcitx5 -r&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ binding  <span class=\"string\">&#x27;&lt;Alt&gt;space&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>我相信你不会将时间浪费在掉在坑里面了<br>\n上面的一切已经非常非常全了</p>\n<hr>\n<h1 id=\"jia-zai-pei-zhi\">加载配置</h1>\n<p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>\n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>\n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p>\n<p>你也可以参考或直接加载我博客下的 <a href=\"/downloads/gnome/dconf.settings\"><strong>dconf.settings</strong></a></p>\n<h2 id=\"dui-yu-fei-nixos\" id=\"对于非Nixos\">对于非Nixos</h2>\n<p>对于普通的Linux发行版, 直接按下面的方式</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>导出当前的dconf数据到某个文件:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加载/导入某个dconf文件到当前系统:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure>\n<p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>\n同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p>\n<h2 id=\"dui-yu-nixos\" id=\"对于Nixos\">对于Nixos</h2>\n<p>如果你使用 Nixos, 请先确保已经安装了 <a href=\"https://github.com/nix-community/home-manager\">HomeManager</a><br>\nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p>\n<p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>\n请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>\n随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br><span class=\"line\">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure>\n<p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">nixpkgs/</span><br><span class=\"line\">├── gnome</span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.background</span></span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.face</span></span><br><span class=\"line\">│   └── dconf<span class=\"selector-class\">.nix</span></span><br><span class=\"line\">└── home.nix</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">imports</span> = [</span><br><span class=\"line\">  ./gnome/dconf.nix</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>\n这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">picture</span> = ../.background.png; <span class=\"keyword\">in</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri-dark</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">home.file.<span class=\"string\">&quot;.face&quot;</span>.<span class=\"attr\">source</span> = ./.face;</span><br></pre></td></tr></table></figure>\n<p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>\n","site":{"data":{}},"length":13276,"excerpt":"<blockquote>\n<p>关于 GNOME 的入坑指南, 让你了解, 配置, 美化桌面环境</p>\n</blockquote>","more":"<div class=\"tips\">\n<p><strong>注意:</strong><br>\n本篇文章的配置皆在注重简洁, 高效, 美观, 想要平铺式, 炫酷效果, 更多功能的, 请自行配置<br>\n请注意GNOME版本是否相符, 有少许地方或因版本差异而不同, 我将尽量保持同步, 使该文章最新<br>\n目前, 该篇文章的GNOME 版本为: <strong>42</strong></p>\n</div>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>2022年了, GNOME 又靠谱又好用, 但有些人的界面仍然像是十年前…<br>\n我个人认为简洁+美观比较重要, 当然你也可以自行修改进行DIY, 请自己动手, 丰衣足食吧!</p>\n<p><img data-src=\"/images/gnome/overview.png\" alt=\"按下Super后的Overview\"></p>\n<hr>\n<h1 id=\"dconf-amp-amp-gsettings\">dconf &amp;&amp; gsettings</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>dconf</code>:<br>\n是一套基于键的配置系统, 十分高效, 相当于 Windows 下的注册表</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>gsettings</code>:<br>\n是 GNOME-DE 下的高级API, 是命令行工具/前端, 用来简化对 dconf 的操作</p>\n</li>\n</ul>\n<p>你可能在年份久远的文章中听说过 <code>gconf</code>, 这是什么? 与 <code>dconf</code> 有啥区别?<br>\n答: 其作用也类似注册表, 但现在已经停止使用, 被效率更高的 <code>dconf</code> 所取代</p>\n<p>接下来的大部分配置, 都会使用 <code>gsettings</code></p>\n<hr>\n<h1 id=\"hong-mo-ban\">触摸板</h1>\n<p>触摸板可是笔记本党的灵魂啊, 尤其对于我这种万年不用鼠标, 除非打CSGO <s>(但CS我也能用触摸板玩)</s></p>\n<h2 id=\"pei-zhi\" id=\"配置\">配置</h2>\n<p>有一些 Linux 发行版的 GNOME比较贴近上游, <code>轻击模拟鼠标点击</code> 默认未开启<br>\n这导致触摸板很难用, 得按下去才能模拟鼠标的点击</p>\n<p>你想一想, 你想选中一段文字, 得重重按下触摸板, 在巨大的摩擦力下移动手指…<br>\n而且, 默认的触摸板, 速度可能比较慢, 反正我不适应, 因此需要修改…<br>\n还有就是, 触摸板在打字的时候默认是禁用的, 这对有时会用触摸板打CSGO的我来说很愤怒…</p>\n<p>你可以在终端输入如下命令进行调整:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad tap-to-click <span class=\"literal\">true</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad speed 0.57</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.peripherals.touchpad disable-while-typing <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>分别对应:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>轻击模拟鼠标点击, 默认为false</p>\n</li>\n<li class=\"lvl-2\">\n<p>调整触摸板速度, 默认为0</p>\n</li>\n<li class=\"lvl-2\">\n<p>打字时禁用触摸板, 默认为true</p>\n</li>\n</ul>\n<h2 id=\"shou-shi\" id=\"手势\">手势</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>单指: 移动鼠标</p>\n</li>\n<li class=\"lvl-2\">\n<p>双指上下: 翻页</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指左右: 切换Workspace</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指上: 打开Overview (不常用, 按Super更快)</p>\n</li>\n<li class=\"lvl-2\">\n<p>三指下: 显示任务栏 (当你隐藏任务栏时)</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"an-zhuang-kuo-zhan\">安装扩展</h1>\n<p>GNOME 的扩展(Extensions)是其重要的组成, 赋予了随意组合的自由与强大, 说是一半的灵魂, 也不为过之<br>\n我将先介绍如何安装/使用它们, 因为后面需要用到扩展</p>\n<p>有两种安装方法, 一种从命令行安装, 一种从浏览器安装<br>\n我更倾向于前者, 因为不需要下载对应的东西, 适合快速部署, 但两者我都会介绍</p>\n<h2 id=\"cong-ming-ling-xing\" id=\"从命令行\">从命令行</h2>\n<div class=\"tips\">\n<p><strong>提示</strong><br>\n请确保拥有以下命令: unzip, jq, 有些发行版默认连 unzip 都没有…<br>\n下载成功后, 切记要 logout, 然后再登进来</p>\n</div>\n<p>每个GNOME扩展都拥有独一无二的, 名为 <code>uuid</code> 的标识符, 我们可以通过 <code>uuid</code>, 下载扩展</p>\n<p>你可以在 <a href=\"https://extensions.gnome.org/\">Extensions-GNOME</a> 这个网站上, 浏览并下载扩展<br>\n请将以 .zip 结尾的扩展放在同一目录下, 假设该目录叫 <code>exts_list</code></p>\n<p>下面是 Bash/Fish 脚本, 传入该目录的路径, 自动进行安装:</p>\n<div class=\"tabs\" id=\"install-extensions\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#install-extensions-1\">Bash</a></li><li class=\"tab\"><a href=\"#install-extensions-2\">Fish</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"install-extensions-1\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.sh</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"><span class=\"built_in\">declare</span> -a UUID_LIST</span><br><span class=\"line\">EXTS_DIR=<span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions</span><br><span class=\"line\">EXTS_LIST=<span class=\"variable\">$&#123;1&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">str_join</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;$*&quot;</span> | sed <span class=\"string\">&#x27;s/&quot;&quot;/&quot;,&quot;/g&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$EXTS_DIR</span></span><br><span class=\"line\">chmod -R 755 <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/</span><br><span class=\"line\"><span class=\"keyword\">for</span> EXT <span class=\"keyword\">in</span> <span class=\"variable\">$EXTS_LIST</span>/*.zip</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  UUID=$(unzip -p <span class=\"variable\">$EXT</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span>)</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$EXT</span> -d <span class=\"variable\">$EXTS_DIR</span>/<span class=\"variable\">$UUID</span></span><br><span class=\"line\">  UUID_LIST+=<span class=\"string\">&quot;\\&quot;<span class=\"variable\">$UUID</span>\\&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">UUID_LIST=[$(str_join <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span>)]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$&#123;UUID_LIST[@]&#125;</span></span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"install-extensions-2\"><figure class=\"highlight bash\"><figcaption><span>install-extensions.fish</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> exts_list <span class=\"variable\">$argv</span>[1]</span><br><span class=\"line\"><span class=\"built_in\">set</span> exts_dir <span class=\"variable\">$HOME</span>/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list</span><br><span class=\"line\">mkdir -p <span class=\"variable\">$exts_dir</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ext <span class=\"keyword\">in</span> exts_list/*.zip</span><br><span class=\"line\">  <span class=\"built_in\">set</span> uuid ( unzip -p <span class=\"variable\">$ext</span> metadata.json | jq -r <span class=\"string\">&quot;.uuid&quot;</span> )</span><br><span class=\"line\">  mkdir -p <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  unzip -q -o <span class=\"variable\">$ext</span> -d <span class=\"variable\">$ext_dir</span>/<span class=\"variable\">$uuid</span></span><br><span class=\"line\">  <span class=\"built_in\">set</span> -a uuid_list \\<span class=\"string\">&#x27;$uuid\\&#x27;</span></span><br><span class=\"line\">end</span><br><span class=\"line\"><span class=\"built_in\">set</span> uuid_list [( string join <span class=\"string\">&quot;,&quot;</span> <span class=\"variable\">$uuid_list</span> )]</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell enabled-extensions <span class=\"variable\">$uuid_list</span></span><br></pre></td></tr></table></figure></div></div></div>\n<p>假设使用Bash: 执行 <code>sh install-extensions.sh exts_list</code> 下载该目录下的所有插件</p>\n<p><strong>注意: 先logout, 再登进来</strong></p>\n<p>也可以通过dbus安装, 但获取uuid还得解压zip, 何不直接像上面那样手动安装? 所以不推荐:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dbus-send --<span class=\"built_in\">type</span>=method_call --dest=org.gnome.Shell /org/gnome/Shell \\</span><br><span class=\"line\">  org.gnome.Shell.Extensions.InstallRemoteExtension string:<span class=\"string\">&#x27;xxxxx_uuid&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"cong-liu-lan-qi\" id=\"从浏览器\">从浏览器</h2>\n<p>该方法其实也蛮方便的, 但不适合快速部署<br>\n你需要安装两个玩意, 才能直接从 <a href=\"https://extensions.gnome.org/\">Extension-GNOME</a> 上直接下载</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>chrome-gnome-shell</code>:<br>\n本地软件, 你可以通过包管理器, 直接搜这个名字</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>GNOME Shell integration</code>:<br>\n浏览器插件, Chrome/Firefox 的浏览器商店都有它<br>\nEdge 的插件商店里无, 但可以下载 iGuge (谷歌访问助手), 然后下Chrome的插件</p>\n</li>\n</ul>\n<p>一个在本地, 一个在浏览器,  因此可以支持你从 <a href=\"https://extensions.gnome.org/\">网站</a> 上 直接安装到本地</p>\n<hr>\n<h1 id=\"cha-kan-pei-zhi-kuo-zhan\">查看/配置扩展</h1>\n<p>通过 <code>gnome-extensions</code> 这个命令, 我们可以查看/配置当前扩展</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取帮助, `Command` 为可选项</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">help</span> [Command]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看扩展列表</span></span><br><span class=\"line\">gnome-extensions list --user    <span class=\"comment\"># 查看用户级扩展</span></span><br><span class=\"line\">gnome-extensions list --system  <span class=\"comment\"># 查看系统级扩展</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看扩展的信息</span></span><br><span class=\"line\">gnome-extensions info launch-new-instance@gnome-shell-extensions.gcampax.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启用/禁用某个扩展</span></span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">enable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\">gnome-extensions <span class=\"built_in\">disable</span> nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置某个扩展 (打开 GUI 界面)</span></span><br><span class=\"line\">gnome-extensions prefs nothing-to-say@extensions.gnome.wouter.bolsterl.ee</span><br></pre></td></tr></table></figure>\n<p>或者通过 <code>gsettings</code> 来配置某个扩展, 但不推荐, 因为麻烦:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看某个扩展的所有选项</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  list-recursively org.gnome.shell.extensions.nothing-to-say</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 得到/重置/设置 某个扩展的某选项当前的值 (根据上面这条命令查看所有选项)</span></span><br><span class=\"line\">gsettings --schemadir ~/.<span class=\"built_in\">local</span>/share/gnome-shell/extensions/nothing-to-say@extensions.gnome.wouter.bolsterl.ee/schemas/  \\</span><br><span class=\"line\">  get    org.gnome.shell.extensions.nothing-to-say show-osd</span><br><span class=\"line\"><span class=\"comment\"># reset  org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br><span class=\"line\"><span class=\"comment\"># set    org.gnome.shell.extensions.nothing-to-say show-osd</span></span><br></pre></td></tr></table></figure>\n<p>你也可以参考或<a href=\"#jia-zai-pei-zhi\"><strong>直接加载</strong></a>我博客下的 <a href=\"/downloads/gnome/dconf.settings\"><strong>dconf.settings</strong></a><br>\n<strong>注意:</strong> 如何你选择直接加载我的配置, 请注意 <code>picture-uri</code> 符合自己实际</p>\n<hr>\n<h1 id=\"tui-jian-de-kuo-zhan\">推荐的扩展</h1>\n<p>以下是我目前正在使用, 推荐的扩展</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/16/auto-move-windows/\">auto-move-windows</a>:<br>\n通过指定窗口规则, 使得打开某个app时, 将其自动分配到特定工作区 (需要指定的.desktop文件)<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/905/refresh-wifi-connections/\">refresh-wifi-connections</a><br>\n当你通过右上角的菜单选择 WIFI 时, 会多出来一个刷新键</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/refresh-wifi-connections.png\" alt=\"refresh-wifi-connections\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1446/transparent-window-moving/\">transparent-window-moving</a><br>\n在对窗口进行移动/调整大小时, 使窗口变得透明</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/transparent-window-moving.png\" alt=\"transparent-window-moving\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3843/just-perfection/\">just-perfection</a><br>\n我最喜欢的一个扩展, 用于对界面进行大量自定义与精简<br>\n比如, 可以隐藏 Dash (按Super后底部的一行), 改变顶栏元素等</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview.png\" alt=\"just-perfection\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3139/eye-extended/\">eye-extended</a><br>\n很有趣的扩展, 平时当作小挂件, 但危机时或许可以派上用场<br>\n在顶栏显示一个眼睛, 眼珠子会一直注视着你的鼠标, 点一下会出现以你鼠标为中心的黄色圆圈</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/eye-extended.png\" alt=\"eye-extended\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1113/nothing-to-say/\">nothing-to-say</a><br>\n用于切断/恢复声音的输入, 对我来说蛮有用的:<br>\n当与同学打游戏, 撞上爸妈查房, 立刻按下 <code>Super+\\</code>, 防止爸妈训我的声音流入同学耳中, 维护尊严 😃</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/nothing-to-say.png\" alt=\"nothing-to-say\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/5090/space-bar/\">space-bar</a><br>\n模仿 I3/Sway/Bspwm 等窗口管理器, 将左上角烦人的 <code>Activities</code> 替换为 <code>Workspaces</code>, 有些类似的扩展, 但这个最好</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/space-bar.png\" alt=\"space-bar\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4696/static-background-in-overview/\">static-background-in-overview</a><br>\n在按下 <code>Super</code> 进入 <code>Overview</code> 时, 背景图片能够填补四边的空缺, 比起默认的四周黑框框更加好看</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview.png\" alt=\"static-background-in-overview\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4788/workspace-switcher-manager/\">workspace-switcher-manager</a><br>\n美化通过键盘(我配成了 <code>Super + 1..9</code>), 切换工作区时的动画效果, 很赞很好看, 可以高度 DIY</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/workspace-switcher-manager.png\" alt=\"workspace-switcher-manager\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4290/disable-workspace-switch-animation-for-gnome-40/\">disable-workspace-switch-animation-for-GNOME40+</a><br>\n消除通过键盘切换工作区时的过渡动画, 获得急速切换的体验感<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1319/gsconnect/\">gsconnect</a><br>\nGNOME版的 <code>kdeconnect</code>, 用于电脑与手机互连 (一个网下), 在右上角菜单添加对应菜单, 以便快速打开<br>\n手机需安装 <code>kdeconnect</code>, 你可以从本博客下载 apk 进行安装: <a href=\"/downloads/gnome/kdeconnect.apk\">kdeconnect</a></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gsconnect.png\" alt=\"gsconnect\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3193/blur-my-shell/\">blur-my-shell</a><br>\n用于让面板, 顶栏, Overview, 锁屏, gnome自带的截屏, 甚至特定的app, 都能被毛玻璃化, 很强大的扩展</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview.png\" alt=\"blur-my-shell\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3488/big-avatar/\">big-avatar</a><br>\n让右上角菜单出现你的头像, 点击之后触发自定义的命令, 但这功能不常用, 提升逼格而已</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/big-avatar.png\" alt=\"big-avatar\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4530/cpudots/\">cpudots</a><br>\n监视你当前的CPU频率, 以百分数的形式呈现在顶栏</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/right-corner.png\" alt=\"cpudots\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4817/colorful-battery-indicator/\">colorful-battery-indicator</a><br>\n让右上角的电池变成彩色, 根据电量, 分别呈现绿色, 黄色, 黄色, 美观且提示作用强</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/right-corner.png\" alt=\"colorful-battery-indicator\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4158/gnome-40-ui-improvements/\">gnome40-ui-improvements</a><br>\n按下 <code>Super</code>, 进入 <code>Overview</code> 后, 在中上方显示工作区的内容</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gnome40-ui-improvements.png\" alt=\"gnome40-ui-improvements\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3956/gnome-fuzzy-app-search/\">gnome-fuzzy-app-search</a><br>\n出于某些目的, 默认的 <code>GNOME</code> 在 <code>Overview</code> 中不支持模糊查找, 可以通过该扩展修改</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/gnome-fuzzy-app-search.png\" alt=\"gnome-fuzzy-app-search\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4691/pip-on-top/\">pip-on-top</a><br>\n当你通过浏览器中的画中画模式, 观看视频时, 让窗口一直保持在最顶部, 即使焦点在别的窗口<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/4792/frequency-boost-switch/\">frequency-boost-switch</a><br>\n在右上角菜单中的 <code>电池策略</code> 中添加一个 <code>Checkox</code>, 用于切换 <code>是否允许超频</code></p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/frequency-boost-switch.png\" alt=\"frequency-boost-switch\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/1702/overview-navigation/\">overview-navigation</a><br>\n当按下 <code>Super</code> 进入 <code>Overview</code> 后, 可以按下 <code>空格键</code>, 窗口上会出现字母<br>\n输入小写字母就切换到对应窗口, 按下 <code>Shift</code> 会使字母颜色变红, 此时输入字母会关闭对应窗口</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview-navigation.png\" alt=\"overview-navigation\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3759/cleaner-overview/\">cleaner-overview</a><br>\n进入 <code>Overview</code> 时, 将窗口排列整齐, 简单实用</p>\n</li>\n</ul>\n<details>\n<summary><span class=\"pre-summary\">&nbsp;</span><strong>点击展开/隐藏图片</strong></summary><p><img data-src=\"/images/gnome/overview-navigation.png\" alt=\"cleaner-overview\"></p>\n</details>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/19/user-themes/\">user-theme</a><br>\n从用户目录加载对应的主题 (之后的换主题教程中会讲到)<br>\n注意: 还需要使用 <code>gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</code> 指定主题<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<br>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://extensions.gnome.org/extension/3414/user-stylesheet-font/\">user-syle-sheet</a><br>\n读取 <code>~/.local/share/gnome-shell/gnome-shell.css</code> 直接修改 GNOME 的默认CSS, 十分逆天, 适合重度 DIY 患者<br>\n<strong>无图片</strong></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"mei-hua\">美化</h1>\n<p>以下美化工作涉及暗模式, 背景, 头像, 主题, 字体, Dash等<br>\n还有很多扩展有帮助, 上面 <a href=\"#tui-jian-de-kuo-zhan\">推荐的扩展</a> 里有提到, 比如那个更改css的, 这里不说了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>启动暗模式:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface color-scheme <span class=\"string\">&quot;prefer-dark&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>背景壁纸: 暗模式下的背景与普通模式可以不一样, 因此也要注意设置下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.background picture-uri-dark <span class=\"string\">&#x27;file:///usr/share/backgrounds/aaa.png&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>头像: 假设用户名是 <code>Xyz</code>, 则需要将图片命名为 <code>Xyz</code>, 随后放到 <code>/var/lib/AccountsService/icons/</code> 下</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mv ./Xyz /var/lib/AccountsService/icons/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或将图片命名为.face, 放到家目录</span></span><br><span class=\"line\"><span class=\"comment\"># mv ./Xyz ~/.face  </span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>主题: 单用户的放 <code>~/.themes/</code> , 多用户的放 <code>/usr/share/themes/</code>, 可前往 <a href=\"https://www.gnome-look.org/\">gnome-look</a> 挑选主题</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以 Nordic 为例子</span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.git</span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface gtk-theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences theme <span class=\"string\">&#x27;Nordic&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你也可以使用 `user-theme` 这个扩展进行设置:  </span></span><br><span class=\"line\">mkdir ~/.themes/ &amp;&amp; <span class=\"built_in\">cd</span> ~/.themes/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirror_jedsek/Nordic.gi</span><br><span class=\"line\">gnome-extensions prefs user-theme@gnome-shell-extensions.gcampax.github.com</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>字体: 将顶栏字体换成 <code>Fira Code</code>, 顺便调整下大小</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.interface font-name <span class=\"string\">&#x27;Fira Code 11.8&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏 <code>Dash</code> 栏: 对我个人来讲, Dash 毫无用处还占地方, 快捷键+Overview的搜索, 可以应付一切工作了</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.shell favorite-apps <span class=\"string\">&quot;[]&quot;</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n以上命令仅仅移除 Dash 中的app, 但仍然会留下一个空的Dash栏, 彻底隐藏, 请使用 <code>Just-perfection</code> 扩展<br>\n此扩展得到官方支持, 可以将桌面 <code>化简</code>, 包括Dash<br>\n如果你只是使用扩展, 将 Dash 隐藏, 未置空列表, 相关快捷键仍然生效, 需被禁用而彻底消除Dash, 请看下面的<a href=\"#jin-yong-kuai-jie-jian\">禁用快捷键</a></p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>去掉左上角的 <code>Activities</code>: 可将其换成 I3/Sway 式, 显示工作区名称 (请安装扩展: <code>space-bar</code> 或 <code>workspace-bar</code>)</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自定义工作区的名称, 不然就是默认的数字</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.preferences workspace-names <span class=\"string\">&quot;[&#x27;Browser&#x27;, &#x27;Terminal&#x27;, &#x27;Game&#x27;, &#x27;Box&#x27;, &#x27;Other&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>隐藏顶栏: 安装 <code>just-perfection</code> &amp;&amp; <code>blur-my-shell</code>, 配置后就是本文 <a href=\"#cheng-pin-zhan-shi\">成品展示</a> 中的了, 处于 <code>Overview</code> 中才显示顶栏</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"kuai-jie-jian\">快捷键</h1>\n<p>这也是个很影响体验的地方, 如果你对自带的快捷键不满意, 完全可以自己更改</p>\n<p>我个人就不喜欢 <code>Alt+Fn数字</code>, 因为太远了, 而且记不清, 干脆换些简单易记的, 像 <code>I3/Sway</code> 那样<br>\n当然, 你还可以禁用一些快捷键, 做到一些事情, 比如消除 Dash</p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n快捷键之间有冲突的话, 可能无法生效, 请通过 <code>gnome-control-center keyboard</code> 查看快捷键冲突</p>\n</div>\n<h2 id=\"cha-zhao-kuai-jie-jian\" id=\"查找快捷键\">查找快捷键</h2>\n<p>首先, 我们得明白如何查找对应的快捷键</p>\n<p>下面的命令会列出极大部分的快捷键:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings list-recursively | grep -E <span class=\"string\">&quot;Super|Alt|Ctrl|Shift|F[0-9]|Page|Up|Down|Right|Left&quot;</span> | cat</span><br></pre></td></tr></table></figure>\n<p>你可以在后面通过 pipeline, 追加一个 grep, 搜索 theme, font, workspace, switch, move 等词语<br>\n如果实在找不到, 一点点看过去也行 😃</p>\n<h2 id=\"jin-yong-kuai-jie-jian\" id=\"禁用快捷键\">禁用快捷键</h2>\n<p>某命令的快捷键, 一般可以有多个, 即某命令的快捷键是一个数组<br>\n想要禁用该快捷键, 将对应的数组设置为空就行了</p>\n<p>举个例子, 禁用Dash的快捷键 (见上文的置空 <code>favorite-apps</code>):</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Default: Super+&quot;1..9&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    gsettings <span class=\"built_in\">set</span> org.gnome.shell.keybindings switch-to-application-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[]&quot;</span>  </span><br><span class=\"line\"><span class=\"keyword\">done</span>    </span><br></pre></td></tr></table></figure>\n<p>禁用快捷键还可以让你避免冲突, 比如:<br>\n某个操作绑定了快捷键A, 另一个操作也绑定了快捷键A, 可能键A就失效了, 我遇到过好几次<br>\n这时就要借助 GUI 的力量了: 输入 <code>gnome-control-center keyboard</code>, 然后进入自定义那栏, 会显示冲突的键</p>\n<p>举个例子, 我想修改 <code>Super+Esc</code> 变成锁屏, 我就要这样做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys screensaver <span class=\"string\">&quot;[&#x27;&lt;Super&gt;Escape&#x27;]&quot;</span> <span class=\"comment\">#Default: Sup+L</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.wayland.keybindings restore-shortcuts <span class=\"string\">&quot;[]&quot;</span> <span class=\"comment\"># Default: Sup+Esc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"xiu-gai-kuai-jie-jian\" id=\"修改快捷键\">修改快捷键</h2>\n<p>修改, 也就是覆写默认的快捷键, 与下文要讲的 <a href=\"#tian-jia-kuai-jie-jian\">添加快捷键</a> 不是一个概念<br>\n单纯的改改改而已, 下面是我个人修改的一套快捷键, 供大家参考</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Vim 式的案件, 改变窗口布局, 替代原有的 <code>Super+方向键</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 其实还有更丧心病狂的, 可以绑定快捷键, 将窗口放左上角, 右上角, 中间左边, 中间右边的......</span></span><br><span class=\"line\"></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-left  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;h&#x27;]&quot;</span> <span class=\"comment\"># 放左边</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  maximize           <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span> <span class=\"comment\"># 最大化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings  unmaximize         <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span> <span class=\"comment\"># 最小化</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.mutter.keybindings      toggle-tiled-right <span class=\"string\">&quot;[&#x27;&lt;Super&gt;l&#x27;]&quot;</span> <span class=\"comment\"># 放右边</span></span><br></pre></td></tr></table></figure>\n<p>对了, 如果你追求平铺式的话, 扩展可以满足一部分要求, 但肯定比不上专业的窗管…</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>move, resize, kill 一个窗口:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Move</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-move   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;x&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Resize</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings begin-resize <span class=\"string\">&quot;[&#x27;&lt;Super&gt;r&#x27;]&quot;</span>        <span class=\"comment\">#Default: Alt+F8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Kill</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings close        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;q&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F4</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>toggle-max, max, min, toggle-fullscreen, show-desktop:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Toggle max</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-maximized  <span class=\"string\">&quot;[&#x27;&lt;Super&gt;m&#x27;]&quot;</span>     <span class=\"comment\">#Default: Alt+F10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Max/Min</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings maximize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;j&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings unmaximize        <span class=\"string\">&quot;[&#x27;&lt;Super&gt;k&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings minimize          <span class=\"string\">&quot;[&#x27;&lt;Super&gt;comma&#x27;]&quot;</span> <span class=\"comment\">#Default: Super+H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Toggle fullscreen</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings toggle-fullscreen <span class=\"string\">&quot;[&#x27;&lt;Super&gt;f&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Show desktop</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings show-desktop      <span class=\"string\">&quot;[&#x27;&lt;Super&gt;d&#x27;]&quot;</span>     <span class=\"comment\">#Default: None</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>还有套很重要的快捷键, 就是切换工作区了, 搭配消除过渡动画/增加特效的扩展, 流畅感Max:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> $(seq 9)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-<span class=\"variable\">$i</span> <span class=\"string\">&quot;[&#x27;&lt;Super&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\">  gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-<span class=\"variable\">$i</span>   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;<span class=\"variable\">$i</span>&#x27;]&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-10   <span class=\"string\">&quot;[&#x27;&lt;Super&gt;0&#x27;]&quot;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings move-to-workspace-10     <span class=\"string\">&quot;[&#x27;&lt;Super&gt;&lt;Shift&gt;0&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>再比如, 覆写 <code>run-dialog</code> 的快捷键 (默认是按Alt-F2, 但太远了…):</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.desktop.wm.keybindings panel-run-dialog <span class=\"string\">&quot;[&#x27;&lt;Super&gt;c&#x27;]&quot;</span> <span class=\"comment\">#Default: Alt+F2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"tian-jia-kuai-jie-jian\" id=\"添加快捷键\">添加快捷键</h2>\n<p>此处指的是真正的, 添加自己的快捷键. 不是简单的覆写<br>\n比如 <code>Super+Return</code> 打开一个终端, <code>Super+B</code> 打开浏览器, <code>Super+E</code> 打开文件管理器…</p>\n<p>废话不多说, 你按下面照猫画虎, 就阔以了:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gp0=<span class=\"string\">&quot;/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\">gp1=<span class=\"string\">&quot;org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:\\</span></span><br><span class=\"line\"><span class=\"string\">/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Custom Keys</span></span><br><span class=\"line\"><span class=\"comment\"># 注意!!!!!!!</span></span><br><span class=\"line\"><span class=\"comment\"># 不要在最后添加逗号</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> org.gnome.settings-daemon.plugins.media-keys custom-keybindings <span class=\"string\">&quot;[     \\</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;<span class=\"variable\">$gp0</span>/custom0/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom1/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom2/&#x27;, &#x27;<span class=\"variable\">$gp0</span>/custom3/&#x27;               \\</span></span><br><span class=\"line\"><span class=\"string\">]&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Terminal</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ name     <span class=\"string\">&#x27;Terminal&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;alacritty&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom0/ binding  <span class=\"string\">&#x27;&lt;Super&gt;Return&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Files</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ name     <span class=\"string\">&#x27;Files&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;nautilus&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom1/ binding  <span class=\"string\">&#x27;&lt;Super&gt;e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Browser</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ name     <span class=\"string\">&#x27;Browser&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;microsoft-edge-beta&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom2/ binding  <span class=\"string\">&#x27;&lt;Super&gt;b&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## Fcitx5 Reload</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ name     <span class=\"string\">&#x27;Fcitx5_Reload&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ <span class=\"built_in\">command</span>  <span class=\"string\">&#x27;fcitx5 -r&#x27;</span></span><br><span class=\"line\">gsettings <span class=\"built_in\">set</span> <span class=\"variable\">$gp1</span>/custom3/ binding  <span class=\"string\">&#x27;&lt;Alt&gt;space&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>我相信你不会将时间浪费在掉在坑里面了<br>\n上面的一切已经非常非常全了</p>\n<hr>\n<h1 id=\"jia-zai-pei-zhi\">加载配置</h1>\n<p>我们可以通过 dconf 这个工具, 导入或导出记载着 GNOME 数据的配置文件<br>\n你可以导出记载当前DE的配置文件, 然后导出到另一台机器上<br>\n这意味着, 当你重装系统时, 按下面的方法能快速恢复到先前的DE</p>\n<p>你也可以参考或直接加载我博客下的 <a href=\"/downloads/gnome/dconf.settings\"><strong>dconf.settings</strong></a></p>\n<h2 id=\"dui-yu-fei-nixos\" id=\"对于非Nixos\">对于非Nixos</h2>\n<p>对于普通的Linux发行版, 直接按下面的方式</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>导出当前的dconf数据到某个文件:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>加载/导入某个dconf文件到当前系统:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat dconf.settings | dconf load -f /</span><br></pre></td></tr></table></figure>\n<p>对于背景与头像, 你可以写一段脚本, 将其复制到相应位置, 然后再添加上面的代码加载配置<br>\n同时确认 <code>dconf.settings</code> 中的 <code>picture-uri</code> / <code>picture-uri-dark</code> 指向对应文件</p>\n<h2 id=\"dui-yu-nixos\" id=\"对于Nixos\">对于Nixos</h2>\n<p>如果你使用 Nixos, 请先确保已经安装了 <a href=\"https://github.com/nix-community/home-manager\">HomeManager</a><br>\nHomeManager 是 Nixos 中用来管理用户配置, 支持回滚的工具</p>\n<p>虽然也能按上面的方法配置 Nixos 的 GNOME, 但还是推荐使用 HomeManager, 原因略过, 自看文档<br>\n请先下载 <code>dconf2nix</code>, 这是一个将 dconf文件, 转换为 nix 表达式的工具<br>\n随后, 在终端输入以下内容, 得到 <code>dconf.nix</code> :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">dconf dump / &gt; dconf.settings</span><br><span class=\"line\">dconf2nix -i dconf.settings -o dconf.nix</span><br></pre></td></tr></table></figure>\n<p>在你的 ~/.config/nixpkgs 中, 保持这样的目录结构 (当然了, 可以随你想法):</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">nixpkgs/</span><br><span class=\"line\">├── gnome</span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.background</span></span><br><span class=\"line\">│   ├── <span class=\"selector-class\">.face</span></span><br><span class=\"line\">│   └── dconf<span class=\"selector-class\">.nix</span></span><br><span class=\"line\">└── home.nix</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>dconf.nix</code> 就是刚刚转换得到的nix表达式, 在 <code>home.nix</code> 中导入它:</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">imports</span> = [</span><br><span class=\"line\">  ./gnome/dconf.nix</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>介于 HomeManager 的权限问题, 必须将背景图片/人物头像, 保持在 <code>$HOME</code> 下<br>\n这里将两个图片放在了 <code>~/.config/nixpkgs/gnome/</code> 下, 因此要修改下相应文件</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于背景图像, 修改 <code>dconf.nix</code> 中的 <code>picture-uri</code>:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;org/gnome/desktop/background&quot;</span> =</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">picture</span> = ../.background.png; <span class=\"keyword\">in</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">  <span class=\"attr\">picture-uri-dark</span> = <span class=\"string\">&quot;file://<span class=\"subst\">$&#123;picture&#125;</span>&quot;</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>对于人物头像, 在 <code>home.nix</code> 添加以下内容:</p>\n</li>\n</ul>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">home.file.<span class=\"string\">&quot;.face&quot;</span>.<span class=\"attr\">source</span> = ./.face;</span><br></pre></td></tr></table></figure>\n<p>大功告成!  我相信这是最最最最最全的一份 GNOME 入坑指南了</p>"},{"title":"high-school-it-p1: 数据与信息","abbrlink":"posts/high-school-it/p1","hidden":false,"date":"2022-09-10T13:05:57.000Z","top":7999,"keywords":["高中信息技术","python"],"_content":"> 本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别\n<!-- more -->\n我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念  \n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普  \n\n# 数据的定义\n数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等  \n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等  \n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:  \n\n- 你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解  \n- 你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解  \n\n上面的两种情况中:  \n\n- `记载在纸上的相对论的文字` 就是数据, 属于客观层面\n- `山顶洞人/科学家` 看见相对论的两种态度, 属于主观层面\n\n没有主观层面上的理解, 数据便只是一张废纸, 毫无意义  \n\n- - -\n# 信息的定义\n虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)  \n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义  \n\n信息论之父, 香农, 对此就有一套理解: \"信息是用来消除随机不确定性的东西\", 这通常被看作经典定义  \n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:  \n\n- 这是一台电脑笔记本\n- 这是一台屏幕大小为15.6英寸的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本\n\n你会看到, 信息越多, 越能消除随机不确定性  \n\n- - -\n\n# 信息的特征\n我们通过香农对信息的定义, 与一个例子, 大概懂得了 \"信息是用来消除随机不确定性的东西\"  \n但我们还得了解更多关于\"信息\"的信息, 来完善\"信息\"的定义, 来加速理解  \n\n下面是信息的5个特征, 教科书上搬的:  \n\n- 载体依附性  \n信息不能独立存在, 它是虚的, 必须有载体  \n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失  \n\n- 不损耗性\n信息在传播的过程中, 是不会发生损耗的\n\n- 时效性  \n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变  \n比如 \"太阳亮着\" 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?  \n\n- 共享性  \n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗  \n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的  \n\n- 可加工处理性/真伪性  \n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人  \n在比如 `盲人摸象/管中窥豹`, 都体现了真伪性  \n\n- 价值性  \n比如天气预报让你出门避免被雨淋湿, 这就是价值  \n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值\n\n- - -\n\n# 知识的定义\n不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和\n它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的  \n指的是人们已经掌握的能力\n\n这部分很简单, 简单概述即可, 但请注意不要与下面的 `智慧的定义搞错了`  \n- - -\n\n# 智慧的定义\n一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力\n\n- - -\n\n# 总结\n以下是一个很好的, 对三者进行了区分的例子:\n\n- 数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号\n- 信息: 人们知道圆周率就是3.1415926\n- 知识: 人们知道如何求解圆的面积来解决现实问题\n- 智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术\n\n这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了  \n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新...\n","source":"_posts/high-school-it/p1-数据与信息.md","raw":"---\ntitle: \"high-school-it-p1: 数据与信息\"\nabbrlink: posts/high-school-it/p1\nhidden: false\ndate: 2022-09-10 21:05:57\ntop: 7999\ntags: [高中信息技术]\nkeywords: [高中信息技术, python, ]\n---\n> 本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别\n<!-- more -->\n我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念  \n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普  \n\n# 数据的定义\n数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等  \n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等  \n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:  \n\n- 你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解  \n- 你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解  \n\n上面的两种情况中:  \n\n- `记载在纸上的相对论的文字` 就是数据, 属于客观层面\n- `山顶洞人/科学家` 看见相对论的两种态度, 属于主观层面\n\n没有主观层面上的理解, 数据便只是一张废纸, 毫无意义  \n\n- - -\n# 信息的定义\n虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)  \n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义  \n\n信息论之父, 香农, 对此就有一套理解: \"信息是用来消除随机不确定性的东西\", 这通常被看作经典定义  \n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:  \n\n- 这是一台电脑笔记本\n- 这是一台屏幕大小为15.6英寸的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本\n- 这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本\n\n你会看到, 信息越多, 越能消除随机不确定性  \n\n- - -\n\n# 信息的特征\n我们通过香农对信息的定义, 与一个例子, 大概懂得了 \"信息是用来消除随机不确定性的东西\"  \n但我们还得了解更多关于\"信息\"的信息, 来完善\"信息\"的定义, 来加速理解  \n\n下面是信息的5个特征, 教科书上搬的:  \n\n- 载体依附性  \n信息不能独立存在, 它是虚的, 必须有载体  \n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失  \n\n- 不损耗性\n信息在传播的过程中, 是不会发生损耗的\n\n- 时效性  \n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变  \n比如 \"太阳亮着\" 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?  \n\n- 共享性  \n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗  \n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的  \n\n- 可加工处理性/真伪性  \n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人  \n在比如 `盲人摸象/管中窥豹`, 都体现了真伪性  \n\n- 价值性  \n比如天气预报让你出门避免被雨淋湿, 这就是价值  \n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值\n\n- - -\n\n# 知识的定义\n不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和\n它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的  \n指的是人们已经掌握的能力\n\n这部分很简单, 简单概述即可, 但请注意不要与下面的 `智慧的定义搞错了`  \n- - -\n\n# 智慧的定义\n一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力\n\n- - -\n\n# 总结\n以下是一个很好的, 对三者进行了区分的例子:\n\n- 数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号\n- 信息: 人们知道圆周率就是3.1415926\n- 知识: 人们知道如何求解圆的面积来解决现实问题\n- 智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术\n\n这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了  \n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新...\n","slug":"high-school-it/p1-数据与信息","published":1,"updated":"2022-09-10T13:05:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86fq00036aij5llma27l","content":"<blockquote>\n<p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>\n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p>\n<h1 id=\"shu-ju-de-ding-yi\">数据的定义</h1>\n<p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>\n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>\n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p>\n</li>\n<li class=\"lvl-2\">\n<p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p>\n</li>\n</ul>\n<p>上面的两种情况中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p>\n</li>\n</ul>\n<p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p>\n<hr>\n<h1 id=\"xin-xi-de-ding-yi\">信息的定义</h1>\n<p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>\n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p>\n<p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>\n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这是一台电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p>\n</li>\n</ul>\n<p>你会看到, 信息越多, 越能消除随机不确定性</p>\n<hr>\n<h1 id=\"xin-xi-de-te-zheng\">信息的特征</h1>\n<p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>\n但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p>\n<p>下面是信息的5个特征, 教科书上搬的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>载体依附性<br>\n信息不能独立存在, 它是虚的, 必须有载体<br>\n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>不损耗性信息在传播的过程中, 是不会发生损耗的</p>\n</li>\n<li class=\"lvl-2\">\n<p>时效性<br>\n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>\n比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p>\n</li>\n<li class=\"lvl-2\">\n<p>共享性<br>\n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>\n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p>\n</li>\n<li class=\"lvl-2\">\n<p>可加工处理性/真伪性<br>\n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>\n在比如 <code>盲人摸象/管中窥豹</code>, 都体现了真伪性</p>\n</li>\n<li class=\"lvl-2\">\n<p>价值性<br>\n比如天气预报让你出门避免被雨淋湿, 这就是价值<br>\n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"zhi-shi-de-ding-yi\">知识的定义</h1>\n<p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的<br>\n指的是人们已经掌握的能力</p>\n<p>这部分很简单, 简单概述即可, 但请注意不要与下面的 <code>智慧的定义搞错了</code></p>\n<hr>\n<h1 id=\"zhi-hui-de-ding-yi\">智慧的定义</h1>\n<p>一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力</p>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<p>以下是一个很好的, 对三者进行了区分的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p>\n</li>\n<li class=\"lvl-2\">\n<p>信息: 人们知道圆周率就是3.1415926</p>\n</li>\n<li class=\"lvl-2\">\n<p>知识: 人们知道如何求解圆的面积来解决现实问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术</p>\n</li>\n</ul>\n<p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>\n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>\n","site":{"data":{}},"length":1556,"excerpt":"<blockquote>\n<p>本章是一些小小的概念, 涉及了数据与信息的定义, 及之间的关系与区别</p>\n</blockquote>","more":"<p>我们会学习数据(Data), 信息(Information), 知识(Knowledge)的概念<br>\n当然, 你可以跳过本节, 因为考试不考, 此篇仅为单纯科普</p>\n<h1 id=\"shu-ju-de-ding-yi\">数据的定义</h1>\n<p>数据(Data), 是一种符号表示, 包括图形符号, 数字, 字母等<br>\n传统意义上的数据有书上的文字, 草稿纸上的数字, 信息时代的数据有电脑中的音频, 图像, 文件等<br>\n数据仅为一种客观层面上的载体, 如果没有主观上的理解, 其完全没有意义, 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>你是位山顶洞人, 看见了从未来穿梭而来的草稿纸, 上面记载着爱因斯坦的相对论, 你无法理解</p>\n</li>\n<li class=\"lvl-2\">\n<p>你是位现代的科学家, 接受过高等教育, 正在研究相对论, 你可以理解</p>\n</li>\n</ul>\n<p>上面的两种情况中:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>记载在纸上的相对论的文字</code> 就是数据, 属于客观层面</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>山顶洞人/科学家</code> 看见相对论的两种态度, 属于主观层面</p>\n</li>\n</ul>\n<p>没有主观层面上的理解, 数据便只是一张废纸, 毫无意义</p>\n<hr>\n<h1 id=\"xin-xi-de-ding-yi\">信息的定义</h1>\n<p>虽然数据是客观的, 但你可以通过数据获取信息, 获取的信息因人而异, 因此过程是主观的 (想象山顶洞人与科学家的例子)<br>\n其实目前仍然没有对信息的具体定义, 毕竟这东西玄乎, 因观察角度, 研究目的等不同而存在不同的定义</p>\n<p>信息论之父, 香农, 对此就有一套理解: “信息是用来消除随机不确定性的东西”, 这通常被看作经典定义<br>\n比如, 当你向朋友描述一台电脑笔记本, 有以下不同版本:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>这是一台电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口的电脑笔记本</p>\n</li>\n<li class=\"lvl-2\">\n<p>这是一台屏幕大小为15.6英寸, 支持type-c接口, 16GB内存的电脑笔记本</p>\n</li>\n</ul>\n<p>你会看到, 信息越多, 越能消除随机不确定性</p>\n<hr>\n<h1 id=\"xin-xi-de-te-zheng\">信息的特征</h1>\n<p>我们通过香农对信息的定义, 与一个例子, 大概懂得了 “信息是用来消除随机不确定性的东西”<br>\n但我们还得了解更多关于&quot;信息&quot;的信息, 来完善&quot;信息&quot;的定义, 来加速理解</p>\n<p>下面是信息的5个特征, 教科书上搬的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>载体依附性<br>\n信息不能独立存在, 它是虚的, 必须有载体<br>\n比如珍贵的古代文献, 有好多都失传了, 就是因为记载着信息的载体, 也就是书籍, 遭受损害, 导致信息丢失</p>\n</li>\n<li class=\"lvl-2\">\n<p>不损耗性信息在传播的过程中, 是不会发生损耗的</p>\n</li>\n<li class=\"lvl-2\">\n<p>时效性<br>\n信息往往反映的是某事物特定时间内的状况, 但事物会随着时间的推移而改变<br>\n比如 “太阳亮着” 这条信息, 一百万亿亿亿年后太阳绝壁熄灭了, 你敢说这条信息永远适用?</p>\n</li>\n<li class=\"lvl-2\">\n<p>共享性<br>\n信息可以被共享, 可以被重复利用, 不像能源那样会发生损耗<br>\n毕竟信息是虚的, 不是实物, 你QQ发的消息, 已经被人看到了, 撤回后那个人还是记得的</p>\n</li>\n<li class=\"lvl-2\">\n<p>可加工处理性/真伪性<br>\n信息能被加工, 比如要打仗了, 肯定要给地方一些假信息, 来迷惑敌人<br>\n在比如 <code>盲人摸象/管中窥豹</code>, 都体现了真伪性</p>\n</li>\n<li class=\"lvl-2\">\n<p>价值性<br>\n比如天气预报让你出门避免被雨淋湿, 这就是价值<br>\n对不同的人, 同信息会产生不同的价值, 比如英国的天气预报对中国居民就没多大价值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"zhi-shi-de-ding-yi\">知识的定义</h1>\n<p>不管有用无用的信息, 那都是信息, 但知识是有用的, 能够运用在实践中的信息, 是人类社会的经验总和它能够被继承, 被传递, 这显而易见, 毕竟它本身就是信息的真子集, 人类就是依靠知识的继承而不断发展的<br>\n指的是人们已经掌握的能力</p>\n<p>这部分很简单, 简单概述即可, 但请注意不要与下面的 <code>智慧的定义搞错了</code></p>\n<hr>\n<h1 id=\"zhi-hui-de-ding-yi\">智慧的定义</h1>\n<p>一般指人们运用所掌握的信息, 知识, 在面对新事物时所发挥的能力</p>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<p>以下是一个很好的, 对三者进行了区分的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>数据: 人们看到的3.1415926, 这是客观的数字, 是表达符号</p>\n</li>\n<li class=\"lvl-2\">\n<p>信息: 人们知道圆周率就是3.1415926</p>\n</li>\n<li class=\"lvl-2\">\n<p>知识: 人们知道如何求解圆的面积来解决现实问题</p>\n</li>\n<li class=\"lvl-2\">\n<p>智慧: 刘徽在落后的时代背景下, 面对如何求解 pai 时创造了割圆术</p>\n</li>\n</ul>\n<p>这是我花了二十分钟写的, 毕竟只是简单地抄了下教科书, 考试也不考, 姑且就这样吧, 累了<br>\n您可以看之后的python语法, 数据结构, 算法, 内存等方面的文字, 等课上到了我应该就会更新…</p>"},{"title":"high-school-it-p2: 基础科普","abbrlink":"posts/high-school-it/p2","hidden":false,"date":"2022-09-11T12:51:16.000Z","top":7998,"keywords":["高中信息技术","python"],"_content":"> 让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!\n<!-- more -->\n\n:::tips\n**注意:**  \n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解\n:::\n\n\n# 编译与解释\n计算机是二进制的, 只认识二进制, 但你不可能手写二进制  \nc/cpp/python 等编程语言, 让你写人类可理解的 \"代码\", 然后将它们 \"转化\" 为二进制后供机器执行  \n\n反正记住一点:  \n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 `.exe` 结尾的文件  \n我们将代码被解析为二进制的过程, 称为 \"编译\", 将解析工具, 称为 \"编译器\"  \n\n当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕  \n我们将分段编译的过程, 称为 \"解释\", 将分段编译的工具, 称为 \"解释器\"  \n\n编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本  \n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码  \n\npy的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑  \n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python :)  \n\n:::tips\n**代码:**  \n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码  \n它仅是段文本, 若没了编译器/解释器, 代码毫无用处  \n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件  \n:::\n\n:::tips\n**文件后缀:**\n文件本身的内容, 并不会因修改文件的后缀名而发生更改  \n后缀只不过起到一个进行分辨的作用, 当你看见 \"xxx.jpg\", 就知道它是张图片, 看见 \"xxx.txt\", 就知道它是段文本  \n\n文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性  \nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:  \n\n当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了  \n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 \"文件损坏\" 了\n\n如何显示文件后缀?  \n按住 \"win+e\" (\"win\" 是键盘下面的windows图标, win与e一起按), 打开文件浏览器  \n在上方顶栏, 点击 \"查看\", 随后勾选右侧的 \"文件扩展名\", 然后关闭文件浏览器  \n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了  \n:::\n\n- - -\n# Python的特点  \n- 是一门 ++高级语言++\n- 是一门 ++面向对象++ 的语言\n- 是一门 ++解释型++ 语言\n- 语法简单, 拥有丰富强大的库, 适合快速开发\n\n:::tips\n**高级语言**  \n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段  \n\n- 机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解  \n- 汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了\n- 高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp  \n\n值得注意的是, 还有一个叫 ++自然语言++, 别和上面的搞混了  \n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语\n\n:::\n\n:::tips\n**面向对象**  \n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木  \n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼  \n(非严谨版, 勿喷, 只是快速了解而已)  \n:::\n\n:::tips\n**库:**  \n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂  \n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了  \n:::\n\n- - -\n\n# 环境搭建\n你可以选择用家里的电脑练习python, 这时就需要自己安装python了\n~~(以Windows为例, 毕竟你要是用的是linux还需要看这步吗...)~~  \n\npython的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: [安装程序](https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe)  \n至于出现安装界面后点哪里, 你就记住两个地方:\n\n- 先勾选底部的两个框框, 分别是\"install launcher\" 与 \"add path\", 都选上\n- 点击 \"Install Now\" 进行安装, 等待安装成功后直接点击close\n\n如何检验自己是否安装成功?  \n请按住 `win+r` (win键是键盘最下面的window图标, \"win\" 与 \"r\" 要一起按)  \n随后输入 `cmd`, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示  \n\n请输入以下命令, 检验python是否安装成功:  \n\n```\npython  --version\n```\n\n以上的 `python`, 就是安装的python解释器, 是个可执行文件(exe)  \n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本  \n它应该会输出类似下面的文字:  \n\n```\nPython 3.9.0\n```\n\n如果是其他输出, 很可能是安装的时候, 未勾选 `add path` 这个框, 导致路径无法被识别  \n\n:::tips\n**命令与路径**  \n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 \"终端/命令行/cmd\"  \n粗体闪烁的光标前的提示符, 表示你当前处于的路径  \n\n你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)  \n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛  \n比如, 敲下 \"C:\\asdiasdadows\\asdadtem32\\casd.exe\" 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)  \n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 :)  \n\n但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 \"xxx\" 来执行 \"C:\\asdad\\xxx.exe\" 该怎么办呢?  \n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件  \n\n你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 \"add path\" 了吗?  \n就是为了能够直接输入 \"python\" 来执行命令, 而不需要在意它的路径!\n\n同样的道理, 你按 \"win+r\" 后, 输入的 `cmd`, 其实就代表着, 通过 `cmd` 背后对应的路径, 执行了叫 `cmd.exe` 的exe文件  \n因此, 出现了这个黑框框 :)\n\n但请明白一点, 这个黑框框只不过是个 \"外壳\", 只是让你输入命令而已, 能够显示文字而已  \n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行  \n你可以 \"win+r\" 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的  \n:::\n\n- - -\n\n# idle的背后原理\n你现在已经了解了很多基础的概念/常识了, 对吧?!  \n\n在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 \"idle\" 的工具, 编辑代码后, 点击 \"Run\" 开始运行? (或类似工具)  \n实际上, 若你明白了先前讲的 \"编译器/解释器\", 这个图形化的界面实际上也并不神秘  \n\n你编辑代码后点击的 \"Run\", 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行  \n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已  \n\n整个过程如下:  \n\n- 新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 \"xxx.py\"\n- 在 cmd 中输入: `python xxx.py`\n\n\n- - -\n# Hello world!\n来加深印象, 写个非常简单的程序吧, 作用是打印一句话: \"Hello world!\"  \n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码  \n\n:::tips\n**注意:**\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化  \n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明  \n:::\n\n首先, 在桌面右键, 新建一个txt文件, 假设它叫 \"first_app\", 然后右键编辑, 输入下面的内容:  \n\n```python\nprint(\"Hello world!\")\n```\n\n随后打开cmd/终端, 你的当前路径应该是 \"C:\\Users\\用户名\"  \n我们新建的文件, 在桌面中, 桌面对应的文件夹是 \"Desktop\", 因此我们应该进入Desktop文件夹, 然后根据路径执行它:  \n\n```bash\ncd Desktop\npython first_app.txt\n```\n\n这将会打印:  \n\n```\nHello world!\n```\n\n瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行  \n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件  \n\n你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已  \n(如果你不懂怎么修改后缀, 请看上面的 \"常识科普: 文件后缀\")  \n\n当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!  \n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 \"这是段python代码\", 然后去寻找相关的工具了  \n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途\n\n但还是有个问题  \n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 \"python\", 进行执行  \n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入  \n\n这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!  \n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了  \n\n在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 \"输入命令, 得到结果\" 的循环  \n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失  \n\n有没有什么办法来阻止双击后黑框框的消失呢? 当然有  \nwindows中有这么一个命令, 叫做 \"pause\", 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿  \n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的  \n\npython是可以调用外部命令的!  \n\n你可以在 first_app.py 中, 这样改进你的代码:  \n\n```python\nimport os\n\nprint(\"Hello World!\")\nos.system(\"pause\")\n```\n\n上面的 `import`, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事  \n`os.system(\"pause\")` 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令  \n\n好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分","source":"_posts/high-school-it/p2-基础科普.md","raw":"---\ntitle: \"high-school-it-p2: 基础科普\"\nabbrlink: posts/high-school-it/p2\nhidden: false\ndate: 2022-09-11 20:51:16\ntop: 7998\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\n---\n> 让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!\n<!-- more -->\n\n:::tips\n**注意:**  \n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解\n:::\n\n\n# 编译与解释\n计算机是二进制的, 只认识二进制, 但你不可能手写二进制  \nc/cpp/python 等编程语言, 让你写人类可理解的 \"代码\", 然后将它们 \"转化\" 为二进制后供机器执行  \n\n反正记住一点:  \n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 `.exe` 结尾的文件  \n我们将代码被解析为二进制的过程, 称为 \"编译\", 将解析工具, 称为 \"编译器\"  \n\n当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕  \n我们将分段编译的过程, 称为 \"解释\", 将分段编译的工具, 称为 \"解释器\"  \n\n编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本  \n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码  \n\npy的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑  \n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python :)  \n\n:::tips\n**代码:**  \n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码  \n它仅是段文本, 若没了编译器/解释器, 代码毫无用处  \n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件  \n:::\n\n:::tips\n**文件后缀:**\n文件本身的内容, 并不会因修改文件的后缀名而发生更改  \n后缀只不过起到一个进行分辨的作用, 当你看见 \"xxx.jpg\", 就知道它是张图片, 看见 \"xxx.txt\", 就知道它是段文本  \n\n文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性  \nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:  \n\n当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了  \n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 \"文件损坏\" 了\n\n如何显示文件后缀?  \n按住 \"win+e\" (\"win\" 是键盘下面的windows图标, win与e一起按), 打开文件浏览器  \n在上方顶栏, 点击 \"查看\", 随后勾选右侧的 \"文件扩展名\", 然后关闭文件浏览器  \n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了  \n:::\n\n- - -\n# Python的特点  \n- 是一门 ++高级语言++\n- 是一门 ++面向对象++ 的语言\n- 是一门 ++解释型++ 语言\n- 语法简单, 拥有丰富强大的库, 适合快速开发\n\n:::tips\n**高级语言**  \n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段  \n\n- 机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解  \n- 汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了\n- 高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp  \n\n值得注意的是, 还有一个叫 ++自然语言++, 别和上面的搞混了  \n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语\n\n:::\n\n:::tips\n**面向对象**  \n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木  \n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼  \n(非严谨版, 勿喷, 只是快速了解而已)  \n:::\n\n:::tips\n**库:**  \n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂  \n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了  \n:::\n\n- - -\n\n# 环境搭建\n你可以选择用家里的电脑练习python, 这时就需要自己安装python了\n~~(以Windows为例, 毕竟你要是用的是linux还需要看这步吗...)~~  \n\npython的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: [安装程序](https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe)  \n至于出现安装界面后点哪里, 你就记住两个地方:\n\n- 先勾选底部的两个框框, 分别是\"install launcher\" 与 \"add path\", 都选上\n- 点击 \"Install Now\" 进行安装, 等待安装成功后直接点击close\n\n如何检验自己是否安装成功?  \n请按住 `win+r` (win键是键盘最下面的window图标, \"win\" 与 \"r\" 要一起按)  \n随后输入 `cmd`, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示  \n\n请输入以下命令, 检验python是否安装成功:  \n\n```\npython  --version\n```\n\n以上的 `python`, 就是安装的python解释器, 是个可执行文件(exe)  \n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本  \n它应该会输出类似下面的文字:  \n\n```\nPython 3.9.0\n```\n\n如果是其他输出, 很可能是安装的时候, 未勾选 `add path` 这个框, 导致路径无法被识别  \n\n:::tips\n**命令与路径**  \n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 \"终端/命令行/cmd\"  \n粗体闪烁的光标前的提示符, 表示你当前处于的路径  \n\n你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)  \n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛  \n比如, 敲下 \"C:\\asdiasdadows\\asdadtem32\\casd.exe\" 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)  \n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 :)  \n\n但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 \"xxx\" 来执行 \"C:\\asdad\\xxx.exe\" 该怎么办呢?  \n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件  \n\n你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 \"add path\" 了吗?  \n就是为了能够直接输入 \"python\" 来执行命令, 而不需要在意它的路径!\n\n同样的道理, 你按 \"win+r\" 后, 输入的 `cmd`, 其实就代表着, 通过 `cmd` 背后对应的路径, 执行了叫 `cmd.exe` 的exe文件  \n因此, 出现了这个黑框框 :)\n\n但请明白一点, 这个黑框框只不过是个 \"外壳\", 只是让你输入命令而已, 能够显示文字而已  \n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行  \n你可以 \"win+r\" 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的  \n:::\n\n- - -\n\n# idle的背后原理\n你现在已经了解了很多基础的概念/常识了, 对吧?!  \n\n在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 \"idle\" 的工具, 编辑代码后, 点击 \"Run\" 开始运行? (或类似工具)  \n实际上, 若你明白了先前讲的 \"编译器/解释器\", 这个图形化的界面实际上也并不神秘  \n\n你编辑代码后点击的 \"Run\", 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行  \n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已  \n\n整个过程如下:  \n\n- 新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 \"xxx.py\"\n- 在 cmd 中输入: `python xxx.py`\n\n\n- - -\n# Hello world!\n来加深印象, 写个非常简单的程序吧, 作用是打印一句话: \"Hello world!\"  \n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码  \n\n:::tips\n**注意:**\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化  \n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明  \n:::\n\n首先, 在桌面右键, 新建一个txt文件, 假设它叫 \"first_app\", 然后右键编辑, 输入下面的内容:  \n\n```python\nprint(\"Hello world!\")\n```\n\n随后打开cmd/终端, 你的当前路径应该是 \"C:\\Users\\用户名\"  \n我们新建的文件, 在桌面中, 桌面对应的文件夹是 \"Desktop\", 因此我们应该进入Desktop文件夹, 然后根据路径执行它:  \n\n```bash\ncd Desktop\npython first_app.txt\n```\n\n这将会打印:  \n\n```\nHello world!\n```\n\n瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行  \n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件  \n\n你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已  \n(如果你不懂怎么修改后缀, 请看上面的 \"常识科普: 文件后缀\")  \n\n当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!  \n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 \"这是段python代码\", 然后去寻找相关的工具了  \n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途\n\n但还是有个问题  \n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 \"python\", 进行执行  \n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入  \n\n这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!  \n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了  \n\n在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 \"输入命令, 得到结果\" 的循环  \n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失  \n\n有没有什么办法来阻止双击后黑框框的消失呢? 当然有  \nwindows中有这么一个命令, 叫做 \"pause\", 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿  \n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的  \n\npython是可以调用外部命令的!  \n\n你可以在 first_app.py 中, 这样改进你的代码:  \n\n```python\nimport os\n\nprint(\"Hello World!\")\nos.system(\"pause\")\n```\n\n上面的 `import`, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事  \n`os.system(\"pause\")` 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令  \n\n好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分","slug":"high-school-it/p2-基础科普","published":1,"updated":"2022-09-11T12:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86fu00056aijc4iicmb0","content":"<blockquote>\n<p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p>\n</blockquote>\n<span id=\"more\"></span>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p>\n</div>\n<h1 id=\"bian-yi-yu-jie-shi\">编译与解释</h1>\n<p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>\nc/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p>\n<p>反正记住一点:<br>\n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 <code>.exe</code> 结尾的文件<br>\n我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p>\n<p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>\n我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p>\n<p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>\n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p>\n<p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>\n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p>\n<div class=\"tips\">\n<p><strong>代码:</strong><br>\n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>\n它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>\n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p>\n</div>\n<div class=\"tips\">\n<p><strong>文件后缀:</strong><br>\n文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>\n后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p>\n<p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>\nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p>\n<p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>\n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p>\n<p>如何显示文件后缀?<br>\n按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>\n在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>\n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p>\n</div>\n<hr>\n<h1 id=\"python-de-te-dian\">Python的特点</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>是一门 <ins>高级语言</ins></p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>面向对象</ins> 的语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>解释型</ins> 语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法简单, 拥有丰富强大的库, 适合快速开发</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><strong>高级语言</strong><br>\n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</li>\n<li class=\"lvl-2\">汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</li>\n<li class=\"lvl-2\">高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</li>\n</ul>\n<p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>\n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p>\n</div>\n<div class=\"tips\">\n<p><strong>面向对象</strong><br>\n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>\n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>\n(非严谨版, 勿喷, 只是快速了解而已)</p>\n</div>\n<div class=\"tips\">\n<p><strong>库:</strong><br>\n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>\n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p>\n</div>\n<hr>\n<h1 id=\"huan-jing-da-jian\">环境搭建</h1>\n<p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br>\n<s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p>\n<p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href=\"https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe\">安装程序</a><br>\n至于出现安装界面后点哪里, 你就记住两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p>\n</li>\n<li class=\"lvl-2\">\n<p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p>\n</li>\n</ul>\n<p>如何检验自己是否安装成功?<br>\n请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>\n随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p>\n<p>请输入以下命令, 检验python是否安装成功:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span>  --<span class=\"keyword\">version</span></span><br></pre></td></tr></table></figure>\n<p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>\n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>\n它应该会输出类似下面的文字:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Python</span> <span class=\"number\">3</span>.<span class=\"number\">9</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p>\n<div class=\"tips\">\n<p><strong>命令与路径</strong><br>\n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>\n粗体闪烁的光标前的提示符, 表示你当前处于的路径</p>\n<p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>\n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>\n比如, 敲下 “C:\\asdiasdadows\\asdadtem32\\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>\n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p>\n<p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\\asdad\\xxx.exe” 该怎么办呢?<br>\n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p>\n<p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>\n就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p>\n<p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>\n因此, 出现了这个黑框框 😃</p>\n<p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>\n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>\n你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p>\n</div>\n<hr>\n<h1 id=\"idle-de-bei-hou-yuan-li\">idle的背后原理</h1>\n<p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p>\n<p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>\n实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p>\n<p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>\n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p>\n<p>整个过程如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href=\"http://xxx.py\">xxx.py</a>”</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 cmd 中输入: <code>python xxx.py</code></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"hello-world\">Hello world!</h1>\n<p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>\n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>\n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p>\n</div>\n<p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>随后打开cmd/终端, 你的当前路径应该是 “C:\\Users\\用户名”<br>\n我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> Desktop</span><br><span class=\"line\">python first_app.txt</span><br></pre></td></tr></table></figure>\n<p>这将会打印:</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello world!</span><br></pre></td></tr></table></figure>\n<p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>\n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p>\n<p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>\n(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p>\n<p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>\n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>\n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p>\n<p>但还是有个问题<br>\n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>\n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p>\n<p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>\n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p>\n<p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>\n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p>\n<p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>\nwindows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>\n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p>\n<p>python是可以调用外部命令的!</p>\n<p>你可以在 first_app.py 中, 这样改进你的代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br>\n<code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p>\n<p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>\n","site":{"data":{}},"length":4249,"excerpt":"<blockquote>\n<p>让我们了解下python, 顺便科普一些常识, 进行环境搭建, 写一个Hello World吧!</p>\n</blockquote>","more":"<div class=\"tips\">\n<p><strong>注意:</strong><br>\n本文是偏向初学者的科普性文章, 语言尽量小白化, 或因此丧失一定的严谨, 望理解</p>\n</div>\n<h1 id=\"bian-yi-yu-jie-shi\">编译与解释</h1>\n<p>计算机是二进制的, 只认识二进制, 但你不可能手写二进制<br>\nc/cpp/python 等编程语言, 让你写人类可理解的 “代码”, 然后将它们 “转化” 为二进制后供机器执行</p>\n<p>反正记住一点:<br>\n机器无法理解代码, 它只理解二进制, 但你能通过程序, 将代码解析为二进制可执行文件, 即 <code>.exe</code> 结尾的文件<br>\n我们将代码被解析为二进制的过程, 称为 “编译”, 将解析工具, 称为 “编译器”</p>\n<p>当然, python 特殊一些, 编译的过程是分段的, 先编译一段, 再执行这段二进制, 重复, 直到全部解析完毕<br>\n我们将分段编译的过程, 称为 “解释”, 将分段编译的工具, 称为 “解释器”</p>\n<p>编程语言, 以 python 为例子, 在不断地高速迭代与进化, 因此有很多新旧版本<br>\n新版本的 python, 可能就会出现许多新的强大语法, 让人更爽地编写代码</p>\n<p>py的代码很简单, 不像c语言要涉及底层的内存管理知识, 你不需关注底层的繁琐细节, 只需关注逻辑<br>\n因此它出现在了高中的信息技术学科教育中, 适合初学者, 虽然我个人并不喜欢python 😃</p>\n<div class=\"tips\">\n<p><strong>代码:</strong><br>\n代码并非特殊之物, 你完全能在桌面新建个txt文件, 然后在里面写代码<br>\n它仅是段文本, 若没了编译器/解释器, 代码毫无用处<br>\n编译器/解释器才是最重要的, 因为它们可以接收文本, 将其解析为exe文件</p>\n</div>\n<div class=\"tips\">\n<p><strong>文件后缀:</strong><br>\n文件本身的内容, 并不会因修改文件的后缀名而发生更改<br>\n后缀只不过起到一个进行分辨的作用, 当你看见 “xxx.jpg”, 就知道它是张图片, 看见 “xxx.txt”, 就知道它是段文本</p>\n<p>文件的后缀只不过是个约定, 让人们知道该文件代表什么, 但约定不具有强制性<br>\nwindows会根据文件的后缀, 尝试用对应的工具打开该文件, 比如:</p>\n<p>当你新建个txt, 然后将其后缀改为jpg, windows就会以为它是张图片, 用查看图片的方式来处理它, 此时自然就无法显示了<br>\n一个图片文件, 你非要把内容改成你随便敲打的文字, 工具无法识别, 自然就是 “文件损坏” 了</p>\n<p>如何显示文件后缀?<br>\n按住 “win+e” (“win” 是键盘下面的windows图标, win与e一起按), 打开文件浏览器<br>\n在上方顶栏, 点击 “查看”, 随后勾选右侧的 “文件扩展名”, 然后关闭文件浏览器<br>\n此时, 桌面上的文件, 就会显示后缀了, 你也能通过重命名修改文件后缀了</p>\n</div>\n<hr>\n<h1 id=\"python-de-te-dian\">Python的特点</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>是一门 <ins>高级语言</ins></p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>面向对象</ins> 的语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>是一门 <ins>解释型</ins> 语言</p>\n</li>\n<li class=\"lvl-2\">\n<p>语法简单, 拥有丰富强大的库, 适合快速开发</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><strong>高级语言</strong><br>\n计算机界, 编程语言具有一个演化史, 那就是越来越具有可读性, 分为三个阶段</p>\n<ul class=\"lvl-1\">\n<li class=\"lvl-2\">机器语言: 由二进制代码组成, 计算机可以识别并运行, 但人类无法理解</li>\n<li class=\"lvl-2\">汇编语言: 加上了许多符号, 通过编译器编译为机器语言, 人类稍微可以理解了</li>\n<li class=\"lvl-2\">高级语言: 加上了非常多的符号与语法, 通过编译器/解释器, 转为汇编语言, 人类可读, 比如py/c/cpp</li>\n</ul>\n<p>值得注意的是, 还有一个叫 <ins>自然语言</ins>, 别和上面的搞混了<br>\n自然语言指我们日常生活中, 进行对话时使用的语言, 如汉语/英语/法语/德语</p>\n</div>\n<div class=\"tips\">\n<p><strong>面向对象</strong><br>\n假设你要搭积木, 这个积木很复杂, 那么你可以将积木分解成五六个子型的小积木<br>\n那么, 可以先拼好这五个小积木, 然后组合成搭积木, 而不是一块一块拼<br>\n(非严谨版, 勿喷, 只是快速了解而已)</p>\n</div>\n<div class=\"tips\">\n<p><strong>库:</strong><br>\n当你需要开发一个无比复杂的程序, 不可能自己从头开始一行一行敲, 太复杂<br>\n比如你用Python时, 想使用产生随机数的功能, 不用自己写, 官方已经给你写好了, 你直接调用就完事了</p>\n</div>\n<hr>\n<h1 id=\"huan-jing-da-jian\">环境搭建</h1>\n<p>你可以选择用家里的电脑练习python, 这时就需要自己安装python了<br>\n<s>(以Windows为例, 毕竟你要是用的是linux还需要看这步吗…)</s></p>\n<p>python的官网在国外, 访问起来有点慢, 让我们使用华为搭建的镜像网站, 点击此处下载py, 版本是3.9.0: <a href=\"https://mirrors.huaweicloud.com/python/3.9.0/python-3.9.0.exe\">安装程序</a><br>\n至于出现安装界面后点哪里, 你就记住两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>先勾选底部的两个框框, 分别是&quot;install launcher&quot; 与 “add path”, 都选上</p>\n</li>\n<li class=\"lvl-2\">\n<p>点击 “Install Now” 进行安装, 等待安装成功后直接点击close</p>\n</li>\n</ul>\n<p>如何检验自己是否安装成功?<br>\n请按住 <code>win+r</code> (win键是键盘最下面的window图标, “win” 与 “r” 要一起按)<br>\n随后输入 <code>cmd</code>, 然后再敲回车, 会出现一个黑窗口, 不用理会闪烁的粗体光标, 与光标前的前置提示</p>\n<p>请输入以下命令, 检验python是否安装成功:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span>  --<span class=\"keyword\">version</span></span><br></pre></td></tr></table></figure>\n<p>以上的 <code>python</code>, 就是安装的python解释器, 是个可执行文件(exe)<br>\n我们执行它, 但并不让它解释代码, 此处仅表示: 让它输出当前python的版本<br>\n它应该会输出类似下面的文字:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Python</span> <span class=\"number\">3</span>.<span class=\"number\">9</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>如果是其他输出, 很可能是安装的时候, 未勾选 <code>add path</code> 这个框, 导致路径无法被识别</p>\n<div class=\"tips\">\n<p><strong>命令与路径</strong><br>\n这个出现的黑框框, 作用是执行你敲下的命令, 我们称其为 “终端/命令行/cmd”<br>\n粗体闪烁的光标前的提示符, 表示你当前处于的路径</p>\n<p>你能输入命令, 敲回车, 来运行该命令 (命令其实也就是一个exe文件)<br>\n事实上, 当你想执行命令时, 应输入它的完整路径, 告诉了windows可执行文件的路径, 才能执行对应的文件嘛<br>\n比如, 敲下 “C:\\asdiasdadows\\asdadtem32\\casd.exe” 来执行某个叫 casd.exe 的可执行文件 (乱编的路径)<br>\n你鼠标点击软件图标后, 就会出现界面, 这也相当于, 在终端/命令行中, 敲下了对应的路径 😃</p>\n<p>但若有个很常用的命令, 不想每次都输完整路径, 只想简单地用 “xxx” 来执行 “C:\\asdad\\xxx.exe” 该怎么办呢?<br>\n这时, 可将该path添加到系统path中, 然后为该path取个名字, 之后输入这名字, 此时就相当于, 执行了对应path指向的文件</p>\n<p>你现在懂得, 为什么在python的安装向导程序中, 需要勾选下方的 “add path” 了吗?<br>\n就是为了能够直接输入 “python” 来执行命令, 而不需要在意它的路径!</p>\n<p>同样的道理, 你按 “win+r” 后, 输入的 <code>cmd</code>, 其实就代表着, 通过 <code>cmd</code> 背后对应的路径, 执行了叫 <code>cmd.exe</code> 的exe文件<br>\n因此, 出现了这个黑框框 😃</p>\n<p>但请明白一点, 这个黑框框只不过是个 “外壳”, 只是让你输入命令而已, 能够显示文字而已<br>\n真正执行命令的, 还是windows系统本身, 你在cmd中敲下的命令, 都会交给windows系统本身去执行<br>\n你可以 “win+r” 后直接敲 python, 与在 cmd 中敲 python, 效果是一样的</p>\n</div>\n<hr>\n<h1 id=\"idle-de-bei-hou-yuan-li\">idle的背后原理</h1>\n<p>你现在已经了解了很多基础的概念/常识了, 对吧?!</p>\n<p>在课堂上, 老师是怎么教你们码代码的?  是不是通过一个叫 “idle” 的工具, 编辑代码后, 点击 “Run” 开始运行? (或类似工具)<br>\n实际上, 若你明白了先前讲的 “编译器/解释器”, 这个图形化的界面实际上也并不神秘</p>\n<p>你编辑代码后点击的 “Run”, 实际上的作用, 就是获取你编辑的当前文件的路径, 然后把该路径传递给python解释器, 进行执行<br>\n执行后, python解释器根据你的代码, 可能会进行输出, 然后 idle 就会该输出粘过来, 显示给你, 仅此而已</p>\n<p>整个过程如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>新建一个文件, 编辑, 然后保存, 复制该文件的路径, 假设该路径是 “<a href=\"http://xxx.py\">xxx.py</a>”</p>\n</li>\n<li class=\"lvl-2\">\n<p>在 cmd 中输入: <code>python xxx.py</code></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"hello-world\">Hello world!</h1>\n<p>来加深印象, 写个非常简单的程序吧, 作用是打印一句话: “Hello world!”<br>\n这是计算机界非常经典的, 几乎适用于一切编程语言的, 非常简单的初学者代码</p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n这是本教程唯一的一次不用idle, 目的是理解上面的知识, 之后的所有代码, 都会使用idle编辑, 因为小白化<br>\n你可以选择直接跳过本节, 该讲的都讲了, 特在此说明</p>\n</div>\n<p>首先, 在桌面右键, 新建一个txt文件, 假设它叫 “first_app”, 然后右键编辑, 输入下面的内容:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello world!&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>随后打开cmd/终端, 你的当前路径应该是 “C:\\Users\\用户名”<br>\n我们新建的文件, 在桌面中, 桌面对应的文件夹是 “Desktop”, 因此我们应该进入Desktop文件夹, 然后根据路径执行它:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> Desktop</span><br><span class=\"line\">python first_app.txt</span><br></pre></td></tr></table></figure>\n<p>这将会打印:</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello world!</span><br></pre></td></tr></table></figure>\n<p>瞧吧! 编辑器/解释器本身, 是不在乎文件后缀的, 只在乎文件的内容, 然后读取文件的内容, 将其解析为二进制, 然后运行<br>\n当然, 这样有个问题, 那就是人们看见其后缀txt, 会下意识认为它仅是个普通的文本文件</p>\n<p>你可以将后缀改为py, 告诉其他人, 这是个装着py代码的文件, 让含义更加清晰, 仅此而已<br>\n(如果你不懂怎么修改后缀, 请看上面的 “常识科普: 文件后缀”)</p>\n<p>当你将后缀更改为py后, 你会发现文件的图标变成了python的图标, 啊, 多么清晰!<br>\n当你右键它, 会发现能用idle编辑了, windows根据后缀, 知道了 “这是段python代码”, 然后去寻找相关的工具了<br>\n这就是正确使用后缀的便利, 即使后缀并不改变文件本身的内容, 但我们能更好地, 根据后缀辨别文件的类型与用途</p>\n<p>但还是有个问题<br>\n那就是, 当你双击时, windows会根据后缀, 将该文件的路径, 传入命令 “python”, 进行执行<br>\n执行的时候, 会自动打开cmd, 来显示你的输出/接收你的输入</p>\n<p>这时, 你会发现, 黑窗窗一闪而过, 为何它没停下来, 直接闪退了?!?!<br>\n实际上, 我们的代码已经执行完毕了, 那么既然已经好了, 临时打开的cmd自然就消失了</p>\n<p>在之前通过win+r产生的cmd, 用途是进行交互, 让你能一直在一个 “输入命令, 得到结果” 的循环<br>\n但通过双击而获得的cmd, 此时仅为单个程序服务, 程序一结束自己就消失</p>\n<p>有没有什么办法来阻止双击后黑框框的消失呢? 当然有<br>\nwindows中有这么一个命令, 叫做 “pause”, 英文的意思是停顿, 作用是停顿cmd, 直到你随便按一个键, 打破这个停顿<br>\n你可以 win+r 打开 cmd, 然后输入 pause, 自己来试试, 就明白了, 很简单的</p>\n<p>python是可以调用外部命令的!</p>\n<p>你可以在 first_app.py 中, 这样改进你的代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">os.system(<span class=\"string\">&quot;pause&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>import</code>, 表示你导入了一个库, 关于库的概念之后会讲, 此处不懂也没事<br>\n<code>os.system(&quot;pause&quot;)</code> 表示调用一条外部命令, 相当于在cmd中调用了 pause 命令</p>\n<p>好了, 本节已经结束了, 仅作为一篇科普向文章, 之后会正式涉及python的语法部分</p>"},{"title":"high-school-it-p4: 进制的转换与应用","abbrlink":"posts/high-school-it/p4","hidden":false,"date":"2022-10-13T15:51:02.000Z","top":7996,"keywords":["高中信息技术","python"],"_content":"> 关于任意进制间的互相转换与应用\n<!-- more -->\n\n","source":"_posts/high-school-it/p4-进制的转换与应用.md","raw":"---\ntitle: \"high-school-it-p4: 进制的转换与应用\"\nabbrlink: posts/high-school-it/p4\nhidden: false\ndate: 2022-10-13 23:51:02\ntop: 7996\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\n---\n> 关于任意进制间的互相转换与应用\n<!-- more -->\n\n","slug":"high-school-it/p4-进制的转换与应用","published":1,"updated":"2022-10-13T15:51:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86fw00066aij3fqwcxzu","content":"<blockquote>\n<p>关于任意进制间的互相转换与应用</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":15,"excerpt":"<blockquote>\n<p>关于任意进制间的互相转换与应用</p>\n</blockquote>","more":""},{"title":"high-school-it-p3: python基础语法-part1","abbrlink":"posts/high-school-it/p3","hidden":false,"date":"2022-09-12T03:45:45.000Z","top":7997,"keywords":["高中信息技术","python"],"_content":"> 正式的对python语法的学习, 包含常见库函数的使用\n<!-- more -->\n\n:::tips\n有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 [p2: 基础科普与环境搭建](/posts/high-school-it/p2)\n:::\n**感谢:** 本文的切片部分来源于 [python切片完全指南(语法篇)](https://zhuanlan.zhihu.com/p/79541418), 已经过原作者准许\n\n# 变量与赋值  \n编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么? \n需要数据, 还需要存放数据的地方, ++变量++, 就是这么一个存放数据的地方  \n\n变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)  \n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实  \n\n有两个概念:\n- 声明变量:  创建变量 (声明一个变量出现了)  \n- 赋值: 把一个值装到箱子(变量)里\n\n比如, 一个很简单的例子:  \n\n```python\na = 1\n```\n\n这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值  \n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量  \n\n变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同  \n\n你也可以这样:  \n\n```python\na = 1\nb = a\n```\n\n我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b  \n第二行表示, 把a里面的数值取出来, 传给了b  \n\npython支持也支持这样的赋值操作, 甚至可以继续长下去\n\n```python\na = b = c = 1\nd = e = f = 2\n\na,b,c = d,e,f\n```\n\n上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2\n\n\n你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:  \n\n```python\na = 1\nb = 2\na,b = b,a\n```\n\n你可能会疑惑:  \n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?  \n该想法对应的代码是这样的:  \n\n```python\na = 1\nb = 2\n\na = b\nb = a\n```\n\n但在交换数值的代码中, 你应该这样理解:  \n\n```python\na = 1\nb = 2\n\n_t1 = b\n_t2 = a\na = _t1\nb = _t2\n```\n\n这表示, 进行 `a,b = b,a` 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b  \n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了  \n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 :)  \n\n另外 选择题会出现这样的常见选项:  \n\n```python\nA.  a = 1, b = 2, c = 3\nB.  a, b, c = 1, 2, 3\nC.  a = 1; b = 2; c = 3\n```\n其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已\n\n- - -\n\n# 变量命名规范\npython中, 变量的命名必须符合规范, 不然直接报错  \n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a  \n\n命名规范如下:  \n- 变量名由字母, 数字, 下划线组成\n- 不能由数字开头\n- 中间不能有空格分割  \n- 不能与python中的关键字重名  \n\n以下都是合法的变量名  \n\n```python\na\nabada\nasd111231\nad190123kkad\nasd_asd1_asd2\n_123daa\n_as11\n```\n\n以下是不合法的变量名:  \n\n```python\ndef\nnot\nin\nlambda\n\n1123\n123adad\nsad;;-``\n``?/\n',\n```\n\n:::tips\n**关键字:**  \n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in  \n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果  \n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用\n:::\n\n你怎么知道哪些是关键字呢? 慢慢看吧, 像 `def/import/for/if/break` 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字\n\n- - -\n# 注释\n\n## 作用\n注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码  \n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么\n\n举个例子:\n\n```python\na = 1  此时 a 的值为 1\n```\n\n```python\na = 1  # 此时 a 的值为 1\n```\n\n前者会报错, 因为 \"此时 a 的值为 1\" 也被解释器当作代码而进行解析, 自然就会报错了  \n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释  \n\n再举个例子:\n\n```python\n# 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出\n\na = 1\nb = 2\nc = 3\nmax = -1\nif a > b > c:\n  max = a\nelif b > c:\n  max = b\nelse:\n  max = c\nprint(max)\n```\n\n瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了  \n\n## 单/多行注释\npython 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了  \n\n```python\n# 12345\n# 上山打老虎\n# 老虎打不着\n# 打到小松鼠\n\n''' \n12345\n上山打老虎\n老虎打不着\n打到小松鼠\n'''\n```\n\n以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候  \n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)\n\n- - -\n# 基本数据类型\n前面说了, 求解问题时, 你需要数据, 还有存放数据的地方  \n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了  \n\n为了模拟现实, py将数据进行了抽象与分类:  \n\n\n- int: 对应整数  \n- float: 对应实数  \n- string: 对应文字\n- bool: 对应真与假\n\n有了这些 ++基本数据类型++, 我们就能够模拟世界了, 进行抽象, 求解问题了  \n\n举些例子:  \n- 我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃  \n- 我的年龄是16岁: 用int来表示 16 这个数字\n- 我的名字叫做: 用string来表示 \"赵二狗\", \"Anasdpa\" 这样的文字  \n\n同时, 我们还可以用这些 ++基本数据类型++, 构建出 ++复杂数据类型++, 比如, 我想创建一个类型, 叫 student, 表示学生  \n你可以这样抽象:  \n\n```python\nstudent {\n  age:  int,\n  height: float,\n  name: string,\n  fat_or_not: bool\n}\n```\n\npy中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已\n\n\n- - -\n\n# 运算符与优先级\npython 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作  \n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个  \n在以下的图表中, 优先级1是最高, 数字越大优先级越低  \n\n## 算术运算符  \n算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字  \n\n|运算符|描述|例子|优先级|\n|--|--|--|--|\n|**|x的y次方|x**y|1|\n|*|x乘以y|x*y|2|\n|/|x除以y, 产生实数值|x/y|2|\n|//|x除以y, 产生整数值|x//y|2|\n|%|x除以y, 取余数|x%y|2|\n|+|x加y|x+y|3|\n|-|x减y|x-y|3|\n\n瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 :)\n\n算术运算符, 可以与赋值运算符相互结合:\n\n```python\na = a + 1\n\na += 1  # 是上面的等价物\n```\n\n类似的, 还有 `-=`, `*=`, `%=`\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍\n\n## 关系运算符\n关系运算符, 若关系成立则返回 True, 不然返回 False, 如 `1 < 2` 是 True, 因此又称为 比较运算符  \n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)\n\n|运算符|描述|例子\n|--|--|--|\n|>| x 大于 y| x > y|\n|<| x 小于 y| x < y|\n|>=| x 大于等于 y| x >= y|\n|<=| x 小于等于 y| x <= y|\n|==| x 等于 y| x == y|\n|!=| x 不等于 y| x != y|\n\n**注:**  \n本博客使用了连体字特性, 因此你看见的>=其实是>号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=\n\n- - -\n\n# 基本数据结构\n数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构  \n\n举个例子, 有种数据结构, 叫做 `队列 (Queue)`, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:  \n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解  \n此时的队列, 就是一个 `单向队列`, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)  \n\n根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构  \n当然, 我们此处仅学习基本数据结构  \n\n## 列表\n列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素  \n\n### 单索引  \n我们可以通过单个索引, 访问对应的单个元素  \n\n举个例子:  \n\n```python\n# 有着 3 个元素的列表\nlist = [300, 400, 500]\n\n# 通过索引, 访问元素 (索引从 0 开始)\nlist[0]  # 300\nlist[1]  # 400\nlist[2]  # 500\n```\n\n:::tips\n**扩展: 为何 index 从 0 开始?**  \n因为, 所谓的index, 代表的概念, 其实是 `偏移量`  \n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素  \n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?  \n\n你可以这样理解:  \n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间  \n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子\n\n列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子  \n如何访问第 1 个格子? 第一个格子向右跳 0 格  \n如何访问第 2 个格子? 第二个格子向右跳 1 格  \n如何访问第 3 个格子? 第三个格子向右跳 2 格  \n\n\n现在懂了吧? 下标其实就是偏移量, 代表的是 `相对于第 1 个格子偏移了多少格`  \n要访问第几个格子, 直接加上偏移量即可 (比如 `list[0]` 偏移了0, 是第一个元素)\n\n如果你非要把下标从 1 开始, 那就得这样:  \nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0  \n于是在根据下标1, 求第一个元素时, 偏移量就是 `1 - 1 = 0`  \n同理, 根据下标2, 求第二个元素时, 偏移量就是 `2 - 1 = 1`  \n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 `index - 1`  \n\n如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?  \n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了  \n~~(好吧, 原因其实真的只是因为习俗)~~\n\n而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 :)  \n:::\n\npy 中还存在 `负索引` 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减  \n比如 `ls[-1]`, 就代表倒数第一个元素, `ls[-2]` 就代表倒数第二个元素  \n\n举个例子, 已知 `a = [10, 20, 30, 40, 50]` 让我们将其与图表进行对立:  \n\n| | | | | | |\n|--|--|--|--|--|--|\n|元素|10|20|30|40|50|\n|正索引|0|1|2|3|4|\n|负索引|-5|-4|-3|-2|-1|\n\n显而易见的, `ls[-1]`, 就相当于 `ls[len(ls) - 1]` ( len(ls) 表示得到列表ls的长度 )  \n\n### 索引越界\n\n于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:  \n\n```python demo.py\na = [10, 20, 30, 40, 50]\na[5]\n```\n\n当我们在命令行中执行 `python demo.py` (见 [p2: 基础科普#环境搭建](/posts/high-school-it/p2#huan-jing-da-jian) ) 或直接使用图形化工具, 点击运行按钮  \n\n脑子想一想都知道肯定编译不过, 我们将得到以下报错:  \n\n```\nTraceback (most recent call last):\n  File \"/home/jedsek/a.py\", line 2, in <module>\n    a[5]\n    ~^^^\nIndexError: list index out of range\n```\n\n看不懂的直接像做玩英语完形一样当作 \"哔(屏蔽词)\" 跳过就好, index 是 \"索引/下标的意思\", 这条报错表示, 下标越界了!  \n因为 a 是个长度为 5 的列表, 所以只能用 `n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)` 来当下标, 即 0 到 4, 因此 5 是非法的  \n负索引也是一样的道理, 不能越界哟~~\n\n### 切片\n切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素  \n\n举个例子:  \n\n```python\nnumbers = [201, 202, 203, 204]  # 定义列表\nnumbers[0:4]  # [201, 202, 203, 204]\nnumbers[0:2]  # [201, 202]\nnumbers[0:1]  # [201]\n```\n\n在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素  \n我们通过 `list[m:n]`, 得到了一个子列表, 只要索引在 `[m, n) (左开右闭区间)` 内, 就会被放入这个子列表  \n\n图表依然会较为直观:  \n\n`numbers = [201, 202, 203, 204]`\n||||\n|--|--|--|\n|切片|对应索引|取出的子列表|\n|0:4|[0, 1, 2, 3]|[201, 202, 203, 204]|\n|0:2|[0, 1]|[201, 202]|\n|0:1|[0]|[201]|\n|-3:-1|[-3, -2]|[202, 203]|\n\n默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 `numbers[0:4:1]` 就相当于 `numbers[0:4]`  \n而 `numbers[0:4:2]` 则相当于从 `[0, 1, 2, 3]` 中的第一个元素 `0` 开始, 作为下标取 numbers 的元素, 然后走两步到 `2`, 依次类推  \n步长不能设置为 0, 不然会报错  \n\n有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 `[]`  \n举个例子: `numbers[3:2]` 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分  \n\n### 省略与默认值\n关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 :)  \n \n已知 `a = [10, 20, 30, 40, 50]`, 你可以使用 `a[start:stop:step]` 来表示 a 的切片, 其中 start/stop/step 都是可以省略的  \n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 `a[start:stop]`/`a[start:stop:]` 的形式时, 步长会使用默认值1  \n\n而对于 `start/stop` 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取  \n举些例子, 已知 `a = [10, 20, 30, 40, 50, 60, 70]`:  \n\n- `a[2:5:1]` 中, `2:4` 对应的下标是 `[2, 3, 4]`, 索引对应的元素是 `[30, 40, 50]`, 因为步长为1, 所以结果直接就是 `[30, 40, 50]`  \n- `a[2::1]` 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 `[30, 40, 50, 60, 70]`  \n- `a[:2:1]` 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 `[10, 20]`  \n- `a[2::-1]` 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 `[30, 20, 10]`  \n- `a[:2:-1]` 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 `[70, 60, 50, 40]`  \n\n什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:  \n- `start` 代表列表中某个元素的下标, 这个元素是切片的起头\n- `stop` 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)  \n- `step` 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取  \n\n要开始了哦, 超级直观的方法:  \n\n以 `a[2:5:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `5`, 所以箭头的终点是 `50` (箭头从 60 逆方向缩一格): [10, 20, ~~30, 40, 50~~>, 60, 70]\n\n以 `a[2::1]` 为例:\n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: [10, 20, ~~30, 40, 50, 60, 70]~~>\n\n以 `a[:2:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 被省略, 所以箭头的起点在左边的无限远处, 不用动: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `20` (箭头从 30 逆方向缩一格): ~~[10, 20~~>, 30, 40, 50, 60, 70]\n\n以 `a[2::-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: <~~[10, 20, 30~~, 40, 50, 60, 70]  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: <~~[10, 20, 30~~, 40, 50, 60, 70]\n \n以 `a[:2:-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 被省略, 所以箭头的起点在右边的无限远处, 不用动: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `40` (箭头从 30 逆方向缩一格): [10, 20, 30, <~~40, 50, 60, 70]~~\n\n对于负索引也是一样的道理, 先确定好 `start` 与 `stop` 的位置, 然后根据步长画对应方向的箭头  \n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行  \n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可  \n\n- - -\n\n## 字典\npython 中的字典, 实际上就是一些键值对组成的集合  \n键值对, 指的就是根据某个键值, 获取其对应的另外一个值  \n\n举个例子:  \n- 名字: \"小明\"  \n- 年龄(year): 16\n- 身高(cm): 178\n\n名字 -> \"小明\", 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了  \n\n在 python 中, 你可以用一对花括号来定义字典:  \n\n```python\na = {'Shadd': 10, 'Lasd': 111, 'PPqwea': 899}\n```\n\n冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  `a['Shadd']` 将得到 `10`","source":"_posts/high-school-it/p3-python基础语法-part1.md","raw":"---\ntitle: \"high-school-it-p3: python基础语法-part1\"\nabbrlink: posts/high-school-it/p3\nhidden: false\ndate: 2022-09-12 11:45:45\ntop: 7997\ntags: [高中信息技术]\nkeywords: [高中信息技术, python]\n---\n> 正式的对python语法的学习, 包含常见库函数的使用\n<!-- more -->\n\n:::tips\n有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 [p2: 基础科普与环境搭建](/posts/high-school-it/p2)\n:::\n**感谢:** 本文的切片部分来源于 [python切片完全指南(语法篇)](https://zhuanlan.zhihu.com/p/79541418), 已经过原作者准许\n\n# 变量与赋值  \n编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么? \n需要数据, 还需要存放数据的地方, ++变量++, 就是这么一个存放数据的地方  \n\n变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)  \n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实  \n\n有两个概念:\n- 声明变量:  创建变量 (声明一个变量出现了)  \n- 赋值: 把一个值装到箱子(变量)里\n\n比如, 一个很简单的例子:  \n\n```python\na = 1\n```\n\n这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值  \n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量  \n\n变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同  \n\n你也可以这样:  \n\n```python\na = 1\nb = a\n```\n\n我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b  \n第二行表示, 把a里面的数值取出来, 传给了b  \n\npython支持也支持这样的赋值操作, 甚至可以继续长下去\n\n```python\na = b = c = 1\nd = e = f = 2\n\na,b,c = d,e,f\n```\n\n上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2\n\n\n你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:  \n\n```python\na = 1\nb = 2\na,b = b,a\n```\n\n你可能会疑惑:  \n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?  \n该想法对应的代码是这样的:  \n\n```python\na = 1\nb = 2\n\na = b\nb = a\n```\n\n但在交换数值的代码中, 你应该这样理解:  \n\n```python\na = 1\nb = 2\n\n_t1 = b\n_t2 = a\na = _t1\nb = _t2\n```\n\n这表示, 进行 `a,b = b,a` 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b  \n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了  \n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 :)  \n\n另外 选择题会出现这样的常见选项:  \n\n```python\nA.  a = 1, b = 2, c = 3\nB.  a, b, c = 1, 2, 3\nC.  a = 1; b = 2; c = 3\n```\n其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已\n\n- - -\n\n# 变量命名规范\npython中, 变量的命名必须符合规范, 不然直接报错  \n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a  \n\n命名规范如下:  \n- 变量名由字母, 数字, 下划线组成\n- 不能由数字开头\n- 中间不能有空格分割  \n- 不能与python中的关键字重名  \n\n以下都是合法的变量名  \n\n```python\na\nabada\nasd111231\nad190123kkad\nasd_asd1_asd2\n_123daa\n_as11\n```\n\n以下是不合法的变量名:  \n\n```python\ndef\nnot\nin\nlambda\n\n1123\n123adad\nsad;;-``\n``?/\n',\n```\n\n:::tips\n**关键字:**  \n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in  \n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果  \n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用\n:::\n\n你怎么知道哪些是关键字呢? 慢慢看吧, 像 `def/import/for/if/break` 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字\n\n- - -\n# 注释\n\n## 作用\n注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码  \n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么\n\n举个例子:\n\n```python\na = 1  此时 a 的值为 1\n```\n\n```python\na = 1  # 此时 a 的值为 1\n```\n\n前者会报错, 因为 \"此时 a 的值为 1\" 也被解释器当作代码而进行解析, 自然就会报错了  \n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释  \n\n再举个例子:\n\n```python\n# 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出\n\na = 1\nb = 2\nc = 3\nmax = -1\nif a > b > c:\n  max = a\nelif b > c:\n  max = b\nelse:\n  max = c\nprint(max)\n```\n\n瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了  \n\n## 单/多行注释\npython 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了  \n\n```python\n# 12345\n# 上山打老虎\n# 老虎打不着\n# 打到小松鼠\n\n''' \n12345\n上山打老虎\n老虎打不着\n打到小松鼠\n'''\n```\n\n以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候  \n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)\n\n- - -\n# 基本数据类型\n前面说了, 求解问题时, 你需要数据, 还有存放数据的地方  \n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了  \n\n为了模拟现实, py将数据进行了抽象与分类:  \n\n\n- int: 对应整数  \n- float: 对应实数  \n- string: 对应文字\n- bool: 对应真与假\n\n有了这些 ++基本数据类型++, 我们就能够模拟世界了, 进行抽象, 求解问题了  \n\n举些例子:  \n- 我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃  \n- 我的年龄是16岁: 用int来表示 16 这个数字\n- 我的名字叫做: 用string来表示 \"赵二狗\", \"Anasdpa\" 这样的文字  \n\n同时, 我们还可以用这些 ++基本数据类型++, 构建出 ++复杂数据类型++, 比如, 我想创建一个类型, 叫 student, 表示学生  \n你可以这样抽象:  \n\n```python\nstudent {\n  age:  int,\n  height: float,\n  name: string,\n  fat_or_not: bool\n}\n```\n\npy中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已\n\n\n- - -\n\n# 运算符与优先级\npython 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作  \n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个  \n在以下的图表中, 优先级1是最高, 数字越大优先级越低  \n\n## 算术运算符  \n算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字  \n\n|运算符|描述|例子|优先级|\n|--|--|--|--|\n|**|x的y次方|x**y|1|\n|*|x乘以y|x*y|2|\n|/|x除以y, 产生实数值|x/y|2|\n|//|x除以y, 产生整数值|x//y|2|\n|%|x除以y, 取余数|x%y|2|\n|+|x加y|x+y|3|\n|-|x减y|x-y|3|\n\n瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 :)\n\n算术运算符, 可以与赋值运算符相互结合:\n\n```python\na = a + 1\n\na += 1  # 是上面的等价物\n```\n\n类似的, 还有 `-=`, `*=`, `%=`\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍\n\n## 关系运算符\n关系运算符, 若关系成立则返回 True, 不然返回 False, 如 `1 < 2` 是 True, 因此又称为 比较运算符  \n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)\n\n|运算符|描述|例子\n|--|--|--|\n|>| x 大于 y| x > y|\n|<| x 小于 y| x < y|\n|>=| x 大于等于 y| x >= y|\n|<=| x 小于等于 y| x <= y|\n|==| x 等于 y| x == y|\n|!=| x 不等于 y| x != y|\n\n**注:**  \n本博客使用了连体字特性, 因此你看见的>=其实是>号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=\n\n- - -\n\n# 基本数据结构\n数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构  \n\n举个例子, 有种数据结构, 叫做 `队列 (Queue)`, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:  \n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解  \n此时的队列, 就是一个 `单向队列`, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)  \n\n根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构  \n当然, 我们此处仅学习基本数据结构  \n\n## 列表\n列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素  \n\n### 单索引  \n我们可以通过单个索引, 访问对应的单个元素  \n\n举个例子:  \n\n```python\n# 有着 3 个元素的列表\nlist = [300, 400, 500]\n\n# 通过索引, 访问元素 (索引从 0 开始)\nlist[0]  # 300\nlist[1]  # 400\nlist[2]  # 500\n```\n\n:::tips\n**扩展: 为何 index 从 0 开始?**  \n因为, 所谓的index, 代表的概念, 其实是 `偏移量`  \n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素  \n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?  \n\n你可以这样理解:  \n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间  \n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子\n\n列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子  \n如何访问第 1 个格子? 第一个格子向右跳 0 格  \n如何访问第 2 个格子? 第二个格子向右跳 1 格  \n如何访问第 3 个格子? 第三个格子向右跳 2 格  \n\n\n现在懂了吧? 下标其实就是偏移量, 代表的是 `相对于第 1 个格子偏移了多少格`  \n要访问第几个格子, 直接加上偏移量即可 (比如 `list[0]` 偏移了0, 是第一个元素)\n\n如果你非要把下标从 1 开始, 那就得这样:  \nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0  \n于是在根据下标1, 求第一个元素时, 偏移量就是 `1 - 1 = 0`  \n同理, 根据下标2, 求第二个元素时, 偏移量就是 `2 - 1 = 1`  \n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 `index - 1`  \n\n如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?  \n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了  \n~~(好吧, 原因其实真的只是因为习俗)~~\n\n而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 :)  \n:::\n\npy 中还存在 `负索引` 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减  \n比如 `ls[-1]`, 就代表倒数第一个元素, `ls[-2]` 就代表倒数第二个元素  \n\n举个例子, 已知 `a = [10, 20, 30, 40, 50]` 让我们将其与图表进行对立:  \n\n| | | | | | |\n|--|--|--|--|--|--|\n|元素|10|20|30|40|50|\n|正索引|0|1|2|3|4|\n|负索引|-5|-4|-3|-2|-1|\n\n显而易见的, `ls[-1]`, 就相当于 `ls[len(ls) - 1]` ( len(ls) 表示得到列表ls的长度 )  \n\n### 索引越界\n\n于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:  \n\n```python demo.py\na = [10, 20, 30, 40, 50]\na[5]\n```\n\n当我们在命令行中执行 `python demo.py` (见 [p2: 基础科普#环境搭建](/posts/high-school-it/p2#huan-jing-da-jian) ) 或直接使用图形化工具, 点击运行按钮  \n\n脑子想一想都知道肯定编译不过, 我们将得到以下报错:  \n\n```\nTraceback (most recent call last):\n  File \"/home/jedsek/a.py\", line 2, in <module>\n    a[5]\n    ~^^^\nIndexError: list index out of range\n```\n\n看不懂的直接像做玩英语完形一样当作 \"哔(屏蔽词)\" 跳过就好, index 是 \"索引/下标的意思\", 这条报错表示, 下标越界了!  \n因为 a 是个长度为 5 的列表, 所以只能用 `n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)` 来当下标, 即 0 到 4, 因此 5 是非法的  \n负索引也是一样的道理, 不能越界哟~~\n\n### 切片\n切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素  \n\n举个例子:  \n\n```python\nnumbers = [201, 202, 203, 204]  # 定义列表\nnumbers[0:4]  # [201, 202, 203, 204]\nnumbers[0:2]  # [201, 202]\nnumbers[0:1]  # [201]\n```\n\n在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素  \n我们通过 `list[m:n]`, 得到了一个子列表, 只要索引在 `[m, n) (左开右闭区间)` 内, 就会被放入这个子列表  \n\n图表依然会较为直观:  \n\n`numbers = [201, 202, 203, 204]`\n||||\n|--|--|--|\n|切片|对应索引|取出的子列表|\n|0:4|[0, 1, 2, 3]|[201, 202, 203, 204]|\n|0:2|[0, 1]|[201, 202]|\n|0:1|[0]|[201]|\n|-3:-1|[-3, -2]|[202, 203]|\n\n默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 `numbers[0:4:1]` 就相当于 `numbers[0:4]`  \n而 `numbers[0:4:2]` 则相当于从 `[0, 1, 2, 3]` 中的第一个元素 `0` 开始, 作为下标取 numbers 的元素, 然后走两步到 `2`, 依次类推  \n步长不能设置为 0, 不然会报错  \n\n有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 `[]`  \n举个例子: `numbers[3:2]` 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分  \n\n### 省略与默认值\n关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 :)  \n \n已知 `a = [10, 20, 30, 40, 50]`, 你可以使用 `a[start:stop:step]` 来表示 a 的切片, 其中 start/stop/step 都是可以省略的  \n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 `a[start:stop]`/`a[start:stop:]` 的形式时, 步长会使用默认值1  \n\n而对于 `start/stop` 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取  \n举些例子, 已知 `a = [10, 20, 30, 40, 50, 60, 70]`:  \n\n- `a[2:5:1]` 中, `2:4` 对应的下标是 `[2, 3, 4]`, 索引对应的元素是 `[30, 40, 50]`, 因为步长为1, 所以结果直接就是 `[30, 40, 50]`  \n- `a[2::1]` 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 `[30, 40, 50, 60, 70]`  \n- `a[:2:1]` 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 `[10, 20]`  \n- `a[2::-1]` 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 `[30, 20, 10]`  \n- `a[:2:-1]` 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 `[70, 60, 50, 40]`  \n\n什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:  \n- `start` 代表列表中某个元素的下标, 这个元素是切片的起头\n- `stop` 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)  \n- `step` 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取  \n\n要开始了哦, 超级直观的方法:  \n\n以 `a[2:5:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `5`, 所以箭头的终点是 `50` (箭头从 60 逆方向缩一格): [10, 20, ~~30, 40, 50~~>, 60, 70]\n\n以 `a[2::1]` 为例:\n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: [10, 20, ~~30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: [10, 20, ~~30, 40, 50, 60, 70]~~>\n\n以 `a[:2:1]` 为例:  \n- 因为步长为正, 先画条从左往右的箭头: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `start` 被省略, 所以箭头的起点在左边的无限远处, 不用动: ~~[10, 20, 30, 40, 50, 60, 70]~~>  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `20` (箭头从 30 逆方向缩一格): ~~[10, 20~~>, 30, 40, 50, 60, 70]\n\n以 `a[2::-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 是 `2`, 所以箭头的起点从 `30` 开始: <~~[10, 20, 30~~, 40, 50, 60, 70]  \n- 因为 `stop` 被省略, 所以箭头无终点, 一直延伸: <~~[10, 20, 30~~, 40, 50, 60, 70]\n \n以 `a[:2:-1]` 为例:  \n- 因为步长为负, 先画条从右往左的箭头: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `start` 被省略, 所以箭头的起点在右边的无限远处, 不用动: <~~[10, 20, 30, 40, 50, 60, 70]~~  \n- 因为 `stop` 是 `2`, 所以箭头的终点是 `40` (箭头从 30 逆方向缩一格): [10, 20, 30, <~~40, 50, 60, 70]~~\n\n对于负索引也是一样的道理, 先确定好 `start` 与 `stop` 的位置, 然后根据步长画对应方向的箭头  \n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行  \n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可  \n\n- - -\n\n## 字典\npython 中的字典, 实际上就是一些键值对组成的集合  \n键值对, 指的就是根据某个键值, 获取其对应的另外一个值  \n\n举个例子:  \n- 名字: \"小明\"  \n- 年龄(year): 16\n- 身高(cm): 178\n\n名字 -> \"小明\", 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了  \n\n在 python 中, 你可以用一对花括号来定义字典:  \n\n```python\na = {'Shadd': 10, 'Lasd': 111, 'PPqwea': 899}\n```\n\n冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  `a['Shadd']` 将得到 `10`","slug":"high-school-it/p3-python基础语法-part1","published":1,"updated":"2022-09-12T03:45:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86fx00076aij2tve51pa","content":"<blockquote>\n<p>正式的对python语法的学习, 包含常见库函数的使用</p>\n</blockquote>\n<span id=\"more\"></span>\n<div class=\"tips\">\n<p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href=\"/posts/high-school-it/p2\">p2: 基础科普与环境搭建</a></p>\n</div>\n<p><strong>感谢:</strong> 本文的切片部分来源于 <a href=\"https://zhuanlan.zhihu.com/p/79541418\">python切片完全指南(语法篇)</a>, 已经过原作者准许</p>\n<h1 id=\"bian-liang-yu-fu-zhi\">变量与赋值</h1>\n<p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>\n需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p>\n<p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>\n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p>\n<p>有两个概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>声明变量:  创建变量 (声明一个变量出现了)</p>\n</li>\n<li class=\"lvl-2\">\n<p>赋值: 把一个值装到箱子(变量)里</p>\n</li>\n</ul>\n<p>比如, 一个很简单的例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>\n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p>\n<p>变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同</p>\n<p>你也可以这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>\n第二行表示, 把a里面的数值取出来, 传给了b</p>\n<p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = b = c = <span class=\"number\">1</span></span><br><span class=\"line\">d = e = f = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a,b,c = d,e,f</span><br></pre></td></tr></table></figure>\n<p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p>\n<p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">a,b = b,a</span><br></pre></td></tr></table></figure>\n<p>你可能会疑惑:<br>\n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>\n该想法对应的代码是这样的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = b</span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>但在交换数值的代码中, 你应该这样理解:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">_t1 = b</span><br><span class=\"line\">_t2 = a</span><br><span class=\"line\">a = _t1</span><br><span class=\"line\">b = _t2</span><br></pre></td></tr></table></figure>\n<p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>\n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了<br>\n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p>\n<p>另外 选择题会出现这样的常见选项:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.  a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, c = <span class=\"number\">3</span></span><br><span class=\"line\">B.  a, b, c = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\">C.  a = <span class=\"number\">1</span>; b = <span class=\"number\">2</span>; c = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已</p>\n<hr>\n<h1 id=\"bian-liang-ming-ming-gui-fan\">变量命名规范</h1>\n<p>python中, 变量的命名必须符合规范, 不然直接报错<br>\n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p>\n<p>命名规范如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>变量名由字母, 数字, 下划线组成</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能由数字开头</p>\n</li>\n<li class=\"lvl-2\">\n<p>中间不能有空格分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能与python中的关键字重名</p>\n</li>\n</ul>\n<p>以下都是合法的变量名</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">abada</span><br><span class=\"line\">asd111231</span><br><span class=\"line\">ad190123kkad</span><br><span class=\"line\">asd_asd1_asd2</span><br><span class=\"line\">_123daa</span><br><span class=\"line\">_as11</span><br></pre></td></tr></table></figure>\n<p>以下是不合法的变量名:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">not</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">in</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lambda</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">1123</span></span><br><span class=\"line\"><span class=\"function\">123<span class=\"title\">adad</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sad</span>;;-``</span></span><br><span class=\"line\"><span class=\"function\">``?/</span></span><br><span class=\"line\"><span class=\"function\">&#x27;,</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><strong>关键字:</strong><br>\n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>\n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>\n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p>\n</div>\n<p>你怎么知道哪些是关键字呢? 慢慢看吧, 像 <code>def/import/for/if/break</code> 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字</p>\n<hr>\n<h1 id=\"zhu-shi\">注释</h1>\n<h2 id=\"zuo-yong\" id=\"作用\">作用</h2>\n<p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>\n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  此时 a 的值为 <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  <span class=\"comment\"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure>\n<p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>\n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p>\n<p>再举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">c = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">max</span> = -<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> a &gt; b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = a</span><br><span class=\"line\"><span class=\"keyword\">elif</span> b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = b</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">max</span>)</span><br></pre></td></tr></table></figure>\n<p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p>\n<h2 id=\"dan-duo-xing-zhu-shi\" id=\"单-多行注释\">单/多行注释</h2>\n<p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 12345</span></span><br><span class=\"line\"><span class=\"comment\"># 上山打老虎</span></span><br><span class=\"line\"><span class=\"comment\"># 老虎打不着</span></span><br><span class=\"line\"><span class=\"comment\"># 打到小松鼠</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27; </span></span><br><span class=\"line\"><span class=\"string\">12345</span></span><br><span class=\"line\"><span class=\"string\">上山打老虎</span></span><br><span class=\"line\"><span class=\"string\">老虎打不着</span></span><br><span class=\"line\"><span class=\"string\">打到小松鼠</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>\n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-lei-xing\">基本数据类型</h1>\n<p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>\n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p>\n<p>为了模拟现实, py将数据进行了抽象与分类:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>int: 对应整数</p>\n</li>\n<li class=\"lvl-2\">\n<p>float: 对应实数</p>\n</li>\n<li class=\"lvl-2\">\n<p>string: 对应文字</p>\n</li>\n<li class=\"lvl-2\">\n<p>bool: 对应真与假</p>\n</li>\n</ul>\n<p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p>\n<p>举些例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的年龄是16岁: 用int来表示 16 这个数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p>\n</li>\n</ul>\n<p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>\n你可以这样抽象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">student &#123;</span><br><span class=\"line\">  age:  <span class=\"built_in\">int</span>,</span><br><span class=\"line\">  height: <span class=\"built_in\">float</span>,</span><br><span class=\"line\">  name: string,</span><br><span class=\"line\">  fat_or_not: <span class=\"built_in\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p>\n<hr>\n<h1 id=\"yun-suan-fu-yu-you-xian-ji\">运算符与优先级</h1>\n<p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>\n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>\n在以下的图表中, 优先级1是最高, 数字越大优先级越低</p>\n<h2 id=\"suan-zhu-yun-suan-fu\" id=\"算术运算符\">算术运算符</h2>\n<p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n<th>优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>x的y次方</td>\n<td>x**y</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>x乘以y</td>\n<td>x*y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>/</td>\n<td>x除以y, 产生实数值</td>\n<td>x/y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>x除以y, 产生整数值</td>\n<td>x//y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>x除以y, 取余数</td>\n<td>x%y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>+</td>\n<td>x加y</td>\n<td>x+y</td>\n<td>3</td>\n</tr>\n<tr>\n<td>-</td>\n<td>x减y</td>\n<td>x-y</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p>\n<p>算术运算符, 可以与赋值运算符相互结合:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a += <span class=\"number\">1</span>  <span class=\"comment\"># 是上面的等价物</span></span><br></pre></td></tr></table></figure>\n<p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p>\n<h2 id=\"guan-xi-yun-suan-fu\" id=\"关系运算符\">关系运算符</h2>\n<p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>\n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>x 大于 y</td>\n<td>x &gt; y</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>x 小于 y</td>\n<td>x &lt; y</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>x 大于等于 y</td>\n<td>x &gt;= y</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>x 小于等于 y</td>\n<td>x &lt;= y</td>\n</tr>\n<tr>\n<td>==</td>\n<td>x 等于 y</td>\n<td>x == y</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>x 不等于 y</td>\n<td>x != y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:</strong><br>\n本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-jie-gou\">基本数据结构</h1>\n<p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p>\n<p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>\n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>\n此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p>\n<p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>\n当然, 我们此处仅学习基本数据结构</p>\n<h2 id=\"lie-biao\" id=\"列表\">列表</h2>\n<p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p>\n<h3 id=\"dan-suo-yin\" id=\"单索引\">单索引</h3>\n<p>我们可以通过单个索引, 访问对应的单个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 有着 3 个元素的列表</span></span><br><span class=\"line\"><span class=\"built_in\">list</span> = [<span class=\"number\">300</span>, <span class=\"number\">400</span>, <span class=\"number\">500</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">0</span>]  <span class=\"comment\"># 300</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">1</span>]  <span class=\"comment\"># 400</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">2</span>]  <span class=\"comment\"># 500</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><strong>扩展: 为何 index 从 0 开始?</strong><br>\n因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>\n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>\n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p>\n<p>你可以这样理解:<br>\n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>\n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p>\n<p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>\n如何访问第 1 个格子? 第一个格子向右跳 0 格<br>\n如何访问第 2 个格子? 第二个格子向右跳 1 格<br>\n如何访问第 3 个格子? 第三个格子向右跳 2 格</p>\n<p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>\n要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p>\n<p>如果你非要把下标从 1 开始, 那就得这样:<br>\nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>\n于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>\n同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>\n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p>\n<p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>\n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br>\n<s>(好吧, 原因其实真的只是因为习俗)</s></p>\n<p>而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 😃</p>\n</div>\n<p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>\n比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p>\n<p>举个例子, 已知 <code>a = [10, 20, 30, 40, 50]</code> 让我们将其与图表进行对立:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>元素</td>\n<td>10</td>\n<td>20</td>\n<td>30</td>\n<td>40</td>\n<td>50</td>\n</tr>\n<tr>\n<td>正索引</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>负索引</td>\n<td>-5</td>\n<td>-4</td>\n<td>-3</td>\n<td>-2</td>\n<td>-1</td>\n</tr>\n</tbody>\n</table>\n<p>显而易见的, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p>\n<h3 id=\"suo-yin-yue-jie\" id=\"索引越界\">索引越界</h3>\n<p>于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:</p>\n<figure class=\"highlight python\"><figcaption><span>demo.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">a[<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>当我们在命令行中执行 <code>python demo.py</code> (见 <a href=\"/posts/high-school-it/p2#huan-jing-da-jian\">p2: 基础科普#环境搭建</a> ) 或直接使用图形化工具, 点击运行按钮</p>\n<p>脑子想一想都知道肯定编译不过, 我们将得到以下报错:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent <span class=\"keyword\">call</span> <span class=\"keyword\">last</span>):</span><br><span class=\"line\">  File <span class=\"string\">&quot;/home/jedsek/a.py&quot;</span>, <span class=\"built_in\">line</span> <span class=\"number\">2</span>, in <span class=\"symbol\">&lt;module&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">a</span>[<span class=\"number\">5</span>]</span><br><span class=\"line\">    ~^^^</span><br><span class=\"line\">IndexError: <span class=\"keyword\">list</span> <span class=\"built_in\">index</span> out of <span class=\"built_in\">range</span></span><br></pre></td></tr></table></figure>\n<p>看不懂的直接像做玩英语完形一样当作 “哔(屏蔽词)” 跳过就好, index 是 “索引/下标的意思”, 这条报错表示, 下标越界了!<br>\n因为 a 是个长度为 5 的列表, 所以只能用 <code>n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)</code> 来当下标, 即 0 到 4, 因此 5 是非法的<br>\n负索引也是一样的道理, 不能越界哟~~</p>\n<h3 id=\"qie-pian\" id=\"切片\">切片</h3>\n<p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">numbers = [<span class=\"number\">201</span>, <span class=\"number\">202</span>, <span class=\"number\">203</span>, <span class=\"number\">204</span>]  <span class=\"comment\"># 定义列表</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">4</span>]  <span class=\"comment\"># [201, 202, 203, 204]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">2</span>]  <span class=\"comment\"># [201, 202]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">1</span>]  <span class=\"comment\"># [201]</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>\n我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p>\n<p>图表依然会较为直观:</p>\n<p><code>numbers = [201, 202, 203, 204]</code></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>切片</td>\n<td>对应索引</td>\n<td>取出的子列表</td>\n</tr>\n<tr>\n<td>0:4</td>\n<td>[0, 1, 2, 3]</td>\n<td>[201, 202, 203, 204]</td>\n</tr>\n<tr>\n<td>0:2</td>\n<td>[0, 1]</td>\n<td>[201, 202]</td>\n</tr>\n<tr>\n<td>0:1</td>\n<td>[0]</td>\n<td>[201]</td>\n</tr>\n<tr>\n<td>-3:-1</td>\n<td>[-3, -2]</td>\n<td>[202, 203]</td>\n</tr>\n</tbody>\n</table>\n<p>默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 <code>numbers[0:4:1]</code> 就相当于 <code>numbers[0:4]</code><br>\n而 <code>numbers[0:4:2]</code> 则相当于从 <code>[0, 1, 2, 3]</code> 中的第一个元素 <code>0</code> 开始, 作为下标取 numbers 的元素, 然后走两步到 <code>2</code>, 依次类推<br>\n步长不能设置为 0, 不然会报错</p>\n<p>有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 <code>[]</code><br>\n举个例子: <code>numbers[3:2]</code> 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分</p>\n<h3 id=\"sheng-lue-yu-mo-ren-zhi\" id=\"省略与默认值\">省略与默认值</h3>\n<p>关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 😃</p>\n<p>已知 <code>a = [10, 20, 30, 40, 50]</code>, 你可以使用 <code>a[start:stop:step]</code> 来表示 a 的切片, 其中 start/stop/step 都是可以省略的<br>\n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 <code>a[start:stop]</code>/<code>a[start:stop:]</code> 的形式时, 步长会使用默认值1</p>\n<p>而对于 <code>start/stop</code> 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取<br>\n举些例子, 已知 <code>a = [10, 20, 30, 40, 50, 60, 70]</code>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>a[2:5:1]</code> 中, <code>2:4</code> 对应的下标是 <code>[2, 3, 4]</code>, 索引对应的元素是 <code>[30, 40, 50]</code>, 因为步长为1, 所以结果直接就是 <code>[30, 40, 50]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::1]</code> 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 <code>[30, 40, 50, 60, 70]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:1]</code> 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 <code>[10, 20]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::-1]</code> 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 <code>[30, 20, 10]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:-1]</code> 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 <code>[70, 60, 50, 40]</code></p>\n</li>\n</ul>\n<p>什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>start</code> 代表列表中某个元素的下标, 这个元素是切片的起头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>stop</code> 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>step</code> 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取</p>\n</li>\n</ul>\n<p>要开始了哦, 超级直观的方法:</p>\n<p>以 <code>a[2:5:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>5</code>, 所以箭头的终点是 <code>50</code> (箭头从 60 逆方向缩一格): [10, 20, <s>30, 40, 50</s>&gt;, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n</ul>\n<p>以 <code>a[:2:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在左边的无限远处, 不用动: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>20</code> (箭头从 30 逆方向缩一格): <s>[10, 20</s>&gt;, 30, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[:2:-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在右边的无限远处, 不用动: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>40</code> (箭头从 30 逆方向缩一格): [10, 20, 30, &lt;<s>40, 50, 60, 70]</s></p>\n</li>\n</ul>\n<p>对于负索引也是一样的道理, 先确定好 <code>start</code> 与 <code>stop</code> 的位置, 然后根据步长画对应方向的箭头<br>\n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行<br>\n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可</p>\n<hr>\n<h2 id=\"zi-dian\" id=\"字典\">字典</h2>\n<p>python 中的字典, 实际上就是一些键值对组成的集合<br>\n键值对, 指的就是根据某个键值, 获取其对应的另外一个值</p>\n<p>举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>名字: “小明”</p>\n</li>\n<li class=\"lvl-2\">\n<p>年龄(year): 16</p>\n</li>\n<li class=\"lvl-2\">\n<p>身高(cm): 178</p>\n</li>\n</ul>\n<p>名字 -&gt; “小明”, 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了</p>\n<p>在 python 中, 你可以用一对花括号来定义字典:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"string\">&#x27;Shadd&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;Lasd&#x27;</span>: <span class=\"number\">111</span>, <span class=\"string\">&#x27;PPqwea&#x27;</span>: <span class=\"number\">899</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  <code>a['Shadd']</code> 将得到 <code>10</code></p>\n","site":{"data":{}},"length":7235,"excerpt":"<blockquote>\n<p>正式的对python语法的学习, 包含常见库函数的使用</p>\n</blockquote>","more":"<div class=\"tips\">\n<p>有关python的基本介绍, 比如编译/解释/面向对象, 怎么自己下载python, 请看 <a href=\"/posts/high-school-it/p2\">p2: 基础科普与环境搭建</a></p>\n</div>\n<p><strong>感谢:</strong> 本文的切片部分来源于 <a href=\"https://zhuanlan.zhihu.com/p/79541418\">python切片完全指南(语法篇)</a>, 已经过原作者准许</p>\n<h1 id=\"bian-liang-yu-fu-zhi\">变量与赋值</h1>\n<p>编程不就是为了模拟世界, 求解问题吗? 求解问题都需要什么?<br>\n需要数据, 还需要存放数据的地方, <ins>变量</ins>, 就是这么一个存放数据的地方</p>\n<p>变量变量, 顾名思义, 指的是可变的量 (有些语言严格区分可变性, 但python里不用在意这么多)<br>\n你可以理解为, 变量, 是一个箱子/寄存器, 装着一些可以运算的数值, 用来求解问题, 模拟现实</p>\n<p>有两个概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>声明变量:  创建变量 (声明一个变量出现了)</p>\n</li>\n<li class=\"lvl-2\">\n<p>赋值: 把一个值装到箱子(变量)里</p>\n</li>\n</ul>\n<p>比如, 一个很简单的例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>这里, 我们声明了一个叫做 a 的变量, 然后把值装到了 a 中, 这就是 声明+赋值<br>\n右边是数值, 左边是变量名, 等号表示把右边的值赋给左边的变量</p>\n<p>变量名是随便你取的, 但必须遵守命名规范, 只能由字母, 下划线开头, 不能由数字开头, 中间不能有空格分割, 不能与关键字相同</p>\n<p>你也可以这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>我们先声明了一个变量a, 值是1, 然后把a放在右边传给了左边的b<br>\n第二行表示, 把a里面的数值取出来, 传给了b</p>\n<p>python支持也支持这样的赋值操作, 甚至可以继续长下去</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = b = c = <span class=\"number\">1</span></span><br><span class=\"line\">d = e = f = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a,b,c = d,e,f</span><br></pre></td></tr></table></figure>\n<p>上面的代码中, a,b,c都被初始化为1, def则为2, 然后赋值, 把abc的值变成了2</p>\n<p>你还可以这样, 表示把b中的值给a, 把a中的值给b, 达到交换值的效果:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">a,b = b,a</span><br></pre></td></tr></table></figure>\n<p>你可能会疑惑:<br>\n当我把b中的值给了a时, a的值不就是2了吗, 此时再把a赋值给b, 那b不还是2吗?<br>\n该想法对应的代码是这样的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = b</span><br><span class=\"line\">b = a</span><br></pre></td></tr></table></figure>\n<p>但在交换数值的代码中, 你应该这样理解:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">_t1 = b</span><br><span class=\"line\">_t2 = a</span><br><span class=\"line\">a = _t1</span><br><span class=\"line\">b = _t2</span><br></pre></td></tr></table></figure>\n<p>这表示, 进行 <code>a,b = b,a</code> 时, 会先把右边的变量给复制(赋值给新的变量)一遍, 再分别赋给a,b<br>\n只不过, 只要我们按照py的语法写, 我们就不需要考虑这么多了, py为我们隐藏了_t1, _t2, 你只需要可以这么写就行了<br>\n现在有没有明白, 为什么大家都说py语法简单呢? 之后还会有很多像这样甜的地方 😃</p>\n<p>另外 选择题会出现这样的常见选项:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">A.  a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, c = <span class=\"number\">3</span></span><br><span class=\"line\">B.  a, b, c = <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\">C.  a = <span class=\"number\">1</span>; b = <span class=\"number\">2</span>; c = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>其中 A 是错的, 别问为什么, 因为 python 的作者这样设计 python 的而已</p>\n<hr>\n<h1 id=\"bian-liang-ming-ming-gui-fan\">变量命名规范</h1>\n<p>python中, 变量的命名必须符合规范, 不然直接报错<br>\n在符合规范的同时, 你也应当尽可能地, 让变量名更加清洗直观, 比如年龄用age, 而不是a</p>\n<p>命名规范如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>变量名由字母, 数字, 下划线组成</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能由数字开头</p>\n</li>\n<li class=\"lvl-2\">\n<p>中间不能有空格分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>不能与python中的关键字重名</p>\n</li>\n</ul>\n<p>以下都是合法的变量名</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">abada</span><br><span class=\"line\">asd111231</span><br><span class=\"line\">ad190123kkad</span><br><span class=\"line\">asd_asd1_asd2</span><br><span class=\"line\">_123daa</span><br><span class=\"line\">_as11</span><br></pre></td></tr></table></figure>\n<p>以下是不合法的变量名:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">not</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">in</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">lambda</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">1123</span></span><br><span class=\"line\"><span class=\"function\">123<span class=\"title\">adad</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sad</span>;;-``</span></span><br><span class=\"line\"><span class=\"function\">``?/</span></span><br><span class=\"line\"><span class=\"function\">&#x27;,</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><strong>关键字:</strong><br>\n关键字/保留字, 是python语法中具有特殊含义的东西, 比如for/while/and/or/not/in<br>\n这些都被称作关键字, 一般出现了关键字, 就能用对应的语法, 实现一些效果<br>\n比如for就对应for循环, not就对应逻辑取反, 具有特殊作用</p>\n</div>\n<p>你怎么知道哪些是关键字呢? 慢慢看吧, 像 <code>def/import/for/if/break</code> 这种经常使用在特殊位置, 有特殊功能的字符, 自然就是关键字了, 又不会考你超纲的关键字</p>\n<hr>\n<h1 id=\"zhu-shi\">注释</h1>\n<h2 id=\"zuo-yong\" id=\"作用\">作用</h2>\n<p>注释, 是以py规定的特殊字符, 而开头的语句, 解释器会无视解析到的注释, 只解析代码<br>\n注释, 能够为阅读代码的人提供思路, 迅速明白这段代码做了什么, 而不用一行一行读代码来明白代码做了什么</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  此时 a 的值为 <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>  <span class=\"comment\"># 此时 a 的值为 1</span></span><br></pre></td></tr></table></figure>\n<p>前者会报错, 因为 “此时 a 的值为 1” 也被解释器当作代码而进行解析, 自然就会报错了<br>\n后者不会报错, 因为解释器解析到 # 开头的那段文字后, 会无视/跳过这段注释</p>\n<p>再举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以下的代码能够获取a,b,c三个变量中的最大值, 并进行输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\">c = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">max</span> = -<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> a &gt; b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = a</span><br><span class=\"line\"><span class=\"keyword\">elif</span> b &gt; c:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = b</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">  <span class=\"built_in\">max</span> = c</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">max</span>)</span><br></pre></td></tr></table></figure>\n<p>瞧, 你看上面的代码时,不用一行一行地去理解这段代码到底是干啥的, 直接看别人给你写的注释, 就能大致明白这段代码的作用了</p>\n<h2 id=\"dan-duo-xing-zhu-shi\" id=\"单-多行注释\">单/多行注释</h2>\n<p>python 的注释分为两种, 一种是以单行注释, 一种是多行注释, 直接看例子就明白了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 12345</span></span><br><span class=\"line\"><span class=\"comment\"># 上山打老虎</span></span><br><span class=\"line\"><span class=\"comment\"># 老虎打不着</span></span><br><span class=\"line\"><span class=\"comment\"># 打到小松鼠</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27; </span></span><br><span class=\"line\"><span class=\"string\">12345</span></span><br><span class=\"line\"><span class=\"string\">上山打老虎</span></span><br><span class=\"line\"><span class=\"string\">老虎打不着</span></span><br><span class=\"line\"><span class=\"string\">打到小松鼠</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>以井号开头的是单行注释, 通常用在注释仅仅是一两句话的时候<br>\n如果要注释有很多行, 用以三个引号开头, 三个引号结尾的多行注释更方便 (无论单双引号都可以)</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-lei-xing\">基本数据类型</h1>\n<p>前面说了, 求解问题时, 你需要数据, 还有存放数据的地方<br>\n如何存放数据, 我相信你已经明白了, 现在就要讲数据本身了</p>\n<p>为了模拟现实, py将数据进行了抽象与分类:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>int: 对应整数</p>\n</li>\n<li class=\"lvl-2\">\n<p>float: 对应实数</p>\n</li>\n<li class=\"lvl-2\">\n<p>string: 对应文字</p>\n</li>\n<li class=\"lvl-2\">\n<p>bool: 对应真与假</p>\n</li>\n</ul>\n<p>有了这些 <ins>基本数据类型</ins>, 我们就能够模拟世界了, 进行抽象, 求解问题了</p>\n<p>举些例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我今天吃饭了吗: 用bool来抽象到底吃饭没, True就是吃了, False就是没吃</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的年龄是16岁: 用int来表示 16 这个数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>我的名字叫做: 用string来表示 “赵二狗”, “Anasdpa” 这样的文字</p>\n</li>\n</ul>\n<p>同时, 我们还可以用这些 <ins>基本数据类型</ins>, 构建出 <ins>复杂数据类型</ins>, 比如, 我想创建一个类型, 叫 student, 表示学生<br>\n你可以这样抽象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">student &#123;</span><br><span class=\"line\">  age:  <span class=\"built_in\">int</span>,</span><br><span class=\"line\">  height: <span class=\"built_in\">float</span>,</span><br><span class=\"line\">  name: string,</span><br><span class=\"line\">  fat_or_not: <span class=\"built_in\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>py中也有语法, 支持创建自定义的类型, 但不是本系列的重点, 此处仅提一嘴而已</p>\n<hr>\n<h1 id=\"yun-suan-fu-yu-you-xian-ji\">运算符与优先级</h1>\n<p>python 提供了一些运算符, 能够让你进行加减乘除, 逻辑运算之类的操作<br>\n这些运算符, 有各自的优先级, 决定了当运算符有多个时, 应该优先计算哪个<br>\n在以下的图表中, 优先级1是最高, 数字越大优先级越低</p>\n<h2 id=\"suan-zhu-yun-suan-fu\" id=\"算术运算符\">算术运算符</h2>\n<p>算术运算符, 可以让你对数字类型 (int, float) 进行计算, 得到新的数字</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n<th>优先级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>**</td>\n<td>x的y次方</td>\n<td>x**y</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>x乘以y</td>\n<td>x*y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>/</td>\n<td>x除以y, 产生实数值</td>\n<td>x/y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>//</td>\n<td>x除以y, 产生整数值</td>\n<td>x//y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>x除以y, 取余数</td>\n<td>x%y</td>\n<td>2</td>\n</tr>\n<tr>\n<td>+</td>\n<td>x加y</td>\n<td>x+y</td>\n<td>3</td>\n</tr>\n<tr>\n<td>-</td>\n<td>x减y</td>\n<td>x-y</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>瞧, 非常符合小学数学的优先级概念, 乘法要比加法先算, 次方要比乘法先算 😃</p>\n<p>算术运算符, 可以与赋值运算符相互结合:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a += <span class=\"number\">1</span>  <span class=\"comment\"># 是上面的等价物</span></span><br></pre></td></tr></table></figure>\n<p>类似的, 还有 <code>-=</code>, <code>*=</code>, <code>%=</code><br>\n这种语法在变量名很长时, 会很有用, 不必把变量名写两遍</p>\n<h2 id=\"guan-xi-yun-suan-fu\" id=\"关系运算符\">关系运算符</h2>\n<p>关系运算符, 若关系成立则返回 True, 不然返回 False, 如 <code>1 &lt; 2</code> 是 True, 因此又称为 比较运算符<br>\n(关系运算符并不注重优先级, 谁先谁后一眼就看出来了)</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;</td>\n<td>x 大于 y</td>\n<td>x &gt; y</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>x 小于 y</td>\n<td>x &lt; y</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>x 大于等于 y</td>\n<td>x &gt;= y</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>x 小于等于 y</td>\n<td>x &lt;= y</td>\n</tr>\n<tr>\n<td>==</td>\n<td>x 等于 y</td>\n<td>x == y</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>x 不等于 y</td>\n<td>x != y</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注:</strong><br>\n本博客使用了连体字特性, 因此你看见的&gt;=其实是&gt;号右边跟着=, !=其实是感叹号!后面跟着=, ==其实是两个=</p>\n<hr>\n<h1 id=\"ji-ben-shu-ju-jie-gou\">基本数据结构</h1>\n<p>数据结构, 其实就是数据的存储结构, 根据场景与数据之间的逻辑关系, 设计出的不同复杂程度的结构</p>\n<p>举个例子, 有种数据结构, 叫做 <code>队列 (Queue)</code>, 其实模拟的就是日常生活中排队的场景, 对数据进行存储:<br>\n在排队时, 来得越早离开越早, 来得越晚离开越晚, 这不难理解<br>\n此时的队列, 就是一个 <code>单向队列</code>, 只允许在一端删除元素(排队的人买好东西走了), 另一端增加数据(新来个排队的)</p>\n<p>根据不同的场景, 不同的逻辑关系, 需要使用不同的方式存储数据, 这种方式, 便是数据结构<br>\n当然, 我们此处仅学习基本数据结构</p>\n<h2 id=\"lie-biao\" id=\"列表\">列表</h2>\n<p>列表(list) 仅表示装着一定数量元素的序列, 可以通过 索引(index) 访问元素</p>\n<h3 id=\"dan-suo-yin\" id=\"单索引\">单索引</h3>\n<p>我们可以通过单个索引, 访问对应的单个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 有着 3 个元素的列表</span></span><br><span class=\"line\"><span class=\"built_in\">list</span> = [<span class=\"number\">300</span>, <span class=\"number\">400</span>, <span class=\"number\">500</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过索引, 访问元素 (索引从 0 开始)</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">0</span>]  <span class=\"comment\"># 300</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">1</span>]  <span class=\"comment\"># 400</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>[<span class=\"number\">2</span>]  <span class=\"comment\"># 500</span></span><br></pre></td></tr></table></figure>\n<div class=\"tips\">\n<p><strong>扩展: 为何 index 从 0 开始?</strong><br>\n因为, 所谓的index, 代表的概念, 其实是 <code>偏移量</code><br>\n实际上, py中的列表, 其元素的内存地址是连续的, 创建一个新的列表时, 会先申请一块内存空间, 用来存放元素<br>\n用下标得到元素时, 实际是通过下标, 计算该元素的对应内存地址, 进行访问, 那么, 如何计算的呢?</p>\n<p>你可以这样理解:<br>\n一个长度为 3(有 3 个元素)的列表, 拥有 3 块内存空间<br>\n你可以从左向右, 画 3 个紧挨在一起的格子, 列表本身, 就代表着这 3 个格子</p>\n<p>列表本身的内存地址, 其实就相当于第一个元素的内存地址, 你可以想象为第一个格子<br>\n如何访问第 1 个格子? 第一个格子向右跳 0 格<br>\n如何访问第 2 个格子? 第二个格子向右跳 1 格<br>\n如何访问第 3 个格子? 第三个格子向右跳 2 格</p>\n<p>现在懂了吧? 下标其实就是偏移量, 代表的是 <code>相对于第 1 个格子偏移了多少格</code><br>\n要访问第几个格子, 直接加上偏移量即可 (比如 <code>list[0]</code> 偏移了0, 是第一个元素)</p>\n<p>如果你非要把下标从 1 开始, 那就得这样:<br>\nlist[1] 代表第 1 个元素, 但相对于第一个元素的偏移量还是0<br>\n于是在根据下标1, 求第一个元素时, 偏移量就是 <code>1 - 1 = 0</code><br>\n同理, 根据下标2, 求第二个元素时, 偏移量就是 <code>2 - 1 = 1</code><br>\n同理, 嗯举下标index, 求第 index 个元素时, 偏移量就是 <code>index - 1</code></p>\n<p>如果你每次计算偏移量, 都得计算一遍 index-1, 次数一多起来不就会降低效率?<br>\n现代计算机其实可以忽略这点影响, 但早期计算机可是一寸内存一寸金, 这个习惯自然而然地被保留下来了<br>\n<s>(好吧, 原因其实真的只是因为习俗)</s></p>\n<p>而且在某些情况下, 下标从0开始会很方便, 有相关论文, 但本菜鸡看不懂 😃</p>\n</div>\n<p>py 中还存在 <code>负索引</code> 的语法糖, 也就是用负数来充当索引, 此时, 下标从右往左, 从 -1 依次递减<br>\n比如 <code>ls[-1]</code>, 就代表倒数第一个元素, <code>ls[-2]</code> 就代表倒数第二个元素</p>\n<p>举个例子, 已知 <code>a = [10, 20, 30, 40, 50]</code> 让我们将其与图表进行对立:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>元素</td>\n<td>10</td>\n<td>20</td>\n<td>30</td>\n<td>40</td>\n<td>50</td>\n</tr>\n<tr>\n<td>正索引</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>负索引</td>\n<td>-5</td>\n<td>-4</td>\n<td>-3</td>\n<td>-2</td>\n<td>-1</td>\n</tr>\n</tbody>\n</table>\n<p>显而易见的, <code>ls[-1]</code>, 就相当于 <code>ls[len(ls) - 1]</code> ( len(ls) 表示得到列表ls的长度 )</p>\n<h3 id=\"suo-yin-yue-jie\" id=\"索引越界\">索引越界</h3>\n<p>于此同时, 通过下标/索引访问某个列表的元素时, 不应该超出范围:</p>\n<figure class=\"highlight python\"><figcaption><span>demo.py</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">a[<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>当我们在命令行中执行 <code>python demo.py</code> (见 <a href=\"/posts/high-school-it/p2#huan-jing-da-jian\">p2: 基础科普#环境搭建</a> ) 或直接使用图形化工具, 点击运行按钮</p>\n<p>脑子想一想都知道肯定编译不过, 我们将得到以下报错:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent <span class=\"keyword\">call</span> <span class=\"keyword\">last</span>):</span><br><span class=\"line\">  File <span class=\"string\">&quot;/home/jedsek/a.py&quot;</span>, <span class=\"built_in\">line</span> <span class=\"number\">2</span>, in <span class=\"symbol\">&lt;module&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">a</span>[<span class=\"number\">5</span>]</span><br><span class=\"line\">    ~^^^</span><br><span class=\"line\">IndexError: <span class=\"keyword\">list</span> <span class=\"built_in\">index</span> out of <span class=\"built_in\">range</span></span><br></pre></td></tr></table></figure>\n<p>看不懂的直接像做玩英语完形一样当作 “哔(屏蔽词)” 跳过就好, index 是 “索引/下标的意思”, 这条报错表示, 下标越界了!<br>\n因为 a 是个长度为 5 的列表, 所以只能用 <code>n ∈ [0, 5) ∩ N (区间[0, 5) 范围内的自然数)</code> 来当下标, 即 0 到 4, 因此 5 是非法的<br>\n负索引也是一样的道理, 不能越界哟~~</p>\n<h3 id=\"qie-pian\" id=\"切片\">切片</h3>\n<p>切片, 能通过索引与冒号, 创建一个区间, 访问一定范围内, 列表的多个元素</p>\n<p>举个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">numbers = [<span class=\"number\">201</span>, <span class=\"number\">202</span>, <span class=\"number\">203</span>, <span class=\"number\">204</span>]  <span class=\"comment\"># 定义列表</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">4</span>]  <span class=\"comment\"># [201, 202, 203, 204]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">2</span>]  <span class=\"comment\"># [201, 202]</span></span><br><span class=\"line\">numbers[<span class=\"number\">0</span>:<span class=\"number\">1</span>]  <span class=\"comment\"># [201]</span></span><br></pre></td></tr></table></figure>\n<p>在上面的例子中, 我们通过索引+冒号, 创建了一个左开右闭的区间, 访问索引在该区间内的所有元素<br>\n我们通过 <code>list[m:n]</code>, 得到了一个子列表, 只要索引在 <code>[m, n) (左开右闭区间)</code> 内, 就会被放入这个子列表</p>\n<p>图表依然会较为直观:</p>\n<p><code>numbers = [201, 202, 203, 204]</code></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>切片</td>\n<td>对应索引</td>\n<td>取出的子列表</td>\n</tr>\n<tr>\n<td>0:4</td>\n<td>[0, 1, 2, 3]</td>\n<td>[201, 202, 203, 204]</td>\n</tr>\n<tr>\n<td>0:2</td>\n<td>[0, 1]</td>\n<td>[201, 202]</td>\n</tr>\n<tr>\n<td>0:1</td>\n<td>[0]</td>\n<td>[201]</td>\n</tr>\n<tr>\n<td>-3:-1</td>\n<td>[-3, -2]</td>\n<td>[202, 203]</td>\n</tr>\n</tbody>\n</table>\n<p>默认的步长是1, 我们还可以再加一个冒号设置其步长, 比如 <code>numbers[0:4:1]</code> 就相当于 <code>numbers[0:4]</code><br>\n而 <code>numbers[0:4:2]</code> 则相当于从 <code>[0, 1, 2, 3]</code> 中的第一个元素 <code>0</code> 开始, 作为下标取 numbers 的元素, 然后走两步到 <code>2</code>, 依次类推<br>\n步长不能设置为 0, 不然会报错</p>\n<p>有个地方需要注意: 当切片对应的索引个数为 0 时, 子列表是个空列表, 即单个的 <code>[]</code><br>\n举个例子: <code>numbers[3:2]</code> 将会得到空列表, 因为步长默认是 1, 而索引越界会直接报错, 两者注意区分</p>\n<h3 id=\"sheng-lue-yu-mo-ren-zhi\" id=\"省略与默认值\">省略与默认值</h3>\n<p>关于此处的知识点, 前面已经提到过一部分了, 即步长默认是1, 但现在还有更多更多滴细节 😃</p>\n<p>已知 <code>a = [10, 20, 30, 40, 50]</code>, 你可以使用 <code>a[start:stop:step]</code> 来表示 a 的切片, 其中 start/stop/step 都是可以省略的<br>\n当它们被省略时, 会有一个默认值作为替补登场, 比如步长被省略, 即 <code>a[start:stop]</code>/<code>a[start:stop:]</code> 的形式时, 步长会使用默认值1</p>\n<p>而对于 <code>start/stop</code> 来讲, 当步长分别为正数或负数时, 默认值是不同的, 因为步长为正时, 切片是正着取元素的, 为负时自然是倒着取<br>\n举些例子, 已知 <code>a = [10, 20, 30, 40, 50, 60, 70]</code>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>a[2:5:1]</code> 中, <code>2:4</code> 对应的下标是 <code>[2, 3, 4]</code>, 索引对应的元素是 <code>[30, 40, 50]</code>, 因为步长为1, 所以结果直接就是 <code>[30, 40, 50]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::1]</code> 中,  右边界为省略, 因为步长为正, 其默认值是该列表的长度, 结果是 <code>[30, 40, 50, 60, 70]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:1]</code> 中, 左边界忽略, 因为步长为正, 其默认值是0, 结果是 <code>[10, 20]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[2::-1]</code> 中, 右边界忽略, 因为步长为负, 其默认值是0, 结果是 <code>[30, 20, 10]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>a[:2:-1]</code> 中, 左边界忽略, 因为步长为负, 其默认值是该列表长度, 结果是 <code>[70, 60, 50, 40]</code></p>\n</li>\n</ul>\n<p>什么鬼, 这是人能记得下来的? 而且这些还只是正索引, 对于负索引呢? 别慌, ***才直接背, 你只需要熟悉定义就行:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>start</code> 代表列表中某个元素的下标, 这个元素是切片的起头</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>stop</code> 代表列表中某个元素的下标, 原列表中该元素附近的那个元素才是切片的结尾 (因为左闭右开, 且步长正负不知)</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>step</code> 代表步长, 其正负决定正序还是倒序取, 其大小决定一次性跳过多少个元素后再取</p>\n</li>\n</ul>\n<p>要开始了哦, 超级直观的方法:</p>\n<p>以 <code>a[2:5:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>5</code>, 所以箭头的终点是 <code>50</code> (箭头从 60 逆方向缩一格): [10, 20, <s>30, 40, 50</s>&gt;, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: [10, 20, <s>30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n</ul>\n<p>以 <code>a[:2:1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为正, 先画条从左往右的箭头: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在左边的无限远处, 不用动: <s>[10, 20, 30, 40, 50, 60, 70]</s>&gt;</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>20</code> (箭头从 30 逆方向缩一格): <s>[10, 20</s>&gt;, 30, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[2::-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 是 <code>2</code>, 所以箭头的起点从 <code>30</code> 开始: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 被省略, 所以箭头无终点, 一直延伸: &lt;<s>[10, 20, 30</s>, 40, 50, 60, 70]</p>\n</li>\n</ul>\n<p>以 <code>a[:2:-1]</code> 为例:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>因为步长为负, 先画条从右往左的箭头: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>start</code> 被省略, 所以箭头的起点在右边的无限远处, 不用动: &lt;<s>[10, 20, 30, 40, 50, 60, 70]</s></p>\n</li>\n<li class=\"lvl-2\">\n<p>因为 <code>stop</code> 是 <code>2</code>, 所以箭头的终点是 <code>40</code> (箭头从 30 逆方向缩一格): [10, 20, 30, &lt;<s>40, 50, 60, 70]</s></p>\n</li>\n</ul>\n<p>对于负索引也是一样的道理, 先确定好 <code>start</code> 与 <code>stop</code> 的位置, 然后根据步长画对应方向的箭头<br>\n照这样算, 最后被覆盖的元素, 就是当步长大小为 1 时, 构成切片的元素, 逆序还是倒叙看箭头就行<br>\n最后根据步长大小, 决定跳过多少个元素后取一个, 将其作为切片的元素即可</p>\n<hr>\n<h2 id=\"zi-dian\" id=\"字典\">字典</h2>\n<p>python 中的字典, 实际上就是一些键值对组成的集合<br>\n键值对, 指的就是根据某个键值, 获取其对应的另外一个值</p>\n<p>举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>名字: “小明”</p>\n</li>\n<li class=\"lvl-2\">\n<p>年龄(year): 16</p>\n</li>\n<li class=\"lvl-2\">\n<p>身高(cm): 178</p>\n</li>\n</ul>\n<p>名字 -&gt; “小明”, 根据键, 得到对应的值, 这就是一对键值对, 由键值对组成的集合, 在 python 中便叫作字典了</p>\n<p>在 python 中, 你可以用一对花括号来定义字典:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"string\">&#x27;Shadd&#x27;</span>: <span class=\"number\">10</span>, <span class=\"string\">&#x27;Lasd&#x27;</span>: <span class=\"number\">111</span>, <span class=\"string\">&#x27;PPqwea&#x27;</span>: <span class=\"number\">899</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>冒号前的就是键, 冒号后的就是这个键对应的值, 键值对之间用逗号进行分割, 比如:  <code>a['Shadd']</code> 将得到 <code>10</code></p>"},{"abbrlink":"categories/gnome","hidden":true,"layout":"page","quicklink":true,"date":"2022-07-20T03:17:42.000Z","title":"GNOME","top":null,"keywords":null,"_content":"先占个位子, 日后再说~~\n\n- [GNOME 入坑指南](/posts/gnome/guide)\n","source":"_posts/categories/GNOME/index.md","raw":"---\nabbrlink: categories/gnome\nhidden: true\nlayout: page\nquicklink: true\ndate: 2022-07-20 11:17:42\ntitle: GNOME\ntop:\ntags:\ncategories:\nkeywords:\n---\n先占个位子, 日后再说~~\n\n- [GNOME 入坑指南](/posts/gnome/guide)\n","slug":"categories/GNOME/index","published":1,"updated":"2022-07-20T03:17:42.000Z","comments":1,"photos":[],"link":"","_id":"clagz86g0000a6aijgtu9hxrc","content":"<p>先占个位子, 日后再说~~</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/posts/gnome/guide\">GNOME 入坑指南</a></li>\n</ul>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":21,"excerpt":"","more":"<p>先占个位子, 日后再说~~</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/posts/gnome/guide\">GNOME 入坑指南</a></li>\n</ul>\n"},{"abbrlink":"categories/haskell-basic","hidden":true,"date":"2022-06-25T13:12:38.000Z","title":"haskell-basic","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1: 系列说明](/posts/haskell-basic/p1)\n[x]  [p2: 环境搭建](/posts/haskell-basic/p2)\n[x]  [p3: 函数式介绍](/posts/haskell-basic/p3)\n[x]  [p4: 基础语法](/posts/haskell-basic/p4)\n[ ]  [p5: 类型与类型类](/posts/haskell-basic/p5)","source":"_posts/categories/haskell/basic.md","raw":"---\nabbrlink: categories/haskell-basic\nhidden: true\ndate: 2022-06-25 21:12:38\ntitle: haskell-basic\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1: 系列说明](/posts/haskell-basic/p1)\n[x]  [p2: 环境搭建](/posts/haskell-basic/p2)\n[x]  [p3: 函数式介绍](/posts/haskell-basic/p3)\n[x]  [p4: 基础语法](/posts/haskell-basic/p4)\n[ ]  [p5: 类型与类型类](/posts/haskell-basic/p5)","slug":"categories/haskell/basic","published":1,"updated":"2022-06-25T13:12:38.000Z","comments":1,"photos":[],"link":"","_id":"clagz86g1000b6aijh59vd7je","content":"<p><input type=\"checkbox\" id=\"checkbox4\" checked=\"true\"><label for=\"checkbox4\"> </label><a href=\"/posts/haskell-basic/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox3\" checked=\"true\"><label for=\"checkbox3\"> </label><a href=\"/posts/haskell-basic/p2\">p2: 环境搭建</a><br>\n<input type=\"checkbox\" id=\"checkbox2\" checked=\"true\"><label for=\"checkbox2\"> </label><a href=\"/posts/haskell-basic/p3\">p3: 函数式介绍</a><br>\n<input type=\"checkbox\" id=\"checkbox1\" checked=\"true\"><label for=\"checkbox1\"> </label><a href=\"/posts/haskell-basic/p4\">p4: 基础语法</a><br>\n<input type=\"checkbox\" id=\"checkbox0\"><label for=\"checkbox0\"> </label><a href=\"/posts/haskell-basic/p5\">p5: 类型与类型类</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":38,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox4\" checked=\"true\"><label for=\"checkbox4\"> </label><a href=\"/posts/haskell-basic/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox3\" checked=\"true\"><label for=\"checkbox3\"> </label><a href=\"/posts/haskell-basic/p2\">p2: 环境搭建</a><br>\n<input type=\"checkbox\" id=\"checkbox2\" checked=\"true\"><label for=\"checkbox2\"> </label><a href=\"/posts/haskell-basic/p3\">p3: 函数式介绍</a><br>\n<input type=\"checkbox\" id=\"checkbox1\" checked=\"true\"><label for=\"checkbox1\"> </label><a href=\"/posts/haskell-basic/p4\">p4: 基础语法</a><br>\n<input type=\"checkbox\" id=\"checkbox0\"><label for=\"checkbox0\"> </label><a href=\"/posts/haskell-basic/p5\">p5: 类型与类型类</a></p>\n"},{"abbrlink":"categories/high-school-it","hidden":true,"layout":"page","quicklink":true,"date":"2022-09-14T10:45:37.000Z","title":"","top":null,"keywords":null,"_content":"高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题  \n\n# 高一\n[x]  [p1: 数据与信息](/posts/high-school-it/p1)\n[x]  [p2: 基础科普](/posts/high-school-it/p2)\n[x]  [p3: python基础语法-part1](/posts/high-school-it/p3)\n[ ]  [p4: 进制的转换与应用](/posts/high-school-it/p4)\n","source":"_posts/categories/high-chool-it/index.md","raw":"---\nabbrlink: categories/high-school-it\nhidden: true\nlayout: page\nquicklink: true\ndate: 2022-09-14 18:45:37\ntitle:\ntop:\ntags:\ncategories:\nkeywords:\n---\n高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题  \n\n# 高一\n[x]  [p1: 数据与信息](/posts/high-school-it/p1)\n[x]  [p2: 基础科普](/posts/high-school-it/p2)\n[x]  [p3: python基础语法-part1](/posts/high-school-it/p3)\n[ ]  [p4: 进制的转换与应用](/posts/high-school-it/p4)\n","slug":"categories/high-chool-it/index","published":1,"updated":"2022-09-14T10:45:37.000Z","comments":1,"photos":[],"link":"","_id":"clagz86g4000d6aij4spqc1y6","content":"<p>高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题</p>\n<h1 id=\"gao-yi\">高一</h1>\n<p><input type=\"checkbox\" id=\"checkbox8\" checked=\"true\"><label for=\"checkbox8\"> </label><a href=\"/posts/high-school-it/p1\">p1: 数据与信息</a><br>\n<input type=\"checkbox\" id=\"checkbox7\" checked=\"true\"><label for=\"checkbox7\"> </label><a href=\"/posts/high-school-it/p2\">p2: 基础科普</a><br>\n<input type=\"checkbox\" id=\"checkbox6\" checked=\"true\"><label for=\"checkbox6\"> </label><a href=\"/posts/high-school-it/p3\">p3: python基础语法-part1</a><br>\n<input type=\"checkbox\" id=\"checkbox5\"><label for=\"checkbox5\"> </label><a href=\"/posts/high-school-it/p4\">p4: 进制的转换与应用</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":78,"excerpt":"","more":"<p>高中信息技术学科的知识点, 有兴趣者自看, 有空的话会增加一些习题</p>\n<h1 id=\"gao-yi\">高一</h1>\n<p><input type=\"checkbox\" id=\"checkbox8\" checked=\"true\"><label for=\"checkbox8\"> </label><a href=\"/posts/high-school-it/p1\">p1: 数据与信息</a><br>\n<input type=\"checkbox\" id=\"checkbox7\" checked=\"true\"><label for=\"checkbox7\"> </label><a href=\"/posts/high-school-it/p2\">p2: 基础科普</a><br>\n<input type=\"checkbox\" id=\"checkbox6\" checked=\"true\"><label for=\"checkbox6\"> </label><a href=\"/posts/high-school-it/p3\">p3: python基础语法-part1</a><br>\n<input type=\"checkbox\" id=\"checkbox5\"><label for=\"checkbox5\"> </label><a href=\"/posts/high-school-it/p4\">p4: 进制的转换与应用</a></p>\n"},{"title":"rust-async","abbrlink":"categories/rust-async","hidden":true,"date":"2021-12-04T13:23:28.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1: 系列说明](/posts/rust-async/p1)\n[x]  [p2: 异步简介](/posts/rust-async/p2)\n[x]  [p3: Future](/posts/rust-async/p3)\n[x]  [p4: 状态的保存与变换](/posts/rust-async/p4)\n","source":"_posts/categories/rust/async.md","raw":"---\ntitle: rust-async\nabbrlink: categories/rust-async\nhidden: true\ndate: 2021-12-04 21:23:28\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1: 系列说明](/posts/rust-async/p1)\n[x]  [p2: 异步简介](/posts/rust-async/p2)\n[x]  [p3: Future](/posts/rust-async/p3)\n[x]  [p4: 状态的保存与变换](/posts/rust-async/p4)\n","slug":"categories/rust/async","published":1,"updated":"2021-12-04T13:23:28.000Z","comments":1,"photos":[],"link":"","_id":"clagz86g5000f6aij6egh24ou","content":"<p><input type=\"checkbox\" id=\"checkbox12\" checked=\"true\"><label for=\"checkbox12\"> </label><a href=\"/posts/rust-async/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox11\" checked=\"true\"><label for=\"checkbox11\"> </label><a href=\"/posts/rust-async/p2\">p2: 异步简介</a><br>\n<input type=\"checkbox\" id=\"checkbox10\" checked=\"true\"><label for=\"checkbox10\"> </label><a href=\"/posts/rust-async/p3\">p3: Future</a><br>\n<input type=\"checkbox\" id=\"checkbox9\" checked=\"true\"><label for=\"checkbox9\"> </label><a href=\"/posts/rust-async/p4\">p4: 状态的保存与变换</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":34,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox12\" checked=\"true\"><label for=\"checkbox12\"> </label><a href=\"/posts/rust-async/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox11\" checked=\"true\"><label for=\"checkbox11\"> </label><a href=\"/posts/rust-async/p2\">p2: 异步简介</a><br>\n<input type=\"checkbox\" id=\"checkbox10\" checked=\"true\"><label for=\"checkbox10\"> </label><a href=\"/posts/rust-async/p3\">p3: Future</a><br>\n<input type=\"checkbox\" id=\"checkbox9\" checked=\"true\"><label for=\"checkbox9\"> </label><a href=\"/posts/rust-async/p4\">p4: 状态的保存与变换</a></p>\n"},{"title":"rust-decl-macro","abbrlink":"categories/rust-decl-macro","hidden":true,"date":"2021-12-04T14:30:59.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n呜呜呜呜呜呜呜呜呜呜呜呜...\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业...  \n\n您可以去看我在B站的相关视频: [传送门](https://www.bilibili.com/video/BV1Wv411W7FH/)  \n我迟早有一天会更完的 :)\n\n[x]  [p1: 系列说明](/posts/rust-decl-macro/p1)\n[x]  [p2: 从println!开始](/posts/rust-decl-macro/p2)\n[x]  [p3: 声明与使用](/posts/rust-decl-macro/p3)\n[x]  [p4: 重复](/posts/rust-decl-macro/p4)\n[ ]  [p5: 卫生性](/posts/rust-decl-macro/p5)\n[ ]  [p6: 实战: 递推序列生成器](/posts/rust-decl-macro/p6)\n[ ]  [p7: 作用域的导入与导出](/posts/rust-decl-macro/p7)\n[ ]  [p8: 模式: TT-Muncher](/posts/rust-decl-macro/p8)\n[ ]  [p9: 模式: 内用规则与尾部分隔符](/posts/rust-decl-macro/p9)\n","source":"_posts/categories/rust/decl-macro.md","raw":"---\ntitle: rust-decl-macro\nabbrlink: categories/rust-decl-macro\nhidden: true\ndate: 2021-12-04 22:30:59\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n呜呜呜呜呜呜呜呜呜呜呜呜...\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业...  \n\n您可以去看我在B站的相关视频: [传送门](https://www.bilibili.com/video/BV1Wv411W7FH/)  \n我迟早有一天会更完的 :)\n\n[x]  [p1: 系列说明](/posts/rust-decl-macro/p1)\n[x]  [p2: 从println!开始](/posts/rust-decl-macro/p2)\n[x]  [p3: 声明与使用](/posts/rust-decl-macro/p3)\n[x]  [p4: 重复](/posts/rust-decl-macro/p4)\n[ ]  [p5: 卫生性](/posts/rust-decl-macro/p5)\n[ ]  [p6: 实战: 递推序列生成器](/posts/rust-decl-macro/p6)\n[ ]  [p7: 作用域的导入与导出](/posts/rust-decl-macro/p7)\n[ ]  [p8: 模式: TT-Muncher](/posts/rust-decl-macro/p8)\n[ ]  [p9: 模式: 内用规则与尾部分隔符](/posts/rust-decl-macro/p9)\n","slug":"categories/rust/decl-macro","published":1,"updated":"2021-12-04T14:30:59.000Z","comments":1,"photos":[],"link":"","_id":"clagz86g7000h6aijdj6p35s4","content":"<p>呜呜呜呜呜呜呜呜呜呜呜呜…<br>\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业…</p>\n<p>您可以去看我在B站的相关视频: <a href=\"https://www.bilibili.com/video/BV1Wv411W7FH/\">传送门</a><br>\n我迟早有一天会更完的 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox21\" checked=\"true\"><label for=\"checkbox21\"> </label><a href=\"/posts/rust-decl-macro/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox20\" checked=\"true\"><label for=\"checkbox20\"> </label><a href=\"/posts/rust-decl-macro/p2\">p2: 从println!开始</a><br>\n<input type=\"checkbox\" id=\"checkbox19\" checked=\"true\"><label for=\"checkbox19\"> </label><a href=\"/posts/rust-decl-macro/p3\">p3: 声明与使用</a><br>\n<input type=\"checkbox\" id=\"checkbox18\" checked=\"true\"><label for=\"checkbox18\"> </label><a href=\"/posts/rust-decl-macro/p4\">p4: 重复</a><br>\n<input type=\"checkbox\" id=\"checkbox17\"><label for=\"checkbox17\"> </label><a href=\"/posts/rust-decl-macro/p5\">p5: 卫生性</a><br>\n<input type=\"checkbox\" id=\"checkbox16\"><label for=\"checkbox16\"> </label><a href=\"/posts/rust-decl-macro/p6\">p6: 实战: 递推序列生成器</a><br>\n<input type=\"checkbox\" id=\"checkbox15\"><label for=\"checkbox15\"> </label><a href=\"/posts/rust-decl-macro/p7\">p7: 作用域的导入与导出</a><br>\n<input type=\"checkbox\" id=\"checkbox14\"><label for=\"checkbox14\"> </label><a href=\"/posts/rust-decl-macro/p8\">p8: 模式: TT-Muncher</a><br>\n<input type=\"checkbox\" id=\"checkbox13\"><label for=\"checkbox13\"> </label><a href=\"/posts/rust-decl-macro/p9\">p9: 模式: 内用规则与尾部分隔符</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":175,"excerpt":"","more":"<p>呜呜呜呜呜呜呜呜呜呜呜呜…<br>\n我B站的视频早早早就已经更完了, 但博客却一直没有补完, 由于懒散与学业…</p>\n<p>您可以去看我在B站的相关视频: <a href=\"https://www.bilibili.com/video/BV1Wv411W7FH/\">传送门</a><br>\n我迟早有一天会更完的 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox21\" checked=\"true\"><label for=\"checkbox21\"> </label><a href=\"/posts/rust-decl-macro/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox20\" checked=\"true\"><label for=\"checkbox20\"> </label><a href=\"/posts/rust-decl-macro/p2\">p2: 从println!开始</a><br>\n<input type=\"checkbox\" id=\"checkbox19\" checked=\"true\"><label for=\"checkbox19\"> </label><a href=\"/posts/rust-decl-macro/p3\">p3: 声明与使用</a><br>\n<input type=\"checkbox\" id=\"checkbox18\" checked=\"true\"><label for=\"checkbox18\"> </label><a href=\"/posts/rust-decl-macro/p4\">p4: 重复</a><br>\n<input type=\"checkbox\" id=\"checkbox17\"><label for=\"checkbox17\"> </label><a href=\"/posts/rust-decl-macro/p5\">p5: 卫生性</a><br>\n<input type=\"checkbox\" id=\"checkbox16\"><label for=\"checkbox16\"> </label><a href=\"/posts/rust-decl-macro/p6\">p6: 实战: 递推序列生成器</a><br>\n<input type=\"checkbox\" id=\"checkbox15\"><label for=\"checkbox15\"> </label><a href=\"/posts/rust-decl-macro/p7\">p7: 作用域的导入与导出</a><br>\n<input type=\"checkbox\" id=\"checkbox14\"><label for=\"checkbox14\"> </label><a href=\"/posts/rust-decl-macro/p8\">p8: 模式: TT-Muncher</a><br>\n<input type=\"checkbox\" id=\"checkbox13\"><label for=\"checkbox13\"> </label><a href=\"/posts/rust-decl-macro/p9\">p9: 模式: 内用规则与尾部分隔符</a></p>\n"},{"abbrlink":"categories/rust-gstreamer","hidden":true,"layout":"page","quicklink":true,"date":"2022-10-22T14:25:49.000Z","title":"rust-gstreamer","top":null,"keywords":null,"_content":"\n这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust  \n值得注意的是, 这些一个都没有开始写 (悲  \n仅仅提醒自己不要忘记而已, 有空再写, 愉快鸽鸽鸽 :)\n\n[ ]  [p1: 系列说明](/posts/rust-gstreamer/p1)\n[ ]  [p2: Basic-管道的基础概念](/posts/rust-gstreamer/p2)\n[ ]  [p3: Basic-管道的动态构建](/posts/rust-gstreamer/p3)\n[ ]  [p4: Basic-时间管理](/posts/rust-gstreamer/p4)\n[ ]  [p5: Basic-与GUI集成](/posts/rust-gstreamer/p5)\n","source":"_posts/categories/rust/gstreamer.md","raw":"---\nabbrlink: categories/rust-gstreamer\nhidden: true\nlayout: page\nquicklink: true\ndate: 2022-10-22 22:25:49\ntitle: rust-gstreamer\ntop: \ntags:\ncategories:\nkeywords:\n---\n\n这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust  \n值得注意的是, 这些一个都没有开始写 (悲  \n仅仅提醒自己不要忘记而已, 有空再写, 愉快鸽鸽鸽 :)\n\n[ ]  [p1: 系列说明](/posts/rust-gstreamer/p1)\n[ ]  [p2: Basic-管道的基础概念](/posts/rust-gstreamer/p2)\n[ ]  [p3: Basic-管道的动态构建](/posts/rust-gstreamer/p3)\n[ ]  [p4: Basic-时间管理](/posts/rust-gstreamer/p4)\n[ ]  [p5: Basic-与GUI集成](/posts/rust-gstreamer/p5)\n","slug":"categories/rust/gstreamer","published":1,"updated":"2022-10-22T14:25:49.000Z","comments":1,"photos":[],"link":"","_id":"clagz86g9000j6aije8fd5b4q","content":"<p>这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust<br>\n值得注意的是, 这些一个都没有开始写 (悲<br>\n仅仅提醒自己不要忘记而已, 有空再写, 愉快鸽鸽鸽 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox26\"><label for=\"checkbox26\"> </label><a href=\"/posts/rust-gstreamer/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox25\"><label for=\"checkbox25\"> </label><a href=\"/posts/rust-gstreamer/p2\">p2: Basic-管道的基础概念</a><br>\n<input type=\"checkbox\" id=\"checkbox24\"><label for=\"checkbox24\"> </label><a href=\"/posts/rust-gstreamer/p3\">p3: Basic-管道的动态构建</a><br>\n<input type=\"checkbox\" id=\"checkbox23\"><label for=\"checkbox23\"> </label><a href=\"/posts/rust-gstreamer/p4\">p4: Basic-时间管理</a><br>\n<input type=\"checkbox\" id=\"checkbox22\"><label for=\"checkbox22\"> </label><a href=\"/posts/rust-gstreamer/p5\">p5: Basic-与GUI集成</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":149,"excerpt":"","more":"<p>这是 gstreamer 的基础教程, 不过代码不是冗杂的 C, 而是我喜欢的 Rust<br>\n值得注意的是, 这些一个都没有开始写 (悲<br>\n仅仅提醒自己不要忘记而已, 有空再写, 愉快鸽鸽鸽 😃</p>\n<p><input type=\"checkbox\" id=\"checkbox26\"><label for=\"checkbox26\"> </label><a href=\"/posts/rust-gstreamer/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox25\"><label for=\"checkbox25\"> </label><a href=\"/posts/rust-gstreamer/p2\">p2: Basic-管道的基础概念</a><br>\n<input type=\"checkbox\" id=\"checkbox24\"><label for=\"checkbox24\"> </label><a href=\"/posts/rust-gstreamer/p3\">p3: Basic-管道的动态构建</a><br>\n<input type=\"checkbox\" id=\"checkbox23\"><label for=\"checkbox23\"> </label><a href=\"/posts/rust-gstreamer/p4\">p4: Basic-时间管理</a><br>\n<input type=\"checkbox\" id=\"checkbox22\"><label for=\"checkbox22\"> </label><a href=\"/posts/rust-gstreamer/p5\">p5: Basic-与GUI集成</a></p>\n"},{"title":"rust-gui","abbrlink":"categories/rust-gui","hidden":true,"date":"2021-12-04T14:34:41.000Z","layout":"page","quicklink":true,"top":null,"keywords":null,"_content":"\n# GTK4\n\n[x]  [p1: 系列说明](/posts/rust-gtk4/p1)\n[x]  [p2: 创建窗口](/posts/rust-gtk4/p2)\n[x]  [p3: GObject-内存管理](/posts/rust-gtk4/p3)\n[x]  [p4: GObject-子类化](/posts/rust-gtk4/p4)\n\n- - -\n\n# Relm4\n[ ]  a\n","source":"_posts/categories/rust/gui.md","raw":"---\ntitle: rust-gui\nabbrlink: categories/rust-gui\nhidden: true\ndate: 2021-12-04 22:34:41\nlayout: page\nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n# GTK4\n\n[x]  [p1: 系列说明](/posts/rust-gtk4/p1)\n[x]  [p2: 创建窗口](/posts/rust-gtk4/p2)\n[x]  [p3: GObject-内存管理](/posts/rust-gtk4/p3)\n[x]  [p4: GObject-子类化](/posts/rust-gtk4/p4)\n\n- - -\n\n# Relm4\n[ ]  a\n","slug":"categories/rust/gui","published":1,"updated":"2021-12-04T14:34:41.000Z","comments":1,"photos":[],"link":"","_id":"clagz86ga000l6aij41gj6t0j","content":"<h1 id=\"gtk-4\">GTK4</h1>\n<p><input type=\"checkbox\" id=\"checkbox30\" checked=\"true\"><label for=\"checkbox30\"> </label><a href=\"/posts/rust-gtk4/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox29\" checked=\"true\"><label for=\"checkbox29\"> </label><a href=\"/posts/rust-gtk4/p2\">p2: 创建窗口</a><br>\n<input type=\"checkbox\" id=\"checkbox28\" checked=\"true\"><label for=\"checkbox28\"> </label><a href=\"/posts/rust-gtk4/p3\">p3: GObject-内存管理</a><br>\n<input type=\"checkbox\" id=\"checkbox27\" checked=\"true\"><label for=\"checkbox27\"> </label><a href=\"/posts/rust-gtk4/p4\">p4: GObject-子类化</a></p>\n<hr>\n<h1 id=\"relm-4\">Relm4</h1>\n<p><input type=\"checkbox\" id=\"checkbox31\"><label for=\"checkbox31\"> a</label></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":53,"excerpt":"","more":"<h1 id=\"gtk-4\">GTK4</h1>\n<p><input type=\"checkbox\" id=\"checkbox30\" checked=\"true\"><label for=\"checkbox30\"> </label><a href=\"/posts/rust-gtk4/p1\">p1: 系列说明</a><br>\n<input type=\"checkbox\" id=\"checkbox29\" checked=\"true\"><label for=\"checkbox29\"> </label><a href=\"/posts/rust-gtk4/p2\">p2: 创建窗口</a><br>\n<input type=\"checkbox\" id=\"checkbox28\" checked=\"true\"><label for=\"checkbox28\"> </label><a href=\"/posts/rust-gtk4/p3\">p3: GObject-内存管理</a><br>\n<input type=\"checkbox\" id=\"checkbox27\" checked=\"true\"><label for=\"checkbox27\"> </label><a href=\"/posts/rust-gtk4/p4\">p4: GObject-子类化</a></p>\n<hr>\n<h1 id=\"relm-4\">Relm4</h1>\n<p><input type=\"checkbox\" id=\"checkbox31\"><label for=\"checkbox31\"> a</label></p>\n"},{"abbrlink":"categories/rust-tui","hidden":true,"date":"2022-06-19T05:05:06.000Z","layout":"page","title":"rust-tui","quicklink":true,"top":null,"keywords":null,"_content":"\n[x]  [p1-系列说明](/posts/rust-tui/p1)","source":"_posts/categories/rust/tui.md","raw":"---\nabbrlink: categories/rust-tui\nhidden: true\ndate: 2022-06-19 13:05:06\nlayout: page\ntitle: rust-tui \nquicklink: true\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n[x]  [p1-系列说明](/posts/rust-tui/p1)","slug":"categories/rust/tui","published":1,"updated":"2022-06-19T05:05:06.000Z","comments":1,"photos":[],"link":"","_id":"clagz86gb000n6aij790d51l1","content":"<p><input type=\"checkbox\" id=\"checkbox32\" checked=\"true\"><label for=\"checkbox32\"> </label><a href=\"/posts/rust-tui/p1\">p1-系列说明</a></p>\n<!-- flag of hidden posts -->","site":{"data":{}},"length":7,"excerpt":"","more":"<p><input type=\"checkbox\" id=\"checkbox32\" checked=\"true\"><label for=\"checkbox32\"> </label><a href=\"/posts/rust-tui/p1\">p1-系列说明</a></p>\n"},{"title":"haskell-basic-p1: 系列说明","abbrlink":"posts/haskell-basic/p1","hidden":false,"date":"2022-06-25T13:22:14.000Z","top":6999,"keywords":["Haskell","函数式编程"],"_content":"> 欢迎大家来到 Haskell 的学习系列\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 系列说明\n本系列会介绍下Haskell, 同时学习它的语法与思想  \n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 :)  \n~~(毕竟是Haskell)~~\n\n- - -\n\n# 参考资料\n1. 书籍\n- [Learn You a Haskell for Great Good! (趣学指南)](http://learnyouahaskell.com/chapters)\n- [A Gentle Introduction to Haskell, Version 98](https://www.haskell.org/tutorial/)\n\n2. 论坛\n- [Haskell Discourse](https://discourse.haskell.org/)\n\n3. 博客\n- [Lambda Calculus (Lambda演算)](http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97)  \n- [Functors In Pictures (图解函子)](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n\n4. Wiki\n- [Haskell Wiki](https://wiki.haskell.org/)\n\n- - -\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","source":"_posts/haskell/basic/p1-系列说明.md","raw":"---\ntitle: \"haskell-basic-p1: 系列说明\"\nabbrlink: posts/haskell-basic/p1\nhidden: false\ndate: 2022-06-25 21:22:14\ntop: 6999\ntags: [Haskell]\nkeywords: [Haskell, 函数式编程]\n---\n> 欢迎大家来到 Haskell 的学习系列\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 系列说明\n本系列会介绍下Haskell, 同时学习它的语法与思想  \n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 :)  \n~~(毕竟是Haskell)~~\n\n- - -\n\n# 参考资料\n1. 书籍\n- [Learn You a Haskell for Great Good! (趣学指南)](http://learnyouahaskell.com/chapters)\n- [A Gentle Introduction to Haskell, Version 98](https://www.haskell.org/tutorial/)\n\n2. 论坛\n- [Haskell Discourse](https://discourse.haskell.org/)\n\n3. 博客\n- [Lambda Calculus (Lambda演算)](http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97)  \n- [Functors In Pictures (图解函子)](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\n\n4. Wiki\n- [Haskell Wiki](https://wiki.haskell.org/)\n\n- - -\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","slug":"haskell/basic/p1-系列说明","published":1,"updated":"2022-06-25T13:22:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gc000o6aij66yp4wai","content":"<blockquote>\n<p>欢迎大家来到 Haskell 的学习系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>\n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br>\n<s>(毕竟是Haskell)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://learnyouahaskell.com/chapters\">Learn You a Haskell for Great Good! (趣学指南)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.haskell.org/tutorial/\">A Gentle Introduction to Haskell, Version 98</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>论坛</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://discourse.haskell.org/\">Haskell Discourse</a></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\">Lambda Calculus (Lambda演算)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors In Pictures (图解函子)</a></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>Wiki</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://wiki.haskell.org/\">Haskell Wiki</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>\n","site":{"data":{}},"length":330,"excerpt":"<blockquote>\n<p>欢迎大家来到 Haskell 的学习系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍下Haskell, 同时学习它的语法与思想<br>\n这将会是个漫长的过程, 预计更新会很慢, 务必做好心理准备 😃<br>\n<s>(毕竟是Haskell)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://learnyouahaskell.com/chapters\">Learn You a Haskell for Great Good! (趣学指南)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.haskell.org/tutorial/\">A Gentle Introduction to Haskell, Version 98</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>论坛</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://discourse.haskell.org/\">Haskell Discourse</a></p>\n</li>\n</ul>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"http://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\">Lambda Calculus (Lambda演算)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\">Functors In Pictures (图解函子)</a></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>Wiki</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://wiki.haskell.org/\">Haskell Wiki</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>"},{"title":"haskell-basic-p2: 环境搭建","abbrlink":"posts/haskell-basic/p2","hidden":false,"date":"2022-06-25T13:57:14.000Z","top":6998,"keywords":["Haskell","函数式"],"_content":"> 首先, 我们得搭建好 Haskell 的环境\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 编译器 && 包管理\n本文假设你使用的是Linux系统  \n\n通过Linux发行版自带的包管理器, 下载 `haskell-platform` 来直接配置环境  \n随后, 你会获得 `ghc`, `ghci`, `cabal`  \n\n- `ghc`: Haskell 的编译器  \n- `ghci`: 一个REPL, 即用于新手学习的交互式解释器  \n- `cabal`: Hsakell的包管理器  \n\n(注, 你也可以选择下载另一个叫 `stack` 的包管理器, 不过我选择了 `cabal (官方的)`, 仅此而已)  \n\n请确保都能正确显示版本:  \n\n```bash\nghc -V\nghci -V\ncabal -V\n```\n\n本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 `ghci`, 因此 `cabal-install (即上面的 cabal)` 这东西不太会用到  \n\n - - -\n\n# 代码编辑\n\n推荐的代码编辑器:\n- Helix (强推)\n- Nvim/Vim\n- Emacs\n- Vscode\n\n如果你使用的是Vscode, 直接下载对应的Haskell插件  \n如果你使用的是 `Helix/Vim/Emacs`, 要下载对应的LSP: `haskell-language-server`  \n\n比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:  \n\n```bash\nsudo dnf copr enable -y petersen/haskell-language-server\nsudo dnf install -y haskell-language-server\n```\n\n如果你使用的是 [Helix](https://helix-editor.com/), LSP将会直接启用  \n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP  \n\n- - -\n\n# 换源\nHaskell的包都放在 [hackage](https://hackage.haskell.org/), 下载依赖时, 速度可能极慢  \n这时, 我们应该进行将其换成镜像源  \n\n若你使用cabal, 可以按照下面的做:\n\n```bash\ncabal user-config init\nsed -i 's/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g' ~/.cabal/config\nsed -i 's/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g' ~/.cabal/config\nsed -i 's/-- secure: True/secure: True/g' ~/.cabal/config\ncabal update\n```\n\n这会生成cabal的配置文件, 并且将url替换为中科大的源  \n\n至此, 环境准备工作已全部完成  \n下一节, 我们将正式开始学习 Haskell  \n\n- - -\n\n# 更改ghci提示符\n第一次执行 `ghci` 时, 你会发现前置的提示符为 `Prelude>`, 这是默认样式  \n但它会随着你引入的模块的增多, 而变得冗杂, 比如:  \n\n当你输入 `:m Data.Time` (表示引入一个模块, 后面会学), 前置提示符变成了 `Prelude Data.Time>`  \n\n为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:  \n\n```bash\necho ':set prompt \"ghci> \"' > ~/.ghci\nchmod go-w ~/.ghci\n```\n\n第一行更改提示符  \n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改  ","source":"_posts/haskell/basic/p2-环境搭建.md","raw":"---\ntitle: \"haskell-basic-p2: 环境搭建\"\nabbrlink: posts/haskell-basic/p2\nhidden: false\ndate: 2022-06-25 21:57:14\ntop: 6998\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\n---\n> 首先, 我们得搭建好 Haskell 的环境\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 编译器 && 包管理\n本文假设你使用的是Linux系统  \n\n通过Linux发行版自带的包管理器, 下载 `haskell-platform` 来直接配置环境  \n随后, 你会获得 `ghc`, `ghci`, `cabal`  \n\n- `ghc`: Haskell 的编译器  \n- `ghci`: 一个REPL, 即用于新手学习的交互式解释器  \n- `cabal`: Hsakell的包管理器  \n\n(注, 你也可以选择下载另一个叫 `stack` 的包管理器, 不过我选择了 `cabal (官方的)`, 仅此而已)  \n\n请确保都能正确显示版本:  \n\n```bash\nghc -V\nghci -V\ncabal -V\n```\n\n本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 `ghci`, 因此 `cabal-install (即上面的 cabal)` 这东西不太会用到  \n\n - - -\n\n# 代码编辑\n\n推荐的代码编辑器:\n- Helix (强推)\n- Nvim/Vim\n- Emacs\n- Vscode\n\n如果你使用的是Vscode, 直接下载对应的Haskell插件  \n如果你使用的是 `Helix/Vim/Emacs`, 要下载对应的LSP: `haskell-language-server`  \n\n比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:  \n\n```bash\nsudo dnf copr enable -y petersen/haskell-language-server\nsudo dnf install -y haskell-language-server\n```\n\n如果你使用的是 [Helix](https://helix-editor.com/), LSP将会直接启用  \n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP  \n\n- - -\n\n# 换源\nHaskell的包都放在 [hackage](https://hackage.haskell.org/), 下载依赖时, 速度可能极慢  \n这时, 我们应该进行将其换成镜像源  \n\n若你使用cabal, 可以按照下面的做:\n\n```bash\ncabal user-config init\nsed -i 's/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g' ~/.cabal/config\nsed -i 's/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g' ~/.cabal/config\nsed -i 's/-- secure: True/secure: True/g' ~/.cabal/config\ncabal update\n```\n\n这会生成cabal的配置文件, 并且将url替换为中科大的源  \n\n至此, 环境准备工作已全部完成  \n下一节, 我们将正式开始学习 Haskell  \n\n- - -\n\n# 更改ghci提示符\n第一次执行 `ghci` 时, 你会发现前置的提示符为 `Prelude>`, 这是默认样式  \n但它会随着你引入的模块的增多, 而变得冗杂, 比如:  \n\n当你输入 `:m Data.Time` (表示引入一个模块, 后面会学), 前置提示符变成了 `Prelude Data.Time>`  \n\n为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:  \n\n```bash\necho ':set prompt \"ghci> \"' > ~/.ghci\nchmod go-w ~/.ghci\n```\n\n第一行更改提示符  \n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改  ","slug":"haskell/basic/p2-环境搭建","published":1,"updated":"2022-06-25T13:57:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gd000q6aij13by565k","content":"<blockquote>\n<p>首先, 我们得搭建好 Haskell 的环境</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"bian-yi-qi-amp-amp-bao-guan-li\">编译器 &amp;&amp; 包管理</h1>\n<p>本文假设你使用的是Linux系统</p>\n<p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>\n随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ghc</code>: Haskell 的编译器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>cabal</code>: Hsakell的包管理器</p>\n</li>\n</ul>\n<p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p>\n<p>请确保都能正确显示版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ghc -V</span><br><span class=\"line\">ghci -V</span><br><span class=\"line\">cabal -V</span><br></pre></td></tr></table></figure>\n<p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p>\n<hr>\n<h1 id=\"dai-ma-bian-ji\">代码编辑</h1>\n<p>推荐的代码编辑器:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Helix (强推)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nvim/Vim</p>\n</li>\n<li class=\"lvl-2\">\n<p>Emacs</p>\n</li>\n<li class=\"lvl-2\">\n<p>Vscode</p>\n</li>\n</ul>\n<p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>\n如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p>\n<p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf copr <span class=\"built_in\">enable</span> -y petersen/haskell-language-server</span><br><span class=\"line\">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure>\n<p>如果你使用的是 <a href=\"https://helix-editor.com/\">Helix</a>, LSP将会直接启用<br>\n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p>\n<hr>\n<h1 id=\"huan-yuan\">换源</h1>\n<p>Haskell的包都放在 <a href=\"https://hackage.haskell.org/\">hackage</a>, 下载依赖时, 速度可能极慢<br>\n这时, 我们应该进行将其换成镜像源</p>\n<p>若你使用cabal, 可以按照下面的做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cabal user-config init</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">cabal update</span><br></pre></td></tr></table></figure>\n<p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p>\n<p>至此, 环境准备工作已全部完成<br>\n下一节, 我们将正式开始学习 Haskell</p>\n<hr>\n<h1 id=\"geng-gai-ghci-ti-shi-fu\">更改ghci提示符</h1>\n<p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>\n但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p>\n<p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p>\n<p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class=\"line\">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure>\n<p>第一行更改提示符<br>\n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>\n","site":{"data":{}},"length":1350,"excerpt":"<blockquote>\n<p>首先, 我们得搭建好 Haskell 的环境</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"bian-yi-qi-amp-amp-bao-guan-li\">编译器 &amp;&amp; 包管理</h1>\n<p>本文假设你使用的是Linux系统</p>\n<p>通过Linux发行版自带的包管理器, 下载 <code>haskell-platform</code> 来直接配置环境<br>\n随后, 你会获得 <code>ghc</code>, <code>ghci</code>, <code>cabal</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>ghc</code>: Haskell 的编译器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>ghci</code>: 一个REPL, 即用于新手学习的交互式解释器</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>cabal</code>: Hsakell的包管理器</p>\n</li>\n</ul>\n<p>(注, 你也可以选择下载另一个叫 <code>stack</code> 的包管理器, 不过我选择了 <code>cabal (官方的)</code>, 仅此而已)</p>\n<p>请确保都能正确显示版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ghc -V</span><br><span class=\"line\">ghci -V</span><br><span class=\"line\">cabal -V</span><br></pre></td></tr></table></figure>\n<p>本系列暂时只涉及 Haskell 的语法部分， 大部分时间花在 <code>ghci</code>, 因此 <code>cabal-install (即上面的 cabal)</code> 这东西不太会用到</p>\n<hr>\n<h1 id=\"dai-ma-bian-ji\">代码编辑</h1>\n<p>推荐的代码编辑器:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Helix (强推)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Nvim/Vim</p>\n</li>\n<li class=\"lvl-2\">\n<p>Emacs</p>\n</li>\n<li class=\"lvl-2\">\n<p>Vscode</p>\n</li>\n</ul>\n<p>如果你使用的是Vscode, 直接下载对应的Haskell插件<br>\n如果你使用的是 <code>Helix/Vim/Emacs</code>, 要下载对应的LSP: <code>haskell-language-server</code></p>\n<p>比如, 我现在用的是Fedora-Linux, 可以这样下载LSP:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf copr <span class=\"built_in\">enable</span> -y petersen/haskell-language-server</span><br><span class=\"line\">sudo dnf install -y haskell-language-server</span><br></pre></td></tr></table></figure>\n<p>如果你使用的是 <a href=\"https://helix-editor.com/\">Helix</a>, LSP将会直接启用<br>\n当然, 你也完全可以使用其他代码编辑器, 最好能支持LSP</p>\n<hr>\n<h1 id=\"huan-yuan\">换源</h1>\n<p>Haskell的包都放在 <a href=\"https://hackage.haskell.org/\">hackage</a>, 下载依赖时, 速度可能极慢<br>\n这时, 我们应该进行将其换成镜像源</p>\n<p>若你使用cabal, 可以按照下面的做:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cabal user-config init</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/repository hackage.haskell.org/repository mirrors.ustc.edu.cn/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/http:\\/\\/hackage.haskell.org\\//http:\\/\\/mirrors.ustc.edu.cn\\/hackage\\//g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/-- secure: True/secure: True/g&#x27;</span> ~/.cabal/config</span><br><span class=\"line\">cabal update</span><br></pre></td></tr></table></figure>\n<p>这会生成cabal的配置文件, 并且将url替换为中科大的源</p>\n<p>至此, 环境准备工作已全部完成<br>\n下一节, 我们将正式开始学习 Haskell</p>\n<hr>\n<h1 id=\"geng-gai-ghci-ti-shi-fu\">更改ghci提示符</h1>\n<p>第一次执行 <code>ghci</code> 时, 你会发现前置的提示符为 <code>Prelude&gt;</code>, 这是默认样式<br>\n但它会随着你引入的模块的增多, 而变得冗杂, 比如:</p>\n<p>当你输入 <code>:m Data.Time</code> (表示引入一个模块, 后面会学), 前置提示符变成了 <code>Prelude Data.Time&gt;</code></p>\n<p>为了防止每引入模块过多, 导致前置提示符过于杂乱, 可以选择修改 ghci 的前置符, 比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;:set prompt &quot;ghci&gt; &quot;&#x27;</span> &gt; ~/.ghci</span><br><span class=\"line\">chmod go-w ~/.ghci</span><br></pre></td></tr></table></figure>\n<p>第一行更改提示符<br>\n第二行移除可写权限, 防止他人更改, 不然 ghci 会警告, 然后拒绝更改</p>"},{"title":"haskell-basic-p4: 基础语法","abbrlink":"posts/haskell-basic/p4","hidden":false,"date":"2022-07-12T13:46:05.000Z","top":6996,"keywords":["Haskell","函数式"],"_content":"> 关于 Haskell 的数字, Bool, List, If语句\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\nHaskell 是一门静态强类型语言, 我们接下来将学习一些基础类型  \n你可以在终端敲下 `ghci` 进入交互解释器, 去执行接下来的代码  \n\n# 数字  \n\n```haskell\n(2 + 8) * 9 - 10   -- 80\n5 / 2              -- 2.5\n5 ^ 2              -- 25\n5 ^  (2.0)         -- error\n5 ** (2.0)         -- 25.0 \n```\n\n加减乘除就不说了, 对于 `^` 与 `**` 都是幂函数, 底数的类型随意  \n但 `^` 接受的指数是个整数, `**` 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)  \n以上的运算符号, 实际上都是函数  \n\n比如, 你可以键入 `:t (+)`, 来得到 `+` 这个函数的类型:  \n\n```haskell\n(+) :: Num a => a -> a -> a\n```\n\n`=>` 后面的表示参数与返回值的类型  \n`=>` 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface  \n\n看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 `ghci` 中, 如何查看类型而已  \n以上的东西, 实际上类似于:  \n\n```\nfunction (+)<a: Num> (a, a, a) -> a { }\n```\n\nHaskell 中的小写字母相当于无约束的泛型, 啥都能匹配  \nNum 这个类型类了, 便起到一个约束的作用  \n\n同时, 由于加法函数的定义, `\"ABC\" + 123` 这样的表达式, 会直接报错  \n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a  \n\n- - -\n\n# Bool \n\n```haskell\nTrue && False      -- False\nTrue || False      -- True\nnot True           -- False\n```\n\n你还可以用 `==` 或 `/=` 来得到一个Bool值:  \n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)\n\n```haskell\n1 == 0             -- False\n2 + 3 == 1 + 4     -- True\n\"ABC\" /= \"AB\"      -- True\n```\n\n值得注意的是, 等号与不等号的左右, 两个值的类型必须相等  \n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型  \n可以键入 `:t (==)` 查看其类型:  \n\n```haskell\n(==) :: Eq a => a -> a -> Bool\n```\n\n表示接受的两个参数, 其类型相同, 都是a  \n并且a类型必须具有相等性, 返回值是Bool类型  \n\n注意:  \n由于其定义, `\"ABC\" == 123` 这样的表达式, 会直接报错  \n原因与先前的加法函数同理\n\n等到后面, 我们可以自己动手, 实现 `&&`, `||`, `not` 这三个函数  \n甚至连 If语句, 我们都可以自己写个函数来代替  \n\nIf语句在 Haskell 中仅仅是个语法糖而已  \n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 `if-else` 这样的语法糖  \n感兴趣的话, 可以自己去看下: [传送门](https://wiki.haskell.org/If-then-else)  \n\n- - -\n\n# List\nList(列表), 在 Haskell 中扮演着一个非常重要的角色  \n就像是其他语言的数组一样, 但却更加强大  \n\n## 省略右端\n像下面, 就创建了一个有十个元素的List:  \n\n```haskell\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n上面的List, 类型为 `Num a => [a]`  \na 实际上就是元素的类型, [a] 表示装着这种类型元素的List  \n\n虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: `take`  \n你可以查看它的类型:\n\n```haskell\ntake :: Int -> [a] -> [a]\n```\n\n这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List  \n比如:\n\n```haskell\ntake 5 [1,2,3,4,5,6,7,8,9,10]      -- [1,2,3,4,5]\n```\n\n这个函数你马上就会用到, 在处理无限元素的List时非常好用  \n\n回到刚才, 你可以一个个地输入元素, 创建List  \n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样  \n\n```haskell\n[1..10]\n[1..100]\n[1..1000]\n```\n\n诸如 `[m..n]` 这样的形式, 会创建一个闭区间, 从m遍历到n  \n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 `Enum` 这个类型类的成员  \n从 Rust, Scala, Java 等语言出发, 相当于实现了 `Enum` 这个 Trait/Interface  \n\n你甚至可以舍去右端, 写下 `[1..]` 这样的式子来表达1到无穷  \n你还可以生成 [Char], 比如 `['a'..'z']` 将会生成 `\"abcdefghijklmnopqrstuvwxyz\"`, 因为String类型等价于 [Char]  \n\n值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a  \n当a也是 `Bounded` 类型类的成员时, 说明这种类型一定有边界, 比如 `Int`, `Char` 等  \n不然的话, a将无界, 比如 `[1..]` 便是一个真正的, 从1到正无穷的List, 类型为 `Num a => [a]`  \n\n当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 `Num a => a` 呢?  \n\n事实上, 这是 Haskell 中为数不多的隐式行为  \n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型  \n\n举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:  \n\n```haskell\na = 100::Integer      -- 100\na + 1                 -- 101\na + 1::Int            -- error\n```\n\n我们先声明了a, 分别与整数字面量, Int类型数字相加  \n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的  \n根据 [(+)函数](#shu-zi) 的定义, 同时也因为Integer是Num这个Typeclass的成员  \n\n回到先前的 `[1..]`, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求  \n\n## 设置步长\n先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点  \n同时, 取决于元素的类型, 会产生无限或有界的List  \n\n但是, 比如 [1..5] 会生成 `[1,2,3,4,5]`, 默认情况下的步长是1  \n如果你想调整步长的话, 可以像下面这样:  \n\n```haskell\n[1,3..]          -- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]\n[5,10..]         -- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]\n```\n\n你还可以设置小数的步长, 比如:\n\n```haskell\n[1.0, 1.5..]     -- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]\n```\n\n哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 :)\n\n## 列表推导\nHaskell 中的 List, 还有一个强大的地方, 那就是 `List Comprehension (列表推导)`  \n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数  \n  \n```haskell\n[x | x <- [1..], mod x 2 == 0]  -- [2,4,6,8,10,12,14,16,18, 20..]\n```\n\n你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 ~~(因为就是这样抄来的啊)~~  \n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: `{x | n ∈ Z, x = 2n}` , 表示了偶数集  \n\nHaskell 中的 `List Comprehension` 也有这么个杠:  \n\n```haskell\n[ x | x <- xs, bool_expr1, bool_expr2 ]   \n```\n\n- 用 `|` 分割组成的表达式, 与后面的推导  \n- xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个  \n- `bool_expr` 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个  \n\n可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了  \n\n```haskell\n[x + y | x <- [1..3], y <- [1..3]]                   -- [2,3,4,3,4,5,4,5,6]\n[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]  -- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]\n```\n\n其实, 就相当于 `多重for循环` + `最后一重for循环中的零个或多个if语句`  \n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:  \n\n- 第一个式子 `[x + y | x <- [1..3], y <- [1..3]]`, 相当于:  \n\n```Rust\nlet new_array\nfor x in [1..3]\n  for y in [1..3]\n    (x + y) -> new_array\n```\n\n- 第二个式子 `[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]`, 相当于:\n\n```Rust\nlet new_array\nfor x in [1..100]\n  if x `mod` 2 == 0 && x `mod` 3 == 0\n    (x) -> new_array\n```\n\n因此, 你可以对比下下面两种式子:  \n\n```haskell\n[ x * y | x <- [1..10], y <- [1..x]  ]\n[ x * y | x <- [1..y],  y <- [1..10] ]\n```\n\n第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过  \n\n好了, 关于List, 暂时先到这吧  \n其实后面还有很多关于List的, 毕竟它太重要了  \n\n- - -\n\n# If语句\n先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的  \n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci  \n\n毕竟 Haskell 比较特殊, 为了函数的 [纯度](/posts/haskell-basic/p3/#chun-han-shu) , 特意搞了一堆东西  \n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)\n\n开始吧!\n\n## 单if\n首先, 让我们新建一个文件, 命名为 `demo.hs`  \n\nBMI, Body Mass Index (身体质量指数)  \n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康  \n\n让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧  \n\n:::tips\n**你可以这样运行以 .hs 结尾的文件:**  \n1. 在 `demo.hs` 所在的目录下, 输入 `runghc demo.hs`, 不会留下目标文件  \n2. 输入 `ghc demo.hs`, 留下目标文件 `./demo`  \n:::\n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if  bmi > 25\n    then putStrLn \"Fat!!!\"\n  else putStrLn \"Thin!!!\"\n```\n\n先别在意那个 `do` 与 `<-` 是啥, 无视即可, 反正这段代码你应该也看得懂:  \n程序会读取输入, 作为 `bmi` 的值, 随后根据大小, 判断是胖是瘦  \n\n当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi > 25\n    then putStrLn \"Fat!!!\"\n    else putStrLn \"Thin!!!\"\n```\n\n也蛮美观的, 但我更喜欢压行 :)\n\n\n\n## 多If\n其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂...\n\n先前的 单If 实在不够, 没有区分输入不对劲的情况  \n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi < 0\n    then putStrLn \"What?\"\n  else if bmi > 25 \n    then putStrLn \"Fat!!!\"\n  else if bmi <= 25 && bmi <= 18.5 \n    then putStrLn \"Healthy!!!\"\n  else \n    putStrLn \"Thin!!!\"\n```\n\n哇, 看着好美, 好熟悉!  \n所以你为什么说没有多重If呢?  \n\n别急, 格式化之后:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n  if bmi < 0\n    then putStrLn \"What?\"\n    else\n      if bmi > 25\n        then putStrLn \"Fat!!!\"\n        else\n          if bmi <= 25 && bmi < 18.5\n            then putStrLn \"12\"\n            else putStrLn \"Thin!!!\"\n```\n\n懂了吧? 它只是 else 中再套一个 if-else 而已  \n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)  \n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)  \n\n这节就到这, 看辉夜3的最后一集去了~~\n","source":"_posts/haskell/basic/p4-基础语法.md","raw":"---\ntitle: \"haskell-basic-p4: 基础语法\"\nabbrlink: posts/haskell-basic/p4\nhidden: false\ndate: 2022-07-12 21:46:05\ntop: 6996\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\n---\n> 关于 Haskell 的数字, Bool, List, If语句\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\nHaskell 是一门静态强类型语言, 我们接下来将学习一些基础类型  \n你可以在终端敲下 `ghci` 进入交互解释器, 去执行接下来的代码  \n\n# 数字  \n\n```haskell\n(2 + 8) * 9 - 10   -- 80\n5 / 2              -- 2.5\n5 ^ 2              -- 25\n5 ^  (2.0)         -- error\n5 ** (2.0)         -- 25.0 \n```\n\n加减乘除就不说了, 对于 `^` 与 `**` 都是幂函数, 底数的类型随意  \n但 `^` 接受的指数是个整数, `**` 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)  \n以上的运算符号, 实际上都是函数  \n\n比如, 你可以键入 `:t (+)`, 来得到 `+` 这个函数的类型:  \n\n```haskell\n(+) :: Num a => a -> a -> a\n```\n\n`=>` 后面的表示参数与返回值的类型  \n`=>` 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface  \n\n看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 `ghci` 中, 如何查看类型而已  \n以上的东西, 实际上类似于:  \n\n```\nfunction (+)<a: Num> (a, a, a) -> a { }\n```\n\nHaskell 中的小写字母相当于无约束的泛型, 啥都能匹配  \nNum 这个类型类了, 便起到一个约束的作用  \n\n同时, 由于加法函数的定义, `\"ABC\" + 123` 这样的表达式, 会直接报错  \n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a  \n\n- - -\n\n# Bool \n\n```haskell\nTrue && False      -- False\nTrue || False      -- True\nnot True           -- False\n```\n\n你还可以用 `==` 或 `/=` 来得到一个Bool值:  \n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)\n\n```haskell\n1 == 0             -- False\n2 + 3 == 1 + 4     -- True\n\"ABC\" /= \"AB\"      -- True\n```\n\n值得注意的是, 等号与不等号的左右, 两个值的类型必须相等  \n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型  \n可以键入 `:t (==)` 查看其类型:  \n\n```haskell\n(==) :: Eq a => a -> a -> Bool\n```\n\n表示接受的两个参数, 其类型相同, 都是a  \n并且a类型必须具有相等性, 返回值是Bool类型  \n\n注意:  \n由于其定义, `\"ABC\" == 123` 这样的表达式, 会直接报错  \n原因与先前的加法函数同理\n\n等到后面, 我们可以自己动手, 实现 `&&`, `||`, `not` 这三个函数  \n甚至连 If语句, 我们都可以自己写个函数来代替  \n\nIf语句在 Haskell 中仅仅是个语法糖而已  \n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 `if-else` 这样的语法糖  \n感兴趣的话, 可以自己去看下: [传送门](https://wiki.haskell.org/If-then-else)  \n\n- - -\n\n# List\nList(列表), 在 Haskell 中扮演着一个非常重要的角色  \n就像是其他语言的数组一样, 但却更加强大  \n\n## 省略右端\n像下面, 就创建了一个有十个元素的List:  \n\n```haskell\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n上面的List, 类型为 `Num a => [a]`  \na 实际上就是元素的类型, [a] 表示装着这种类型元素的List  \n\n虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: `take`  \n你可以查看它的类型:\n\n```haskell\ntake :: Int -> [a] -> [a]\n```\n\n这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List  \n比如:\n\n```haskell\ntake 5 [1,2,3,4,5,6,7,8,9,10]      -- [1,2,3,4,5]\n```\n\n这个函数你马上就会用到, 在处理无限元素的List时非常好用  \n\n回到刚才, 你可以一个个地输入元素, 创建List  \n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样  \n\n```haskell\n[1..10]\n[1..100]\n[1..1000]\n```\n\n诸如 `[m..n]` 这样的形式, 会创建一个闭区间, 从m遍历到n  \n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 `Enum` 这个类型类的成员  \n从 Rust, Scala, Java 等语言出发, 相当于实现了 `Enum` 这个 Trait/Interface  \n\n你甚至可以舍去右端, 写下 `[1..]` 这样的式子来表达1到无穷  \n你还可以生成 [Char], 比如 `['a'..'z']` 将会生成 `\"abcdefghijklmnopqrstuvwxyz\"`, 因为String类型等价于 [Char]  \n\n值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a  \n当a也是 `Bounded` 类型类的成员时, 说明这种类型一定有边界, 比如 `Int`, `Char` 等  \n不然的话, a将无界, 比如 `[1..]` 便是一个真正的, 从1到正无穷的List, 类型为 `Num a => [a]`  \n\n当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 `Num a => a` 呢?  \n\n事实上, 这是 Haskell 中为数不多的隐式行为  \n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型  \n\n举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:  \n\n```haskell\na = 100::Integer      -- 100\na + 1                 -- 101\na + 1::Int            -- error\n```\n\n我们先声明了a, 分别与整数字面量, Int类型数字相加  \n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的  \n根据 [(+)函数](#shu-zi) 的定义, 同时也因为Integer是Num这个Typeclass的成员  \n\n回到先前的 `[1..]`, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求  \n\n## 设置步长\n先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点  \n同时, 取决于元素的类型, 会产生无限或有界的List  \n\n但是, 比如 [1..5] 会生成 `[1,2,3,4,5]`, 默认情况下的步长是1  \n如果你想调整步长的话, 可以像下面这样:  \n\n```haskell\n[1,3..]          -- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]\n[5,10..]         -- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]\n```\n\n你还可以设置小数的步长, 比如:\n\n```haskell\n[1.0, 1.5..]     -- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]\n```\n\n哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 :)\n\n## 列表推导\nHaskell 中的 List, 还有一个强大的地方, 那就是 `List Comprehension (列表推导)`  \n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数  \n  \n```haskell\n[x | x <- [1..], mod x 2 == 0]  -- [2,4,6,8,10,12,14,16,18, 20..]\n```\n\n你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 ~~(因为就是这样抄来的啊)~~  \n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: `{x | n ∈ Z, x = 2n}` , 表示了偶数集  \n\nHaskell 中的 `List Comprehension` 也有这么个杠:  \n\n```haskell\n[ x | x <- xs, bool_expr1, bool_expr2 ]   \n```\n\n- 用 `|` 分割组成的表达式, 与后面的推导  \n- xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个  \n- `bool_expr` 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个  \n\n可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了  \n\n```haskell\n[x + y | x <- [1..3], y <- [1..3]]                   -- [2,3,4,3,4,5,4,5,6]\n[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]  -- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]\n```\n\n其实, 就相当于 `多重for循环` + `最后一重for循环中的零个或多个if语句`  \n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:  \n\n- 第一个式子 `[x + y | x <- [1..3], y <- [1..3]]`, 相当于:  \n\n```Rust\nlet new_array\nfor x in [1..3]\n  for y in [1..3]\n    (x + y) -> new_array\n```\n\n- 第二个式子 `[x | x <- [1..100], x `mod` 2 == 0, x `mod` 3 == 0]`, 相当于:\n\n```Rust\nlet new_array\nfor x in [1..100]\n  if x `mod` 2 == 0 && x `mod` 3 == 0\n    (x) -> new_array\n```\n\n因此, 你可以对比下下面两种式子:  \n\n```haskell\n[ x * y | x <- [1..10], y <- [1..x]  ]\n[ x * y | x <- [1..y],  y <- [1..10] ]\n```\n\n第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过  \n\n好了, 关于List, 暂时先到这吧  \n其实后面还有很多关于List的, 毕竟它太重要了  \n\n- - -\n\n# If语句\n先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的  \n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci  \n\n毕竟 Haskell 比较特殊, 为了函数的 [纯度](/posts/haskell-basic/p3/#chun-han-shu) , 特意搞了一堆东西  \n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)\n\n开始吧!\n\n## 单if\n首先, 让我们新建一个文件, 命名为 `demo.hs`  \n\nBMI, Body Mass Index (身体质量指数)  \n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康  \n\n让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧  \n\n:::tips\n**你可以这样运行以 .hs 结尾的文件:**  \n1. 在 `demo.hs` 所在的目录下, 输入 `runghc demo.hs`, 不会留下目标文件  \n2. 输入 `ghc demo.hs`, 留下目标文件 `./demo`  \n:::\n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if  bmi > 25\n    then putStrLn \"Fat!!!\"\n  else putStrLn \"Thin!!!\"\n```\n\n先别在意那个 `do` 与 `<-` 是啥, 无视即可, 反正这段代码你应该也看得懂:  \n程序会读取输入, 作为 `bmi` 的值, 随后根据大小, 判断是胖是瘦  \n\n当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi > 25\n    then putStrLn \"Fat!!!\"\n    else putStrLn \"Thin!!!\"\n```\n\n也蛮美观的, 但我更喜欢压行 :)\n\n\n\n## 多If\n其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂...\n\n先前的 单If 实在不够, 没有区分输入不对劲的情况  \n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n\n  if bmi < 0\n    then putStrLn \"What?\"\n  else if bmi > 25 \n    then putStrLn \"Fat!!!\"\n  else if bmi <= 25 && bmi <= 18.5 \n    then putStrLn \"Healthy!!!\"\n  else \n    putStrLn \"Thin!!!\"\n```\n\n哇, 看着好美, 好熟悉!  \n所以你为什么说没有多重If呢?  \n\n别急, 格式化之后:  \n\n```haskell\n-- demo.hs\n\nmain = do\n  putStrLn \"Please input your BMI:\"\n  bmi <- readLn\n  if bmi < 0\n    then putStrLn \"What?\"\n    else\n      if bmi > 25\n        then putStrLn \"Fat!!!\"\n        else\n          if bmi <= 25 && bmi < 18.5\n            then putStrLn \"12\"\n            else putStrLn \"Thin!!!\"\n```\n\n懂了吧? 它只是 else 中再套一个 if-else 而已  \n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)  \n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)  \n\n这节就到这, 看辉夜3的最后一集去了~~\n","slug":"haskell/basic/p4-基础语法","published":1,"updated":"2022-07-12T13:46:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86ge000s6aij9frf2k7h","content":"<blockquote>\n<p>关于 Haskell 的数字, Bool, List, If语句</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>\n你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p>\n<h1 id=\"shu-zi\">数字</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">2</span> + <span class=\"number\">8</span>) * <span class=\"number\">9</span> - <span class=\"number\">10</span>   <span class=\"comment\">-- 80</span></span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span>              <span class=\"comment\">-- 2.5</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^ <span class=\"number\">2</span>              <span class=\"comment\">-- 25</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^  (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- error</span></span><br><span class=\"line\"><span class=\"number\">5</span> ** (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- 25.0 </span></span><br></pre></td></tr></table></figure>\n<p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>\n但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>\n以上的运算符号, 实际上都是函数</p>\n<p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(+) :: <span class=\"type\">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>\n<p><code>=&gt;</code> 后面的表示参数与返回值的类型<br>\n<code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p>\n<p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>\n以上的东西, 实际上类似于:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"params\">(+)</span>&lt;<span class=\"title\">a</span>: <span class=\"title\">Num</span>&gt; <span class=\"params\">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>\nNum 这个类型类了, 便起到一个约束的作用</p>\n<p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>\n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p>\n<hr>\n<h1 id=\"bool\">Bool</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">True</span> &amp;&amp; <span class=\"type\">False</span>      <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"type\">True</span> || <span class=\"type\">False</span>      <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"title\">not</span> <span class=\"type\">True</span>           <span class=\"comment\">-- False</span></span><br></pre></td></tr></table></figure>\n<p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>\n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> == <span class=\"number\">0</span>             <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"number\">2</span> + <span class=\"number\">3</span> == <span class=\"number\">1</span> + <span class=\"number\">4</span>     <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"string\">&quot;ABC&quot;</span> /= <span class=\"string\">&quot;AB&quot;</span>      <span class=\"comment\">-- True</span></span><br></pre></td></tr></table></figure>\n<p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>\n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>\n可以键入 <code>:t (==)</code> 查看其类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(==) :: <span class=\"type\">Eq</span> a =&gt; a -&gt; a -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>表示接受的两个参数, 其类型相同, 都是a<br>\n并且a类型必须具有相等性, 返回值是Bool类型</p>\n<p>注意:<br>\n由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>\n原因与先前的加法函数同理</p>\n<p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>\n甚至连 If语句, 我们都可以自己写个函数来代替</p>\n<p>If语句在 Haskell 中仅仅是个语法糖而已<br>\n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>\n感兴趣的话, 可以自己去看下: <a href=\"https://wiki.haskell.org/If-then-else\">传送门</a></p>\n<hr>\n<h1 id=\"list\">List</h1>\n<p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>\n就像是其他语言的数组一样, 但却更加强大</p>\n<h2 id=\"sheng-lue-you-duan\" id=\"省略右端\">省略右端</h2>\n<p>像下面, 就创建了一个有十个元素的List:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>\na 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p>\n<p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>\n你可以查看它的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> :: <span class=\"type\">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>\n<p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>\n比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> <span class=\"number\">5</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]      <span class=\"comment\">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p>\n<p>回到刚才, 你可以一个个地输入元素, 创建List<br>\n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.10</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.100</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.1000</span>]</span><br></pre></td></tr></table></figure>\n<p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>\n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>\n从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p>\n<p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>\n你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p>\n<p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>\n当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>\n不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p>\n<p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p>\n<p>事实上, 这是 Haskell 中为数不多的隐式行为<br>\n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p>\n<p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">a</span> = <span class=\"number\">100</span>::<span class=\"type\">Integer</span>      <span class=\"comment\">-- 100</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>                 <span class=\"comment\">-- 101</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>::<span class=\"type\">Int</span>            <span class=\"comment\">-- error</span></span><br></pre></td></tr></table></figure>\n<p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>\n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>\n根据 <a href=\"#shu-zi\">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p>\n<p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p>\n<h2 id=\"she-zhi-bu-chang\" id=\"设置步长\">设置步长</h2>\n<p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>\n同时, 取决于元素的类型, 会产生无限或有界的List</p>\n<p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>\n如果你想调整步长的话, 可以像下面这样:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3.</span>.]          <span class=\"comment\">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">10.</span>.]         <span class=\"comment\">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure>\n<p>你还可以设置小数的步长, 比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.0</span>, <span class=\"number\">1.5</span>..]     <span class=\"comment\">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure>\n<p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p>\n<h2 id=\"lie-biao-tui-dao\" id=\"列表推导\">列表推导</h2>\n<p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>\n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span>.], mod x <span class=\"number\">2</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure>\n<p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>\n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p>\n<p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p>\n</li>\n<li class=\"lvl-2\">\n<p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p>\n</li>\n</ul>\n<p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x + y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>], y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>]]                   <span class=\"comment\">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.100</span>], x `mod` <span class=\"number\">2</span> == <span class=\"number\">0</span>, x `mod` <span class=\"number\">3</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure>\n<p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>\n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">100</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x `<span class=\"keyword\">mod</span>` <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; x `<span class=\"keyword\">mod</span>` <span class=\"number\">3</span> == <span class=\"number\">0</span></span><br><span class=\"line\">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<p>因此, 你可以对比下下面两种式子:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>], y &lt;- [<span class=\"number\">1.</span>.x]  ]</span><br><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span>.y],  y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>] ]</span><br></pre></td></tr></table></figure>\n<p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p>\n<p>好了, 关于List, 暂时先到这吧<br>\n其实后面还有很多关于List的, 毕竟它太重要了</p>\n<hr>\n<h1 id=\"if-yu-ju\">If语句</h1>\n<p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>\n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p>\n<p>毕竟 Haskell 比较特殊, 为了函数的 <a href=\"/posts/haskell-basic/p3/#chun-han-shu\">纯度</a> , 特意搞了一堆东西<br>\n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p>\n<p>开始吧!</p>\n<h2 id=\"dan-if\" id=\"单if\">单if</h2>\n<p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p>\n<p>BMI, Body Mass Index (身体质量指数)<br>\n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p>\n<p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p>\n<div class=\"tips\">\n<p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p>\n<ol>\n<li class=\"lvl-3\">在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</li>\n<li class=\"lvl-3\">输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></li>\n</ol>\n</div>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>  bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>\n程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p>\n<p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>也蛮美观的, 但我更喜欢压行 😃</p>\n<h2 id=\"duo-if\" id=\"多If\">多If</h2>\n<p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p>\n<p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>\n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt;= <span class=\"number\">18.5</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Healthy!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">    putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>哇, 看着好美, 好熟悉!<br>\n所以你为什么说没有多重If呢?</p>\n<p>别急, 格式化之后:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">        <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt; <span class=\"number\">18.5</span></span><br><span class=\"line\">            <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;12&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>\n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>\n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p>\n<p>这节就到这, 看辉夜3的最后一集去了~~</p>\n","site":{"data":{}},"length":5117,"excerpt":"<blockquote>\n<p>关于 Haskell 的数字, Bool, List, If语句</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>Haskell 是一门静态强类型语言, 我们接下来将学习一些基础类型<br>\n你可以在终端敲下 <code>ghci</code> 进入交互解释器, 去执行接下来的代码</p>\n<h1 id=\"shu-zi\">数字</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">2</span> + <span class=\"number\">8</span>) * <span class=\"number\">9</span> - <span class=\"number\">10</span>   <span class=\"comment\">-- 80</span></span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span>              <span class=\"comment\">-- 2.5</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^ <span class=\"number\">2</span>              <span class=\"comment\">-- 25</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^  (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- error</span></span><br><span class=\"line\"><span class=\"number\">5</span> ** (<span class=\"number\">2.0</span>)         <span class=\"comment\">-- 25.0 </span></span><br></pre></td></tr></table></figure>\n<p>加减乘除就不说了, 对于 <code>^</code> 与 <code>**</code> 都是幂函数, 底数的类型随意<br>\n但 <code>^</code> 接受的指数是个整数, <code>**</code> 则可以接受小数/整数 (类型方面之后再讲, 这里有点不准确)<br>\n以上的运算符号, 实际上都是函数</p>\n<p>比如, 你可以键入 <code>:t (+)</code>, 来得到 <code>+</code> 这个函数的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(+) :: <span class=\"type\">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>\n<p><code>=&gt;</code> 后面的表示参数与返回值的类型<br>\n<code>=&gt;</code> 前的一块是类型类(Typeclass), 起类型约束的作用, 相当于其他语言的 trait/interface</p>\n<p>看不懂没关系, 之后会学, 跳过即可, 此处只是为了告诉你, 在 <code>ghci</code> 中, 如何查看类型而已<br>\n以上的东西, 实际上类似于:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"params\">(+)</span>&lt;<span class=\"title\">a</span>: <span class=\"title\">Num</span>&gt; <span class=\"params\">(a, a, a)</span> -&gt;</span> a &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>Haskell 中的小写字母相当于无约束的泛型, 啥都能匹配<br>\nNum 这个类型类了, 便起到一个约束的作用</p>\n<p>同时, 由于加法函数的定义, <code>&quot;ABC&quot; + 123</code> 这样的表达式, 会直接报错<br>\n因为不满足传入参数的要求: 两个参数的类型必须相等, 因为它们都是a</p>\n<hr>\n<h1 id=\"bool\">Bool</h1>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">True</span> &amp;&amp; <span class=\"type\">False</span>      <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"type\">True</span> || <span class=\"type\">False</span>      <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"title\">not</span> <span class=\"type\">True</span>           <span class=\"comment\">-- False</span></span><br></pre></td></tr></table></figure>\n<p>你还可以用 <code>==</code> 或 <code>/=</code> 来得到一个Bool值:<br>\n(注: 我的博客可能启用了连体字, 上面的等号是两个等号, 不等号是斜杠+等号)</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> == <span class=\"number\">0</span>             <span class=\"comment\">-- False</span></span><br><span class=\"line\"><span class=\"number\">2</span> + <span class=\"number\">3</span> == <span class=\"number\">1</span> + <span class=\"number\">4</span>     <span class=\"comment\">-- True</span></span><br><span class=\"line\"><span class=\"string\">&quot;ABC&quot;</span> /= <span class=\"string\">&quot;AB&quot;</span>      <span class=\"comment\">-- True</span></span><br></pre></td></tr></table></figure>\n<p>值得注意的是, 等号与不等号的左右, 两个值的类型必须相等<br>\n这是因为 Haskell 中的运算符都是函数, 已经定义好了类型<br>\n可以键入 <code>:t (==)</code> 查看其类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(==) :: <span class=\"type\">Eq</span> a =&gt; a -&gt; a -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>表示接受的两个参数, 其类型相同, 都是a<br>\n并且a类型必须具有相等性, 返回值是Bool类型</p>\n<p>注意:<br>\n由于其定义, <code>&quot;ABC&quot; == 123</code> 这样的表达式, 会直接报错<br>\n原因与先前的加法函数同理</p>\n<p>等到后面, 我们可以自己动手, 实现 <code>&amp;&amp;</code>, <code>||</code>, <code>not</code> 这三个函数<br>\n甚至连 If语句, 我们都可以自己写个函数来代替</p>\n<p>If语句在 Haskell 中仅仅是个语法糖而已<br>\n在 Haskell-Wiki 上, 甚至有个讨论, 正反双方辩论要不要抛弃 <code>if-else</code> 这样的语法糖<br>\n感兴趣的话, 可以自己去看下: <a href=\"https://wiki.haskell.org/If-then-else\">传送门</a></p>\n<hr>\n<h1 id=\"list\">List</h1>\n<p>List(列表), 在 Haskell 中扮演着一个非常重要的角色<br>\n就像是其他语言的数组一样, 但却更加强大</p>\n<h2 id=\"sheng-lue-you-duan\" id=\"省略右端\">省略右端</h2>\n<p>像下面, 就创建了一个有十个元素的List:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure>\n<p>上面的List, 类型为 <code>Num a =&gt; [a]</code><br>\na 实际上就是元素的类型, [a] 表示装着这种类型元素的List</p>\n<p>虽然我想把常用的函数放到之后再讲, 但还是得先教你一个: <code>take</code><br>\n你可以查看它的类型:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> :: <span class=\"type\">Int</span> -&gt; [a] -&gt; [a]</span><br></pre></td></tr></table></figure>\n<p>这表示, 它接受两个参数, 第一个表示要取前面多少个元素, 第二个是任意类型的List, 随后返回新的List<br>\n比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">take</span> <span class=\"number\">5</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>]      <span class=\"comment\">-- [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>这个函数你马上就会用到, 在处理无限元素的List时非常好用</p>\n<p>回到刚才, 你可以一个个地输入元素, 创建List<br>\n不过这太麻烦了, 如果我想要一百个, 一千个连续的整数呢? 你可以像下面这样</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.10</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.100</span>]</span><br><span class=\"line\">[<span class=\"number\">1.</span><span class=\"number\">.1000</span>]</span><br></pre></td></tr></table></figure>\n<p>诸如 <code>[m..n]</code> 这样的形式, 会创建一个闭区间, 从m遍历到n<br>\n当然, 得先保证元素本身的类型, 是可以进行遍历的, 即元素本身是 <code>Enum</code> 这个类型类的成员<br>\n从 Rust, Scala, Java 等语言出发, 相当于实现了 <code>Enum</code> 这个 Trait/Interface</p>\n<p>你甚至可以舍去右端, 写下 <code>[1..]</code> 这样的式子来表达1到无穷<br>\n你还可以生成 [Char], 比如 <code>['a'..'z']</code> 将会生成 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, 因为String类型等价于 [Char]</p>\n<p>值得注意的是, 忽略右端点时, 生成的List可能无穷大, 也可能是有界的, 我们先假设元素的类型为a<br>\n当a也是 <code>Bounded</code> 类型类的成员时, 说明这种类型一定有边界, 比如 <code>Int</code>, <code>Char</code> 等<br>\n不然的话, a将无界, 比如 <code>[1..]</code> 便是一个真正的, 从1到正无穷的List, 类型为 <code>Num a =&gt; [a]</code></p>\n<p>当你看到这里时, 可能会有个疑问: 1 的类型不应该是Int吗?  为什么会是 <code>Num a =&gt; a</code> 呢?</p>\n<p>事实上, 这是 Haskell 中为数不多的隐式行为<br>\n任何整数的字面量, 为了运算方便, 都把它们看作实现了Num类型类的类型, 以便于向下转型</p>\n<p>举个例子, 你使用了Integer(无限精度的Int) 与 整数字面量:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">a</span> = <span class=\"number\">100</span>::<span class=\"type\">Integer</span>      <span class=\"comment\">-- 100</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>                 <span class=\"comment\">-- 101</span></span><br><span class=\"line\"><span class=\"title\">a</span> + <span class=\"number\">1</span>::<span class=\"type\">Int</span>            <span class=\"comment\">-- error</span></span><br></pre></td></tr></table></figure>\n<p>我们先声明了a, 分别与整数字面量, Int类型数字相加<br>\n对于第一个加法, 1是个字面量, 是Num, 编译器可以自动推导出1应该也是Integer类型的<br>\n根据 <a href=\"#shu-zi\">(+)函数</a> 的定义, 同时也因为Integer是Num这个Typeclass的成员</p>\n<p>回到先前的 <code>[1..]</code>, 1是Num, 当 List 产生的数字超越 Int 的最大值时, 不会溢出, 而是转成 Integer 以满足需求</p>\n<h2 id=\"she-zhi-bu-chang\" id=\"设置步长\">设置步长</h2>\n<p>先前我们讲到, 你除了傻乎乎地去一个个地填写List的元素, 还可以省略右端点<br>\n同时, 取决于元素的类型, 会产生无限或有界的List</p>\n<p>但是, 比如 [1…5] 会生成 <code>[1,2,3,4,5]</code>, 默认情况下的步长是1<br>\n如果你想调整步长的话, 可以像下面这样:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3.</span>.]          <span class=\"comment\">-- 步长是2, [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33..]</span></span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">10.</span>.]         <span class=\"comment\">-- 步长是5, [5,10,15,20,25,30,35,40,45,50,55,60,65,70..]</span></span><br></pre></td></tr></table></figure>\n<p>你还可以设置小数的步长, 比如:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1.0</span>, <span class=\"number\">1.5</span>..]     <span class=\"comment\">-- 步长是0.5, [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0..]</span></span><br></pre></td></tr></table></figure>\n<p>哇塞, 真是个聪明的编译器呢, 当然, 编译器有时候也不会如你所愿的 😃</p>\n<h2 id=\"lie-biao-tui-dao\" id=\"列表推导\">列表推导</h2>\n<p>Haskell 中的 List, 还有一个强大的地方, 那就是 <code>List Comprehension (列表推导)</code><br>\n听着挺懵的, 来个例子吧, 以下表达式将创建一个无限级List, 元素是2的倍数</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span>.], mod x <span class=\"number\">2</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [2,4,6,8,10,12,14,16,18, 20..]</span></span><br></pre></td></tr></table></figure>\n<p>你会发现, 上面表示这样一个List的方法, 和高一学的集合的表示法非常相近 <s>(因为就是这样抄来的啊)</s><br>\n希望你还没忘记高一学习的, 表示集合的方法之一, 列举法: <code>&#123;x | n ∈ Z, x = 2n&#125;</code> , 表示了偶数集</p>\n<p>Haskell 中的 <code>List Comprehension</code> 也有这么个杠:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x | x &lt;- xs, bool_expr1, bool_expr2 ]   </span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用 <code>|</code> 分割组成的表达式, 与后面的推导</p>\n</li>\n<li class=\"lvl-2\">\n<p>xs 表示一个List, 因为是 x 的复数, 也是尾巴后面加上s, 可以有一个或多个</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>bool_expr</code> 表示要满足的条件, 只有当 x 代入这个表达式, 满足条件才行, 可以有零个或多个</p>\n</li>\n</ul>\n<p>可能你还是有点懵? 没事, 多看点例子, 直觉上明白就可以了</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x + y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>], y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.3</span>]]                   <span class=\"comment\">-- [2,3,4,3,4,5,4,5,6]</span></span><br><span class=\"line\">[x | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.100</span>], x `mod` <span class=\"number\">2</span> == <span class=\"number\">0</span>, x `mod` <span class=\"number\">3</span> == <span class=\"number\">0</span>]  <span class=\"comment\">-- [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96]</span></span><br></pre></td></tr></table></figure>\n<p>其实, 就相当于 <code>多重for循环</code> + <code>最后一重for循环中的零个或多个if语句</code><br>\n随后利用满足条件的值, 创建新的表达式, 放进新的集合并返回:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个式子 <code>[x + y | x &lt;- [1..3], y &lt;- [1..3]]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">3</span>]</span><br><span class=\"line\">    (x + y) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二个式子 <code>[x | x &lt;- [1..100], x </code>mod<code>2 == 0, x</code>mod<code> 3 == 0]</code>, 相当于:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> new_array</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> [<span class=\"number\">1</span>..<span class=\"number\">100</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x `<span class=\"keyword\">mod</span>` <span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; x `<span class=\"keyword\">mod</span>` <span class=\"number\">3</span> == <span class=\"number\">0</span></span><br><span class=\"line\">    (x) -&gt; new_array</span><br></pre></td></tr></table></figure>\n<p>因此, 你可以对比下下面两种式子:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>], y &lt;- [<span class=\"number\">1.</span>.x]  ]</span><br><span class=\"line\">[ x * y | x &lt;- [<span class=\"number\">1.</span>.y],  y &lt;- [<span class=\"number\">1.</span><span class=\"number\">.10</span>] ]</span><br></pre></td></tr></table></figure>\n<p>第一种合法, 但第二种不合法, 把它们理解为for循环, 你就知道原因了, 此处跳过</p>\n<p>好了, 关于List, 暂时先到这吧<br>\n其实后面还有很多关于List的, 毕竟它太重要了</p>\n<hr>\n<h1 id=\"if-yu-ju\">If语句</h1>\n<p>先前说道, If语句仅仅是个语法糖, 但我们还是有必要学下这个语法的<br>\n顺便找个机会, 教下如何将代码写进文件并编译, 脱离 ghci</p>\n<p>毕竟 Haskell 比较特殊, 为了函数的 <a href=\"/posts/haskell-basic/p3/#chun-han-shu\">纯度</a> , 特意搞了一堆东西<br>\n再不讲恐怕之后都讲不了呢, 所以我打算强硬点穿插着讲 (捂嘴笑)</p>\n<p>开始吧!</p>\n<h2 id=\"dan-if\" id=\"单if\">单if</h2>\n<p>首先, 让我们新建一个文件, 命名为 <code>demo.hs</code></p>\n<p>BMI, Body Mass Index (身体质量指数)<br>\n它与体内脂肪总量密切相关，常用来衡量人体胖瘦程度、是否健康</p>\n<p>让我们来编写一个程序, 根据输入的bmi判断胖与瘦吧</p>\n<div class=\"tips\">\n<p><strong>你可以这样运行以 .hs 结尾的文件:</strong></p>\n<ol>\n<li class=\"lvl-3\">在 <code>demo.hs</code> 所在的目录下, 输入 <code>runghc demo.hs</code>, 不会留下目标文件</li>\n<li class=\"lvl-3\">输入 <code>ghc demo.hs</code>, 留下目标文件 <code>./demo</code></li>\n</ol>\n</div>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>  bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>先别在意那个 <code>do</code> 与 <code>&lt;-</code> 是啥, 无视即可, 反正这段代码你应该也看得懂:<br>\n程序会读取输入, 作为 <code>bmi</code> 的值, 随后根据大小, 判断是胖是瘦</p>\n<p>当然, 如果你使用LSP, 代码格式化之后, 你可以得到下面这一段:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>也蛮美观的, 但我更喜欢压行 😃</p>\n<h2 id=\"duo-if\" id=\"多If\">多If</h2>\n<p>其实在 Haskell 中根本不存在多重If这种玩意儿, 你往下看就会懂…</p>\n<p>先前的 单If 实在不够, 没有区分输入不对劲的情况<br>\n而且只是简单地判断了胖瘦, 让我们再加一个判断是否健康的情况吧</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt;= <span class=\"number\">18.5</span> </span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Healthy!!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> </span><br><span class=\"line\">    putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>哇, 看着好美, 好熟悉!<br>\n所以你为什么说没有多重If呢?</p>\n<p>别急, 格式化之后:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- demo.hs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">main</span> = <span class=\"keyword\">do</span></span><br><span class=\"line\">  putStrLn <span class=\"string\">&quot;Please input your BMI:&quot;</span></span><br><span class=\"line\">  bmi &lt;- readLn</span><br><span class=\"line\">  <span class=\"keyword\">if</span> bmi &lt; <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;What?&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> bmi &gt; <span class=\"number\">25</span></span><br><span class=\"line\">        <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;Fat!!!&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> bmi &lt;= <span class=\"number\">25</span> &amp;&amp; bmi &lt; <span class=\"number\">18.5</span></span><br><span class=\"line\">            <span class=\"keyword\">then</span> putStrLn <span class=\"string\">&quot;12&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> putStrLn <span class=\"string\">&quot;Thin!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>懂了吧? 它只是 else 中再套一个 if-else 而已<br>\n而且就连 if-else, 我们都可以用自己定义的函数取代掉 (之后会讲)<br>\n就算我们不取代 if-else, 它的使用率也很低, 模式匹配更加美观, 也更强大 (Guard也是之后会讲)</p>\n<p>这节就到这, 看辉夜3的最后一集去了~~</p>"},{"title":"haskell-basic-p5: 类型与类型类","abbrlink":"posts/haskell-basic/p5","hidden":false,"date":"2022-07-18T08:24:44.000Z","top":6995,"keywords":["Haskell","函数式"],"_content":"> 关于 Haskell 中的类型(Type), 与类型类(Typeclass)  \n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 开篇","source":"_posts/haskell/basic/p5-类型与类型类.md","raw":"---\ntitle: \"haskell-basic-p5: 类型与类型类\"\nabbrlink: posts/haskell-basic/p5\nhidden: false\ndate: 2022-07-18 16:24:44\ntop: 6995\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\n---\n> 关于 Haskell 中的类型(Type), 与类型类(Typeclass)  \n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n# 开篇","slug":"haskell/basic/p5-类型与类型类","published":1,"updated":"2022-07-18T08:24:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gf000t6aij3oy452ds","content":"<blockquote>\n<p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n","site":{"data":{}},"length":57,"excerpt":"<blockquote>\n<p>关于 Haskell 中的类型(Type), 与类型类(Typeclass)</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<h1 id=\"kai-pian\">开篇</h1>"},{"title":"haskell-basic-p3: 函数式介绍","abbrlink":"posts/haskell-basic/p3","hidden":false,"date":"2022-06-26T08:16:10.000Z","top":6997,"keywords":["Haskell","函数式"],"_content":"> 何为函数式编程(FP, 即Functional Programming) ?\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西  \n那么, 开始吧!  \n\n# 编程范式\n## 概览\nFP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式  \n\n编程范式是一种思考方式, 技术, 语言范式, 编程模型  \n在世界上, 有许多编程范式, 最主要的有:  \n\n|简称|中文名|英文名|\n|--|--|--|\n|FP|函数式编程|Functional Programming|\n|OOP|面向对象编程|Object-Oriented Programming|\n|POP|面向过程编程|Procedure-Oriented Programming|\n|LP |逻辑式编程|Logic Programming|\n|DP |声明式编程|Declarative Programming|\n|IP |命令式编程|Imperative Programming|\n\n\n编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西  \n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆  \n\n\n\n编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响  \n下面是一些编程范式的例子:  \n\n::: tips\n**提示**\n如果你已经了解过以下范式, 直接跳到 [**总结**](#zong-jie) 吧\n:::\n\n- 面向过程:  \n优点:  \n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉  \n缺点:  \n代码复用能力差, 扩展性差, 繁琐  \n\n- 面向对象:  \n优点:  \n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍  \n缺点:  \n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐  \n\n- 逻辑式:\n优点:  \n通过建立 `事实`, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇  \n缺点:\n玄学编程, 可能想象不到怎么样建立出 `能正确求解的前提条件/定义`, 也可能因推理过于复杂, 导致性能低下  \n\n- 函数式:\n优点:\n通过以数学中的 `函数` 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性  \n缺点:  \n学习难度较大, 性能因不可变数据, 不可避免地会低下一些  \n\n- 命令式:  \n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已  \n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可  \n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了  \n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等  \n\n- 声明式:  \n指你编程依靠描述, 而非面向过程地去思考  \n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发  \nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库  \n特点是一旦脱离相关领域, 语法就不再便利  \n\n\n## 总结\n各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式  \n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集  \n\n比如:\n- 面向过程/面向对象 && 命令式 \n- 函数式/逻辑式 && 声明式\n- 混合一种, 两种, 甚至各种范式\n\n再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想  \n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力  \n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子  \n\n相信经过本小节, 你对什么是编程范式有了一个初步的认知  \n接下来, 我们就要专注于本节的主角, 函数式  \n\n简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中  \n让我们开始对函数式的正式介绍吧!\n\n- - -\n\n# 高阶函数\n高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数  \n\n你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民  \n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较  \n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)  \n~~(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)~~  \n\n一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民  \n\n- - -\n\n# 不可变数据\n不可变数据(Immutable Data), 指你无法修改已经存在的数据  \n\n换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它  \n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 `变量` 感到困惑  \n\n这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身  \n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费  \n\n而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制  \n但不可变的数据能够有效降低并发的难度  \n\n而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊  \n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值  \n- - -\n\n# 副作用\n副作用(Side Effects), 指与外界发生的交互  \n\n假设有这么一个函数:  \n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出  \n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出  \n\n因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情  \n这种超脱于语言, 来自更真实世界的交互, 我们称之为 `副作用`  \n\n副作用包括, 但不限于:  \n- 发送网络请求  \n- 访问系统状态\n- 操作数据库\n- 操作DOM\n- IO操作\n- 修改函数外部的变量  \n- 使用具有副作用的函数 (传播性)\n\n你会注意到 `修改函数外部的变量`, 它也可以看作 `与外界的交互`  \n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值  \n那么这将无法保证相同输入, 能得到相同输出  \n\n但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互  \n绝对的没有副作用, 意味着这个程序绝对的没用  \n\n- - -\n\n# 引用透明\n引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价  \n\n引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等  \n以下是数学中的 RT, 简单来讲, 就是等式推导:  \n\nf(x) = (x+1)^2^\nf(2) = (2+1)^2^ = (3)^2^ = 9\n\n可以看到, `2+1`可以被`3`代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 `等式推导`:  \n某个 `父表达式` 由许多 `子表达式` 组成, 如果可以将这些 `子表达式` 替换为它们计算得到的对应值, 就能简化这个 `父表达式`    \n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT  \n\n总而言之, 就是替换, 替换, 还是替换  \n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等  \n\nRT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:  \n若有这么个函数:  \n\n```haskell\ndouble_x(x: Int): Int {\n    println(x);\n    return x+x;\n}\n```\n\n那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)  \n此时进行替换的话, 比如 `double_x(10) -> 20`, 因为后者少了次打印, 语义不一致  \n假设你将其中10次对 `double_x(x)` 的调用, 都用 `x+x` 来替换, 那你将缺少10次打印  \n\n这只是个简单的例子, 你完全能将函数中的 `println(x)`, 换成其他具有副作用, 而非单纯数运算的表达式  \n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难  \n你将需要额外使用复杂的工具, 去分析一段复杂的代码  \n这通常是一些 BUG 的来源  \n\nRT, 即引用透明, 注定与副作用互斥  \n\n- - -\n\n# 纯函数\n纯函数(Pure Functions), 表示引用透明的函数  \n\n引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已  \n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好  \n\n因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已  \n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系  \n\n一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:  \n有三个纯函数: `f(x), h(x), g(x)`, 那么 `f(x) + h(x) + g(x)` 中, 三个函数直接并行计算即可  \n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性  \n\n但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来  \n\n- - -\n\n# 其他\n以上是对函数式的小小概括  \n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解  \n\n为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码  \n\n- 埃氏筛求素数:\n\n```haskell\nprimes = filterPrime [2..]\n  where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0]\n```\n\n\n\n- 斐波那契数列:\n\n```haskell\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n- 快速排列:\n\n```haskell\nqsort [] = []\nqsort (x : xs) = qsort sList ++ [x] ++ qsort bList\n  where (sList, bList) = partition (< x) xs\n```\n\n- 辗转相除法求最大公约数:\n\n```haskell\ngcd' x y\n  | y == 0 = x\n  | otherwise = gcd' y (x `mod` y)\n```\n\n感谢你的观看, 咋们下期见!!  \n先让我鸽几天 :)\n","source":"_posts/haskell/basic/p3-函数式编程.md","raw":"---\ntitle: \"haskell-basic-p3: 函数式介绍\"\nabbrlink: posts/haskell-basic/p3\nhidden: false\ndate: 2022-06-26 16:16:10\ntop: 6997\ntags: [Haskell]\nkeywords: [Haskell, 函数式]\n---\n> 何为函数式编程(FP, 即Functional Programming) ?\n<!-- more -->\n\n同系列传送门: [haskell-basic](/categories/haskell-basic)\n\n本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西  \n那么, 开始吧!  \n\n# 编程范式\n## 概览\nFP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式  \n\n编程范式是一种思考方式, 技术, 语言范式, 编程模型  \n在世界上, 有许多编程范式, 最主要的有:  \n\n|简称|中文名|英文名|\n|--|--|--|\n|FP|函数式编程|Functional Programming|\n|OOP|面向对象编程|Object-Oriented Programming|\n|POP|面向过程编程|Procedure-Oriented Programming|\n|LP |逻辑式编程|Logic Programming|\n|DP |声明式编程|Declarative Programming|\n|IP |命令式编程|Imperative Programming|\n\n\n编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西  \n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆  \n\n\n\n编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响  \n下面是一些编程范式的例子:  \n\n::: tips\n**提示**\n如果你已经了解过以下范式, 直接跳到 [**总结**](#zong-jie) 吧\n:::\n\n- 面向过程:  \n优点:  \n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉  \n缺点:  \n代码复用能力差, 扩展性差, 繁琐  \n\n- 面向对象:  \n优点:  \n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍  \n缺点:  \n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐  \n\n- 逻辑式:\n优点:  \n通过建立 `事实`, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇  \n缺点:\n玄学编程, 可能想象不到怎么样建立出 `能正确求解的前提条件/定义`, 也可能因推理过于复杂, 导致性能低下  \n\n- 函数式:\n优点:\n通过以数学中的 `函数` 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性  \n缺点:  \n学习难度较大, 性能因不可变数据, 不可避免地会低下一些  \n\n- 命令式:  \n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已  \n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可  \n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了  \n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等  \n\n- 声明式:  \n指你编程依靠描述, 而非面向过程地去思考  \n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发  \nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库  \n特点是一旦脱离相关领域, 语法就不再便利  \n\n\n## 总结\n各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式  \n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集  \n\n比如:\n- 面向过程/面向对象 && 命令式 \n- 函数式/逻辑式 && 声明式\n- 混合一种, 两种, 甚至各种范式\n\n再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想  \n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力  \n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子  \n\n相信经过本小节, 你对什么是编程范式有了一个初步的认知  \n接下来, 我们就要专注于本节的主角, 函数式  \n\n简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中  \n让我们开始对函数式的正式介绍吧!\n\n- - -\n\n# 高阶函数\n高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数  \n\n你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民  \n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较  \n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)  \n~~(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)~~  \n\n一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民  \n\n- - -\n\n# 不可变数据\n不可变数据(Immutable Data), 指你无法修改已经存在的数据  \n\n换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它  \n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 `变量` 感到困惑  \n\n这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身  \n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费  \n\n而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制  \n但不可变的数据能够有效降低并发的难度  \n\n而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊  \n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值  \n- - -\n\n# 副作用\n副作用(Side Effects), 指与外界发生的交互  \n\n假设有这么一个函数:  \n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出  \n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出  \n\n因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情  \n这种超脱于语言, 来自更真实世界的交互, 我们称之为 `副作用`  \n\n副作用包括, 但不限于:  \n- 发送网络请求  \n- 访问系统状态\n- 操作数据库\n- 操作DOM\n- IO操作\n- 修改函数外部的变量  \n- 使用具有副作用的函数 (传播性)\n\n你会注意到 `修改函数外部的变量`, 它也可以看作 `与外界的交互`  \n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值  \n那么这将无法保证相同输入, 能得到相同输出  \n\n但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互  \n绝对的没有副作用, 意味着这个程序绝对的没用  \n\n- - -\n\n# 引用透明\n引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价  \n\n引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等  \n以下是数学中的 RT, 简单来讲, 就是等式推导:  \n\nf(x) = (x+1)^2^\nf(2) = (2+1)^2^ = (3)^2^ = 9\n\n可以看到, `2+1`可以被`3`代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 `等式推导`:  \n某个 `父表达式` 由许多 `子表达式` 组成, 如果可以将这些 `子表达式` 替换为它们计算得到的对应值, 就能简化这个 `父表达式`    \n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT  \n\n总而言之, 就是替换, 替换, 还是替换  \n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等  \n\nRT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:  \n若有这么个函数:  \n\n```haskell\ndouble_x(x: Int): Int {\n    println(x);\n    return x+x;\n}\n```\n\n那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)  \n此时进行替换的话, 比如 `double_x(10) -> 20`, 因为后者少了次打印, 语义不一致  \n假设你将其中10次对 `double_x(x)` 的调用, 都用 `x+x` 来替换, 那你将缺少10次打印  \n\n这只是个简单的例子, 你完全能将函数中的 `println(x)`, 换成其他具有副作用, 而非单纯数运算的表达式  \n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难  \n你将需要额外使用复杂的工具, 去分析一段复杂的代码  \n这通常是一些 BUG 的来源  \n\nRT, 即引用透明, 注定与副作用互斥  \n\n- - -\n\n# 纯函数\n纯函数(Pure Functions), 表示引用透明的函数  \n\n引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已  \n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好  \n\n因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已  \n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系  \n\n一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:  \n有三个纯函数: `f(x), h(x), g(x)`, 那么 `f(x) + h(x) + g(x)` 中, 三个函数直接并行计算即可  \n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性  \n\n但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来  \n\n- - -\n\n# 其他\n以上是对函数式的小小概括  \n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解  \n\n为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码  \n\n- 埃氏筛求素数:\n\n```haskell\nprimes = filterPrime [2..]\n  where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0]\n```\n\n\n\n- 斐波那契数列:\n\n```haskell\nfibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n```\n\n- 快速排列:\n\n```haskell\nqsort [] = []\nqsort (x : xs) = qsort sList ++ [x] ++ qsort bList\n  where (sList, bList) = partition (< x) xs\n```\n\n- 辗转相除法求最大公约数:\n\n```haskell\ngcd' x y\n  | y == 0 = x\n  | otherwise = gcd' y (x `mod` y)\n```\n\n感谢你的观看, 咋们下期见!!  \n先让我鸽几天 :)\n","slug":"haskell/basic/p3-函数式编程","published":1,"updated":"2022-06-26T08:16:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gg000u6aij3dd2avjj","content":"<blockquote>\n<p>何为函数式编程(FP, 即Functional Programming) ?</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>\n那么, 开始吧!</p>\n<h1 id=\"bian-cheng-fan-shi\">编程范式</h1>\n<h2 id=\"gai-lan\" id=\"概览\">概览</h2>\n<p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p>\n<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>\n在世界上, 有许多编程范式, 最主要的有:</p>\n<table>\n<thead>\n<tr>\n<th>简称</th>\n<th>中文名</th>\n<th>英文名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FP</td>\n<td>函数式编程</td>\n<td>Functional Programming</td>\n</tr>\n<tr>\n<td>OOP</td>\n<td>面向对象编程</td>\n<td>Object-Oriented Programming</td>\n</tr>\n<tr>\n<td>POP</td>\n<td>面向过程编程</td>\n<td>Procedure-Oriented Programming</td>\n</tr>\n<tr>\n<td>LP</td>\n<td>逻辑式编程</td>\n<td>Logic Programming</td>\n</tr>\n<tr>\n<td>DP</td>\n<td>声明式编程</td>\n<td>Declarative Programming</td>\n</tr>\n<tr>\n<td>IP</td>\n<td>命令式编程</td>\n<td>Imperative Programming</td>\n</tr>\n</tbody>\n</table>\n<p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>\n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p>\n<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>\n下面是一些编程范式的例子:</p>\n<div class=\"tips\">\n<p><strong>提示</strong><br>\n如果你已经了解过以下范式, 直接跳到 <a href=\"#zong-jie\"><strong>总结</strong></a> 吧</p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程:<br>\n优点:<br>\n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>\n缺点:<br>\n代码复用能力差, 扩展性差, 繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>面向对象:<br>\n优点:<br>\n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>\n缺点:<br>\n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>逻辑式:<br>\n优点:<br>\n通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>\n缺点:<br>\n玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式:<br>\n优点:<br>\n通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>\n缺点:<br>\n学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令式:<br>\n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>\n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>\n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>\n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>声明式:<br>\n指你编程依靠描述, 而非面向过程地去思考<br>\n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>\nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>\n特点是一旦脱离相关领域, 语法就不再便利</p>\n</li>\n</ul>\n<h2 id=\"zong-jie\" id=\"总结\">总结</h2>\n<p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>\n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p>\n<p>比如:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程/面向对象 &amp;&amp; 命令式</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式/逻辑式 &amp;&amp; 声明式</p>\n</li>\n<li class=\"lvl-2\">\n<p>混合一种, 两种, 甚至各种范式</p>\n</li>\n</ul>\n<p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>\n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>\n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p>\n<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>\n接下来, 我们就要专注于本节的主角, 函数式</p>\n<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>\n让我们开始对函数式的正式介绍吧!</p>\n<hr>\n<h1 id=\"gao-jie-han-shu\">高阶函数</h1>\n<p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p>\n<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>\n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>\n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br>\n<s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p>\n<p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p>\n<hr>\n<h1 id=\"bu-ke-bian-shu-ju\">不可变数据</h1>\n<p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p>\n<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>\n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p>\n<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>\n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p>\n<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>\n但不可变的数据能够有效降低并发的难度</p>\n<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>\n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p>\n<hr>\n<h1 id=\"fu-zuo-yong\">副作用</h1>\n<p>副作用(Side Effects), 指与外界发生的交互</p>\n<p>假设有这么一个函数:<br>\n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>\n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p>\n<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>\n这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p>\n<p>副作用包括, 但不限于:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>发送网络请求</p>\n</li>\n<li class=\"lvl-2\">\n<p>访问系统状态</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作数据库</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作DOM</p>\n</li>\n<li class=\"lvl-2\">\n<p>IO操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>修改函数外部的变量</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用具有副作用的函数 (传播性)</p>\n</li>\n</ul>\n<p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>\n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>\n那么这将无法保证相同输入, 能得到相同输出</p>\n<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>\n绝对的没有副作用, 意味着这个程序绝对的没用</p>\n<hr>\n<h1 id=\"yin-yong-tou-ming\">引用透明</h1>\n<p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p>\n<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>\n以下是数学中的 RT, 简单来讲, 就是等式推导:</p>\n<p>f(x) = (x+1)<sup>2</sup><br>\nf(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p>\n<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>\n某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>\n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p>\n<p>总而言之, 就是替换, 替换, 还是替换<br>\n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p>\n<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>\n若有这么个函数:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">double_x</span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    println(x);</span><br><span class=\"line\">    return x+x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>\n此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>\n假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p>\n<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>\n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>\n你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>\n这通常是一些 BUG 的来源</p>\n<p>RT, 即引用透明, 注定与副作用互斥</p>\n<hr>\n<h1 id=\"chun-han-shu\">纯函数</h1>\n<p>纯函数(Pure Functions), 表示引用透明的函数</p>\n<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>\n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p>\n<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>\n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p>\n<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>\n有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>\n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p>\n<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p>\n<hr>\n<h1 id=\"qi-ta\">其他</h1>\n<p>以上是对函数式的小小概括<br>\n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p>\n<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>埃氏筛求素数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">primes</span> = filterPrime [<span class=\"number\">2.</span>.]</span><br><span class=\"line\">  <span class=\"keyword\">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>斐波那契数列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fibs</span> = <span class=\"number\">0</span> : <span class=\"number\">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>快速排列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> [] = []</span><br><span class=\"line\"><span class=\"title\">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class=\"line\">  <span class=\"keyword\">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>辗转相除法求最大公约数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">gcd&#x27;</span> x y</span><br><span class=\"line\">  | y == <span class=\"number\">0</span> = x</span><br><span class=\"line\">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure>\n<p>感谢你的观看, 咋们下期见!!<br>\n先让我鸽几天 😃</p>\n","site":{"data":{}},"length":3837,"excerpt":"<blockquote>\n<p>何为函数式编程(FP, 即Functional Programming) ?</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/haskell-basic\">haskell-basic</a></p>\n<p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br>\n那么, 开始吧!</p>\n<h1 id=\"bian-cheng-fan-shi\">编程范式</h1>\n<h2 id=\"gai-lan\" id=\"概览\">概览</h2>\n<p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式</p>\n<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br>\n在世界上, 有许多编程范式, 最主要的有:</p>\n<table>\n<thead>\n<tr>\n<th>简称</th>\n<th>中文名</th>\n<th>英文名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FP</td>\n<td>函数式编程</td>\n<td>Functional Programming</td>\n</tr>\n<tr>\n<td>OOP</td>\n<td>面向对象编程</td>\n<td>Object-Oriented Programming</td>\n</tr>\n<tr>\n<td>POP</td>\n<td>面向过程编程</td>\n<td>Procedure-Oriented Programming</td>\n</tr>\n<tr>\n<td>LP</td>\n<td>逻辑式编程</td>\n<td>Logic Programming</td>\n</tr>\n<tr>\n<td>DP</td>\n<td>声明式编程</td>\n<td>Declarative Programming</td>\n</tr>\n<tr>\n<td>IP</td>\n<td>命令式编程</td>\n<td>Imperative Programming</td>\n</tr>\n</tbody>\n</table>\n<p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br>\n记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆</p>\n<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br>\n下面是一些编程范式的例子:</p>\n<div class=\"tips\">\n<p><strong>提示</strong><br>\n如果你已经了解过以下范式, 直接跳到 <a href=\"#zong-jie\"><strong>总结</strong></a> 吧</p>\n</div>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程:<br>\n优点:<br>\n解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br>\n缺点:<br>\n代码复用能力差, 扩展性差, 繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>面向对象:<br>\n优点:<br>\n将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br>\n缺点:<br>\n不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐</p>\n</li>\n<li class=\"lvl-2\">\n<p>逻辑式:<br>\n优点:<br>\n通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br>\n缺点:<br>\n玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式:<br>\n优点:<br>\n通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br>\n缺点:<br>\n学习难度较大, 性能因不可变数据, 不可避免地会低下一些</p>\n</li>\n<li class=\"lvl-2\">\n<p>命令式:<br>\n有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br>\n我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br>\n毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br>\n现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等</p>\n</li>\n<li class=\"lvl-2\">\n<p>声明式:<br>\n指你编程依靠描述, 而非面向过程地去思考<br>\n这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br>\nDSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br>\n特点是一旦脱离相关领域, 语法就不再便利</p>\n</li>\n</ul>\n<h2 id=\"zong-jie\" id=\"总结\">总结</h2>\n<p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br>\n编程范式并非严格的互相独立的, 它们大多在概念上也存在交集</p>\n<p>比如:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>面向过程/面向对象 &amp;&amp; 命令式</p>\n</li>\n<li class=\"lvl-2\">\n<p>函数式/逻辑式 &amp;&amp; 声明式</p>\n</li>\n<li class=\"lvl-2\">\n<p>混合一种, 两种, 甚至各种范式</p>\n</li>\n</ul>\n<p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br>\n比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br>\n再比如 Rust 中的 Option/Result, 有着 Haskell 的影子</p>\n<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br>\n接下来, 我们就要专注于本节的主角, 函数式</p>\n<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br>\n让我们开始对函数式的正式介绍吧!</p>\n<hr>\n<h1 id=\"gao-jie-han-shu\">高阶函数</h1>\n<p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数</p>\n<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br>\n函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br>\n比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br>\n<s>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</s></p>\n<p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民</p>\n<hr>\n<h1 id=\"bu-ke-bian-shu-ju\">不可变数据</h1>\n<p>不可变数据(Immutable Data), 指你无法修改已经存在的数据</p>\n<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br>\n被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑</p>\n<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br>\n但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费</p>\n<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br>\n但不可变的数据能够有效降低并发的难度</p>\n<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br>\n比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值</p>\n<hr>\n<h1 id=\"fu-zuo-yong\">副作用</h1>\n<p>副作用(Side Effects), 指与外界发生的交互</p>\n<p>假设有这么一个函数:<br>\n它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br>\n可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出</p>\n<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br>\n这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code></p>\n<p>副作用包括, 但不限于:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>发送网络请求</p>\n</li>\n<li class=\"lvl-2\">\n<p>访问系统状态</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作数据库</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作DOM</p>\n</li>\n<li class=\"lvl-2\">\n<p>IO操作</p>\n</li>\n<li class=\"lvl-2\">\n<p>修改函数外部的变量</p>\n</li>\n<li class=\"lvl-2\">\n<p>使用具有副作用的函数 (传播性)</p>\n</li>\n</ul>\n<p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br>\n比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br>\n那么这将无法保证相同输入, 能得到相同输出</p>\n<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br>\n绝对的没有副作用, 意味着这个程序绝对的没用</p>\n<hr>\n<h1 id=\"yin-yong-tou-ming\">引用透明</h1>\n<p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价</p>\n<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br>\n以下是数学中的 RT, 简单来讲, 就是等式推导:</p>\n<p>f(x) = (x+1)<sup>2</sup><br>\nf(2) = (2+1)<sup>2</sup> = (3)<sup>2</sup> = 9</p>\n<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br>\n某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br>\n计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT</p>\n<p>总而言之, 就是替换, 替换, 还是替换<br>\n即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等</p>\n<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br>\n若有这么个函数:</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">double_x</span>(x: <span class=\"type\">Int</span>): <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    println(x);</span><br><span class=\"line\">    return x+x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br>\n此时进行替换的话, 比如 <code>double_x(10) -&gt; 20</code>, 因为后者少了次打印, 语义不一致<br>\n假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印</p>\n<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br>\n使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br>\n你将需要额外使用复杂的工具, 去分析一段复杂的代码<br>\n这通常是一些 BUG 的来源</p>\n<p>RT, 即引用透明, 注定与副作用互斥</p>\n<hr>\n<h1 id=\"chun-han-shu\">纯函数</h1>\n<p>纯函数(Pure Functions), 表示引用透明的函数</p>\n<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br>\n相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好</p>\n<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br>\n简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系</p>\n<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br>\n有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br>\n这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性</p>\n<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来</p>\n<hr>\n<h1 id=\"qi-ta\">其他</h1>\n<p>以上是对函数式的小小概括<br>\n还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解</p>\n<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>埃氏筛求素数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">primes</span> = filterPrime [<span class=\"number\">2.</span>.]</span><br><span class=\"line\">  <span class=\"keyword\">where</span> filterPrime (p:xs) = p : filterPrime [x | x &lt;- xs, x `mod` p /= <span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>斐波那契数列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fibs</span> = <span class=\"number\">0</span> : <span class=\"number\">1</span> : zipWith (+) fibs (tail fibs)</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>快速排列:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">qsort</span> [] = []</span><br><span class=\"line\"><span class=\"title\">qsort</span> (x : xs) = qsort sList ++ [x] ++ qsort bList</span><br><span class=\"line\">  <span class=\"keyword\">where</span> (sList, bList) = partition (&lt; x) xs</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>辗转相除法求最大公约数:</p>\n</li>\n</ul>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">gcd&#x27;</span> x y</span><br><span class=\"line\">  | y == <span class=\"number\">0</span> = x</span><br><span class=\"line\">  | otherwise = gcd&#x27; y (x `mod` y)</span><br></pre></td></tr></table></figure>\n<p>感谢你的观看, 咋们下期见!!<br>\n先让我鸽几天 😃</p>"},{"title":"rust-decl-macro-p1: 系列说明","abbrlink":"posts/rust-decl-macro/p1","date":"2021-09-19T13:51:27.000Z","top":10999,"keywords":["Macro","声明宏","Rust"],"_content":"> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 系列说明\n此系列,我们将学习Rust中的 `声明宏`  \n请注意, 是声明宏, 过程宏日后再说\n- - - \n# 参考资料\n1. 书籍\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. 文章  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)\n","source":"_posts/rust/decl-macro/p1-系列说明.md","raw":"---\ntitle: \"rust-decl-macro-p1: 系列说明\"\nabbrlink: posts/rust-decl-macro/p1\ndate: 2021-09-19 21:51:27\ntop: 10999\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\n---\n> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 系列说明\n此系列,我们将学习Rust中的 `声明宏`  \n请注意, 是声明宏, 过程宏日后再说\n- - - \n# 参考资料\n1. 书籍\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. 文章  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)\n","slug":"rust/decl-macro/p1-系列说明","published":1,"updated":"2021-09-19T13:51:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gh000x6aijbk70gs6a","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>声明宏</code><br>\n请注意, 是声明宏, 过程宏日后再说</p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文章</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":233,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>声明宏</code><br>\n请注意, 是声明宏, 过程宏日后再说</p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文章</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"},{"title":"clap-rs 简介","abbrlink":"posts/rust-clap/intro","hidden":false,"date":"2022-08-16T12:03:34.000Z","top":12999,"keywords":["Rust","Clap","CLI","命令行"],"_content":"> 学习命令行的常识, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能  \n<!-- more -->\n\n前置知识: Rust基础  \n完整代码: [github/jedsek/rust-wc](https://github.com/Jedsek/rust-wc)\n\n:::tips\n**注意**\n本项目基于当前最新版本的 clap, 也就是 version 4\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)\n\n推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手  \n官方教程: [derive tutorial](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)\n官方资料: [derive reference](https://docs.rs/clap/latest/clap/_derive/index.html)\n:::\n\n# 成品展示\n你可以通过如下命令, 从 [crates.io](https://crates.io) 上下载该成品, 可执行文件的名称是 `rwc`:  \n\n```bash\ncargo install rust-wc\n```\n\n以下是使用 [asciinema](https://asciinema.org/) 录制的展示:  \n\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n\n- - -\n\n# 基础概念\nCLI, 是 `command-line interface` 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理  \n如在Linux下常见的 `ls/cp/mv` 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出  \n\nGNU 项目提供了非常多的开源命令, 如 `wc`, 它可以统计文件的 bytes/char/line 的数量  \n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 `wc`  \n\n::: tips\n**注意:**  \ncli 可以代表抽象的界面, 也可以指代具体的某个程序  \n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等\n:::\n\n再写之前, 我们还应了解些基本概念 ~~(直接跳过感觉也木得问题??)~~:  \n\n- `参数(Arguments)`:  \n传给命令的参数, 比如一个路径 ~~(嘶, 感觉在说废话)~~\n\n- `选项(Options)`:\n通常以单/双横杠开头, 不同的options表示不同的行为  \n比如 `ls ./*`, 表示以默认行为下进行输出, `ls -l ./*` 以长列表形式输出, `ls -a ./*` 输出所有隐藏文件  \n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 `ls -i` 与 `ls --inode`  \n\n- `子命令(Subcommands)`:  \n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options  \n比如 `cargo build` 与 `cargo publish`, 都是 `cargo` 的子命令  \n\n- `双横杠(--)`:  \n在命令后面的某处位置, 加上 `--`, 可以将 `--` 后面的内容当作 argument 传入, 而非 options  \n举个例子, 我有个文件, 叫做 `--asd`, 我想使用 `cat --asd` 来输出里面的内容  \n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 `--asd` 这个option, 故失败  \n在比如有个文件叫 `--help`, 使用 `cat --help` 将会打印其 help 信息  \n此时, 你应该使用 `cat -- --asd`, 将 `--asd` 视作参数传入\n\n- `短/长帮助(short/long help)`:\n有些命令, `-h` 与 `--help` 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息\n\n- - -\n\n# 初始配置\n以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件  \n请自行创建好目录:  \n\n```\n./rust-wc\n├── Cargo.lock\n├── Cargo.toml\n└── src\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n   ├── lib.rs         # 声明模块, 类型别名\n   └── main.rs\n```\n\n让我们新建一个叫做 `rust-wc` 的项目, 然后在 `Cargo.toml` 中添加 clap 吧:\n\n```toml Cargo.toml\n# 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)\n[package]\nname = \"rust-wc\"\nauthors = [\"jedsek <jedsek@qq.com>\"]\nversion = \"0.0.1\"\ndescription = \"A GNU/wc implementation written in rust, which is faster when reading a large of big files\"\nedition = \"2021\"\n\n# 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`\n[[bin]]\nname = \"rwc\"\npath = \"src/main.rs\"\n\n# 指定依赖\n[dependencies]\nclap = {version = \"4.0.8\", features = [\"derive\"]}      # 解析参数\nunicode-width = \"0.1.10\"                               # 计算 Unicode 字符宽度\nindicatif = \"0.17.1\"                                   # 进度条\nprettytable-rs = \"0.9.0\"                               # 打印表格\nrayon = \"1.5.3\"                                        # 并行化\n```\n\n以下是 lib.rs 的内容:  \n\n```rust src/lib.rs\n use std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n- - -\n\n# 命令定义\n\n:::tips\n**注意:**\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt  \n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap  \n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码  \n:::\n\n\n让我们来想象下这个命令:  \n\n- 必须接受一个参数\n- 参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容\n- 根据启用的 flag 来决定计算并打印哪些东西\n\n多亏了 derive 宏, 我们可以这样定义它, 下面是 `src/cli.rs` 的完整代码:  \n\n```rust src/cli.rs\nuse clap::{ArgGroup, Parser, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Parser)]  // 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 \n#[command(\n    author, version, about,\n    group(ArgGroup::new(\"options\").multiple(true).required(true).args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])),\n    subcommand_negates_reqs = true,\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n\n    /// Print the byte counts\n    #[arg(short, long)]\n    pub bytes: bool,\n\n    /// Print the character counts\n    #[arg(short, long)]\n    pub chars: bool,\n\n    /// Print the word counts\n    #[arg(short, long)]\n    pub words: bool,\n\n    /// Print the line counts\n    #[arg(short, long)]\n    pub lines: bool,\n\n    /// Print the maximum line width (Unicode)\n    #[arg(short = 'L', long)]\n    pub longest_line: bool,\n\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n\n\n// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n\nimpl Cli {\n    // 开启所有的 options\n    pub fn enable_all_options(&mut self) {\n        self.bytes = true;\n        self.chars = true;\n        self.words = true;\n        self.lines = true;\n        self.longest_line = true;\n    }\n        \n    // 返回启用的options, 类型是 Vec<&str>, 方便后面打印表格时, 作为表格的标题\n    pub fn get_enabled_options(&self) -> Vec<&'static str> {\n        let mut enabled_options = vec![];\n\n        self.bytes.then(|| enabled_options.push(\"Bytes\"));\n        self.chars.then(|| enabled_options.push(\"Chars\"));\n        self.words.then(|| enabled_options.push(\"Words\"));\n        self.lines.then(|| enabled_options.push(\"Lines\"));\n        self.longest_line.then(|| enabled_options.push(\"Maximum line width (Unicode)\"));\n\n        enabled_options\n    }\n}\n```\n\n以上的代码表示, 我们定义了一个 `Cli` 结构体, 表示对输入参数的建模  \n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型  \n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示  \n\nclap 以及为我们做好了一切 :)  \n\n我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:  \n\n```rust\nuse clap::Parser;\nuse rust_wc::{cli::Cli, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    Ok(())\n}\n```\n\n## 文档注释与帮助\n\n等下再解释, 现在先让我们看看效果, 查看下 help 吧:  \n\n```rust\ncargo run -- -h\n```\n\n```\nA GNU/wc clone written in rust, which is super faster when reading a large of big files\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n       rwc [PATH]... <COMMAND>\n\nCommands:\n  all   Enabled all available options\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  <PATH>...  The path(s) you should provide\n\nOptions:\n  -b, --bytes         Print the byte counts\n  -c, --chars         Print the character counts\n  -w, --words         Print the word counts\n  -l, --lines         Print the line counts\n  -L, --longest-line  Print the maximum line width (Unicode)\n  -h, --help          Print help information\n  -V, --version       Print version information\n```\n\n哇哦! 若你用这段文字, 对比下前面的 `src/cli.rs`, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息  \n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息  \n\n如果你不想要 `about` 信息直接照搬 `Cargo.toml` 里的 `description` 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:  \n\n```rust\n#[derive(Parser)]\n#[command(\n    about = \"...\",\n// ......\n// ......\n```\n\n并且, 像 author/version/about 等信息, 是通过读取 `Cargo.toml` 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁  \n你可以查看 [help_template](https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template) 知晓如何显示, 例子可能是 `builder形式`, 也就是非声明式, 但别慌张:  \n\n你可以像这样将 builder形式 的代码转化为 derive形式:  \n\n```rust\nCommand::new(\"myprog\")\n    .help_template(\"{bin} ({version}) - {usage}\")\n\n#[derive(Parser)]\n#[command(\n    help_template = \"{bin} ({version}) - {usage}\",\n// ......\n// ......\n```\n\n实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码  \n\n## 选项与参数的生成\nclap 能非常方便地以声明的方式, 定义选项/参数\n\n### 选项\n对于一个option, 比如 `-b/--bytes`, 你只需要这样写:  \n\n```rust\n/// Print the byte counts\n#[arg(short, long)]\npub bytes: bool,\n```\n\n它由三部分组成:  \n\n- 文档注释: help 中对该命令的解释\n- `#[arg(short, long)]`: 该 option 具有短/长横杠的形式\n- 类型为bool: 传入时默认的行为是将其设置为 true\n\n如 help 中所示, 会生成如下内容:\n\n```\nOptions:\n  -b, --bytes         Print the byte counts\n```\n\n当你传入该参数时, `Cli` 实例中的 `bytes` 属性将被设置为 true  \n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部  \n\n比如 `-l/--lines` 与 `-L/--longest-line`, 不指定时都是 `-l`, 编译会报错, 需要自己指定:  \n\n```rust\n/// Print the maximum line width (Unicode)\n#[arg(short = 'L', long)]\npub longest_line: bool,\n```\n\n### 参数\n当你没有添加 `short` 或 `long` 时, 自然就代表这是个 argument  \n\n在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径   \n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 `PATH`, 同时指定该参数必选, 防止路径数为0:  \n\n```rust\n/// The path(s) you should provide\n#[arg(value_name = \"PATH\", required = true)]\npub paths: Vec<PathBuf>,\n```\n\n如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:  \n\n```bash\ncargo run -- -b\n```\n\n```\nerror: The following required arguments were not provided:\n  <PATH>...\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n\nFor more information try '--help'\n```\n\n但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行  \n没错, clap 只是负责帮我们生成 `进行转换的代码`  \n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 :)  \n\n因此, 我们来学学如何使用自定义的参数解析器吧\n\n## 自定义参数解析器\n有些疑问或许会萦绕在你的心头:  \n- clap 是怎么进行解析的?\n- clap 能否将传入的参数, 解析为自定义的类型呢?  \n- 我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?\n\n实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证  \n比如, 如果我们想验证传入的路径是否合法, 可以这样写:  \n\n```rust\n// ......\n// ......\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n```\n\nGood, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误  \n该错误会在用户传入非法路径时, 作为报错信息出现:  \n\n```bash\ncargo run -- -b asdxxx\n```\n\n```\nerror: Invalid value \"asd\" for '<PATH>...': No such path: `asdxxx`\n\nFor more information try '--help'\n```\n\n于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser  \n得益于此, 你可以为任何类型定义对应的 parser\n\n## 参数关系\n有时候, 我们可能会面临这样或那样的问题:  \n\n- 当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用\n- 一个或多个指定的 option(s) 必须被启用\n- 多个指定的 options 可以同时被启用\n\n如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情  \n它叫做 `参数关系(Argument Relations)`, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改  \n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系\n\n实际上, 你先前在 `paths` 头上写的 `required = true`, 就是一种参数关系  \n\n以我们的 `rwc` 举个例子:  \n- `-b/-c/-w/-l/-L` 能同时出现, 即支持类似 `-b -c -w` 或 `-bcw` 的形式\n- `-b/-c/-w/-l/-L` 至少出现其中一个, 防止只传路径不传 option \n\n任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系  \n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 `-b/-c/-w/-l/-L` 都放入其中:  \n\n```rust\n// ......\n// ......\n#[derive(Parser)]\n#[command(\n    author, version, about,\n    group(ArgGroup::new(\"options\").multiple(true).required(true).args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])),\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n```\n\n`multiple(true)` 表示可以同时出现参数组的成员, `required(true)` 表示至少传入该参数组中的其中一个成员  \n\n## 子命令\n我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数  \n\n```rust\npub struct Cli {\n// ......\n// ......\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n```\n\n你可以会想, 能不能让子命令复用 `Cli` 中定义的 `paths`, 减少重复代码呢?  \n当然可以, 请在 `Cli` 的成员 `paths`, 头上的`#[arg]` 中添加 `global = true`, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数  \n\n但非常遗憾, 当设置 `global = true` 后, 就无法设置 `required = true` 了, 因此我们还是得定义一份相同的参数, 详见 [相关issue](https://github.com/clap-rs/clap/issues/1546)\n\n::: tips\n**注意:**  \n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入  \n但本文还是定义了 subcommand 以便读者了解, 起演示作用\n:::\n\n\n- - -\n# 逻辑实现\n根据:\n\n```\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n```\n\n我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了  \n为了避免你回到前面看 `lib.rs` 的内容, 下面再贴一遍:  \n\n```rust src/lib.rs\nuse std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:  \n\n{% tabs 逻辑实现代码 %}\n\n<!-- tab 读取文件 -->\n\n```rust src/files.rs\n// 声明依赖\n// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好\nuse crate::{PathWithContent, Result};\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse rayon::prelude::*;\nuse std::ffi::OsStr;\nuse std::process;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{\n    fs::File,\n    io::{BufReader, Read},\n    path::PathBuf,\n};\n\n\n// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果\n// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)\nstatic INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(0);\nconst BUFFER_SIZR: usize = 16 * 1024;\n\n\n// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀\n// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下\n// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰\ntrait PathExt {\n    fn without_dotted_prefix(&self) -> bool;\n    fn add_dotted_prefix(&mut self);\n}\n\nimpl PathExt for PathBuf {\n    fn without_dotted_prefix(&self) -> bool {\n        self.is_relative() && !self.starts_with(\"../\") && !self.starts_with(\"./\")\n    }\n\n    fn add_dotted_prefix(&mut self) {\n        *self = PathBuf::from_iter([OsStr::new(\"./\"), self.as_os_str()]);\n    }\n}\n\n\n// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组\npub fn read_files(paths: Vec<PathBuf>) -> Result<PathWithContent> {\n    println!(\"Reading files / Getting content from stdin:\");\n\n    // 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧\n    let result = paths\n        .into_par_iter()\n        .filter(|path| path.is_file() || path.as_os_str() == \"-\")\n        .map(|mut path| {\n            let should_read_from_input = path.as_os_str() == \"-\";\n\n            let content = get_content(&path, should_read_from_input);\n\n            if path.without_dotted_prefix() {\n                path.add_dotted_prefix();\n            }\n\n            if should_read_from_input {\n                let inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(1, Ordering::SeqCst);\n                path = PathBuf::from(format!(\"Input/{}\", inputted_file_number));\n            }\n\n            let content = content.unwrap_or_else(|err| {\n                eprintln!(\"{}: {}\", path.display(), err);\n                process::exit(1);\n            });\n\n            (path, content)\n        })\n        .collect();\n    Ok(result)\n}\n\n\n// helper 函数, 针对单个路径\nfn get_content(path: &PathBuf, should_read_from_input: bool) -> Result<String> {\n    if should_read_from_input {\n        read_from_stdin()\n    } else {\n        let bars = MultiProgress::new();\n        let style =\n            ProgressStyle::with_template(\"[{elapsed}][{percent}%] {bar:45.cyan/blue} {bytes} {wide_msg}\")?\n                .progress_chars(\">-\");\n        read_file_with_progress(path, style, bars)\n    }\n}\n\n\n// 读取对应路径的文件\nfn read_file_with_progress(path: &PathBuf, style: ProgressStyle, bars: MultiProgress) -> Result<String> {\n    let mut content = String::new();\n\n    let file = File::open(path)?;\n    let size = file.metadata()?.len();\n\n    let bar = ProgressBar::new(size).with_message(format! {\"Reading {}\", path.display()}).with_style(style);\n    let bar = bars.add(bar);\n\n    let mut bufreader = BufReader::new(file);\n    let mut buf = [0; BUFFER_SIZR];\n\n    while let Ok(n) = bufreader.read(&mut buf) {\n        if n == 0 {\n            break;\n        }\n        bar.inc(n as u64);\n        content += &String::from_utf8_lossy(&buf[..n]);\n    }\n    bar.finish_with_message(\"Done!\");\n\n    Ok(content)\n}\n\n\n// 从 stdin 中读取, 作为临时文件的内容\nfn read_from_stdin() -> Result<String> {\n    let mut content = vec![];\n    std::io::stdin().read_to_end(&mut content)?;\n    Ok(String::from_utf8(content)?)\n}\n```\n\n<!-- endtab -->\n\n<!-- tab  进行计算 -->\n\n```rust src/wc_result.rs\n// 声明依赖\nuse crate::{\n    cli::{Cli, SubCommands},\n    files::read_files,\n    Counts, Result,\n};\nuse prettytable::{cell, format::consts::FORMAT_BOX_CHARS, Row, Table};\nuse rayon::prelude::*;\nuse std::{collections::HashMap, path::PathBuf, str};\n\n\n// 存放被启用的 options, 与键值对\npub struct WcResult {\n    enabled_options: Vec<&'static str>,\n    paths_with_counts: HashMap<PathBuf, Counts>,\n}\n\n\n// 实例化函数\npub fn get(mut cli: Cli) -> Result<WcResult> {\n    println!(\"Please waiting...\\n\");\n\n    // 根据子命令进行相应操作\n    match cli.sub_commands {\n        Some(SubCommands::All { ref paths }) => {\n            cli.paths = paths.clone();\n            cli.enable_all_options();\n        }\n        None => cli.enable_all_options(),\n    };\n\n    // 进行计算\n    println!(\"Calculating...\");\n    let wc_result = WcResult {\n        enabled_options: cli.get_enabled_options(),\n        paths_with_counts: {\n            let contents = read_files(cli.paths.clone())?;\n            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&cli, content))).collect()\n        },\n    };\n\n    Ok(wc_result)\n}\n\n\nimpl WcResult {\n    // 将保存的信息转化为美化后的表格\n    pub fn to_pretty_table(self) -> Table {\n        let titles = {\n            let enabled_options = self.enabled_options;\n            let mut titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -> x)).collect());\n            titles.insert_cell(0, cell!(Fybi -> \"Path\"));\n            titles\n        };\n\n        let mut table = Table::new();\n        table.set_titles(titles);\n        table.set_format(*FORMAT_BOX_CHARS);\n\n        for (path, counts) in self.paths_with_counts {\n            let mut row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());\n            let path_cell = if path.starts_with(\"Input\") {\n                cell!(Fbb -> path.display())\n            } else {\n                cell!(Fmb -> path.display())\n            };\n\n            row.insert_cell(0, path_cell);\n            table.add_row(row);\n        }\n\n        table\n    }\n}\n\n\n// 不太懂 rayon, 暂时这样糊上去了\nfn calculate_counts(cli: &Cli, content: String) -> Counts {\n    let v: Vec<Option<usize>> = vec![None; 5];\n    v.into_par_iter()\n        .enumerate()\n        .map(|(idx, _)| match idx {\n            0 => cli.bytes.then_some(content.len()),\n            1 => cli.chars.then_some(content.chars().count()),\n            2 => cli.words.then_some(content.split_whitespace().count()),\n            3 => cli.lines.then_some(content.lines().count()),\n            4 => cli\n                .longest_line\n                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(0)),\n            _ => None,\n        })\n        .flatten()\n        .collect()\n}\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n然后就是 main 函数:  \n\n```rust src/main.rs\nuse clap::Parser;\nuse rust_wc::{cli::Cli, wc_result, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    let pretty_table = wc_result::get(cli)?.to_pretty_table();\n    pretty_table.printstd();\n    Ok(())\n}\n```\n\n就酱, 结束啦! 希望本文能帮到你 :)","source":"_posts/rust/clap/intro.md","raw":"---\ntitle: \"clap-rs 简介\"\nabbrlink: posts/rust-clap/intro\nhidden: false\ndate: 2022-08-16 20:03:34\ntop: 12999\ntags: [Rust, Clap, CLI]\nkeywords: [Rust, Clap, CLI, 命令行]\n---\n> 学习命令行的常识, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能  \n<!-- more -->\n\n前置知识: Rust基础  \n完整代码: [github/jedsek/rust-wc](https://github.com/Jedsek/rust-wc)\n\n:::tips\n**注意**\n本项目基于当前最新版本的 clap, 也就是 version 4\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)\n\n推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手  \n官方教程: [derive tutorial](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)\n官方资料: [derive reference](https://docs.rs/clap/latest/clap/_derive/index.html)\n:::\n\n# 成品展示\n你可以通过如下命令, 从 [crates.io](https://crates.io) 上下载该成品, 可执行文件的名称是 `rwc`:  \n\n```bash\ncargo install rust-wc\n```\n\n以下是使用 [asciinema](https://asciinema.org/) 录制的展示:  \n\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n\n- - -\n\n# 基础概念\nCLI, 是 `command-line interface` 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理  \n如在Linux下常见的 `ls/cp/mv` 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出  \n\nGNU 项目提供了非常多的开源命令, 如 `wc`, 它可以统计文件的 bytes/char/line 的数量  \n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 `wc`  \n\n::: tips\n**注意:**  \ncli 可以代表抽象的界面, 也可以指代具体的某个程序  \n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等\n:::\n\n再写之前, 我们还应了解些基本概念 ~~(直接跳过感觉也木得问题??)~~:  \n\n- `参数(Arguments)`:  \n传给命令的参数, 比如一个路径 ~~(嘶, 感觉在说废话)~~\n\n- `选项(Options)`:\n通常以单/双横杠开头, 不同的options表示不同的行为  \n比如 `ls ./*`, 表示以默认行为下进行输出, `ls -l ./*` 以长列表形式输出, `ls -a ./*` 输出所有隐藏文件  \n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 `ls -i` 与 `ls --inode`  \n\n- `子命令(Subcommands)`:  \n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options  \n比如 `cargo build` 与 `cargo publish`, 都是 `cargo` 的子命令  \n\n- `双横杠(--)`:  \n在命令后面的某处位置, 加上 `--`, 可以将 `--` 后面的内容当作 argument 传入, 而非 options  \n举个例子, 我有个文件, 叫做 `--asd`, 我想使用 `cat --asd` 来输出里面的内容  \n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 `--asd` 这个option, 故失败  \n在比如有个文件叫 `--help`, 使用 `cat --help` 将会打印其 help 信息  \n此时, 你应该使用 `cat -- --asd`, 将 `--asd` 视作参数传入\n\n- `短/长帮助(short/long help)`:\n有些命令, `-h` 与 `--help` 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息\n\n- - -\n\n# 初始配置\n以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件  \n请自行创建好目录:  \n\n```\n./rust-wc\n├── Cargo.lock\n├── Cargo.toml\n└── src\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n   ├── lib.rs         # 声明模块, 类型别名\n   └── main.rs\n```\n\n让我们新建一个叫做 `rust-wc` 的项目, 然后在 `Cargo.toml` 中添加 clap 吧:\n\n```toml Cargo.toml\n# 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)\n[package]\nname = \"rust-wc\"\nauthors = [\"jedsek <jedsek@qq.com>\"]\nversion = \"0.0.1\"\ndescription = \"A GNU/wc implementation written in rust, which is faster when reading a large of big files\"\nedition = \"2021\"\n\n# 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`\n[[bin]]\nname = \"rwc\"\npath = \"src/main.rs\"\n\n# 指定依赖\n[dependencies]\nclap = {version = \"4.0.8\", features = [\"derive\"]}      # 解析参数\nunicode-width = \"0.1.10\"                               # 计算 Unicode 字符宽度\nindicatif = \"0.17.1\"                                   # 进度条\nprettytable-rs = \"0.9.0\"                               # 打印表格\nrayon = \"1.5.3\"                                        # 并行化\n```\n\n以下是 lib.rs 的内容:  \n\n```rust src/lib.rs\n use std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n- - -\n\n# 命令定义\n\n:::tips\n**注意:**\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt  \n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap  \n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码  \n:::\n\n\n让我们来想象下这个命令:  \n\n- 必须接受一个参数\n- 参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容\n- 根据启用的 flag 来决定计算并打印哪些东西\n\n多亏了 derive 宏, 我们可以这样定义它, 下面是 `src/cli.rs` 的完整代码:  \n\n```rust src/cli.rs\nuse clap::{ArgGroup, Parser, Subcommand};\nuse std::path::PathBuf;\n\n#[derive(Parser)]  // 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 \n#[command(\n    author, version, about,\n    group(ArgGroup::new(\"options\").multiple(true).required(true).args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])),\n    subcommand_negates_reqs = true,\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n\n    /// Print the byte counts\n    #[arg(short, long)]\n    pub bytes: bool,\n\n    /// Print the character counts\n    #[arg(short, long)]\n    pub chars: bool,\n\n    /// Print the word counts\n    #[arg(short, long)]\n    pub words: bool,\n\n    /// Print the line counts\n    #[arg(short, long)]\n    pub lines: bool,\n\n    /// Print the maximum line width (Unicode)\n    #[arg(short = 'L', long)]\n    pub longest_line: bool,\n\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n\n\n// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n\nimpl Cli {\n    // 开启所有的 options\n    pub fn enable_all_options(&mut self) {\n        self.bytes = true;\n        self.chars = true;\n        self.words = true;\n        self.lines = true;\n        self.longest_line = true;\n    }\n        \n    // 返回启用的options, 类型是 Vec<&str>, 方便后面打印表格时, 作为表格的标题\n    pub fn get_enabled_options(&self) -> Vec<&'static str> {\n        let mut enabled_options = vec![];\n\n        self.bytes.then(|| enabled_options.push(\"Bytes\"));\n        self.chars.then(|| enabled_options.push(\"Chars\"));\n        self.words.then(|| enabled_options.push(\"Words\"));\n        self.lines.then(|| enabled_options.push(\"Lines\"));\n        self.longest_line.then(|| enabled_options.push(\"Maximum line width (Unicode)\"));\n\n        enabled_options\n    }\n}\n```\n\n以上的代码表示, 我们定义了一个 `Cli` 结构体, 表示对输入参数的建模  \n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型  \n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示  \n\nclap 以及为我们做好了一切 :)  \n\n我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:  \n\n```rust\nuse clap::Parser;\nuse rust_wc::{cli::Cli, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    Ok(())\n}\n```\n\n## 文档注释与帮助\n\n等下再解释, 现在先让我们看看效果, 查看下 help 吧:  \n\n```rust\ncargo run -- -h\n```\n\n```\nA GNU/wc clone written in rust, which is super faster when reading a large of big files\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n       rwc [PATH]... <COMMAND>\n\nCommands:\n  all   Enabled all available options\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  <PATH>...  The path(s) you should provide\n\nOptions:\n  -b, --bytes         Print the byte counts\n  -c, --chars         Print the character counts\n  -w, --words         Print the word counts\n  -l, --lines         Print the line counts\n  -L, --longest-line  Print the maximum line width (Unicode)\n  -h, --help          Print help information\n  -V, --version       Print version information\n```\n\n哇哦! 若你用这段文字, 对比下前面的 `src/cli.rs`, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息  \n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息  \n\n如果你不想要 `about` 信息直接照搬 `Cargo.toml` 里的 `description` 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:  \n\n```rust\n#[derive(Parser)]\n#[command(\n    about = \"...\",\n// ......\n// ......\n```\n\n并且, 像 author/version/about 等信息, 是通过读取 `Cargo.toml` 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁  \n你可以查看 [help_template](https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template) 知晓如何显示, 例子可能是 `builder形式`, 也就是非声明式, 但别慌张:  \n\n你可以像这样将 builder形式 的代码转化为 derive形式:  \n\n```rust\nCommand::new(\"myprog\")\n    .help_template(\"{bin} ({version}) - {usage}\")\n\n#[derive(Parser)]\n#[command(\n    help_template = \"{bin} ({version}) - {usage}\",\n// ......\n// ......\n```\n\n实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码  \n\n## 选项与参数的生成\nclap 能非常方便地以声明的方式, 定义选项/参数\n\n### 选项\n对于一个option, 比如 `-b/--bytes`, 你只需要这样写:  \n\n```rust\n/// Print the byte counts\n#[arg(short, long)]\npub bytes: bool,\n```\n\n它由三部分组成:  \n\n- 文档注释: help 中对该命令的解释\n- `#[arg(short, long)]`: 该 option 具有短/长横杠的形式\n- 类型为bool: 传入时默认的行为是将其设置为 true\n\n如 help 中所示, 会生成如下内容:\n\n```\nOptions:\n  -b, --bytes         Print the byte counts\n```\n\n当你传入该参数时, `Cli` 实例中的 `bytes` 属性将被设置为 true  \n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部  \n\n比如 `-l/--lines` 与 `-L/--longest-line`, 不指定时都是 `-l`, 编译会报错, 需要自己指定:  \n\n```rust\n/// Print the maximum line width (Unicode)\n#[arg(short = 'L', long)]\npub longest_line: bool,\n```\n\n### 参数\n当你没有添加 `short` 或 `long` 时, 自然就代表这是个 argument  \n\n在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径   \n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 `PATH`, 同时指定该参数必选, 防止路径数为0:  \n\n```rust\n/// The path(s) you should provide\n#[arg(value_name = \"PATH\", required = true)]\npub paths: Vec<PathBuf>,\n```\n\n如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:  \n\n```bash\ncargo run -- -b\n```\n\n```\nerror: The following required arguments were not provided:\n  <PATH>...\n\nUsage: rwc <--bytes|--chars|--words|--lines|--longest-line> <PATH>...\n\nFor more information try '--help'\n```\n\n但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行  \n没错, clap 只是负责帮我们生成 `进行转换的代码`  \n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 :)  \n\n因此, 我们来学学如何使用自定义的参数解析器吧\n\n## 自定义参数解析器\n有些疑问或许会萦绕在你的心头:  \n- clap 是怎么进行解析的?\n- clap 能否将传入的参数, 解析为自定义的类型呢?  \n- 我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?\n\n实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证  \n比如, 如果我们想验证传入的路径是否合法, 可以这样写:  \n\n```rust\n// ......\n// ......\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n\nfn check_path(filename: &str) -> Result<PathBuf, String> {\n    let path = PathBuf::from(filename);\n    if filename == \"-\" || path.exists() {\n        Ok(path)\n    } else {\n        Err(format!(\"No such path: `{}`\", path.display()))\n    }\n}\n```\n\nGood, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误  \n该错误会在用户传入非法路径时, 作为报错信息出现:  \n\n```bash\ncargo run -- -b asdxxx\n```\n\n```\nerror: Invalid value \"asd\" for '<PATH>...': No such path: `asdxxx`\n\nFor more information try '--help'\n```\n\n于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser  \n得益于此, 你可以为任何类型定义对应的 parser\n\n## 参数关系\n有时候, 我们可能会面临这样或那样的问题:  \n\n- 当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用\n- 一个或多个指定的 option(s) 必须被启用\n- 多个指定的 options 可以同时被启用\n\n如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情  \n它叫做 `参数关系(Argument Relations)`, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改  \n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系\n\n实际上, 你先前在 `paths` 头上写的 `required = true`, 就是一种参数关系  \n\n以我们的 `rwc` 举个例子:  \n- `-b/-c/-w/-l/-L` 能同时出现, 即支持类似 `-b -c -w` 或 `-bcw` 的形式\n- `-b/-c/-w/-l/-L` 至少出现其中一个, 防止只传路径不传 option \n\n任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系  \n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 `-b/-c/-w/-l/-L` 都放入其中:  \n\n```rust\n// ......\n// ......\n#[derive(Parser)]\n#[command(\n    author, version, about,\n    group(ArgGroup::new(\"options\").multiple(true).required(true).args(&[ \"bytes\", \"chars\", \"words\", \"lines\", \"longest_line\"])),\n)]\npub struct Cli {\n    /// The path(s) you should provide\n    #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n    pub paths: Vec<PathBuf>,\n// ......\n// ......\n```\n\n`multiple(true)` 表示可以同时出现参数组的成员, `required(true)` 表示至少传入该参数组中的其中一个成员  \n\n## 子命令\n我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数  \n\n```rust\npub struct Cli {\n// ......\n// ......\n    #[command(subcommand)]\n    pub sub_commands: Option<SubCommands>,\n}\n\n#[derive(Subcommand)]\npub enum SubCommands {\n    /// Enabled all available options\n    All {\n        /// The path(s) you should provide\n        #[arg(value_parser = check_path, value_name = \"PATH\", required = true)]\n        paths: Vec<PathBuf>,\n    },\n}\n```\n\n你可以会想, 能不能让子命令复用 `Cli` 中定义的 `paths`, 减少重复代码呢?  \n当然可以, 请在 `Cli` 的成员 `paths`, 头上的`#[arg]` 中添加 `global = true`, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数  \n\n但非常遗憾, 当设置 `global = true` 后, 就无法设置 `required = true` 了, 因此我们还是得定义一份相同的参数, 详见 [相关issue](https://github.com/clap-rs/clap/issues/1546)\n\n::: tips\n**注意:**  \n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入  \n但本文还是定义了 subcommand 以便读者了解, 起演示作用\n:::\n\n\n- - -\n# 逻辑实现\n根据:\n\n```\n   ├── wc_result.rs   # 计算并存储结果\n   ├── cli.rs         # 命令行的定义\n   ├── files.rs       # 读取文件\n```\n\n我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了  \n为了避免你回到前面看 `lib.rs` 的内容, 下面再贴一遍:  \n\n```rust src/lib.rs\nuse std::{collections::HashMap, path::PathBuf};\n\npub mod cli;\npub mod files;\npub mod wc_result;\n\npub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;\npub type Counts = Vec<usize>;\npub type PathWithContent = HashMap<PathBuf, String>;\n```\n\n下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:  \n\n{% tabs 逻辑实现代码 %}\n\n<!-- tab 读取文件 -->\n\n```rust src/files.rs\n// 声明依赖\n// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好\nuse crate::{PathWithContent, Result};\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse rayon::prelude::*;\nuse std::ffi::OsStr;\nuse std::process;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::{\n    fs::File,\n    io::{BufReader, Read},\n    path::PathBuf,\n};\n\n\n// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果\n// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)\nstatic INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(0);\nconst BUFFER_SIZR: usize = 16 * 1024;\n\n\n// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀\n// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下\n// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰\ntrait PathExt {\n    fn without_dotted_prefix(&self) -> bool;\n    fn add_dotted_prefix(&mut self);\n}\n\nimpl PathExt for PathBuf {\n    fn without_dotted_prefix(&self) -> bool {\n        self.is_relative() && !self.starts_with(\"../\") && !self.starts_with(\"./\")\n    }\n\n    fn add_dotted_prefix(&mut self) {\n        *self = PathBuf::from_iter([OsStr::new(\"./\"), self.as_os_str()]);\n    }\n}\n\n\n// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组\npub fn read_files(paths: Vec<PathBuf>) -> Result<PathWithContent> {\n    println!(\"Reading files / Getting content from stdin:\");\n\n    // 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧\n    let result = paths\n        .into_par_iter()\n        .filter(|path| path.is_file() || path.as_os_str() == \"-\")\n        .map(|mut path| {\n            let should_read_from_input = path.as_os_str() == \"-\";\n\n            let content = get_content(&path, should_read_from_input);\n\n            if path.without_dotted_prefix() {\n                path.add_dotted_prefix();\n            }\n\n            if should_read_from_input {\n                let inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(1, Ordering::SeqCst);\n                path = PathBuf::from(format!(\"Input/{}\", inputted_file_number));\n            }\n\n            let content = content.unwrap_or_else(|err| {\n                eprintln!(\"{}: {}\", path.display(), err);\n                process::exit(1);\n            });\n\n            (path, content)\n        })\n        .collect();\n    Ok(result)\n}\n\n\n// helper 函数, 针对单个路径\nfn get_content(path: &PathBuf, should_read_from_input: bool) -> Result<String> {\n    if should_read_from_input {\n        read_from_stdin()\n    } else {\n        let bars = MultiProgress::new();\n        let style =\n            ProgressStyle::with_template(\"[{elapsed}][{percent}%] {bar:45.cyan/blue} {bytes} {wide_msg}\")?\n                .progress_chars(\">-\");\n        read_file_with_progress(path, style, bars)\n    }\n}\n\n\n// 读取对应路径的文件\nfn read_file_with_progress(path: &PathBuf, style: ProgressStyle, bars: MultiProgress) -> Result<String> {\n    let mut content = String::new();\n\n    let file = File::open(path)?;\n    let size = file.metadata()?.len();\n\n    let bar = ProgressBar::new(size).with_message(format! {\"Reading {}\", path.display()}).with_style(style);\n    let bar = bars.add(bar);\n\n    let mut bufreader = BufReader::new(file);\n    let mut buf = [0; BUFFER_SIZR];\n\n    while let Ok(n) = bufreader.read(&mut buf) {\n        if n == 0 {\n            break;\n        }\n        bar.inc(n as u64);\n        content += &String::from_utf8_lossy(&buf[..n]);\n    }\n    bar.finish_with_message(\"Done!\");\n\n    Ok(content)\n}\n\n\n// 从 stdin 中读取, 作为临时文件的内容\nfn read_from_stdin() -> Result<String> {\n    let mut content = vec![];\n    std::io::stdin().read_to_end(&mut content)?;\n    Ok(String::from_utf8(content)?)\n}\n```\n\n<!-- endtab -->\n\n<!-- tab  进行计算 -->\n\n```rust src/wc_result.rs\n// 声明依赖\nuse crate::{\n    cli::{Cli, SubCommands},\n    files::read_files,\n    Counts, Result,\n};\nuse prettytable::{cell, format::consts::FORMAT_BOX_CHARS, Row, Table};\nuse rayon::prelude::*;\nuse std::{collections::HashMap, path::PathBuf, str};\n\n\n// 存放被启用的 options, 与键值对\npub struct WcResult {\n    enabled_options: Vec<&'static str>,\n    paths_with_counts: HashMap<PathBuf, Counts>,\n}\n\n\n// 实例化函数\npub fn get(mut cli: Cli) -> Result<WcResult> {\n    println!(\"Please waiting...\\n\");\n\n    // 根据子命令进行相应操作\n    match cli.sub_commands {\n        Some(SubCommands::All { ref paths }) => {\n            cli.paths = paths.clone();\n            cli.enable_all_options();\n        }\n        None => cli.enable_all_options(),\n    };\n\n    // 进行计算\n    println!(\"Calculating...\");\n    let wc_result = WcResult {\n        enabled_options: cli.get_enabled_options(),\n        paths_with_counts: {\n            let contents = read_files(cli.paths.clone())?;\n            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&cli, content))).collect()\n        },\n    };\n\n    Ok(wc_result)\n}\n\n\nimpl WcResult {\n    // 将保存的信息转化为美化后的表格\n    pub fn to_pretty_table(self) -> Table {\n        let titles = {\n            let enabled_options = self.enabled_options;\n            let mut titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -> x)).collect());\n            titles.insert_cell(0, cell!(Fybi -> \"Path\"));\n            titles\n        };\n\n        let mut table = Table::new();\n        table.set_titles(titles);\n        table.set_format(*FORMAT_BOX_CHARS);\n\n        for (path, counts) in self.paths_with_counts {\n            let mut row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());\n            let path_cell = if path.starts_with(\"Input\") {\n                cell!(Fbb -> path.display())\n            } else {\n                cell!(Fmb -> path.display())\n            };\n\n            row.insert_cell(0, path_cell);\n            table.add_row(row);\n        }\n\n        table\n    }\n}\n\n\n// 不太懂 rayon, 暂时这样糊上去了\nfn calculate_counts(cli: &Cli, content: String) -> Counts {\n    let v: Vec<Option<usize>> = vec![None; 5];\n    v.into_par_iter()\n        .enumerate()\n        .map(|(idx, _)| match idx {\n            0 => cli.bytes.then_some(content.len()),\n            1 => cli.chars.then_some(content.chars().count()),\n            2 => cli.words.then_some(content.split_whitespace().count()),\n            3 => cli.lines.then_some(content.lines().count()),\n            4 => cli\n                .longest_line\n                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(0)),\n            _ => None,\n        })\n        .flatten()\n        .collect()\n}\n```\n\n<!-- endtab -->\n\n{% endtabs %}\n\n然后就是 main 函数:  \n\n```rust src/main.rs\nuse clap::Parser;\nuse rust_wc::{cli::Cli, wc_result, Result};\n\nfn main() -> Result<()> {\n    let cli = Cli::parse();\n    let pretty_table = wc_result::get(cli)?.to_pretty_table();\n    pretty_table.printstd();\n    Ok(())\n}\n```\n\n就酱, 结束啦! 希望本文能帮到你 :)","slug":"rust/clap/intro","published":1,"updated":"2022-08-16T12:03:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gi000z6aij8uyfh2zr","content":"<blockquote>\n<p>学习命令行的常识, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>前置知识: Rust基础<br>\n完整代码: <a href=\"https://github.com/Jedsek/rust-wc\">github/jedsek/rust-wc</a></p>\n<div class=\"tips\">\n<p><strong>注意</strong><br>\n本项目基于当前最新版本的 clap, 也就是 version 4<br>\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p>\n<p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>\n官方教程: <a href=\"https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html\">derive tutorial</a><br>\n官方资料: <a href=\"https://docs.rs/clap/latest/clap/_derive/index.html\">derive reference</a></p>\n</div>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>你可以通过如下命令, 从 <a href=\"https://crates.io\">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo install rust-wc</span><br></pre></td></tr></table></figure>\n<p>以下是使用 <a href=\"https://asciinema.org/\">asciinema</a> 录制的展示:</p>\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n<hr>\n<h1 id=\"ji-chu-gai-nian\">基础概念</h1>\n<p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>\n如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p>\n<p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>\n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\ncli 可以代表抽象的界面, 也可以指代具体的某个程序<br>\n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p>\n</div>\n<p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>参数(Arguments)</code>:<br>\n传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>选项(Options)</code>:<br>\n通常以单/双横杠开头, 不同的options表示不同的行为<br>\n比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>\n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>子命令(Subcommands)</code>:<br>\n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>\n比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>双横杠(--)</code>:<br>\n在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>\n举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>\n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>\n在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>\n此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>短/长帮助(short/long help)</code>:<br>\n有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"chu-shi-pei-zhi\">初始配置</h1>\n<p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>\n请自行创建好目录:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">./rust-wc</span><br><span class=\"line\">├── Cargo.lock</span><br><span class=\"line\">├── Cargo.toml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">   ├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">   ├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">   ├── files.rs       <span class=\"meta\"># 读取文件</span></span><br><span class=\"line\">   ├── lib.rs         <span class=\"meta\"># 声明模块, 类型别名</span></span><br><span class=\"line\">   └── main.rs</span><br></pre></td></tr></table></figure>\n<p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rust-wc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">authors</span> = [<span class=\"string\">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">&quot;0.0.1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">description</span> = <span class=\"string\">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class=\"line\"><span class=\"attr\">edition</span> = <span class=\"string\">&quot;2021&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class=\"line\"><span class=\"section\">[[bin]]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rwc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">path</span> = <span class=\"string\">&quot;src/main.rs&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定依赖</span></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">clap</span> = &#123;version = <span class=\"string\">&quot;4.0.8&quot;</span>, features = [<span class=\"string\">&quot;derive&quot;</span>]&#125;      <span class=\"comment\"># 解析参数</span></span><br><span class=\"line\"><span class=\"attr\">unicode-width</span> = <span class=\"string\">&quot;0.1.10&quot;</span>                               <span class=\"comment\"># 计算 Unicode 字符宽度</span></span><br><span class=\"line\"><span class=\"attr\">indicatif</span> = <span class=\"string\">&quot;0.17.1&quot;</span>                                   <span class=\"comment\"># 进度条</span></span><br><span class=\"line\"><span class=\"attr\">prettytable-rs</span> = <span class=\"string\">&quot;0.9.0&quot;</span>                               <span class=\"comment\"># 打印表格</span></span><br><span class=\"line\"><span class=\"attr\">rayon</span> = <span class=\"string\">&quot;1.5.3&quot;</span>                                        <span class=\"comment\"># 并行化</span></span><br></pre></td></tr></table></figure>\n<p>以下是 <a href=\"http://lib.rs\">lib.rs</a> 的内容:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ming-ling-ding-yi\">命令定义</h1>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>\n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>\n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p>\n</div>\n<p>让我们来想象下这个命令:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>必须接受一个参数</p>\n</li>\n<li class=\"lvl-2\">\n<p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p>\n</li>\n<li class=\"lvl-2\">\n<p>根据启用的 flag 来决定计算并打印哪些东西</p>\n</li>\n</ul>\n<p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::path::PathBuf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span>  <span class=\"comment\">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about,</span></span><br><span class=\"line\"><span class=\"meta\">    group(ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)),</span><br><span class=\"line\">    subcommand_negates_reqs = <span class=\"literal\">true</span>,</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the character counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> chars: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the word counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> words: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the line counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> lines: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Cli &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开启所有的 options</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">enable_all_options</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_enabled_options</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> enabled_options = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes.then(|| enabled_options.push(<span class=\"string\">&quot;Bytes&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars.then(|| enabled_options.push(<span class=\"string\">&quot;Chars&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words.then(|| enabled_options.push(<span class=\"string\">&quot;Words&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines.then(|| enabled_options.push(<span class=\"string\">&quot;Lines&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line.then(|| enabled_options.push(<span class=\"string\">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        enabled_options</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>\n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>\n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p>\n<p>clap 以及为我们做好了一切 😃</p>\n<p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"wen-dang-zhu-shi-yu-bang-zhu\" id=\"文档注释与帮助\">文档注释与帮助</h2>\n<p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -h</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">A GNU/wc clone written in rust, which <span class=\"keyword\">is</span> super faster when reading <span class=\"keyword\">a</span> large of big <span class=\"keyword\">files</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class=\"built_in\">line</span>&gt; <span class=\"symbol\">&lt;PATH&gt;</span>...</span><br><span class=\"line\">       rwc [PATH]... <span class=\"symbol\">&lt;COMMAND&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Command<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"keyword\">all</span>   Enabled <span class=\"keyword\">all</span> available <span class=\"keyword\">options</span></span><br><span class=\"line\">  <span class=\"keyword\">help</span>  <span class=\"keyword\">Print</span> this message <span class=\"built_in\">or</span> the <span class=\"keyword\">help</span> of the given subcommand(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Argument<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"symbol\">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class=\"line\"></span><br><span class=\"line\">Option<span class=\"variable\">s:</span></span><br><span class=\"line\">  -<span class=\"keyword\">b</span>, --bytes         <span class=\"keyword\">Print</span> the byte counts</span><br><span class=\"line\">  -<span class=\"keyword\">c</span>, --chars         <span class=\"keyword\">Print</span> the character counts</span><br><span class=\"line\">  -<span class=\"keyword\">w</span>, --words         <span class=\"keyword\">Print</span> the word counts</span><br><span class=\"line\">  -<span class=\"keyword\">l</span>, --lines         <span class=\"keyword\">Print</span> the <span class=\"built_in\">line</span> counts</span><br><span class=\"line\">  -L, --longest-<span class=\"built_in\">line</span>  <span class=\"keyword\">Print</span> the maximum <span class=\"built_in\">line</span> width (Unicode)</span><br><span class=\"line\">  -h, --<span class=\"keyword\">help</span>          <span class=\"keyword\">Print</span> <span class=\"keyword\">help</span> information</span><br><span class=\"line\">  -V, --<span class=\"keyword\">version</span>       <span class=\"keyword\">Print</span> <span class=\"keyword\">version</span> information</span><br></pre></td></tr></table></figure>\n<p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>\n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p>\n<p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    about = <span class=\"meta-string\">&quot;...&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>\n你可以查看 <a href=\"https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template\">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p>\n<p>你可以像这样将 builder形式 的代码转化为 derive形式:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command::new(<span class=\"string\">&quot;myprog&quot;</span>)</span><br><span class=\"line\">    .help_template(<span class=\"string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    help_template = <span class=\"meta-string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p>\n<h2 id=\"xuan-xiang-yu-can-shu-de-sheng-cheng\" id=\"选项与参数的生成\">选项与参数的生成</h2>\n<p>clap 能非常方便地以声明的方式, 定义选项/参数</p>\n<h3 id=\"xuan-xiang\" id=\"选项\">选项</h3>\n<p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<p>它由三部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文档注释: help 中对该命令的解释</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p>类型为bool: 传入时默认的行为是将其设置为 true</p>\n</li>\n</ul>\n<p>如 help 中所示, 会生成如下内容:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Options</span>:</span><br><span class=\"line\">  -b, --bytes         <span class=\"keyword\">Print</span> the <span class=\"keyword\">byte</span> counts</span><br></pre></td></tr></table></figure>\n<p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>\n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p>\n<p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<h3 id=\"can-shu\" id=\"参数\">参数</h3>\n<p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p>\n<p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>\n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure>\n<p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>The following required arguments were not provided:</span><br><span class=\"line\">  &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>\n没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>\n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p>\n<p>因此, 我们来学学如何使用自定义的参数解析器吧</p>\n<h2 id=\"zi-ding-yi-can-shu-jie-xi-qi\" id=\"自定义参数解析器\">自定义参数解析器</h2>\n<p>有些疑问或许会萦绕在你的心头:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>clap 是怎么进行解析的?</p>\n</li>\n<li class=\"lvl-2\">\n<p>clap 能否将传入的参数, 解析为自定义的类型呢?</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p>\n</li>\n</ul>\n<p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>\n比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>\n该错误会在用户传入非法路径时, 作为报错信息出现:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>\n得益于此, 你可以为任何类型定义对应的 parser</p>\n<h2 id=\"can-shu-guan-xi\" id=\"参数关系\">参数关系</h2>\n<p>有时候, 我们可能会面临这样或那样的问题:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个或多个指定的 option(s) 必须被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个指定的 options 可以同时被启用</p>\n</li>\n</ul>\n<p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>\n它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>\n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p>\n<p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p>\n<p>以我们的 <code>rwc</code> 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p>\n</li>\n</ul>\n<p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>\n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about,</span></span><br><span class=\"line\"><span class=\"meta\">    group(ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)),</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n<p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p>\n<h2 id=\"zi-ming-ling\" id=\"子命令\">子命令</h2>\n<p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>\n当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p>\n<p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href=\"https://github.com/clap-rs/clap/issues/1546\">相关issue</a></p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>\n但本文还是定义了 subcommand 以便读者了解, 起演示作用</p>\n</div>\n<hr>\n<h1 id=\"luo-ji-shi-xian\">逻辑实现</h1>\n<p>根据:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">├── files.rs       <span class=\"meta\"># 读取文件</span></span><br></pre></td></tr></table></figure>\n<p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>\n为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p>\n<div class=\"tabs\" id=\"逻辑实现代码\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#逻辑实现代码-1\">读取文件</a></li><li class=\"tab\"><a href=\"#逻辑实现代码-2\">进行计算</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"逻辑实现代码-1\"><figure class=\"highlight rust\"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"comment\">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;PathWithContent, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ffi::OsStr;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::process;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;BufReader, Read&#125;,</span><br><span class=\"line\">    path::PathBuf,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class=\"line\"><span class=\"comment\">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> BUFFER_SIZR: <span class=\"built_in\">usize</span> = <span class=\"number\">16</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class=\"line\"><span class=\"comment\">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class=\"line\"><span class=\"comment\">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">PathExt</span></span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> PathExt <span class=\"keyword\">for</span> PathBuf &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.is_relative() &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;../&quot;</span>) &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;./&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        *<span class=\"keyword\">self</span> = PathBuf::from_iter([OsStr::new(<span class=\"string\">&quot;./&quot;</span>), <span class=\"keyword\">self</span>.as_os_str()]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_files</span></span>(paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;) -&gt; <span class=\"built_in\">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = paths</span><br><span class=\"line\">        .into_par_iter()</span><br><span class=\"line\">        .filter(|path| path.is_file() || path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>)</span><br><span class=\"line\">        .map(|<span class=\"keyword\">mut</span> path| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> should_read_from_input = path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> path.without_dotted_prefix() &#123;</span><br><span class=\"line\">                path.add_dotted_prefix();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class=\"number\">1</span>, Ordering::SeqCst);</span><br><span class=\"line\">                path = PathBuf::from(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class=\"line\">                eprintln!(<span class=\"string\">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            (path, content)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .collect();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// helper 函数, 针对单个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class=\"built_in\">bool</span>) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">        read_from_stdin()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bars = MultiProgress::new();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> style =</span><br><span class=\"line\">            ProgressStyle::with_template(<span class=\"string\">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class=\"line\">                .progress_chars(<span class=\"string\">&quot;&gt;-&quot;</span>);</span><br><span class=\"line\">        read_file_with_progress(path, style, bars)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取对应路径的文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path)?;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> size = file.metadata()?.len();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = ProgressBar::new(size).with_message(<span class=\"built_in\">format!</span> &#123;<span class=\"string\">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = bars.add(bar);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> bufreader = BufReader::new(file);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = [<span class=\"number\">0</span>; BUFFER_SIZR];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Ok</span>(n) = bufreader.read(&amp;<span class=\"keyword\">mut</span> buf) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bar.inc(n <span class=\"keyword\">as</span> <span class=\"built_in\">u64</span>);</span><br><span class=\"line\">        content += &amp;<span class=\"built_in\">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar.finish_with_message(<span class=\"string\">&quot;Done!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_from_stdin</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">    std::io::stdin().read_to_end(&amp;<span class=\"keyword\">mut</span> content)?;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(<span class=\"built_in\">String</span>::from_utf8(content)?)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"逻辑实现代码-2\"><figure class=\"highlight rust\"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;</span><br><span class=\"line\">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class=\"line\">    files::read_files,</span><br><span class=\"line\">    Counts, <span class=\"built_in\">Result</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class=\"built_in\">str</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存放被启用的 options, 与键值对</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WcResult</span></span> &#123;</span><br><span class=\"line\">    enabled_options: <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt;,</span><br><span class=\"line\">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例化函数</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get</span></span>(<span class=\"keyword\">mut</span> cli: Cli) -&gt; <span class=\"built_in\">Result</span>&lt;WcResult&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Please waiting...\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据子命令进行相应操作</span></span><br><span class=\"line\">    <span class=\"keyword\">match</span> cli.sub_commands &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(SubCommands::All &#123; <span class=\"keyword\">ref</span> paths &#125;) =&gt; &#123;</span><br><span class=\"line\">            cli.paths = paths.clone();</span><br><span class=\"line\">            cli.enable_all_options();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">None</span> =&gt; cli.enable_all_options(),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行计算</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Calculating...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> wc_result = WcResult &#123;</span><br><span class=\"line\">        enabled_options: cli.get_enabled_options(),</span><br><span class=\"line\">        paths_with_counts: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class=\"line\">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(wc_result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WcResult &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将保存的信息转化为美化后的表格</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_pretty_table</span></span>(<span class=\"keyword\">self</span>) -&gt; Table &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> titles = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> enabled_options = <span class=\"keyword\">self</span>.enabled_options;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class=\"line\">            titles.insert_cell(<span class=\"number\">0</span>, cell!(Fybi -&gt; <span class=\"string\">&quot;Path&quot;</span>));</span><br><span class=\"line\">            titles</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> table = Table::new();</span><br><span class=\"line\">        table.set_titles(titles);</span><br><span class=\"line\">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (path, counts) <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.paths_with_counts &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class=\"line\">            <span class=\"keyword\">let</span> path_cell = <span class=\"keyword\">if</span> path.starts_with(<span class=\"string\">&quot;Input&quot;</span>) &#123;</span><br><span class=\"line\">                cell!(Fbb -&gt; path.display())</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cell!(Fmb -&gt; path.display())</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            row.insert_cell(<span class=\"number\">0</span>, path_cell);</span><br><span class=\"line\">            table.add_row(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        table</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">calculate_counts</span></span>(cli: &amp;Cli, content: <span class=\"built_in\">String</span>) -&gt; Counts &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">usize</span>&gt;&gt; = <span class=\"built_in\">vec!</span>[<span class=\"literal\">None</span>; <span class=\"number\">5</span>];</span><br><span class=\"line\">    v.into_par_iter()</span><br><span class=\"line\">        .enumerate()</span><br><span class=\"line\">        .map(|(idx, _)| <span class=\"keyword\">match</span> idx &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class=\"line\">            <span class=\"number\">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class=\"line\">            <span class=\"number\">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class=\"line\">            <span class=\"number\">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class=\"line\">            <span class=\"number\">4</span> =&gt; cli</span><br><span class=\"line\">                .longest_line</span><br><span class=\"line\">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class=\"number\">0</span>)),</span><br><span class=\"line\">            _ =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .flatten()</span><br><span class=\"line\">        .collect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></div></div>\n<p>然后就是 main 函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class=\"line\">    pretty_table.printstd();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就酱, 结束啦! 希望本文能帮到你 😃</p>\n","site":{"data":{}},"length":15868,"excerpt":"<blockquote>\n<p>学习命令行的常识, 然后用 clap-rs 写个类似 GNU/wc 命令的 rwc 吧, 增加了进度条, 表格输出, 并行化等功能</p>\n</blockquote>","more":"<p>前置知识: Rust基础<br>\n完整代码: <a href=\"https://github.com/Jedsek/rust-wc\">github/jedsek/rust-wc</a></p>\n<div class=\"tips\">\n<p><strong>注意</strong><br>\n本项目基于当前最新版本的 clap, 也就是 version 4<br>\n本项目使用 clap 中的 derive 特性, 而非 builder 特性 (其实差不多)</p>\n<p>推荐读者别直接跟着敲代码, 先整体看一遍, 明白大致思路后再动手<br>\n官方教程: <a href=\"https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html\">derive tutorial</a><br>\n官方资料: <a href=\"https://docs.rs/clap/latest/clap/_derive/index.html\">derive reference</a></p>\n</div>\n<h1 id=\"cheng-pin-zhan-shi\">成品展示</h1>\n<p>你可以通过如下命令, 从 <a href=\"https://crates.io\">crates.io</a> 上下载该成品, 可执行文件的名称是 <code>rwc</code>:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo install rust-wc</span><br></pre></td></tr></table></figure>\n<p>以下是使用 <a href=\"https://asciinema.org/\">asciinema</a> 录制的展示:</p>\n<script id=\"asciicast-534647\" src=\"https://asciinema.org/a/534647.js\" async></script>\n<hr>\n<h1 id=\"ji-chu-gai-nian\">基础概念</h1>\n<p>CLI, 是 <code>command-line interface</code> 的简称, 意思是命令行界面, 和 GUI/TUI 是一个道理<br>\n如在Linux下常见的 <code>ls/cp/mv</code> 等命令, 你传入参数, 它就会做些事情, 并可能会打印相应输出</p>\n<p>GNU 项目提供了非常多的开源命令, 如 <code>wc</code>, 它可以统计文件的 bytes/char/line 的数量<br>\n我们将会使用 Rust 语言, 搭配一个叫 clap 的库, 写一个升级版的 <code>wc</code></p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\ncli 可以代表抽象的界面, 也可以指代具体的某个程序<br>\n后文中的cli, 一般情况下都指代某个具体的命令行程序, 比如 ls/cp 等</p>\n</div>\n<p>再写之前, 我们还应了解些基本概念 <s>(直接跳过感觉也木得问题??)</s>:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>参数(Arguments)</code>:<br>\n传给命令的参数, 比如一个路径 <s>(嘶, 感觉在说废话)</s></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>选项(Options)</code>:<br>\n通常以单/双横杠开头, 不同的options表示不同的行为<br>\n比如 <code>ls ./*</code>, 表示以默认行为下进行输出, <code>ls -l ./*</code> 以长列表形式输出, <code>ls -a ./*</code> 输出所有隐藏文件<br>\n单横杠开头的只有一个字母, 双横杠开头的可以有很多字母, 如 <code>ls -i</code> 与 <code>ls --inode</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>子命令(Subcommands)</code>:<br>\n一个命令的子命令, 通常情况下需要不同的 args, 有不同的 options<br>\n比如 <code>cargo build</code> 与 <code>cargo publish</code>, 都是 <code>cargo</code> 的子命令</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>双横杠(--)</code>:<br>\n在命令后面的某处位置, 加上 <code>--</code>, 可以将 <code>--</code> 后面的内容当作 argument 传入, 而非 options<br>\n举个例子, 我有个文件, 叫做 <code>--asd</code>, 我想使用 <code>cat --asd</code> 来输出里面的内容<br>\n如果你直接这样传参, 因为文件名以横杠开头, 将会被命令视作 options, 而 cat 本身没 <code>--asd</code> 这个option, 故失败<br>\n在比如有个文件叫 <code>--help</code>, 使用 <code>cat --help</code> 将会打印其 help 信息<br>\n此时, 你应该使用 <code>cat -- --asd</code>, 将 <code>--asd</code> 视作参数传入</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>短/长帮助(short/long help)</code>:<br>\n有些命令, <code>-h</code> 与 <code>--help</code> 分别对应短帮助与长帮助, 后者比前者会显示更多提示信息</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"chu-shi-pei-zhi\">初始配置</h1>\n<p>以下是层次结构, 之后要生成自动补全文件时, 还会再增加一些文件<br>\n请自行创建好目录:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">./rust-wc</span><br><span class=\"line\">├── Cargo.lock</span><br><span class=\"line\">├── Cargo.toml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">   ├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">   ├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">   ├── files.rs       <span class=\"meta\"># 读取文件</span></span><br><span class=\"line\">   ├── lib.rs         <span class=\"meta\"># 声明模块, 类型别名</span></span><br><span class=\"line\">   └── main.rs</span><br></pre></td></tr></table></figure>\n<p>让我们新建一个叫做 <code>rust-wc</code> 的项目, 然后在 <code>Cargo.toml</code> 中添加 clap 吧:</p>\n<figure class=\"highlight toml\"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 包名为 `rust-wc` (因为我发布到 crates.io 的时候, `rwc` 已经被占了呜呜呜呜呜)</span></span><br><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rust-wc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">authors</span> = [<span class=\"string\">&quot;jedsek &lt;jedsek@qq.com&gt;&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">&quot;0.0.1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">description</span> = <span class=\"string\">&quot;A GNU/wc implementation written in rust, which is faster when reading a large of big files&quot;</span></span><br><span class=\"line\"><span class=\"attr\">edition</span> = <span class=\"string\">&quot;2021&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定生成的可执行文件的名字, 此处是 `rwc`, 虽然包名是 `rust-wc`, 但命令是 `rwc`</span></span><br><span class=\"line\"><span class=\"section\">[[bin]]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rwc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">path</span> = <span class=\"string\">&quot;src/main.rs&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定依赖</span></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">clap</span> = &#123;version = <span class=\"string\">&quot;4.0.8&quot;</span>, features = [<span class=\"string\">&quot;derive&quot;</span>]&#125;      <span class=\"comment\"># 解析参数</span></span><br><span class=\"line\"><span class=\"attr\">unicode-width</span> = <span class=\"string\">&quot;0.1.10&quot;</span>                               <span class=\"comment\"># 计算 Unicode 字符宽度</span></span><br><span class=\"line\"><span class=\"attr\">indicatif</span> = <span class=\"string\">&quot;0.17.1&quot;</span>                                   <span class=\"comment\"># 进度条</span></span><br><span class=\"line\"><span class=\"attr\">prettytable-rs</span> = <span class=\"string\">&quot;0.9.0&quot;</span>                               <span class=\"comment\"># 打印表格</span></span><br><span class=\"line\"><span class=\"attr\">rayon</span> = <span class=\"string\">&quot;1.5.3&quot;</span>                                        <span class=\"comment\"># 并行化</span></span><br></pre></td></tr></table></figure>\n<p>以下是 <a href=\"http://lib.rs\">lib.rs</a> 的内容:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"ming-ling-ding-yi\">命令定义</h1>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\nclap-v3 时, 融进了另一个很强大的命令行编写库: structopt<br>\n因此以后看见 structopt 与 clap, 直接用 clap 就完事了, 前者也发过通知, 让别人直接用 clap<br>\n这给 clap 带来的巨大变化, 就是出现了derive宏, 以一种非常便利的声明式写法, 帮你生成与解析代码</p>\n</div>\n<p>让我们来想象下这个命令:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>必须接受一个参数</p>\n</li>\n<li class=\"lvl-2\">\n<p>参数必须是存在的路径, 或者是 -, 表示从标准输入读取内容</p>\n</li>\n<li class=\"lvl-2\">\n<p>根据启用的 flag 来决定计算并打印哪些东西</p>\n</li>\n</ul>\n<p>多亏了 derive 宏, 我们可以这样定义它, 下面是 <code>src/cli.rs</code> 的完整代码:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/cli.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::&#123;ArgGroup, Parser, Subcommand&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::path::PathBuf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span>  <span class=\"comment\">// 这里的 derive(Parser) 表示下面这一坨都会被 `宏的黑魔法` 所洗礼 </span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about,</span></span><br><span class=\"line\"><span class=\"meta\">    group(ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)),</span><br><span class=\"line\">    subcommand_negates_reqs = <span class=\"literal\">true</span>,</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the character counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> chars: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the word counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> words: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the line counts</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> lines: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义了一个解析器, 检测路径是否存在, 或者是否从标准输入读取内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Cli &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开启所有的 options</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">enable_all_options</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 返回启用的options, 类型是 Vec&lt;&amp;str&gt;, 方便后面打印表格时, 作为表格的标题</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_enabled_options</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> enabled_options = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.bytes.then(|| enabled_options.push(<span class=\"string\">&quot;Bytes&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.chars.then(|| enabled_options.push(<span class=\"string\">&quot;Chars&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.words.then(|| enabled_options.push(<span class=\"string\">&quot;Words&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lines.then(|| enabled_options.push(<span class=\"string\">&quot;Lines&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.longest_line.then(|| enabled_options.push(<span class=\"string\">&quot;Maximum line width (Unicode)&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        enabled_options</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的代码表示, 我们定义了一个 <code>Cli</code> 结构体, 表示对输入参数的建模<br>\n得益于宏的黑魔法, clap 将生成一些代码, 使我们不用再耗费脑力, 考虑如何处理输入参数, 并将其解析为对应类型<br>\n也不用再考虑解析失败时, 应该如何编写一个用户友好的错误提示</p>\n<p>clap 以及为我们做好了一切 😃</p>\n<p>我们能调用 clap 为我们实现的 Parser (trait) 中的 parse 方法, 解析参数并进行转换:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"wen-dang-zhu-shi-yu-bang-zhu\" id=\"文档注释与帮助\">文档注释与帮助</h2>\n<p>等下再解释, 现在先让我们看看效果, 查看下 help 吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -h</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">A GNU/wc clone written in rust, which <span class=\"keyword\">is</span> super faster when reading <span class=\"keyword\">a</span> large of big <span class=\"keyword\">files</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-<span class=\"built_in\">line</span>&gt; <span class=\"symbol\">&lt;PATH&gt;</span>...</span><br><span class=\"line\">       rwc [PATH]... <span class=\"symbol\">&lt;COMMAND&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Command<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"keyword\">all</span>   Enabled <span class=\"keyword\">all</span> available <span class=\"keyword\">options</span></span><br><span class=\"line\">  <span class=\"keyword\">help</span>  <span class=\"keyword\">Print</span> this message <span class=\"built_in\">or</span> the <span class=\"keyword\">help</span> of the given subcommand(s)</span><br><span class=\"line\"></span><br><span class=\"line\">Argument<span class=\"variable\">s:</span></span><br><span class=\"line\">  <span class=\"symbol\">&lt;PATH&gt;</span>...  The path(s) you should provide</span><br><span class=\"line\"></span><br><span class=\"line\">Option<span class=\"variable\">s:</span></span><br><span class=\"line\">  -<span class=\"keyword\">b</span>, --bytes         <span class=\"keyword\">Print</span> the byte counts</span><br><span class=\"line\">  -<span class=\"keyword\">c</span>, --chars         <span class=\"keyword\">Print</span> the character counts</span><br><span class=\"line\">  -<span class=\"keyword\">w</span>, --words         <span class=\"keyword\">Print</span> the word counts</span><br><span class=\"line\">  -<span class=\"keyword\">l</span>, --lines         <span class=\"keyword\">Print</span> the <span class=\"built_in\">line</span> counts</span><br><span class=\"line\">  -L, --longest-<span class=\"built_in\">line</span>  <span class=\"keyword\">Print</span> the maximum <span class=\"built_in\">line</span> width (Unicode)</span><br><span class=\"line\">  -h, --<span class=\"keyword\">help</span>          <span class=\"keyword\">Print</span> <span class=\"keyword\">help</span> information</span><br><span class=\"line\">  -V, --<span class=\"keyword\">version</span>       <span class=\"keyword\">Print</span> <span class=\"keyword\">version</span> information</span><br></pre></td></tr></table></figure>\n<p>哇哦! 若你用这段文字, 对比下前面的 <code>src/cli.rs</code>, 会发现先前的文档注释, 在声明宏的威力下, 变成了 help 信息<br>\n没错! clap 能自动帮你做很多事情, 包括但不限于通过文本注释来生成 help 信息</p>\n<p>如果你不想要 <code>about</code> 信息直接照搬 <code>Cargo.toml</code> 里的 <code>description</code> 怎么办? 没事, 直接覆写就行, 覆写的优先级更高:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    about = <span class=\"meta-string\">&quot;...&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>并且, 像 author/version/about 等信息, 是通过读取 <code>Cargo.toml</code> 来获取的, 但在 v4 版本, clap 默认不显示, 以保持简洁<br>\n你可以查看 <a href=\"https://docs.rs/clap/latest/clap/builder/struct.Command.html#method.help_template\">help_template</a> 知晓如何显示, 例子可能是 <code>builder形式</code>, 也就是非声明式, 但别慌张:</p>\n<p>你可以像这样将 builder形式 的代码转化为 derive形式:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">Command::new(<span class=\"string\">&quot;myprog&quot;</span>)</span><br><span class=\"line\">    .help_template(<span class=\"string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    help_template = <span class=\"meta-string\">&quot;&#123;bin&#125; (&#123;version&#125;) - &#123;usage&#125;&quot;</span>,</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">// ......</span></span><br></pre></td></tr></table></figure>\n<p>实际上, 宏的黑魔法, 就是将这些声明式代码, 在编译期转化为 builder 代码</p>\n<h2 id=\"xuan-xiang-yu-can-shu-de-sheng-cheng\" id=\"选项与参数的生成\">选项与参数的生成</h2>\n<p>clap 能非常方便地以声明的方式, 定义选项/参数</p>\n<h3 id=\"xuan-xiang\" id=\"选项\">选项</h3>\n<p>对于一个option, 比如 <code>-b/--bytes</code>, 你只需要这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the byte counts</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> bytes: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<p>它由三部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>文档注释: help 中对该命令的解释</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>#[arg(short, long)]</code>: 该 option 具有短/长横杠的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p>类型为bool: 传入时默认的行为是将其设置为 true</p>\n</li>\n</ul>\n<p>如 help 中所示, 会生成如下内容:</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Options</span>:</span><br><span class=\"line\">  -b, --bytes         <span class=\"keyword\">Print</span> the <span class=\"keyword\">byte</span> counts</span><br></pre></td></tr></table></figure>\n<p>当你传入该参数时, <code>Cli</code> 实例中的 <code>bytes</code> 属性将被设置为 true<br>\n你也可以自行指定 short/long 的名称, 不指定时, short取首字母, long取全部</p>\n<p>比如 <code>-l/--lines</code> 与 <code>-L/--longest-line</code>, 不指定时都是 <code>-l</code>, 编译会报错, 需要自己指定:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Print the maximum line width (Unicode)</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(short = &#x27;L&#x27;, long)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> longest_line: <span class=\"built_in\">bool</span>,</span><br></pre></td></tr></table></figure>\n<h3 id=\"can-shu\" id=\"参数\">参数</h3>\n<p>当你没有添加 <code>short</code> 或 <code>long</code> 时, 自然就代表这是个 argument</p>\n<p>在这里, 我们唯一需要的参数, 是一个或多个路径, 因此我们使用 Vec<PathBuf> 来表示它, clap 会自动将参数解析为路径<br>\n为了醒目, 我们将其显示在 help 中的名字, 改为大写的 <code>PATH</code>, 同时指定该参数必选, 防止路径数为0:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\"><span class=\"meta\">#[arg(value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br></pre></td></tr></table></figure>\n<p>如果你不输入参数, 命令行就会优雅地显示错误, 友善地来提醒你:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>The following required arguments were not provided:</span><br><span class=\"line\">  &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: rwc &lt;--bytes|--chars|--words|--lines|--longest-line&gt; &lt;PATH&gt;...</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>但此时, 其实还有一个问题: 参数虽然被转化为 PathBuf, 但不存在的路径也是路径啊! 此时就应该报错才行<br>\n没错, clap 只是负责帮我们生成 <code>进行转换的代码</code><br>\n但验证存在性等工作, 应该自己来完成, 毕竟 clap 又不知道这个参数会被拿去干啥 😃</p>\n<p>因此, 我们来学学如何使用自定义的参数解析器吧</p>\n<h2 id=\"zi-ding-yi-can-shu-jie-xi-qi\" id=\"自定义参数解析器\">自定义参数解析器</h2>\n<p>有些疑问或许会萦绕在你的心头:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>clap 是怎么进行解析的?</p>\n</li>\n<li class=\"lvl-2\">\n<p>clap 能否将传入的参数, 解析为自定义的类型呢?</p>\n</li>\n<li class=\"lvl-2\">\n<p>我们能否在用户穿参时, 检查参数是否合法, 非法的直接报错, 来提醒用户呢?</p>\n</li>\n</ul>\n<p>实际上, 你需要通过向名为 value_parser 的函数, 传入一个解析器, 通过调用该解析器来对参数进行解析与验证<br>\n比如, 如果我们想验证传入的路径是否合法, 可以这样写:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">check_path</span></span>(filename: &amp;<span class=\"built_in\">str</span>) -&gt; <span class=\"built_in\">Result</span>&lt;PathBuf, <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = PathBuf::from(filename);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> filename == <span class=\"string\">&quot;-&quot;</span> || path.exists() &#123;</span><br><span class=\"line\">        <span class=\"literal\">Ok</span>(path)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"literal\">Err</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;No such path: `&#123;&#125;`&quot;</span>, path.display()))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Good, 现在当你传入路径时, 程序会对路径进行验证, 若路径不存在, 那就返回一个错误<br>\n该错误会在用户传入非法路径时, 作为报错信息出现:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cargo run -- -b asdxxx</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">error: </span>Invalid value &quot;asd&quot; for &#x27;&lt;PATH&gt;...&#x27;: No such path: `asdxxx`</span><br><span class=\"line\"></span><br><span class=\"line\">For more information try &#x27;--help&#x27;</span><br></pre></td></tr></table></figure>\n<p>于此同时, clap 已经为非常多的基本类型, 常用类型, 嵌套基本类型, 嵌套常用类型实现了非常多的 parser<br>\n得益于此, 你可以为任何类型定义对应的 parser</p>\n<h2 id=\"can-shu-guan-xi\" id=\"参数关系\">参数关系</h2>\n<p>有时候, 我们可能会面临这样或那样的问题:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当启用这个 option 时, 另外一个与其冲突的 option 不应该被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个或多个指定的 option(s) 必须被启用</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个指定的 options 可以同时被启用</p>\n</li>\n</ul>\n<p>如何实现这些关系? 你可能会想自己手写, 但时间不应该浪费在这些事情上, 在 clap 中, 有着对应机制来处理这些事情<br>\n它叫做 <code>参数关系(Argument Relations)</code>, 当参数不符合对应关系时, 会出现友善的报错信息, 提示用户应该如何修改<br>\n因此, 我们可以使用 Arg/ArgGroup (参数与参数组) 来声明这些关系</p>\n<p>实际上, 你先前在 <code>paths</code> 头上写的 <code>required = true</code>, 就是一种参数关系</p>\n<p>以我们的 <code>rwc</code> 举个例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 能同时出现, 即支持类似 <code>-b -c -w</code> 或 <code>-bcw</code> 的形式</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>-b/-c/-w/-l/-L</code> 至少出现其中一个, 防止只传路径不传 option</p>\n</li>\n</ul>\n<p>任何一个 Arg 类型 (被 #[arg] 所修饰的), 或者 ArgGroup, 都能够声明这种参数间的关系<br>\n我们可以新建一个 ArgGroup 的实例, 然后把先前的一坨 <code>-b/-c/-w/-l/-L</code> 都放入其中:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(Parser)]</span></span><br><span class=\"line\"><span class=\"meta\">#[command(</span></span><br><span class=\"line\"><span class=\"meta\">    author, version, about,</span></span><br><span class=\"line\"><span class=\"meta\">    group(ArgGroup::new(<span class=\"meta-string\">&quot;options&quot;</span>).multiple(true).required(true).args(&amp;[ <span class=\"meta-string\">&quot;bytes&quot;</span>, <span class=\"meta-string\">&quot;chars&quot;</span>, <span class=\"meta-string\">&quot;words&quot;</span>, <span class=\"meta-string\">&quot;lines&quot;</span>, <span class=\"meta-string\">&quot;longest_line&quot;</span>]</span>)),</span><br><span class=\"line\">)]</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">    <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n<p><code>multiple(true)</code> 表示可以同时出现参数组的成员, <code>required(true)</code> 表示至少传入该参数组中的其中一个成员</p>\n<h2 id=\"zi-ming-ling\" id=\"子命令\">子命令</h2>\n<p>我们还可以定义一个 subcommand, 用来启用所有的 options, 它也要接受一个路径作为参数</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cli</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"meta\">#[command(subcommand)]</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> sub_commands: <span class=\"built_in\">Option</span>&lt;SubCommands&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Subcommand)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SubCommands</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// Enabled all available options</span></span><br><span class=\"line\">    All &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// The path(s) you should provide</span></span><br><span class=\"line\">        <span class=\"meta\">#[arg(value_parser = check_path, value_name = <span class=\"meta-string\">&quot;PATH&quot;</span>, required = true)]</span></span><br><span class=\"line\">        paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以会想, 能不能让子命令复用 <code>Cli</code> 中定义的 <code>paths</code>, 减少重复代码呢?<br>\n当然可以, 请在 <code>Cli</code> 的成员 <code>paths</code>, 头上的<code>#[arg]</code> 中添加 <code>global = true</code>, 表示该参数是全局性的, 相当于子命令中也添加了这么个参数</p>\n<p>但非常遗憾, 当设置 <code>global = true</code> 后, 就无法设置 <code>required = true</code> 了, 因此我们还是得定义一份相同的参数, 详见 <a href=\"https://github.com/clap-rs/clap/issues/1546\">相关issue</a></p>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n这里其实可以选择不定义 subcommand, 当没有传入 options 时默认开启所有 options, 来简化用户输入<br>\n但本文还是定义了 subcommand 以便读者了解, 起演示作用</p>\n</div>\n<hr>\n<h1 id=\"luo-ji-shi-xian\">逻辑实现</h1>\n<p>根据:</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── wc_result.rs   <span class=\"meta\"># 计算并存储结果</span></span><br><span class=\"line\">├── <span class=\"keyword\">cli</span>.rs         <span class=\"meta\"># 命令行的定义</span></span><br><span class=\"line\">├── files.rs       <span class=\"meta\"># 读取文件</span></span><br></pre></td></tr></table></figure>\n<p>我们已经完成了对命令行的定义, 接下来要做的, 就是根据 Cli 的内容来实现逻辑了<br>\n为了避免你回到前面看 <code>lib.rs</code> 的内容, 下面再贴一遍:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/lib.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> cli;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> files;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> wc_result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = std::result::<span class=\"built_in\">Result</span>&lt;T, <span class=\"built_in\">Box</span>&lt;<span class=\"keyword\">dyn</span> std::error::Error&gt;&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Counts</span></span> = <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">usize</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">PathWithContent</span></span> = HashMap&lt;PathBuf, <span class=\"built_in\">String</span>&gt;;</span><br></pre></td></tr></table></figure>\n<p>下面是对应模块的逻辑实现, 在我的博客中是以tab的形式呈现, 比较清晰, 其他平台未知:</p>\n<div class=\"tabs\" id=\"逻辑实现代码\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a href=\"#逻辑实现代码-1\">读取文件</a></li><li class=\"tab\"><a href=\"#逻辑实现代码-2\">进行计算</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"逻辑实现代码-1\"><figure class=\"highlight rust\"><figcaption><span>src/files.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"comment\">// 我写的时候遇见没有导入的, 也是直接用 lsp 来自动导入, 直接与后面的代码对照看会比较好</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;PathWithContent, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> indicatif::&#123;MultiProgress, ProgressBar, ProgressStyle&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::ffi::OsStr;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::process;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;BufReader, Read&#125;,</span><br><span class=\"line\">    path::PathBuf,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `INPUTTED_FILE_NUMBER` 表示 INPUT 的编号, 是本文开篇的 asciinema 展示中的效果</span></span><br><span class=\"line\"><span class=\"comment\">// `BUFFER_SIZR` 表示每次读取文件时缓冲区的大小 (实现进度条)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> INPUTTED_FILE_NUMBER: AtomicUsize = AtomicUsize::new(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> BUFFER_SIZR: <span class=\"built_in\">usize</span> = <span class=\"number\">16</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 trait 来扩展标准库中的 PathBuf 类型, 有两个函数, 一个检测是否是以点开头的, 一个加上点前缀</span></span><br><span class=\"line\"><span class=\"comment\">// 比如, 当你传入 `./build.rs` 与 `build.rs`, 前者输出时有点前缀, 后者没有, 因此统一下</span></span><br><span class=\"line\"><span class=\"comment\">// 并且当是从 stdin 读取的时候, 就显示无点前缀的 `Input/0` 会更清晰</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">PathExt</span></span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> PathExt <span class=\"keyword\">for</span> PathBuf &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">without_dotted_prefix</span></span>(&amp;<span class=\"keyword\">self</span>) -&gt; <span class=\"built_in\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.is_relative() &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;../&quot;</span>) &amp;&amp; !<span class=\"keyword\">self</span>.starts_with(<span class=\"string\">&quot;./&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_dotted_prefix</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        *<span class=\"keyword\">self</span> = PathBuf::from_iter([OsStr::new(<span class=\"string\">&quot;./&quot;</span>), <span class=\"keyword\">self</span>.as_os_str()]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件的函数, 被暴露给其他模块, 参数是一个路径数组</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_files</span></span>(paths: <span class=\"built_in\">Vec</span>&lt;PathBuf&gt;) -&gt; <span class=\"built_in\">Result</span>&lt;PathWithContent&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Reading files / Getting content from stdin:&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其实这里的 filter 不太好, 还可以判断目录与递归读取, 但暂时就这样吧</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = paths</span><br><span class=\"line\">        .into_par_iter()</span><br><span class=\"line\">        .filter(|path| path.is_file() || path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>)</span><br><span class=\"line\">        .map(|<span class=\"keyword\">mut</span> path| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> should_read_from_input = path.as_os_str() == <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = get_content(&amp;path, should_read_from_input);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> path.without_dotted_prefix() &#123;</span><br><span class=\"line\">                path.add_dotted_prefix();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> inputted_file_number = INPUTTED_FILE_NUMBER.fetch_add(<span class=\"number\">1</span>, Ordering::SeqCst);</span><br><span class=\"line\">                path = PathBuf::from(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;Input/&#123;&#125;&quot;</span>, inputted_file_number));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> content = content.unwrap_or_else(|err| &#123;</span><br><span class=\"line\">                eprintln!(<span class=\"string\">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, path.display(), err);</span><br><span class=\"line\">                process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            (path, content)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .collect();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// helper 函数, 针对单个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_content</span></span>(path: &amp;PathBuf, should_read_from_input: <span class=\"built_in\">bool</span>) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> should_read_from_input &#123;</span><br><span class=\"line\">        read_from_stdin()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> bars = MultiProgress::new();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> style =</span><br><span class=\"line\">            ProgressStyle::with_template(<span class=\"string\">&quot;[&#123;elapsed&#125;][&#123;percent&#125;%] &#123;bar:45.cyan/blue&#125; &#123;bytes&#125; &#123;wide_msg&#125;&quot;</span>)?</span><br><span class=\"line\">                .progress_chars(<span class=\"string\">&quot;&gt;-&quot;</span>);</span><br><span class=\"line\">        read_file_with_progress(path, style, bars)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取对应路径的文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_file_with_progress</span></span>(path: &amp;PathBuf, style: ProgressStyle, bars: MultiProgress) -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path)?;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> size = file.metadata()?.len();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = ProgressBar::new(size).with_message(<span class=\"built_in\">format!</span> &#123;<span class=\"string\">&quot;Reading &#123;&#125;&quot;</span>, path.display()&#125;).with_style(style);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bar = bars.add(bar);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> bufreader = BufReader::new(file);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> buf = [<span class=\"number\">0</span>; BUFFER_SIZR];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> <span class=\"literal\">Ok</span>(n) = bufreader.read(&amp;<span class=\"keyword\">mut</span> buf) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bar.inc(n <span class=\"keyword\">as</span> <span class=\"built_in\">u64</span>);</span><br><span class=\"line\">        content += &amp;<span class=\"built_in\">String</span>::from_utf8_lossy(&amp;buf[..n]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar.finish_with_message(<span class=\"string\">&quot;Done!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从 stdin 中读取, 作为临时文件的内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">read_from_stdin</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> content = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">    std::io::stdin().read_to_end(&amp;<span class=\"keyword\">mut</span> content)?;</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(<span class=\"built_in\">String</span>::from_utf8(content)?)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div><div class=\"tab-pane\" id=\"逻辑实现代码-2\"><figure class=\"highlight rust\"><figcaption><span>src/wc_result.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明依赖</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::&#123;</span><br><span class=\"line\">    cli::&#123;Cli, SubCommands&#125;,</span><br><span class=\"line\">    files::read_files,</span><br><span class=\"line\">    Counts, <span class=\"built_in\">Result</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> prettytable::&#123;cell, format::consts::FORMAT_BOX_CHARS, Row, Table&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rayon::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;collections::HashMap, path::PathBuf, <span class=\"built_in\">str</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存放被启用的 options, 与键值对</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WcResult</span></span> &#123;</span><br><span class=\"line\">    enabled_options: <span class=\"built_in\">Vec</span>&lt;&amp;<span class=\"symbol\">&#x27;static</span> <span class=\"built_in\">str</span>&gt;,</span><br><span class=\"line\">    paths_with_counts: HashMap&lt;PathBuf, Counts&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例化函数</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get</span></span>(<span class=\"keyword\">mut</span> cli: Cli) -&gt; <span class=\"built_in\">Result</span>&lt;WcResult&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Please waiting...\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据子命令进行相应操作</span></span><br><span class=\"line\">    <span class=\"keyword\">match</span> cli.sub_commands &#123;</span><br><span class=\"line\">        <span class=\"literal\">Some</span>(SubCommands::All &#123; <span class=\"keyword\">ref</span> paths &#125;) =&gt; &#123;</span><br><span class=\"line\">            cli.paths = paths.clone();</span><br><span class=\"line\">            cli.enable_all_options();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"literal\">None</span> =&gt; cli.enable_all_options(),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行计算</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Calculating...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> wc_result = WcResult &#123;</span><br><span class=\"line\">        enabled_options: cli.get_enabled_options(),</span><br><span class=\"line\">        paths_with_counts: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> contents = read_files(cli.paths.clone())?;</span><br><span class=\"line\">            contents.into_par_iter().map(|(path, content)| (path, calculate_counts(&amp;cli, content))).collect()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(wc_result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> WcResult &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将保存的信息转化为美化后的表格</span></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">to_pretty_table</span></span>(<span class=\"keyword\">self</span>) -&gt; Table &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> titles = &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> enabled_options = <span class=\"keyword\">self</span>.enabled_options;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> titles = Row::new(enabled_options.into_iter().map(|x| cell!(Fybi -&gt; x)).collect());</span><br><span class=\"line\">            titles.insert_cell(<span class=\"number\">0</span>, cell!(Fybi -&gt; <span class=\"string\">&quot;Path&quot;</span>));</span><br><span class=\"line\">            titles</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> table = Table::new();</span><br><span class=\"line\">        table.set_titles(titles);</span><br><span class=\"line\">        table.set_format(*FORMAT_BOX_CHARS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (path, counts) <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.paths_with_counts &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> row = Row::new(counts.into_iter().map(|x| cell!(x)).collect());</span><br><span class=\"line\">            <span class=\"keyword\">let</span> path_cell = <span class=\"keyword\">if</span> path.starts_with(<span class=\"string\">&quot;Input&quot;</span>) &#123;</span><br><span class=\"line\">                cell!(Fbb -&gt; path.display())</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cell!(Fmb -&gt; path.display())</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            row.insert_cell(<span class=\"number\">0</span>, path_cell);</span><br><span class=\"line\">            table.add_row(row);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        table</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不太懂 rayon, 暂时这样糊上去了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">calculate_counts</span></span>(cli: &amp;Cli, content: <span class=\"built_in\">String</span>) -&gt; Counts &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">usize</span>&gt;&gt; = <span class=\"built_in\">vec!</span>[<span class=\"literal\">None</span>; <span class=\"number\">5</span>];</span><br><span class=\"line\">    v.into_par_iter()</span><br><span class=\"line\">        .enumerate()</span><br><span class=\"line\">        .map(|(idx, _)| <span class=\"keyword\">match</span> idx &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> =&gt; cli.bytes.then_some(content.len()),</span><br><span class=\"line\">            <span class=\"number\">1</span> =&gt; cli.chars.then_some(content.chars().count()),</span><br><span class=\"line\">            <span class=\"number\">2</span> =&gt; cli.words.then_some(content.split_whitespace().count()),</span><br><span class=\"line\">            <span class=\"number\">3</span> =&gt; cli.lines.then_some(content.lines().count()),</span><br><span class=\"line\">            <span class=\"number\">4</span> =&gt; cli</span><br><span class=\"line\">                .longest_line</span><br><span class=\"line\">                .then_some(content.lines().map(unicode_width::UnicodeWidthStr::width).max().unwrap_or(<span class=\"number\">0</span>)),</span><br><span class=\"line\">            _ =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .flatten()</span><br><span class=\"line\">        .collect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></div></div>\n<p>然后就是 main 函数:</p>\n<figure class=\"highlight rust\"><figcaption><span>src/main.rs</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> clap::Parser;</span><br><span class=\"line\"><span class=\"keyword\">use</span> rust_wc::&#123;cli::Cli, wc_result, <span class=\"built_in\">Result</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; <span class=\"built_in\">Result</span>&lt;()&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cli = Cli::parse();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pretty_table = wc_result::get(cli)?.to_pretty_table();</span><br><span class=\"line\">    pretty_table.printstd();</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就酱, 结束啦! 希望本文能帮到你 😃</p>"},{"title":"rust-decl-macro-p2: 从println开始","abbrlink":"posts/rust-decl-macro/p2","date":"2021-09-19T14:50:27.000Z","top":10998,"keywords":["Macro","声明宏","Rust"],"_content":"> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇  \n大家应该都用过一个宏, 它就是 `println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?  \n\n亲爱的 TRPl 在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 时告诉过你: 名字后加个感叹号,就是个`宏(macro)`  \n可 macro 到底是啥? ~~(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)~~  \n\n- - -\n\n# 查看定义  \n让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现, 根本看不懂这堆鬼画符... 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:  \n\n- 我们将`macro_rules!`放在`println`前面,说明后者是个宏 (`macro_rules!`当作特定语法即可)  \n- 之后用花括号包起来,里面是该宏的具体定义  \n\n问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?  \n请容许我来帮你粗暴地类比一下`match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:  \n\nmatch:\n- match表达式,称呼每个匹配分支为`arm`  \n- 逗号分割它们彼此,或者不用逗号而用花括号包裹来分割  \n- 最后一个arm可省略逗号  \n\nmacro:\n- macro,则称呼每个匹配分支为`rule`(明白为什么使用`macro_rules!`创建宏了吗)  \n- 必须使用花括号包裹,使用分号分隔彼此  \n- 最后一个rule可省略分号  \n\n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可  \n现在再来看看 `println`,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\nfn main() {}\n```\n\n2. 然后创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {}\n```\n\n3. 调用时, 要做到: 宏名+感叹号+传参:  \n(传入的参数,若与任何rule都不匹配,则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  \n","source":"_posts/rust/decl-macro/p2-从println开始.md","raw":"---\ntitle: \"rust-decl-macro-p2: 从println开始\"\nabbrlink: posts/rust-decl-macro/p2\ndate: 2021-09-19 22:50:27\ntop: 10998\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\n---\n> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇  \n大家应该都用过一个宏, 它就是 `println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?  \n\n亲爱的 TRPl 在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 时告诉过你: 名字后加个感叹号,就是个`宏(macro)`  \n可 macro 到底是啥? ~~(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)~~  \n\n- - -\n\n# 查看定义  \n让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现, 根本看不懂这堆鬼画符... 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:  \n\n- 我们将`macro_rules!`放在`println`前面,说明后者是个宏 (`macro_rules!`当作特定语法即可)  \n- 之后用花括号包起来,里面是该宏的具体定义  \n\n问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?  \n请容许我来帮你粗暴地类比一下`match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:  \n\nmatch:\n- match表达式,称呼每个匹配分支为`arm`  \n- 逗号分割它们彼此,或者不用逗号而用花括号包裹来分割  \n- 最后一个arm可省略逗号  \n\nmacro:\n- macro,则称呼每个匹配分支为`rule`(明白为什么使用`macro_rules!`创建宏了吗)  \n- 必须使用花括号包裹,使用分号分隔彼此  \n- 最后一个rule可省略分号  \n\n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可  \n现在再来看看 `println`,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\nfn main() {}\n```\n\n2. 然后创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {}\n```\n\n3. 调用时, 要做到: 宏名+感叹号+传参:  \n(传入的参数,若与任何rule都不匹配,则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  \n","slug":"rust/decl-macro/p2-从println开始","published":1,"updated":"2021-09-19T14:50:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gj00126aij8rrg5sjr","content":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家应该都用过一个宏, 它就是 <code>println!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?</p>\n<p>亲爱的 TRPl 在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 时告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>\n可 macro 到底是啥? <s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p>\n<hr>\n<h1 id=\"cha-kan-ding-yi\">查看定义</h1>\n<p>让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n<p>你悲催地发现, 根本看不懂这堆鬼画符… 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏 (<code>macro_rules!</code>当作特定语法即可)</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后用花括号包起来,里面是该宏的具体定义</p>\n</li>\n</ul>\n<p>问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?<br>\n请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>macro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:</p>\n<p>match:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>match表达式,称呼每个匹配分支为<code>arm</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个arm可省略逗号</p>\n</li>\n</ul>\n<p>macro:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)</p>\n</li>\n<li class=\"lvl-2\">\n<p>必须使用花括号包裹,使用分号分隔彼此</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个rule可省略分号</p>\n</li>\n</ul>\n<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>\n现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>然后创建两个匹配分支:<br>\n(匹配空参 =&gt; 不做任何事)<br>\n(匹配123 =&gt; 打印123)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>调用时, 要做到: 宏名+感叹号+传参:<br>\n(传入的参数,若与任何rule都不匹配,则报错)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>\n咱们下期见</p>\n","site":{"data":{}},"length":2285,"excerpt":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家应该都用过一个宏, 它就是 <code>println!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑, 为什么后面要跟个感叹号? 为什么括号里面的参数可以不一样?</p>\n<p>亲爱的 TRPl 在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 时告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>\n可 macro 到底是啥? <s>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</s></p>\n<hr>\n<h1 id=\"cha-kan-ding-yi\">查看定义</h1>\n<p>让我们按住Ctrl,鼠标左键点击println (以VSCode 为例):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n<p>你悲催地发现, 根本看不懂这堆鬼画符… 但没事, 到后面几节你肯定就懂, 现在只需明白的是大致结构:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏 (<code>macro_rules!</code>当作特定语法即可)</p>\n</li>\n<li class=\"lvl-2\">\n<p>之后用花括号包起来,里面是该宏的具体定义</p>\n</li>\n</ul>\n<p>问题来了, 那对花括号内, 也就是具体定义里, 到底干着怎么的事?<br>\n请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>macro有点像是match,能根据不同参数,展开不同的代码, 在macro最外层的花括号中,有许多匹配分支, 想match一样:</p>\n<p>match:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>match表达式,称呼每个匹配分支为<code>arm</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个arm可省略逗号</p>\n</li>\n</ul>\n<p>macro:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)</p>\n</li>\n<li class=\"lvl-2\">\n<p>必须使用花括号包裹,使用分号分隔彼此</p>\n</li>\n<li class=\"lvl-2\">\n<p>最后一个rule可省略分号</p>\n</li>\n</ul>\n<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>\n现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"zong-jie\">总结</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>创建一个假设叫xxx的macro,花括号包裹具体定义:</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>然后创建两个匹配分支:<br>\n(匹配空参 =&gt; 不做任何事)<br>\n(匹配123 =&gt; 打印123)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>调用时, 要做到: 宏名+感叹号+传参:<br>\n(传入的参数,若与任何rule都不匹配,则报错)</p>\n</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知, 相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>\n咱们下期见</p>"},{"title":"rust-decl-macro-p3: 声明与使用","abbrlink":"posts/rust-decl-macro/p3","date":"2021-09-20T12:06:15.000Z","top":10997,"keywords":["Macro","声明宏","Rust"],"_content":"> 正式系统的关于 macro 的 声明与使用\n<!-- more -->  \n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 框架建立\n前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:  \n- `macro_rules!(这是特点语法)`来创建一个macro\n- `rule(s)(匹配分支,以 \"参数=>展开代码\" 的形式)`放在最外层的花括号内  \n- 调用宏时,宏名+感叹号+括号内传参,比如: `println!(some_str)`  \n\n现在稍微深入一点:  \n一个 `rule` 可以被这样抽象地表示: (matcher)=>(transcriber), 它由三个重要的部分组成:\n\n- `matcher (匹配器)`: 用来匹配传入的参数  \n- `metavariable/literal (元变量/字面量)`: 绑定传入的代码片段,出现于 `matcher`\n- `transcriber (转录器)`: 用来在宏匹配成功后,进行代码替换\n\n以`println!`为例子,我们向其传入了一些参数,它给我们打印到标准输出上  \n因为原本的`println!`涉及到`卫生性`,`重复语法`,`路径作用域`等,不适合新鸟阅读,所以我抽象了它:  \n\n```rust\nmacro_rules! println {\n    (/* 空参匹配 */) => (/* `换行` 的代码 */);\n    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)\n}\n```\n\n`println`由两个`rule`组成,每个的形式都是: `matcher=>transcriber`, 从上往下,每个rule的`matcher`会与传入参数尝试匹配, 匹配时括号具有多样性  \n下面是具体阐述:  \n\n匹配规则:  \n- 匹配到: 就替换为`transcriber`里面的代码  \n- 匹配不到: 所有`matcher`都无法与`传入参数`进行匹配,则编译报错  \n\n括号多样性: \n- 概念: `matcher`与`transcriber`的括号,可以是(),[],{}三种之一  \n- 定义时: 比如, rule可写成 `[pattern]=>{expansion}`  \n- 调用时: 一样遵从该规则, 比如 `vec![0, 1,2,3]` 与 `pritnln!(\"xx\")`\n\n而`metavariable/literal`则出现在`matcher`中,用于匹配并捕获代码片段  \n在对应的`transcriber`中,则可以操控这些`元值`,即操控捕获到的代码片段  \n\n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n\n- - -\n\n# 两种宏参数\n是时候引入一些新的东西了, 顺便加深下你的印象  \n\n## 元变量  \n元变量, 即Metavariable, 让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\nfn main() {\n\tmy_macro!(1);\n\tmy_macro!(1, 2);\n}\n/* 宏全部展开后, 可以理解为下面: \nfn main() {\n    1;\n    1 + 2;\n}\n*/\n```\n\n你会注意到,每个rule之间的参数, 其声明都有点奇怪:  \n比如: `$a:expr` -> `$+参数标识符+类型`  \n\n`$` 这个前缀是干嘛的?  \n这显式说明, 它是 `metavariable`, 可以匹配并捕获代码片段, 这里会捕获表达式  \n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~  \n\n先看看 `expr` 类型, 其全称为 `expression(表达式)`  \n第一次宏调用时, 传入了 `1(一个字面量)`, 这当然是个expr, 与第一个rule成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为相应的展开代码`  \n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码  \nmacro就像个code generator: 一段用来生成code的code  \n注意: \nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点  \n在本节下面会更详细地讲讲\n## 元字面量  \n元字面量, 即Metaliteral  \n为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 -- 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  \n\n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  \n这种固定的参数, 如同token中的字面量一样  \n我姑且称它为 `Literal Token(字面量标记)`, 或者 `Metaliteral (元字面量)`\n(因为我也不知道有什么对应术语, 所以用了 \"姑且\", 知道的麻烦告诉我)  \n\n假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! fuck {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tfuck!(1);       // No\n\tfuck!(a:expr);  // Yes ~~(Oh~)~~\n}\n```\n\n对于定义中的 \"a:expr\"(它是 `MetaLiteral`), 传入固定形式的 \"a:expr\" 时才可发生匹配  \n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰  \n\n## 例子\n假设有这么个宏 `map!`(联想一下`vec!`)  \n它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  \n如下:  \n\n```rust\nfn main() {\n\tlet m = map![\n\t\t\"吉良吉影\" => 33,\n\t\t\"空条承太郎\" => 41,\n\t]\n\t// `m` 的类型为: std::collections::HashMap<&str, i32>\n}\n```\n\n我们来写一个这样的宏吧!  \n不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  \n\n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key=>Value`  \n来看看两种宏参数在宏中, 发挥着怎样的作用:  \n- `Metavariable`: \n将捕获的传入的代码片段绑定到自身, 并在 `Transcriber` 中被使用, 最后展开为新代码  \n\n- `Metaliteral `: \n限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配\n若改成 `map!(\"普通上班族\", 33)`, 则每个rule的 `Matcher` 都无法匹配上  \n(这里只有一个rule, 空匹配的懒得放里面了)  \n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  \n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  \n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册  \n(博客的话, 我周六放学回来慢慢更吧......)\n~~(潜台词是随时会鸽子)~~\n\n- - -\n\n# 本质  \nmacro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  \n\n假若由你来设计一个Rust编译器:  \n\n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n若我们将每遍扫描并做点事情的过程, 称为`pass`, pass一次就生成了, 对于很大的源码来说, 这不现实吧  \n那我们就pass多次, 将 `从源码编译为目标码` 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗\n\n这种 `中间表示`, 就称为 `IR (Intermediate Representation )`  \n\n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:  \n\n```rust\n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  \nenum ASTNode {\n\tInt(i32), \n\tBinaryExpr {\n\t\top: Op,\n\t\tlhs: Box<ASTNode>,\n\t\trhs: Box<ASTNode>,\n\t}\n}\n// 二元运算的符号: 这里只抽象了加法\nenum Op {\n\tPlus, \n}\n```\n\n你只需明白AST是对源码封装的一层抽象产物就可以了  \n\n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了  \n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n\n基于AST, 我们可以再来一些`IR`, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛  \n`AST`很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码    \n\nQ: 生成AST需要点啥? 或者说, 它由什么组成?  \nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 `token`  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架  \n这个庞然大物便是 AST 了  \n\n- - - \n\n# 回到Macro  \n## Token类型表\n生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型  \n\nmacro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?  \n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 `Metavariable`)  \n\n所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\n|名称|对应|\n|--|--|\n|ident|标识符, 如函数名, 变量名, 关键字|\n|expr|expression, 表达式,如`x`与`1_i32`|\n|literal|literal expression, 即字面量表达式, 是expr的子集|\n|pat|pattern, 比如在match表达式下的 (pattern) => todo!()|\n|path|路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的|\n|ty|type, 如 i32, u32, String, Option<T>等|\n|tt|token tree, 之后我会单独再讲解下它的|\n|meta|元条目/项, 比如 `#[allow(unsued)]`, `meta` 就对应 `allow(unuse)` |\n|vis|visibility, 可见性, 比如pub, pub(crate)等, 也可能为空|\n|lifetime|生命周期|\n|item|条目/项, 例如函数定义|\n|block|代码块|\n|stmt|statemen, 语句|\n\n## TT\n这里有个比较特殊的类型 `tt (Token Tree)`  \n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~  \n\n`tt`,可以捕获`Single Token`,或由(),[],{}及括号包裹起来的东西  \n作为 Token Tree 的根节点, 先让我们来点例子:  \n```rust\nmacro_rules! aa {\n    ($a:tt) => {\n        println!(\"{}\", stringify!($a));\n    };\n}\nfn main() {\n\t// Single Token\n    aa!(123);          // Yes: 123\n    aa!(FuckYou);      // Yes: FuckYou\n    // aa!(Fuck You);     // No\n    // aa!(123 + 11);     // No\n\t// (), [], {}\n\taa!([123]);        // Yes: [123]\n\taa!({123 + 123});  // Yes: { 123 + 123 }\n}\n```\n上面的代码, 展示了 `tt` 可以匹配捕获哪些东西  \n请看以下内容, 以理解它, 我们以`<<xxx>>`, 来表示 `xxx` 是一颗 `Token Tree`  \n```rust\n// 你的眼中:\n1 + 2 + (3 + 4)\n// tt的眼中:\n<<1>> <<+>> <<2>> <<+>> <<( )>>\n                           |\n                           |\n                   <<3>> <<+>> <<4>>\n```\n这段代码的Token Tree共有5个:  \n1. <<1>>\n2. <<+>>\n3. <<2>>\n4. <<+>>\n5. <<(3 + 4)>>\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree  \n对于第5个, 因为有()包裹, <<(...)>> 作为根节点, 它还有三个子节点(这里正好同层)  \n\n有没有对 `Token后面跟着Tree` 更加理解?  \n\n\n## AST节点\n\nmacro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)  \n比如 `map!` 中, `$key:value` 与 `$val:expr`, 都会被解析为expr类型的AST节点:  \n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n\n我们通过使用 macro , 站在了更抽象的视角上  \n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  \n\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md) 上面的代码了:  \n\n```rust\nmacro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5)\n    );\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5)\n    );\n}\n```\n\n输出结果会是:  \n```rust\ngot an identifier\ngot an addition\ngot something else\ngot something else\ngot something else\ngot something else\n```\n\n比如这里, `match_tokens` 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!  \n\n比如 `5 + 7`, 原本是可以与 `$a:tt + $b:tt` 相匹配, 也可以与 `$a: expr` 匹配  \n但经二次传入后(向 `capture_then_match_tokens`传入的参数又传给 `match_tokens`)  \n`5 + 7` 变成AST表达式节点, 只能与 `$a: expr`, 而不能与 `$a:tt + $b:tt` 匹配  \n\n只有 `tt`, `ident`, `lifetime` 能免遭 AST节点化, 可以好好理解下这块  \n\n总结:  \n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点  \n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 :D)\n\n宏展开的结果是个某类型的AST节点, 这相比于C语言的 `#define` 宏, 有什么好处?  \n最直接的好处, 如下 ~~(相当于自动给你加上了括号)~~:\n```rust\n// C语言: 简单的文本替换\n#define SUM(a,b) a+b\nint main(void) {\n\tSUM(2, 2);     // 2 * 2\n\t5 * SUM(2, 2); // 5 * 2 + 2\n\treturn 0;\n}\n// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点\nmacro_rules! sum {\n\t($a:expr,$b:expr) => {$a + $b};\n}\nfn main() {\n\tsum!(2,2);     // 2 + 2\n\t5 * sum!(2,2); // 5 * (2 + 2)\n}\n```\n\n\n## 匹配注意点\n在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md)\n\n### 匹配误区\n来看看下面一段代码:\n```rust\nmacro_rules! aa {\n\t($a: expr) => {};\n\t($a: ident +) => {}\n}\nfn main() {\n\taa!(a);   // Yes\n\taa!(a+);  // No\n}\n```\n\n按照你的直觉, `aa!(a+)` 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:  \n\n```rust\nexpected expression, found end of macro arguments\n// 期望表达式, 却发现宏参数结束了\n```\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \n\n`a (lhs, left hand side)` 能被第一个rule匹配  \n而 `+ (二元加)` 因为可以尾随表达式, 也可以被第一个rule匹配\n但由于缺少 `rhs`, 此时会直接报错, 而不是去尝试匹配下一个rule  \n\n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n\n### 歧义限制  \n由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 `Metavariable` 后面可以跟的内容有所限制, 详情可见 [Rust-Reference: 限制](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)  \n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可  \n~~(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)~~  \n\n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n","source":"_posts/rust/decl-macro/p3-声明与使用.md","raw":"---\ntitle: \"rust-decl-macro-p3: 声明与使用\"\nabbrlink: posts/rust-decl-macro/p3\ndate: 2021-09-20 20:06:15\ntop: 10997\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\n---\n> 正式系统的关于 macro 的 声明与使用\n<!-- more -->  \n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 框架建立\n前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:  \n- `macro_rules!(这是特点语法)`来创建一个macro\n- `rule(s)(匹配分支,以 \"参数=>展开代码\" 的形式)`放在最外层的花括号内  \n- 调用宏时,宏名+感叹号+括号内传参,比如: `println!(some_str)`  \n\n现在稍微深入一点:  \n一个 `rule` 可以被这样抽象地表示: (matcher)=>(transcriber), 它由三个重要的部分组成:\n\n- `matcher (匹配器)`: 用来匹配传入的参数  \n- `metavariable/literal (元变量/字面量)`: 绑定传入的代码片段,出现于 `matcher`\n- `transcriber (转录器)`: 用来在宏匹配成功后,进行代码替换\n\n以`println!`为例子,我们向其传入了一些参数,它给我们打印到标准输出上  \n因为原本的`println!`涉及到`卫生性`,`重复语法`,`路径作用域`等,不适合新鸟阅读,所以我抽象了它:  \n\n```rust\nmacro_rules! println {\n    (/* 空参匹配 */) => (/* `换行` 的代码 */);\n    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)\n}\n```\n\n`println`由两个`rule`组成,每个的形式都是: `matcher=>transcriber`, 从上往下,每个rule的`matcher`会与传入参数尝试匹配, 匹配时括号具有多样性  \n下面是具体阐述:  \n\n匹配规则:  \n- 匹配到: 就替换为`transcriber`里面的代码  \n- 匹配不到: 所有`matcher`都无法与`传入参数`进行匹配,则编译报错  \n\n括号多样性: \n- 概念: `matcher`与`transcriber`的括号,可以是(),[],{}三种之一  \n- 定义时: 比如, rule可写成 `[pattern]=>{expansion}`  \n- 调用时: 一样遵从该规则, 比如 `vec![0, 1,2,3]` 与 `pritnln!(\"xx\")`\n\n而`metavariable/literal`则出现在`matcher`中,用于匹配并捕获代码片段  \n在对应的`transcriber`中,则可以操控这些`元值`,即操控捕获到的代码片段  \n\n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n\n- - -\n\n# 两种宏参数\n是时候引入一些新的东西了, 顺便加深下你的印象  \n\n## 元变量  \n元变量, 即Metavariable, 让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\nfn main() {\n\tmy_macro!(1);\n\tmy_macro!(1, 2);\n}\n/* 宏全部展开后, 可以理解为下面: \nfn main() {\n    1;\n    1 + 2;\n}\n*/\n```\n\n你会注意到,每个rule之间的参数, 其声明都有点奇怪:  \n比如: `$a:expr` -> `$+参数标识符+类型`  \n\n`$` 这个前缀是干嘛的?  \n这显式说明, 它是 `metavariable`, 可以匹配并捕获代码片段, 这里会捕获表达式  \n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~  \n\n先看看 `expr` 类型, 其全称为 `expression(表达式)`  \n第一次宏调用时, 传入了 `1(一个字面量)`, 这当然是个expr, 与第一个rule成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为相应的展开代码`  \n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码  \nmacro就像个code generator: 一段用来生成code的code  \n注意: \nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点  \n在本节下面会更详细地讲讲\n## 元字面量  \n元字面量, 即Metaliteral  \n为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 -- 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  \n\n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  \n这种固定的参数, 如同token中的字面量一样  \n我姑且称它为 `Literal Token(字面量标记)`, 或者 `Metaliteral (元字面量)`\n(因为我也不知道有什么对应术语, 所以用了 \"姑且\", 知道的麻烦告诉我)  \n\n假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! fuck {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tfuck!(1);       // No\n\tfuck!(a:expr);  // Yes ~~(Oh~)~~\n}\n```\n\n对于定义中的 \"a:expr\"(它是 `MetaLiteral`), 传入固定形式的 \"a:expr\" 时才可发生匹配  \n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰  \n\n## 例子\n假设有这么个宏 `map!`(联想一下`vec!`)  \n它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  \n如下:  \n\n```rust\nfn main() {\n\tlet m = map![\n\t\t\"吉良吉影\" => 33,\n\t\t\"空条承太郎\" => 41,\n\t]\n\t// `m` 的类型为: std::collections::HashMap<&str, i32>\n}\n```\n\n我们来写一个这样的宏吧!  \n不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  \n\n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key=>Value`  \n来看看两种宏参数在宏中, 发挥着怎样的作用:  \n- `Metavariable`: \n将捕获的传入的代码片段绑定到自身, 并在 `Transcriber` 中被使用, 最后展开为新代码  \n\n- `Metaliteral `: \n限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配\n若改成 `map!(\"普通上班族\", 33)`, 则每个rule的 `Matcher` 都无法匹配上  \n(这里只有一个rule, 空匹配的懒得放里面了)  \n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  \n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  \n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册  \n(博客的话, 我周六放学回来慢慢更吧......)\n~~(潜台词是随时会鸽子)~~\n\n- - -\n\n# 本质  \nmacro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  \n\n假若由你来设计一个Rust编译器:  \n\n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n若我们将每遍扫描并做点事情的过程, 称为`pass`, pass一次就生成了, 对于很大的源码来说, 这不现实吧  \n那我们就pass多次, 将 `从源码编译为目标码` 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗\n\n这种 `中间表示`, 就称为 `IR (Intermediate Representation )`  \n\n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:  \n\n```rust\n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  \nenum ASTNode {\n\tInt(i32), \n\tBinaryExpr {\n\t\top: Op,\n\t\tlhs: Box<ASTNode>,\n\t\trhs: Box<ASTNode>,\n\t}\n}\n// 二元运算的符号: 这里只抽象了加法\nenum Op {\n\tPlus, \n}\n```\n\n你只需明白AST是对源码封装的一层抽象产物就可以了  \n\n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了  \n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n\n基于AST, 我们可以再来一些`IR`, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛  \n`AST`很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码    \n\nQ: 生成AST需要点啥? 或者说, 它由什么组成?  \nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 `token`  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架  \n这个庞然大物便是 AST 了  \n\n- - - \n\n# 回到Macro  \n## Token类型表\n生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型  \n\nmacro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?  \n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 `Metavariable`)  \n\n所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\n|名称|对应|\n|--|--|\n|ident|标识符, 如函数名, 变量名, 关键字|\n|expr|expression, 表达式,如`x`与`1_i32`|\n|literal|literal expression, 即字面量表达式, 是expr的子集|\n|pat|pattern, 比如在match表达式下的 (pattern) => todo!()|\n|path|路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的|\n|ty|type, 如 i32, u32, String, Option<T>等|\n|tt|token tree, 之后我会单独再讲解下它的|\n|meta|元条目/项, 比如 `#[allow(unsued)]`, `meta` 就对应 `allow(unuse)` |\n|vis|visibility, 可见性, 比如pub, pub(crate)等, 也可能为空|\n|lifetime|生命周期|\n|item|条目/项, 例如函数定义|\n|block|代码块|\n|stmt|statemen, 语句|\n\n## TT\n这里有个比较特殊的类型 `tt (Token Tree)`  \n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~  \n\n`tt`,可以捕获`Single Token`,或由(),[],{}及括号包裹起来的东西  \n作为 Token Tree 的根节点, 先让我们来点例子:  \n```rust\nmacro_rules! aa {\n    ($a:tt) => {\n        println!(\"{}\", stringify!($a));\n    };\n}\nfn main() {\n\t// Single Token\n    aa!(123);          // Yes: 123\n    aa!(FuckYou);      // Yes: FuckYou\n    // aa!(Fuck You);     // No\n    // aa!(123 + 11);     // No\n\t// (), [], {}\n\taa!([123]);        // Yes: [123]\n\taa!({123 + 123});  // Yes: { 123 + 123 }\n}\n```\n上面的代码, 展示了 `tt` 可以匹配捕获哪些东西  \n请看以下内容, 以理解它, 我们以`<<xxx>>`, 来表示 `xxx` 是一颗 `Token Tree`  \n```rust\n// 你的眼中:\n1 + 2 + (3 + 4)\n// tt的眼中:\n<<1>> <<+>> <<2>> <<+>> <<( )>>\n                           |\n                           |\n                   <<3>> <<+>> <<4>>\n```\n这段代码的Token Tree共有5个:  \n1. <<1>>\n2. <<+>>\n3. <<2>>\n4. <<+>>\n5. <<(3 + 4)>>\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree  \n对于第5个, 因为有()包裹, <<(...)>> 作为根节点, 它还有三个子节点(这里正好同层)  \n\n有没有对 `Token后面跟着Tree` 更加理解?  \n\n\n## AST节点\n\nmacro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)  \n比如 `map!` 中, `$key:value` 与 `$val:expr`, 都会被解析为expr类型的AST节点:  \n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n\n我们通过使用 macro , 站在了更抽象的视角上  \n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  \n\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md) 上面的代码了:  \n\n```rust\nmacro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5)\n    );\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5)\n    );\n}\n```\n\n输出结果会是:  \n```rust\ngot an identifier\ngot an addition\ngot something else\ngot something else\ngot something else\ngot something else\n```\n\n比如这里, `match_tokens` 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!  \n\n比如 `5 + 7`, 原本是可以与 `$a:tt + $b:tt` 相匹配, 也可以与 `$a: expr` 匹配  \n但经二次传入后(向 `capture_then_match_tokens`传入的参数又传给 `match_tokens`)  \n`5 + 7` 变成AST表达式节点, 只能与 `$a: expr`, 而不能与 `$a:tt + $b:tt` 匹配  \n\n只有 `tt`, `ident`, `lifetime` 能免遭 AST节点化, 可以好好理解下这块  \n\n总结:  \n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点  \n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 :D)\n\n宏展开的结果是个某类型的AST节点, 这相比于C语言的 `#define` 宏, 有什么好处?  \n最直接的好处, 如下 ~~(相当于自动给你加上了括号)~~:\n```rust\n// C语言: 简单的文本替换\n#define SUM(a,b) a+b\nint main(void) {\n\tSUM(2, 2);     // 2 * 2\n\t5 * SUM(2, 2); // 5 * 2 + 2\n\treturn 0;\n}\n// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点\nmacro_rules! sum {\n\t($a:expr,$b:expr) => {$a + $b};\n}\nfn main() {\n\tsum!(2,2);     // 2 + 2\n\t5 * sum!(2,2); // 5 * (2 + 2)\n}\n```\n\n\n## 匹配注意点\n在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md)\n\n### 匹配误区\n来看看下面一段代码:\n```rust\nmacro_rules! aa {\n\t($a: expr) => {};\n\t($a: ident +) => {}\n}\nfn main() {\n\taa!(a);   // Yes\n\taa!(a+);  // No\n}\n```\n\n按照你的直觉, `aa!(a+)` 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:  \n\n```rust\nexpected expression, found end of macro arguments\n// 期望表达式, 却发现宏参数结束了\n```\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \n\n`a (lhs, left hand side)` 能被第一个rule匹配  \n而 `+ (二元加)` 因为可以尾随表达式, 也可以被第一个rule匹配\n但由于缺少 `rhs`, 此时会直接报错, 而不是去尝试匹配下一个rule  \n\n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n\n### 歧义限制  \n由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 `Metavariable` 后面可以跟的内容有所限制, 详情可见 [Rust-Reference: 限制](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)  \n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可  \n~~(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)~~  \n\n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n","slug":"rust/decl-macro/p3-声明与使用","published":1,"updated":"2021-09-20T12:06:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gk00146aij79ii8p59","content":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>\n<span id=\"more\"></span>  \n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kuang-jia-jian-li\">框架建立</h1>\n<p>前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p>\n</li>\n</ul>\n<p>现在稍微深入一点:<br>\n一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber), 它由三个重要的部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>matcher (匹配器)</code>: 用来匹配传入的参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>metavariable/literal (元变量/字面量)</code>: 绑定传入的代码片段,出现于 <code>matcher</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>transcriber (转录器)</code>: 用来在宏匹配成功后,进行代码替换</p>\n</li>\n</ul>\n<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>\n因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    (<span class=\"comment\">/* 空参匹配 */</span>) =&gt; (<span class=\"comment\">/* `换行` 的代码 */</span>);</span><br><span class=\"line\">    (<span class=\"comment\">/* 有参匹配 */</span>) =&gt; (<span class=\"comment\">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code>, 从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配, 匹配时括号具有多样性<br>\n下面是具体阐述:</p>\n<p>匹配规则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匹配到: 就替换为<code>transcriber</code>里面的代码</p>\n</li>\n<li class=\"lvl-2\">\n<p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p>\n</li>\n</ul>\n<p>括号多样性:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p>\n</li>\n<li class=\"lvl-2\">\n<p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>\n</li>\n</ul>\n<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>\n在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p>\n<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p>\n<hr>\n<h1 id=\"liang-chong-hong-can-shu\">两种宏参数</h1>\n<p>是时候引入一些新的东西了, 顺便加深下你的印象</p>\n<h2 id=\"yuan-bian-liang\" id=\"元变量\">元变量</h2>\n<p>元变量, 即Metavariable, 让我们来看个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    1;</span></span><br><span class=\"line\"><span class=\"comment\">    1 + 2;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>\n比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p>\n<p><code>$</code> 这个前缀是干嘛的?<br>\n这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>\n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~</p>\n<p>先看看 <code>expr</code> 类型, 其全称为 <code>expression(表达式)</code><br>\n第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>\n这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>\n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)<br>\n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>\nmacro就像个code generator: 一段用来生成code的code<br>\n注意:<br>\nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点<br>\n在本节下面会更详细地讲讲</p>\n<h2 id=\"yuan-zi-mian-liang\" id=\"元字面量\">元字面量</h2>\n<p>元字面量, 即Metaliteral<br>\n为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>\n你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p>\n<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>\n这种固定的参数, 如同token中的字面量一样<br>\n我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>\n(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p>\n<p>假若 rule 中的参数没有 $前缀 进行区分:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> fuck &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    fuck!(<span class=\"number\">1</span>);       <span class=\"comment\">// No</span></span><br><span class=\"line\">    fuck!(a:expr);  <span class=\"comment\">// Yes ~~(Oh~)~~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>), 传入固定形式的 “a:expr” 时才可发生匹配<br>\n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰</p>\n<h2 id=\"li-zi\" id=\"例子\">例子</h2>\n<p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>\n它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>\n如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map![</span><br><span class=\"line\">        <span class=\"string\">&quot;吉良吉影&quot;</span> =&gt; <span class=\"number\">33</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;空条承太郎&quot;</span> =&gt; <span class=\"number\">41</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来写一个这样的宏吧!<br>\n不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>\n来看看两种宏参数在宏中, 发挥着怎样的作用:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Metavariable</code>:<br>\n将捕获的传入的代码片段绑定到自身, 并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Metaliteral </code>:<br>\n限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>\n(这里只有一个rule, 空匹配的懒得放里面了)</p>\n</li>\n</ul>\n<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>\n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>\n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>\n(博客的话, 我周六放学回来慢慢更吧…)<br>\n<s>(潜台词是随时会鸽子)</s></p>\n<hr>\n<h1 id=\"ben-zhi\">本质</h1>\n<p>macro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p>\n<p>假若由你来设计一个Rust编译器:</p>\n<p>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>\n若我们将每遍扫描并做点事情的过程, 称为<code>pass</code>, pass一次就生成了, 对于很大的源码来说, 这不现实吧<br>\n那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗</p>\n<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p>\n<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASTNode</span></span> &#123;</span><br><span class=\"line\">    Int(<span class=\"built_in\">i32</span>), </span><br><span class=\"line\">    BinaryExpr &#123;</span><br><span class=\"line\">        op: Op,</span><br><span class=\"line\">        lhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">        rhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Op</span></span> &#123;</span><br><span class=\"line\">    Plus, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你只需明白AST是对源码封装的一层抽象产物就可以了</p>\n<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了<br>\n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p>\n<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛<br>\n<code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码</p>\n<p>Q: 生成AST需要点啥? 或者说, 它由什么组成?<br>\nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架<br>\n这个庞然大物便是 AST 了</p>\n<hr>\n<h1 id=\"hui-dao-macro\">回到Macro</h1>\n<h2 id=\"token-lei-xing-biao\" id=\"Token类型表\">Token类型表</h2>\n<p>生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型</p>\n<p>macro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?<br>\n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p>\n<p>所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>对应</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ident</td>\n<td>标识符, 如函数名, 变量名, 关键字</td>\n</tr>\n<tr>\n<td>expr</td>\n<td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td>\n</tr>\n<tr>\n<td>literal</td>\n<td>literal expression, 即字面量表达式, 是expr的子集</td>\n</tr>\n<tr>\n<td>pat</td>\n<td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td>\n</tr>\n<tr>\n<td>path</td>\n<td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td>\n</tr>\n<tr>\n<td>ty</td>\n<td>type, 如 i32, u32, String, Option<T>等</td>\n</tr>\n<tr>\n<td>tt</td>\n<td>token tree, 之后我会单独再讲解下它的</td>\n</tr>\n<tr>\n<td>meta</td>\n<td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td>\n</tr>\n<tr>\n<td>vis</td>\n<td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td>\n</tr>\n<tr>\n<td>lifetime</td>\n<td>生命周期</td>\n</tr>\n<tr>\n<td>item</td>\n<td>条目/项, 例如函数定义</td>\n</tr>\n<tr>\n<td>block</td>\n<td>代码块</td>\n</tr>\n<tr>\n<td>stmt</td>\n<td>statemen, 语句</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"tt\" id=\"TT\">TT</h2>\n<p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>\n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p>\n<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>\n作为 Token Tree 的根节点, 先让我们来点例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a:tt) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($a));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Single Token</span></span><br><span class=\"line\">    aa!(<span class=\"number\">123</span>);          <span class=\"comment\">// Yes: 123</span></span><br><span class=\"line\">    aa!(FuckYou);      <span class=\"comment\">// Yes: FuckYou</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(Fuck You);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(123 + 11);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// (), [], &#123;&#125;</span></span><br><span class=\"line\">    aa!([<span class=\"number\">123</span>]);        <span class=\"comment\">// Yes: [123]</span></span><br><span class=\"line\">    aa!(&#123;<span class=\"number\">123</span> + <span class=\"number\">123</span>&#125;);  <span class=\"comment\">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>\n请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你的眼中:</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span> + (<span class=\"number\">3</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// tt的眼中:</span></span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                   &lt;&lt;<span class=\"number\">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的Token Tree共有5个:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>&lt;&lt;1&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;2&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;(3 + 4)&gt;&gt;</p>\n</li>\n</ol>\n<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>\n对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p>\n<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p>\n<h2 id=\"ast-jie-dian\" id=\"AST节点\">AST节点</h2>\n<p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>\n比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们通过使用 macro , 站在了更抽象的视角上<br>\n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)<br>\n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p>\n<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a> 上面的代码了:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class=\"line\">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> match_tokens &#123;</span><br><span class=\"line\">    ($a:tt + $b:tt) =&gt; &#123;<span class=\"string\">&quot;got an addition&quot;</span>&#125;;</span><br><span class=\"line\">    (($i:ident)) =&gt; &#123;<span class=\"string\">&quot;got an identifier&quot;</span>&#125;;</span><br><span class=\"line\">    ($($other:tt)*) =&gt; &#123;<span class=\"string\">&quot;got something else&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;</span>,</span><br><span class=\"line\">        match_tokens!((caravan)),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;</span>,</span><br><span class=\"line\">        capture_then_match_tokens!((caravan)),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果会是:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">got an identifier</span><br><span class=\"line\">got an addition</span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br></pre></td></tr></table></figure>\n<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!</p>\n<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>\n但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br>\n<code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p>\n<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p>\n<p>总结:<br>\n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>\n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 😄)</p>\n<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>\n最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言: 简单的文本替换</span></span><br><span class=\"line\">#define SUM(a,b) a+b</span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>);     <span class=\"comment\">// 2 * 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 5 * 2 + 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>);     <span class=\"comment\">// 2 + 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 5 * (2 + 2)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"pi-pei-zhu-yi-dian\" id=\"匹配注意点\">匹配注意点</h2>\n<p>在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a></p>\n<h3 id=\"pi-pei-wu-qu\" id=\"匹配误区\">匹配误区</h3>\n<p>来看看下面一段代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    aa!(a);   <span class=\"comment\">// Yes</span></span><br><span class=\"line\">    aa!(a+);  <span class=\"comment\">// No</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">expected expression, found end of <span class=\"keyword\">macro</span> arguments</span><br><span class=\"line\"><span class=\"comment\">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>\n<p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p>\n<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>\n而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p>\n<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p>\n<h3 id=\"qi-yi-xian-zhi\" id=\"歧义限制\">歧义限制</h3>\n<p>由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">Rust-Reference: 限制</a><br>\n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br>\n<s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)</s></p>\n<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p>\n","site":{"data":{}},"length":8377,"excerpt":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"kuang-jia-jian-li\">框架建立</h1>\n<p>前一节,我们大概清楚了macro的结构, 现在让我们再来简单复习一遍:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>macro_rules!(这是特点语法)</code>来创建一个macro</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内</p>\n</li>\n<li class=\"lvl-2\">\n<p>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code></p>\n</li>\n</ul>\n<p>现在稍微深入一点:<br>\n一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber), 它由三个重要的部分组成:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>matcher (匹配器)</code>: 用来匹配传入的参数</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>metavariable/literal (元变量/字面量)</code>: 绑定传入的代码片段,出现于 <code>matcher</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>transcriber (转录器)</code>: 用来在宏匹配成功后,进行代码替换</p>\n</li>\n</ul>\n<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>\n因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    (<span class=\"comment\">/* 空参匹配 */</span>) =&gt; (<span class=\"comment\">/* `换行` 的代码 */</span>);</span><br><span class=\"line\">    (<span class=\"comment\">/* 有参匹配 */</span>) =&gt; (<span class=\"comment\">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code>, 从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配, 匹配时括号具有多样性<br>\n下面是具体阐述:</p>\n<p>匹配规则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>匹配到: 就替换为<code>transcriber</code>里面的代码</p>\n</li>\n<li class=\"lvl-2\">\n<p>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错</p>\n</li>\n</ul>\n<p>括号多样性:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一</p>\n</li>\n<li class=\"lvl-2\">\n<p>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></p>\n</li>\n</ul>\n<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>\n在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段</p>\n<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了</p>\n<hr>\n<h1 id=\"liang-chong-hong-can-shu\">两种宏参数</h1>\n<p>是时候引入一些新的东西了, 顺便加深下你的印象</p>\n<h2 id=\"yuan-bian-liang\" id=\"元变量\">元变量</h2>\n<p>元变量, 即Metavariable, 让我们来看个例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    1;</span></span><br><span class=\"line\"><span class=\"comment\">    1 + 2;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>\n比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code></p>\n<p><code>$</code> 这个前缀是干嘛的?<br>\n这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>\n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗? 下面就要讲到啦, 别着急~</p>\n<p>先看看 <code>expr</code> 类型, 其全称为 <code>expression(表达式)</code><br>\n第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>\n这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>\n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)<br>\n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>\nmacro就像个code generator: 一段用来生成code的code<br>\n注意:<br>\nmacro实际上, 是将传入部分解析为一个AST节点, 然后将调用部分, 替换为一个新的AST节点<br>\n在本节下面会更详细地讲讲</p>\n<h2 id=\"yuan-zi-mian-liang\" id=\"元字面量\">元字面量</h2>\n<p>元字面量, 即Metaliteral<br>\n为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>\n你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code></p>\n<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>\n这种固定的参数, 如同token中的字面量一样<br>\n我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>\n(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)</p>\n<p>假若 rule 中的参数没有 $前缀 进行区分:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> fuck &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    fuck!(<span class=\"number\">1</span>);       <span class=\"comment\">// No</span></span><br><span class=\"line\">    fuck!(a:expr);  <span class=\"comment\">// Yes ~~(Oh~)~~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>), 传入固定形式的 “a:expr” 时才可发生匹配<br>\n因此, 切记住当你想绑定一段代码片段, 在参数名前, 必须加上$进行修饰</p>\n<h2 id=\"li-zi\" id=\"例子\">例子</h2>\n<p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>\n它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>\n如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map![</span><br><span class=\"line\">        <span class=\"string\">&quot;吉良吉影&quot;</span> =&gt; <span class=\"number\">33</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;空条承太郎&quot;</span> =&gt; <span class=\"number\">41</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来写一个这样的宏吧!<br>\n不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>\n来看看两种宏参数在宏中, 发挥着怎样的作用:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>Metavariable</code>:<br>\n将捕获的传入的代码片段绑定到自身, 并在 <code>Transcriber</code> 中被使用, 最后展开为新代码</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>Metaliteral </code>:<br>\n限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>\n(这里只有一个rule, 空匹配的懒得放里面了)</p>\n</li>\n</ul>\n<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>\n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>\n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>\n(博客的话, 我周六放学回来慢慢更吧…)<br>\n<s>(潜台词是随时会鸽子)</s></p>\n<hr>\n<h1 id=\"ben-zhi\">本质</h1>\n<p>macro的本质, 是生成一个AST节点, 可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解</p>\n<p>假若由你来设计一个Rust编译器:</p>\n<p>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?<br>\n若我们将每遍扫描并做点事情的过程, 称为<code>pass</code>, pass一次就生成了, 对于很大的源码来说, 这不现实吧<br>\n那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题, 每一次pass都解决一个小问题, 那不就Ok了吗</p>\n<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code></p>\n<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree), 那是一种代码被抽象后的树状结构, 比如我们用Rust的enum表示一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASTNode</span></span> &#123;</span><br><span class=\"line\">    Int(<span class=\"built_in\">i32</span>), </span><br><span class=\"line\">    BinaryExpr &#123;</span><br><span class=\"line\">        op: Op,</span><br><span class=\"line\">        lhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">        rhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Op</span></span> &#123;</span><br><span class=\"line\">    Plus, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你只需明白AST是对源码封装的一层抽象产物就可以了</p>\n<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小, 但是, 如果源码很大呢? AST已经很复杂了<br>\n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能</p>\n<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的, 注意, 是一些,而非一个, 因为一次可能还是不够嘛<br>\n<code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架, 而另外的IR, 也是有必要的, 这也增强了可维护性, 编译器在AST的基础上, 最终生成了目标码</p>\n<p>Q: 生成AST需要点啥? 或者说, 它由什么组成?<br>\nA: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code></p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构, 它将token们联系起来, 表达了代码的骨架<br>\n这个庞然大物便是 AST 了</p>\n<hr>\n<h1 id=\"hui-dao-macro\">回到Macro</h1>\n<h2 id=\"token-lei-xing-biao\" id=\"Token类型表\">Token类型表</h2>\n<p>生成AST需要Token协助, macro 中, 其参数的类型, 便是token类型</p>\n<p>macro要操控传入的token (或AST节点, 等会讲), 我们总得知道token类型吧, 不然怎知如何操控?<br>\n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)</p>\n<p>所以, 辛苦你将下面的记一下, 稍微记下, 有印象即可, 多用几下保证你熟悉得不行:</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>对应</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ident</td>\n<td>标识符, 如函数名, 变量名, 关键字</td>\n</tr>\n<tr>\n<td>expr</td>\n<td>expression, 表达式,如<code>x</code>与<code>1_i32</code></td>\n</tr>\n<tr>\n<td>literal</td>\n<td>literal expression, 即字面量表达式, 是expr的子集</td>\n</tr>\n<tr>\n<td>pat</td>\n<td>pattern, 比如在match表达式下的 (pattern) =&gt; todo!()</td>\n</tr>\n<tr>\n<td>path</td>\n<td>路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的</td>\n</tr>\n<tr>\n<td>ty</td>\n<td>type, 如 i32, u32, String, Option<T>等</td>\n</tr>\n<tr>\n<td>tt</td>\n<td>token tree, 之后我会单独再讲解下它的</td>\n</tr>\n<tr>\n<td>meta</td>\n<td>元条目/项, 比如 <code>#[allow(unsued)]</code>, <code>meta</code> 就对应 <code>allow(unuse)</code></td>\n</tr>\n<tr>\n<td>vis</td>\n<td>visibility, 可见性, 比如pub, pub(crate)等, 也可能为空</td>\n</tr>\n<tr>\n<td>lifetime</td>\n<td>生命周期</td>\n</tr>\n<tr>\n<td>item</td>\n<td>条目/项, 例如函数定义</td>\n</tr>\n<tr>\n<td>block</td>\n<td>代码块</td>\n</tr>\n<tr>\n<td>stmt</td>\n<td>statemen, 语句</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"tt\" id=\"TT\">TT</h2>\n<p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>\n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~</p>\n<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>\n作为 Token Tree 的根节点, 先让我们来点例子:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a:tt) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($a));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Single Token</span></span><br><span class=\"line\">    aa!(<span class=\"number\">123</span>);          <span class=\"comment\">// Yes: 123</span></span><br><span class=\"line\">    aa!(FuckYou);      <span class=\"comment\">// Yes: FuckYou</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(Fuck You);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(123 + 11);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// (), [], &#123;&#125;</span></span><br><span class=\"line\">    aa!([<span class=\"number\">123</span>]);        <span class=\"comment\">// Yes: [123]</span></span><br><span class=\"line\">    aa!(&#123;<span class=\"number\">123</span> + <span class=\"number\">123</span>&#125;);  <span class=\"comment\">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>\n请看以下内容, 以理解它, 我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示 <code>xxx</code> 是一颗 <code>Token Tree</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你的眼中:</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span> + (<span class=\"number\">3</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// tt的眼中:</span></span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                   &lt;&lt;<span class=\"number\">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的Token Tree共有5个:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>&lt;&lt;1&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;2&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;+&gt;&gt;</p>\n</li>\n<li class=\"lvl-3\">\n<p>&lt;&lt;(3 + 4)&gt;&gt;</p>\n</li>\n</ol>\n<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>\n对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)</p>\n<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?</p>\n<h2 id=\"ast-jie-dian\" id=\"AST节点\">AST节点</h2>\n<p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>\n比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>我们通过使用 macro , 站在了更抽象的视角上<br>\n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)<br>\n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码</p>\n<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果, 我直接用 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a> 上面的代码了:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class=\"line\">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> match_tokens &#123;</span><br><span class=\"line\">    ($a:tt + $b:tt) =&gt; &#123;<span class=\"string\">&quot;got an addition&quot;</span>&#125;;</span><br><span class=\"line\">    (($i:ident)) =&gt; &#123;<span class=\"string\">&quot;got an identifier&quot;</span>&#125;;</span><br><span class=\"line\">    ($($other:tt)*) =&gt; &#123;<span class=\"string\">&quot;got something else&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;</span>,</span><br><span class=\"line\">        match_tokens!((caravan)),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;</span>,</span><br><span class=\"line\">        capture_then_match_tokens!((caravan)),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果会是:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">got an identifier</span><br><span class=\"line\">got an addition</span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br></pre></td></tr></table></figure>\n<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点, 它不再是token, 而是个AST节点了!</p>\n<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>\n但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br>\n<code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配</p>\n<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块</p>\n<p>总结:<br>\n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>\n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏 (只要宏展开的AST节点正确即可 😄)</p>\n<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>\n最直接的好处, 如下 <s>(相当于自动给你加上了括号)</s>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言: 简单的文本替换</span></span><br><span class=\"line\">#define SUM(a,b) a+b</span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>);     <span class=\"comment\">// 2 * 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 5 * 2 + 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>);     <span class=\"comment\">// 2 + 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 5 * (2 + 2)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"pi-pei-zhu-yi-dian\" id=\"匹配注意点\">匹配注意点</h2>\n<p>在传参时有两个地方要注意, 一是个很常见的误解, 二是些为了以后宏的发展而有的限制, 有时间的也可以去看看 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a></p>\n<h3 id=\"pi-pei-wu-qu\" id=\"匹配误区\">匹配误区</h3>\n<p>来看看下面一段代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    aa!(a);   <span class=\"comment\">// Yes</span></span><br><span class=\"line\">    aa!(a+);  <span class=\"comment\">// No</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配, 但是实际上会报这么一个错误:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">expected expression, found end of <span class=\"keyword\">macro</span> arguments</span><br><span class=\"line\"><span class=\"comment\">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>\n<p>你会发现实际上都是在与第一个rule尝试着进行匹配:</p>\n<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>\n而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule</p>\n<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要</p>\n<h3 id=\"qi-yi-xian-zhi\" id=\"歧义限制\">歧义限制</h3>\n<p>由于一些歧义, 为了向后兼容性与不破坏代码, 当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">Rust-Reference: 限制</a><br>\n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br>\n<s>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许, 因为我也没全搞懂, 反正这样不允许就对了)</s></p>\n<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)</p>"},{"title":"rust-decl-macro-p4: 重复","abbrlink":"posts/rust-decl-macro/p4","date":"2021-10-09T14:36:00.000Z","top":10996,"keywords":["Macro","声明宏","Rust"],"_content":"> 宏中非常重要的语法: 重复(repetition)\n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 介绍\n`重复 (Repetition)` 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n\n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n- Matcher: 将一段指定的模式, 重复地匹配与捕获\n- Transcriber: 将一段指定的模式, 重复地展开\n\n~~(废话, Rust的声明宏不就这两个主要部分嘛)~~  \n\n假设你要设计一个宏, 进行求和(参数个数不确定):  \n\n```rust\n// Examples:\nassert_eq!( 0,  sum!() );\nassert_eq!( 15, sum!(1,2,3,4,5) );\n```\n  \n让我们来看看, 如何使用重复吧\n\n# 语法  \n关键在于参数的个数不确定, 因此我们应使用重复语法:  \n```rust\nmacro_rules! sum {\n\t($($a:expr),*) => {\n\t\t0 $(+ $a)*\n\t}\n}\nfn main() {\n\tsum!();          // 0\n\tsum!(5);         // 5\n\tsum!(1,2,3,4,5); // 15\n}\n```\n\n伪代码表示:  \n```rust\n$( Pattern )   Sep    RepOp\n$(   模式   )  分隔符  重复符号\n```\n\n它可以被分为三个部分:  \n- 模式(Pattern): \n被包裹于 `$( )`, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n\n- 分隔符(Separator): \n用来分割重复的模式, 比如 `vec![1,2,3]` 中的逗号  \n\n- 重复符号(Repetition Operator): \n对模式匹配次数, 进行说明限制, 不符合就编译报错  \n\n\n以 `sum!` 为例子, 它在第二个rule中用到了重复:  \n\n- In Matcher: \n模式: `$a:expr` 是重复的模式, 表示重复地匹配与捕获expr  \n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配  \n次数: *号, 说明了重复模式的个数, 它被限制为>=0  \n\n- In Transcriber: \n模式: `+ $a` 是重复模式, 比如传入 `1,2,3,4,5` 时, 会被展开为 `0+1+2+3+4+5`  \n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep\n次数:\t 同 Matcher  \n\n`$()` 与 `RepOp` 是必填的, `Sep` 是可选的  \n\nRepOp 有三种可选项, 有点像正则:\n- `*` 表示 模式匹配的次数 >= 0  \n记忆法-> 该符号看上去像是一个点, 联想为0\n- `+` 表示 模式匹配的次数 >= 1\n记忆法-> 联想为正数, 那就>=1\n- `?` 表示 模式匹配的次数 = 0 or 1  \n记忆法-> 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n- 当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  \n- Sep 是有限制的, [p3#歧义限制](/posts/rust-decl-macro/p3#qi-yi-xian-zhi) 提到过, 详情可见 [rust-reference](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)\n","source":"_posts/rust/decl-macro/p4-重复.md","raw":"---\ntitle: \"rust-decl-macro-p4: 重复\"\nabbrlink: posts/rust-decl-macro/p4\ndate: 2021-10-09 22:36:00\ntop: 10996\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\n---\n> 宏中非常重要的语法: 重复(repetition)\n<!-- more -->\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 介绍\n`重复 (Repetition)` 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n\n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n- Matcher: 将一段指定的模式, 重复地匹配与捕获\n- Transcriber: 将一段指定的模式, 重复地展开\n\n~~(废话, Rust的声明宏不就这两个主要部分嘛)~~  \n\n假设你要设计一个宏, 进行求和(参数个数不确定):  \n\n```rust\n// Examples:\nassert_eq!( 0,  sum!() );\nassert_eq!( 15, sum!(1,2,3,4,5) );\n```\n  \n让我们来看看, 如何使用重复吧\n\n# 语法  \n关键在于参数的个数不确定, 因此我们应使用重复语法:  \n```rust\nmacro_rules! sum {\n\t($($a:expr),*) => {\n\t\t0 $(+ $a)*\n\t}\n}\nfn main() {\n\tsum!();          // 0\n\tsum!(5);         // 5\n\tsum!(1,2,3,4,5); // 15\n}\n```\n\n伪代码表示:  \n```rust\n$( Pattern )   Sep    RepOp\n$(   模式   )  分隔符  重复符号\n```\n\n它可以被分为三个部分:  \n- 模式(Pattern): \n被包裹于 `$( )`, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n\n- 分隔符(Separator): \n用来分割重复的模式, 比如 `vec![1,2,3]` 中的逗号  \n\n- 重复符号(Repetition Operator): \n对模式匹配次数, 进行说明限制, 不符合就编译报错  \n\n\n以 `sum!` 为例子, 它在第二个rule中用到了重复:  \n\n- In Matcher: \n模式: `$a:expr` 是重复的模式, 表示重复地匹配与捕获expr  \n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配  \n次数: *号, 说明了重复模式的个数, 它被限制为>=0  \n\n- In Transcriber: \n模式: `+ $a` 是重复模式, 比如传入 `1,2,3,4,5` 时, 会被展开为 `0+1+2+3+4+5`  \n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep\n次数:\t 同 Matcher  \n\n`$()` 与 `RepOp` 是必填的, `Sep` 是可选的  \n\nRepOp 有三种可选项, 有点像正则:\n- `*` 表示 模式匹配的次数 >= 0  \n记忆法-> 该符号看上去像是一个点, 联想为0\n- `+` 表示 模式匹配的次数 >= 1\n记忆法-> 联想为正数, 那就>=1\n- `?` 表示 模式匹配的次数 = 0 or 1  \n记忆法-> 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n- 当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  \n- Sep 是有限制的, [p3#歧义限制](/posts/rust-decl-macro/p3#qi-yi-xian-zhi) 提到过, 详情可见 [rust-reference](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)\n","slug":"rust/decl-macro/p4-重复","published":1,"updated":"2021-10-09T14:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gm00176aijdt8ohrv6","content":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"jie-shao\">介绍</h1>\n<p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p>\n<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p>\n</li>\n<li class=\"lvl-2\">\n<p>Transcriber: 将一段指定的模式, 重复地展开</p>\n</li>\n</ul>\n<p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p>\n<p>假设你要设计一个宏, 进行求和(参数个数不确定):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Examples:</span></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">0</span>,  sum!() );</span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">15</span>, sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) );</span><br></pre></td></tr></table></figure>\n<p>让我们来看看, 如何使用重复吧</p>\n<h1 id=\"yu-fa\">语法</h1>\n<p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($a:expr),*) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> $(+ $a)*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();          <span class=\"comment\">// 0</span></span><br><span class=\"line\">    sum!(<span class=\"number\">5</span>);         <span class=\"comment\">// 5</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>伪代码表示:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">$( Pattern )   Sep    RepOp</span><br><span class=\"line\">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>\n<p>它可以被分为三个部分:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>模式(Pattern):<br>\n被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p>\n</li>\n<li class=\"lvl-2\">\n<p>分隔符(Separator):<br>\n用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p>\n</li>\n<li class=\"lvl-2\">\n<p>重复符号(Repetition Operator):<br>\n对模式匹配次数, 进行说明限制, 不符合就编译报错</p>\n</li>\n</ul>\n<p>以 <code>sum!</code> 为例子, 它在第二个rule中用到了重复:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>In Matcher:<br>\n模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>\n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>\n次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p>\n</li>\n<li class=\"lvl-2\">\n<p>In Transcriber:<br>\n模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>\n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>\n次数:\t 同 Matcher</p>\n</li>\n</ul>\n<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p>\n<p>RepOp 有三种可选项, 有点像正则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>\n记忆法-&gt; 该符号看上去像是一个点, 联想为0</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>\n记忆法-&gt; 联想为正数, 那就&gt;=1</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>\n记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p>\n</li>\n</ul>\n<p>有一些注意点:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Sep 是有限制的, <a href=\"/posts/rust-decl-macro/p3#qi-yi-xian-zhi\">p3#歧义限制</a> 提到过, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">rust-reference</a></p>\n</li>\n</ul>\n","site":{"data":{}},"length":1121,"excerpt":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></li>\n<li class=\"lvl-2\"><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<h1 id=\"jie-shao\">介绍</h1>\n<p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它</p>\n<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Matcher: 将一段指定的模式, 重复地匹配与捕获</p>\n</li>\n<li class=\"lvl-2\">\n<p>Transcriber: 将一段指定的模式, 重复地展开</p>\n</li>\n</ul>\n<p><s>(废话, Rust的声明宏不就这两个主要部分嘛)</s></p>\n<p>假设你要设计一个宏, 进行求和(参数个数不确定):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Examples:</span></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">0</span>,  sum!() );</span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">15</span>, sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) );</span><br></pre></td></tr></table></figure>\n<p>让我们来看看, 如何使用重复吧</p>\n<h1 id=\"yu-fa\">语法</h1>\n<p>关键在于参数的个数不确定, 因此我们应使用重复语法:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($a:expr),*) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> $(+ $a)*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();          <span class=\"comment\">// 0</span></span><br><span class=\"line\">    sum!(<span class=\"number\">5</span>);         <span class=\"comment\">// 5</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>伪代码表示:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">$( Pattern )   Sep    RepOp</span><br><span class=\"line\">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>\n<p>它可以被分为三个部分:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>模式(Pattern):<br>\n被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)</p>\n</li>\n<li class=\"lvl-2\">\n<p>分隔符(Separator):<br>\n用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号</p>\n</li>\n<li class=\"lvl-2\">\n<p>重复符号(Repetition Operator):<br>\n对模式匹配次数, 进行说明限制, 不符合就编译报错</p>\n</li>\n</ul>\n<p>以 <code>sum!</code> 为例子, 它在第二个rule中用到了重复:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>In Matcher:<br>\n模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>\n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>\n次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0</p>\n</li>\n<li class=\"lvl-2\">\n<p>In Transcriber:<br>\n模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>\n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>\n次数:\t 同 Matcher</p>\n</li>\n</ul>\n<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的</p>\n<p>RepOp 有三种可选项, 有点像正则:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>\n记忆法-&gt; 该符号看上去像是一个点, 联想为0</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>\n记忆法-&gt; 联想为正数, 那就&gt;=1</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>\n记忆法-&gt; 问号表示疑问, 代表 有 or 没有</p>\n</li>\n</ul>\n<p>有一些注意点:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)</p>\n</li>\n<li class=\"lvl-2\">\n<p>Sep 是有限制的, <a href=\"/posts/rust-decl-macro/p3#qi-yi-xian-zhi\">p3#歧义限制</a> 提到过, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">rust-reference</a></p>\n</li>\n</ul>"},{"title":"rust-decl-macro-p5: 卫生性","abbrlink":"posts/rust-decl-macro/p5","date":"2021-10-16T06:04:12.000Z","top":10995,"keywords":["Macro","声明宏","Rust"],"_content":"> 本节将介绍宏的 卫生性(hygienic)\n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇\n什么是 卫生性(Hygienic) 呢?\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染  \n如果你是第一次接触此概念, 我不信你不会懵逼  \n不过实际上, 这个概念理解起来不算困难  \n\n让我们先来讨论一个问题, 请看下面的代码:\n```rust\nmacro_rules! create_var {\n\t() => {\n\t\tlet a = 1;\n\t};\n}\nfn main() {\n\tcreate_var!();\n\tprintln!(\"{}\",a);\n}\n```\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","source":"_posts/rust/decl-macro/p5-卫生性.md","raw":"---\ntitle: \"rust-decl-macro-p5: 卫生性\"\nabbrlink: posts/rust-decl-macro/p5\ndate: 2021-10-16 14:04:12\ntop: 10995\ntags: [Rust, Macro]\nkeywords: [Macro, 声明宏, Rust]\n---\n> 本节将介绍宏的 卫生性(hygienic)\n<!-- more -->\n\n同系列传送门:  \n- [博客: rust-decl-macro](/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n# 开篇\n什么是 卫生性(Hygienic) 呢?\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染  \n如果你是第一次接触此概念, 我不信你不会懵逼  \n不过实际上, 这个概念理解起来不算困难  \n\n让我们先来讨论一个问题, 请看下面的代码:\n```rust\nmacro_rules! create_var {\n\t() => {\n\t\tlet a = 1;\n\t};\n}\nfn main() {\n\tcreate_var!();\n\tprintln!(\"{}\",a);\n}\n```\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","slug":"rust/decl-macro/p5-卫生性","published":1,"updated":"2021-10-16T06:04:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gn00186aij34gz1s7u","content":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>什么是 卫生性(Hygienic) 呢?<br>\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>\n如果你是第一次接触此概念, 我不信你不会懵逼<br>\n不过实际上, 这个概念理解起来不算困难</p>\n<p>让我们先来讨论一个问题, 请看下面的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_var &#123;</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_var!();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>\n","site":{"data":{}},"length":346,"excerpt":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>","more":"<p>同系列传送门:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"/categories/rust-decl-macro\">博客: rust-decl-macro</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></p>\n</li>\n</ul>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>什么是 卫生性(Hygienic) 呢?<br>\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>\n如果你是第一次接触此概念, 我不信你不会懵逼<br>\n不过实际上, 这个概念理解起来不算困难</p>\n<p>让我们先来讨论一个问题, 请看下面的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_var &#123;</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_var!();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a</p>"},{"title":"rust-gstreamer-p1: 系列说明","abbrlink":"posts/rust-gstreamer/p1","hidden":false,"date":"2022-10-22T14:42:00.000Z","top":11999,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 欢迎大家来到 gstreamer 的系列, 学习如何处理音视频\n<!-- more -->\n","source":"_posts/rust/gstreamer/p1-系列说明.md","raw":"---\ntitle: \"rust-gstreamer-p1: 系列说明\"\nabbrlink: posts/rust-gstreamer/p1\nhidden: false\ndate: 2022-10-22 22:42:00\ntop: 11999\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 欢迎大家来到 gstreamer 的系列, 学习如何处理音视频\n<!-- more -->\n","slug":"rust/gstreamer/p1-系列说明","published":1,"updated":"2022-10-22T14:42:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86go001a6aijbjg66hln","content":"<blockquote>\n<p>欢迎大家来到 gstreamer 的系列, 学习如何处理音视频</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":28,"excerpt":"<blockquote>\n<p>欢迎大家来到 gstreamer 的系列, 学习如何处理音视频</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p3: Basic-管道的动态构建","abbrlink":"posts/rust-gstreamer/p3","hidden":false,"date":"2022-10-22T14:43:55.000Z","top":11996,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 学习如何动态地构建管道\n<!-- more -->","source":"_posts/rust/gstreamer/p3-Basic-管道的动态构建.md","raw":"---\ntitle: \"rust-gstreamer-p3: Basic-管道的动态构建\"\nabbrlink: posts/rust-gstreamer/p3\nhidden: false\ndate: 2022-10-22 22:43:55\ntop: 11996\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 学习如何动态地构建管道\n<!-- more -->","slug":"rust/gstreamer/p3-Basic-管道的动态构建","published":1,"updated":"2022-10-22T14:43:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gp001b6aij3b1egey8","content":"<blockquote>\n<p>学习如何动态地构建管道</p>\n</blockquote>\n<span id=\"more\"></span>","site":{"data":{}},"length":11,"excerpt":"<blockquote>\n<p>学习如何动态地构建管道</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p2: Basic-管道的基础概念","abbrlink":"posts/rust-gstreamer/p2","hidden":false,"date":"2022-10-22T14:43:36.000Z","top":11998,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 通过一个入门级例子, 讲述 gstreamer 中管道的基础概念\n<!-- more -->\n","source":"_posts/rust/gstreamer/p2-Basic-管道的基础概念.md","raw":"---\ntitle: \"rust-gstreamer-p2: Basic-管道的基础概念\"\nabbrlink: posts/rust-gstreamer/p2\nhidden: false\ndate: 2022-10-22 22:43:36\ntop: 11998\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 通过一个入门级例子, 讲述 gstreamer 中管道的基础概念\n<!-- more -->\n","slug":"rust/gstreamer/p2-Basic-管道的基础概念","published":1,"updated":"2022-10-22T14:43:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gq001d6aijbem24q4x","content":"<blockquote>\n<p>通过一个入门级例子, 讲述 gstreamer 中管道的基础概念</p>\n</blockquote>\n<span id=\"more\"></span>\n","site":{"data":{}},"length":29,"excerpt":"<blockquote>\n<p>通过一个入门级例子, 讲述 gstreamer 中管道的基础概念</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p4: Basic-时间管理","abbrlink":"posts/rust-gstreamer/p4","hidden":false,"date":"2022-10-22T14:44:02.000Z","top":11995,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 学习 gstreamer 中的时间管理, 执行快进/后退等操作\n<!-- more -->","source":"_posts/rust/gstreamer/p4-Basic-时间管理.md","raw":"---\ntitle: \"rust-gstreamer-p4: Basic-时间管理\"\nabbrlink: posts/rust-gstreamer/p4\nhidden: false\ndate: 2022-10-22 22:44:02\ntop: 11995\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 学习 gstreamer 中的时间管理, 执行快进/后退等操作\n<!-- more -->","slug":"rust/gstreamer/p4-Basic-时间管理","published":1,"updated":"2022-10-22T14:44:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gr001f6aij6qogh8u1","content":"<blockquote>\n<p>学习 gstreamer 中的时间管理, 执行快进/后退等操作</p>\n</blockquote>\n<span id=\"more\"></span>","site":{"data":{}},"length":28,"excerpt":"<blockquote>\n<p>学习 gstreamer 中的时间管理, 执行快进/后退等操作</p>\n</blockquote>","more":""},{"title":"rust-gstreamer-p5: Basic-与GUI集成","abbrlink":"posts/rust-gstreamer/p5","hidden":false,"date":"2022-10-22T14:44:16.000Z","top":11994,"keywords":["GStreamer","Rust","Video","Audio"],"_content":"> 通过与 GUI 集成, 来制作一个简易的音乐播放器\n<!-- more -->","source":"_posts/rust/gstreamer/p5-Basic-与GUI集成.md","raw":"---\ntitle: \"rust-gstreamer-p5: Basic-与GUI集成\"\nabbrlink: posts/rust-gstreamer/p5\nhidden: false\ndate: 2022-10-22 22:44:16\ntop: 11994\ntags: [GStreamer, Rust, Video, Audio]\nkeywords: [GStreamer, Rust, Video, Audio]\n---\n> 通过与 GUI 集成, 来制作一个简易的音乐播放器\n<!-- more -->","slug":"rust/gstreamer/p5-Basic-与GUI集成","published":1,"updated":"2022-10-22T14:44:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gs001i6aijbrcy8mjy","content":"<blockquote>\n<p>通过与 GUI 集成, 来制作一个简易的音乐播放器</p>\n</blockquote>\n<span id=\"more\"></span>","site":{"data":{}},"length":22,"excerpt":"<blockquote>\n<p>通过与 GUI 集成, 来制作一个简易的音乐播放器</p>\n</blockquote>","more":""},{"title":"rust-async-p1: 系列说明","abbrlink":"posts/rust-async/p1","date":"2021-09-12T03:43:19.000Z","top":9899,"keywords":["Async","异步","Rust"],"_content":"> 欢迎大家来到 Rust 的 异步(async) 系列  \n<!-- more -->\n\n同系列传送门: [rust-async](/categories/rust-async) \n\n# 系列说明\n此系列,我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n- - - \n# 资料来源\n1. 书籍  \n- [async-book](https://rust-lang.github.io/async-book/**)\n- [async_std/tutorials](https://book.async.rs/overview/async-std)\n- [tokio/tutorials](https://tokio.rs/tokio/tutorial)\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n2. 博客\n- [Withoutboats's blogs](https://without.boats/blog/)  \n\n- - -\n\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","source":"_posts/rust/async/p1-系列说明.md","raw":"---\ntitle: \"rust-async-p1: 系列说明\"\nabbrlink: posts/rust-async/p1\ndate: 2021-09-12 11:43:19\ntop: 9899\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\n---\n> 欢迎大家来到 Rust 的 异步(async) 系列  \n<!-- more -->\n\n同系列传送门: [rust-async](/categories/rust-async) \n\n# 系列说明\n此系列,我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n- - - \n# 资料来源\n1. 书籍  \n- [async-book](https://rust-lang.github.io/async-book/**)\n- [async_std/tutorials](https://book.async.rs/overview/async-std)\n- [tokio/tutorials](https://tokio.rs/tokio/tutorial)\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n2. 博客\n- [Withoutboats's blogs](https://without.boats/blog/)  \n\n- - -\n\n# 欢迎骚扰\n发现错误的话,请及时跟我联系,毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后,谢谢你的观看 :)","slug":"rust/async/p1-系列说明","published":1,"updated":"2021-09-12T03:43:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gt001j6aij8owodhd4","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>\n当然也会介绍异步方面的相关概念咯</p>\n<hr>\n<h1 id=\"zi-liao-lai-yuan\">资料来源</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rust-lang.github.io/async-book/**\">async-book</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://book.async.rs/overview/async-std\">async_std/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://tokio.rs/tokio/tutorial\">tokio/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>\n","site":{"data":{}},"length":245,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>\n当然也会介绍异步方面的相关概念咯</p>\n<hr>\n<h1 id=\"zi-liao-lai-yuan\">资料来源</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://rust-lang.github.io/async-book/**\">async-book</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://book.async.rs/overview/async-std\">async_std/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://tokio.rs/tokio/tutorial\">tokio/tutorials</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话,请及时跟我联系,毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后,谢谢你的观看 😃</p>"},{"title":"rust-async-p2: 异步简介","abbrlink":"posts/rust-async/p2","date":"2021-09-12T04:04:09.000Z","top":9898,"keywords":["Async","异步","Rust"],"_content":"> 来简单介绍一下异步吧  \n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n\n**异步编程 (Asynchronous programming)**, 是一种**并发编程模型** \n特点是通过少量`OS_thread(系统线程)`, 即可运行大量`并发任务`, 在某些场景下,可以疯狂压榨cpu的性能\n\n- - -\n\n# 模型对比\n为何选择异步,它的优势有哪些? 让我们对比下 **异步** 与其他 **并发模型**:  \n\n1.`系统线程 (OS Thread)`  \n由操作系统提供线程,进行并发,如 `std::thread`  \n- 简单易使用, 建模能力强, 足够传统  \n- 操作系统就是运行时, 与C语言交互方便 \n- 数据同步困难, 易发生数据竞争  \n- 小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n\n\n2.`绿色线程 (Green Thread)`  \n它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身, 由程序本身进行模拟  \nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库  \n- 程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长  \n- 创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  \n- 由程序本身实现模拟出来, Runtime 较大  \n- 如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互\n- 绿色线程在不同平台上,其实现可能不同  \n- 对多平台的支持/维护/改进得靠实现者保证  \n\n- - -\n# 异步\n我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:  \n\n```rust\nlet file = /*  */\nlet content = read(file);\ncompute()\n```\n\n读取 `file`, 获取 `content`, 在此期间, 我们做不了任何其他事, 得等待`IO操作(Input/Output, 输入/输出)` 完毕, 才能进行接下来的 `compute`  \n`读取文件`, 属于`IO操作`, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速: \n\n```rust\nlet file = /*  */\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n// 使用 join 阻塞调用线程, 确保句柄线程执行结束\nlet content = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n两个任务 `read` 与 `compute` 是独立无依赖的, 所以我们`spawn`了两个线程  \n- 第一个用于读取文件,获取数据\n- 第二个用于执行 `compute`    \n\n速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作  \n单线程中的异步(伪)代码如下:\n\n```rust\nlet file = /*  */\nlet content = read_async(file);\ncompute_async()\n```\n\n你会注意到:  \n- `read` -> `read_async`  \n- `compute` -> `compute_async`  \n\n伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:  \n\n- `read`:  \n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 `compute`  \n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时,会运行 `compute_async`, 线程由 `read_async` 接管, 变为由 `compute_async` 接管  \n当阻塞时间结束,则程序继续变为运行`read_async`\n\n瞧, `read_async` 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程  \n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨  \n异步操作, 就像是可以随意 `start/stop` 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待  \n\n即使是单线程, 也能做到同时运行多个 `Task(异步任务)`, 而异步结合多线程也是可以的, 只要存在耗时的IO操作  \n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步\n\n- - -\n\n# 尾声\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了  \n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!  \n\n","source":"_posts/rust/async/p2-异步简介.md","raw":"---\ntitle: \"rust-async-p2: 异步简介\"\nabbrlink: posts/rust-async/p2\ndate: 2021-09-12 12:04:09\ntop: 9898\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\n---\n> 来简单介绍一下异步吧  \n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n\n**异步编程 (Asynchronous programming)**, 是一种**并发编程模型** \n特点是通过少量`OS_thread(系统线程)`, 即可运行大量`并发任务`, 在某些场景下,可以疯狂压榨cpu的性能\n\n- - -\n\n# 模型对比\n为何选择异步,它的优势有哪些? 让我们对比下 **异步** 与其他 **并发模型**:  \n\n1.`系统线程 (OS Thread)`  \n由操作系统提供线程,进行并发,如 `std::thread`  \n- 简单易使用, 建模能力强, 足够传统  \n- 操作系统就是运行时, 与C语言交互方便 \n- 数据同步困难, 易发生数据竞争  \n- 小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低\n\n\n2.`绿色线程 (Green Thread)`  \n它几乎与系统线程一样, 不过 `Runtime(运行时,jvm/.net听说过吗?)` 从操作系统变为了程序本身, 由程序本身进行模拟  \nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库  \n- 程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长  \n- 创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务  \n- 由程序本身实现模拟出来, Runtime 较大  \n- 如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互\n- 绿色线程在不同平台上,其实现可能不同  \n- 对多平台的支持/维护/改进得靠实现者保证  \n\n- - -\n# 异步\n我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:  \n\n```rust\nlet file = /*  */\nlet content = read(file);\ncompute()\n```\n\n读取 `file`, 获取 `content`, 在此期间, 我们做不了任何其他事, 得等待`IO操作(Input/Output, 输入/输出)` 完毕, 才能进行接下来的 `compute`  \n`读取文件`, 属于`IO操作`, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速: \n\n```rust\nlet file = /*  */\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n// 使用 join 阻塞调用线程, 确保句柄线程执行结束\nlet content = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n两个任务 `read` 与 `compute` 是独立无依赖的, 所以我们`spawn`了两个线程  \n- 第一个用于读取文件,获取数据\n- 第二个用于执行 `compute`    \n\n速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作  \n单线程中的异步(伪)代码如下:\n\n```rust\nlet file = /*  */\nlet content = read_async(file);\ncompute_async()\n```\n\n你会注意到:  \n- `read` -> `read_async`  \n- `compute` -> `compute_async`  \n\n伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:  \n\n- `read`:  \n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 `compute`  \n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时,会运行 `compute_async`, 线程由 `read_async` 接管, 变为由 `compute_async` 接管  \n当阻塞时间结束,则程序继续变为运行`read_async`\n\n瞧, `read_async` 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程  \n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨  \n异步操作, 就像是可以随意 `start/stop` 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待  \n\n即使是单线程, 也能做到同时运行多个 `Task(异步任务)`, 而异步结合多线程也是可以的, 只要存在耗时的IO操作  \n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步\n\n- - -\n\n# 尾声\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了  \n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!  \n\n","slug":"rust/async/p2-异步简介","published":1,"updated":"2021-09-12T04:04:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gu001l6aijdxrn7py7","content":"<blockquote>\n<p>来简单介绍一下异步吧</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>异步编程 (Asynchronous programming)</strong>, 是一种<strong>并发编程模型</strong><br>\n特点是通过少量<code>OS_thread(系统线程)</code>, 即可运行大量<code>并发任务</code>, 在某些场景下,可以疯狂压榨cpu的性能</p>\n<hr>\n<h1 id=\"mo-xing-dui-bi\">模型对比</h1>\n<p>为何选择异步,它的优势有哪些? 让我们对比下 <strong>异步</strong> 与其他 <strong>并发模型</strong>:</p>\n<p>1.<code>系统线程 (OS Thread)</code><br>\n由操作系统提供线程,进行并发,如 <code>std::thread</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>简单易使用, 建模能力强, 足够传统</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作系统就是运行时, 与C语言交互方便</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据同步困难, 易发生数据竞争</p>\n</li>\n<li class=\"lvl-2\">\n<p>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>\n</li>\n</ul>\n<p>2.<code>绿色线程 (Green Thread)</code><br>\n它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身, 由程序本身进行模拟<br>\nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>由程序本身实现模拟出来, Runtime 较大</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互</p>\n</li>\n<li class=\"lvl-2\">\n<p>绿色线程在不同平台上,其实现可能不同</p>\n</li>\n<li class=\"lvl-2\">\n<p>对多平台的支持/维护/改进得靠实现者保证</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"yi-bu\">异步</h1>\n<p>我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read(file);</span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>读取 <code>file</code>, 获取 <code>content</code>, 在此期间, 我们做不了任何其他事, 得等待<code>IO操作(Input/Output, 输入/输出)</code> 完毕, 才能进行接下来的 <code>compute</code><br>\n<code>读取文件</code>, 属于<code>IO操作</code>, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"><span class=\"comment\">// 使用 join 阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n<p>两个任务 <code>read</code> 与 <code>compute</code> 是独立无依赖的, 所以我们<code>spawn</code>了两个线程</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个用于读取文件,获取数据</p>\n</li>\n<li class=\"lvl-2\">\n<p>第二个用于执行 <code>compute</code></p>\n</li>\n</ul>\n<p>速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作<br>\n单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read_async(file);</span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n<p>你会注意到:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code> -&gt; <code>read_async</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>compute</code> -&gt; <code>compute_async</code></p>\n</li>\n</ul>\n<p>伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code>:<br>\n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 <code>compute</code><br>\n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>read_async</code>:<br>\n它处于阻塞时,会运行 <code>compute_async</code>, 线程由 <code>read_async</code> 接管, 变为由 <code>compute_async</code> 接管<br>\n当阻塞时间结束,则程序继续变为运行<code>read_async</code></p>\n</li>\n</ul>\n<p>瞧, <code>read_async</code> 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程<br>\n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨<br>\n异步操作, 就像是可以随意 <code>start/stop</code> 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待</p>\n<p>即使是单线程, 也能做到同时运行多个 <code>Task(异步任务)</code>, 而异步结合多线程也是可以的, 只要存在耗时的IO操作<br>\n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步</p>\n<hr>\n<h1 id=\"wei-sheng\">尾声</h1>\n<p>Q:<br>\n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>\nA:<br>\n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了<br>\n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!</p>\n","site":{"data":{}},"length":1849,"excerpt":"<blockquote>\n<p>来简单介绍一下异步吧</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>异步编程 (Asynchronous programming)</strong>, 是一种<strong>并发编程模型</strong><br>\n特点是通过少量<code>OS_thread(系统线程)</code>, 即可运行大量<code>并发任务</code>, 在某些场景下,可以疯狂压榨cpu的性能</p>\n<hr>\n<h1 id=\"mo-xing-dui-bi\">模型对比</h1>\n<p>为何选择异步,它的优势有哪些? 让我们对比下 <strong>异步</strong> 与其他 <strong>并发模型</strong>:</p>\n<p>1.<code>系统线程 (OS Thread)</code><br>\n由操作系统提供线程,进行并发,如 <code>std::thread</code></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>简单易使用, 建模能力强, 足够传统</p>\n</li>\n<li class=\"lvl-2\">\n<p>操作系统就是运行时, 与C语言交互方便</p>\n</li>\n<li class=\"lvl-2\">\n<p>数据同步困难, 易发生数据竞争</p>\n</li>\n<li class=\"lvl-2\">\n<p>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</p>\n</li>\n</ul>\n<p>2.<code>绿色线程 (Green Thread)</code><br>\n它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身, 由程序本身进行模拟<br>\nRust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长</p>\n</li>\n<li class=\"lvl-2\">\n<p>创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>由程序本身实现模拟出来, Runtime 较大</p>\n</li>\n<li class=\"lvl-2\">\n<p>如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互</p>\n</li>\n<li class=\"lvl-2\">\n<p>绿色线程在不同平台上,其实现可能不同</p>\n</li>\n<li class=\"lvl-2\">\n<p>对多平台的支持/维护/改进得靠实现者保证</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"yi-bu\">异步</h1>\n<p>我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read(file);</span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>读取 <code>file</code>, 获取 <code>content</code>, 在此期间, 我们做不了任何其他事, 得等待<code>IO操作(Input/Output, 输入/输出)</code> 完毕, 才能进行接下来的 <code>compute</code><br>\n<code>读取文件</code>, 属于<code>IO操作</code>, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"><span class=\"comment\">// 使用 join 阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n<p>两个任务 <code>read</code> 与 <code>compute</code> 是独立无依赖的, 所以我们<code>spawn</code>了两个线程</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一个用于读取文件,获取数据</p>\n</li>\n<li class=\"lvl-2\">\n<p>第二个用于执行 <code>compute</code></p>\n</li>\n</ul>\n<p>速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作<br>\n单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = read_async(file);</span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n<p>你会注意到:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code> -&gt; <code>read_async</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>compute</code> -&gt; <code>compute_async</code></p>\n</li>\n</ul>\n<p>伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>read</code>:<br>\n它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 <code>compute</code><br>\n阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>read_async</code>:<br>\n它处于阻塞时,会运行 <code>compute_async</code>, 线程由 <code>read_async</code> 接管, 变为由 <code>compute_async</code> 接管<br>\n当阻塞时间结束,则程序继续变为运行<code>read_async</code></p>\n</li>\n</ul>\n<p>瞧, <code>read_async</code> 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程<br>\n总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨<br>\n异步操作, 就像是可以随意 <code>start/stop</code> 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待</p>\n<p>即使是单线程, 也能做到同时运行多个 <code>Task(异步任务)</code>, 而异步结合多线程也是可以的, 只要存在耗时的IO操作<br>\n如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步</p>\n<hr>\n<h1 id=\"wei-sheng\">尾声</h1>\n<p>Q:<br>\n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>\nA:<br>\n现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了<br>\n所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!</p>"},{"title":"rust-async-p3: Future","abbrlink":"posts/rust-async/p3","date":"2021-09-12T05:56:48.000Z","top":9897,"keywords":["Async","异步","Rust"],"_content":"> Rust 中的 Future/async/.await 说明  \n<!-- more -->  \n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧    \n\n本节, 我们将学习以下三个概念的大致含义:  \n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n- - -\n\n# Future\n## 概念\n`Future`,一个标准/核心库中的trait: `std/core::future::Future`   \n\n在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 `一次异步计算`, 可将其交给 `Runtime(运行时)` 来异步执行   \n\n`异步执行`, 也就是指:    \n- 其他异步任务阻塞时,当前异步任务有机会执行  \n- 当前异步任务阻塞时,其他异步任务有机会执行  \n\n总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别,举个例子你就明白了:  \n  \n假设有这么个父计算, 由两个子计算组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期  \n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算  \n(我们将`最顶层的父计算(top-level Future, 即最顶层的Future实例)`称为`Task(任务)`)  \n\n当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算  \n\n总结:  \n- Task 是一个顶层 Future 实例 (即一次顶层异步计算) \n- 一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future\n- Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算\n- Task 可以只是一次单独计算\n\n一个 Future, 可理解为是组成一个 Task 的最小单位 \n\n## 定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output: 代表 Future 执行完毕后, 产出的值的类型   \n- poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成\n- Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:  \n`Poll::Pending`: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)  \n`Poll::Ready(T)`: 指明该计算执行完毕, 并产出一个类型为 T 的值  \n\n- - -\n\n# Async  \nRust 为我们提供了关键字 async, 方便人们为某次计算实现 Future  \n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊  \nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例  \n\n来个例子,看看 async 的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n// 2 \nstruct HelloStr;\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的  \n看看它们两的返回值:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n注意, 异步函数的调用, 只是返回一个 Future实例  \n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户\n\n这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作  \n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可  \n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了\n\nasync 的作用就是创建一个 Future 实例, 以下是不同的语法糖:  \n- `async fn`: 异步函数, 要求返回一个 Future 实例   \n- `async block`: 异步代码块, 创建一个 Future 实例  \n- `async closure`: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?  \n请接着往下看\n\n- - -\n\n# 执行\n## 背景介绍  \nRust本身并不提供 `异步运行时 (async runtime)`, 以便语言内核精小, 便于进化/迭代/维护  \n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境  \n\n异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n因此它是可选的, 你可以凭借 `cartes.io` 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序  \n\n在开始下面的章节前, 请确保你已经在 `Cargo.toml` 中添加了如下代码  \n以 `async-std` 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:  \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n## Runtime\n\n我们先来创建一个打印 \"hello world\" 的 Future吧:   \n\n```rust\nuse async_std::task;\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?  \n`async_std::task` 提供了大量 API, 用来执行/操控这些 Task  \n\n如这里出现的`task::block_on`, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程  \n该任务执行完毕后产出的值,会作为 `block_on` 的返回值  \n\n我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n`.await` 关键字出场了! \n\n- - -\n\n# Await  \n`.await` 只能出现在 `async fn/block` 内部, 在某个 Future 变量后面添加 `.await` 后, 该 Future 就会执行  \n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future   \n\n来看看它的使用:  \n\n```rust\nuse async_std::task;\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await` 是一个标记点, 可理解为是一个 `yield point`, Runtime 执行到 `xxx.await` 时,先会执行一次 `xxx`  \n\n一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 `Poll::Pending` 或 `Poll::Ready(T)`  \n来决定做以下两件事中的哪一件:  \n- 让其他 Task 接管执行权(yield)  \n- 继续执行当前 Task  \n\n若为`Pending`: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)  \n若为`Ready`: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)  \n\n可能有点难理解, 来个简单粗暴理解版:  \n\n`.await` 指明 `执行某个Future` 这一逻辑  \n当 `xxx.await` 所在的 Task 交给 Runtime 并并执行到 `xxx.await` 时, `xxx` 这个 Future实例 会执行  \n\n若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行  \n若不阻塞, 就继续往下执行(可能还会碰见 `.await` 哟), 直到该 Task 结束   \n\n- - -  \n\n# 补充\n- `#[async_std::main]`  \n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰  \n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 `async_std::task::JoinHandle` 类型的实例  \n它实现了 Future, 与标准库中的 `JoinHandle` 无比相似, 不过 `join` 相应地改变为了 `.await`  \n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 `.await` 进行修饰哦:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n\n","source":"_posts/rust/async/p3-Future.md","raw":"---\ntitle: \"rust-async-p3: Future\"\nabbrlink: posts/rust-async/p3\ndate: 2021-09-12 13:56:48\ntop: 9897\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\n---\n> Rust 中的 Future/async/.await 说明  \n<!-- more -->  \n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧    \n\n本节, 我们将学习以下三个概念的大致含义:  \n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n- - -\n\n# Future\n## 概念\n`Future`,一个标准/核心库中的trait: `std/core::future::Future`   \n\n在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 `一次异步计算`, 可将其交给 `Runtime(运行时)` 来异步执行   \n\n`异步执行`, 也就是指:    \n- 其他异步任务阻塞时,当前异步任务有机会执行  \n- 当前异步任务阻塞时,其他异步任务有机会执行  \n\n总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别,举个例子你就明白了:  \n  \n假设有这么个父计算, 由两个子计算组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期  \n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算  \n(我们将`最顶层的父计算(top-level Future, 即最顶层的Future实例)`称为`Task(任务)`)  \n\n当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算  \n\n总结:  \n- Task 是一个顶层 Future 实例 (即一次顶层异步计算) \n- 一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future\n- Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算\n- Task 可以只是一次单独计算\n\n一个 Future, 可理解为是组成一个 Task 的最小单位 \n\n## 定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output: 代表 Future 执行完毕后, 产出的值的类型   \n- poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成\n- Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:  \n`Poll::Pending`: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)  \n`Poll::Ready(T)`: 指明该计算执行完毕, 并产出一个类型为 T 的值  \n\n- - -\n\n# Async  \nRust 为我们提供了关键字 async, 方便人们为某次计算实现 Future  \n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊  \nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例  \n\n来个例子,看看 async 的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n// 2 \nstruct HelloStr;\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的  \n看看它们两的返回值:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n注意, 异步函数的调用, 只是返回一个 Future实例  \n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户\n\n这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作  \n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可  \n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了\n\nasync 的作用就是创建一个 Future 实例, 以下是不同的语法糖:  \n- `async fn`: 异步函数, 要求返回一个 Future 实例   \n- `async block`: 异步代码块, 创建一个 Future 实例  \n- `async closure`: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?  \n请接着往下看\n\n- - -\n\n# 执行\n## 背景介绍  \nRust本身并不提供 `异步运行时 (async runtime)`, 以便语言内核精小, 便于进化/迭代/维护  \n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境  \n\n异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n因此它是可选的, 你可以凭借 `cartes.io` 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序  \n\n在开始下面的章节前, 请确保你已经在 `Cargo.toml` 中添加了如下代码  \n以 `async-std` 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:  \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n## Runtime\n\n我们先来创建一个打印 \"hello world\" 的 Future吧:   \n\n```rust\nuse async_std::task;\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?  \n`async_std::task` 提供了大量 API, 用来执行/操控这些 Task  \n\n如这里出现的`task::block_on`, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程  \n该任务执行完毕后产出的值,会作为 `block_on` 的返回值  \n\n我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?  \n`.await` 关键字出场了! \n\n- - -\n\n# Await  \n`.await` 只能出现在 `async fn/block` 内部, 在某个 Future 变量后面添加 `.await` 后, 该 Future 就会执行  \n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future   \n\n来看看它的使用:  \n\n```rust\nuse async_std::task;\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await` 是一个标记点, 可理解为是一个 `yield point`, Runtime 执行到 `xxx.await` 时,先会执行一次 `xxx`  \n\n一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 `Poll::Pending` 或 `Poll::Ready(T)`  \n来决定做以下两件事中的哪一件:  \n- 让其他 Task 接管执行权(yield)  \n- 继续执行当前 Task  \n\n若为`Pending`: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)  \n若为`Ready`: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)  \n\n可能有点难理解, 来个简单粗暴理解版:  \n\n`.await` 指明 `执行某个Future` 这一逻辑  \n当 `xxx.await` 所在的 Task 交给 Runtime 并并执行到 `xxx.await` 时, `xxx` 这个 Future实例 会执行  \n\n若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行  \n若不阻塞, 就继续往下执行(可能还会碰见 `.await` 哟), 直到该 Task 结束   \n\n- - -  \n\n# 补充\n- `#[async_std::main]`  \n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰  \n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 `async_std::task::JoinHandle` 类型的实例  \n它实现了 Future, 与标准库中的 `JoinHandle` 无比相似, 不过 `join` 相应地改变为了 `.await`  \n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 `.await` 进行修饰哦:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n\n","slug":"rust/async/p3-Future","published":1,"updated":"2021-09-12T05:56:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gv001m6aijggsm80zu","content":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明</p>\n</blockquote>\n<span id=\"more\"></span>  \n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧</p>\n<p>本节, 我们将学习以下三个概念的大致含义:<br>\n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future (trait)</p>\n</li>\n<li class=\"lvl-2\">\n<p>async (keyword)</p>\n</li>\n<li class=\"lvl-2\">\n<p>.await (keyword)</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"future\">Future</h1>\n<h2 id=\"gai-nian\" id=\"概念\">概念</h2>\n<p><code>Future</code>,一个标准/核心库中的trait: <code>std/core::future::Future</code></p>\n<p>在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 <code>一次异步计算</code>, 可将其交给 <code>Runtime(运行时)</code> 来异步执行</p>\n<p><code>异步执行</code>, 也就是指:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其他异步任务阻塞时,当前异步任务有机会执行</p>\n</li>\n<li class=\"lvl-2\">\n<p>当前异步任务阻塞时,其他异步任务有机会执行</p>\n</li>\n</ul>\n<p>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>异步 计算</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>异步 任务</code></p>\n</li>\n</ul>\n<p>两者有着区别,举个例子你就明白了:</p>\n<p>假设有这么个父计算, 由两个子计算组成:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Open: 先异步打开一个文件(async open)</p>\n</li>\n<li class=\"lvl-3\">\n<p>Read: 再异步读取该文件(async read)</p>\n</li>\n</ol>\n<p>我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>\n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算<br>\n(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p>\n<p>当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算</p>\n<p>总结:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Task 是一个顶层 Future 实例 (即一次顶层异步计算)</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 可以只是一次单独计算</p>\n</li>\n</ul>\n<p>一个 Future, 可理解为是组成一个 Task 的最小单位</p>\n<h2 id=\"ding-yi\" id=\"定义\">定义</h2>\n<p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future:<br>\n代表一次异步计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Output: 代表 Future 执行完毕后, 产出的值的类型</p>\n</li>\n<li class=\"lvl-2\">\n<p>poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成</p>\n</li>\n<li class=\"lvl-2\">\n<p>Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:<br>\n<code>Poll::Pending</code>: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br>\n<code>Poll::Ready(T)</code>: 指明该计算执行完毕, 并产出一个类型为 T 的值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"async\">Async</h1>\n<p>Rust 为我们提供了关键字 async, 方便人们为某次计算实现 Future<br>\n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊<br>\nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例</p>\n<p>来个例子,看看 async 的好处:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的<br>\n看看它们两的返回值:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n<p>注意, 异步函数的调用, 只是返回一个 Future实例<br>\n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户</p>\n<p>这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作<br>\n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可<br>\n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了</p>\n<p>async 的作用就是创建一个 Future 实例, 以下是不同的语法糖:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async fn</code>: 异步函数, 要求返回一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async block</code>: 异步代码块, 创建一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async closure</code>: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n<p>创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?<br>\n请接着往下看</p>\n<hr>\n<h1 id=\"zhi-xing\">执行</h1>\n<h2 id=\"bei-jing-jie-shao\" id=\"背景介绍\">背景介绍</h2>\n<p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>\n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境</p>\n<p>异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序<br>\n因此它是可选的, 你可以凭借 <code>cartes.io</code> 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序</p>\n<p>在开始下面的章节前, 请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码<br>\n以 <code>async-std</code> 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"runtime\" id=\"Runtime\">Runtime</h2>\n<p>我们先来创建一个打印 “hello world” 的 Future吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?<br>\n<code>async_std::task</code> 提供了大量 API, 用来执行/操控这些 Task</p>\n<p>如这里出现的<code>task::block_on</code>, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程<br>\n该任务执行完毕后产出的值,会作为 <code>block_on</code> 的返回值</p>\n<p>我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?<br>\n<code>.await</code> 关键字出场了!</p>\n<hr>\n<h1 id=\"await\">Await</h1>\n<p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部, 在某个 Future 变量后面添加 <code>.await</code> 后, 该 Future 就会执行<br>\n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>\n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future</p>\n<p>来看看它的使用:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>.await</code> 是一个标记点, 可理解为是一个 <code>yield point</code>, Runtime 执行到 <code>xxx.await</code> 时,先会执行一次 <code>xxx</code></p>\n<p>一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 <code>Poll::Pending</code> 或 <code>Poll::Ready(T)</code><br>\n来决定做以下两件事中的哪一件:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让其他 Task 接管执行权(yield)</p>\n</li>\n<li class=\"lvl-2\">\n<p>继续执行当前 Task</p>\n</li>\n</ul>\n<p>若为<code>Pending</code>: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)<br>\n若为<code>Ready</code>: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)</p>\n<p>可能有点难理解, 来个简单粗暴理解版:</p>\n<p><code>.await</code> 指明 <code>执行某个Future</code> 这一逻辑<br>\n当 <code>xxx.await</code> 所在的 Task 交给 Runtime 并并执行到 <code>xxx.await</code> 时, <code>xxx</code> 这个 Future实例 会执行</p>\n<p>若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行<br>\n若不阻塞, 就继续往下执行(可能还会碰见 <code>.await</code> 哟), 直到该 Task 结束</p>\n<hr>\n<h1 id=\"bu-chong\">补充</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#[async_std::main]</code><br>\n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰<br>\n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async_std::task::spawn</code><br>\n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 <code>async_std::task::JoinHandle</code> 类型的实例<br>\n它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似, 不过 <code>join</code> 相应地改变为了 <code>.await</code><br>\n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 <code>.await</code> 进行修饰哦:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":5078,"excerpt":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p>大家好! 我们上一节已经知晓异步的基础概念, 现在,来看看Rust中的异步语法吧</p>\n<p>本节, 我们将学习以下三个概念的大致含义:<br>\n(暂时不涉及背后原理, 原理要等之后专门出好几节来讲)</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future (trait)</p>\n</li>\n<li class=\"lvl-2\">\n<p>async (keyword)</p>\n</li>\n<li class=\"lvl-2\">\n<p>.await (keyword)</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"future\">Future</h1>\n<h2 id=\"gai-nian\" id=\"概念\">概念</h2>\n<p><code>Future</code>,一个标准/核心库中的trait: <code>std/core::future::Future</code></p>\n<p>在Rust中,一个实现了Future(trait)的类型, 该类型的实例(一个Future实例), 便代表 <code>一次异步计算</code>, 可将其交给 <code>Runtime(运行时)</code> 来异步执行</p>\n<p><code>异步执行</code>, 也就是指:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>其他异步任务阻塞时,当前异步任务有机会执行</p>\n</li>\n<li class=\"lvl-2\">\n<p>当前异步任务阻塞时,其他异步任务有机会执行</p>\n</li>\n</ul>\n<p>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>异步 计算</code></p>\n</li>\n<li class=\"lvl-2\">\n<p><code>异步 任务</code></p>\n</li>\n</ul>\n<p>两者有着区别,举个例子你就明白了:</p>\n<p>假设有这么个父计算, 由两个子计算组成:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Open: 先异步打开一个文件(async open)</p>\n</li>\n<li class=\"lvl-3\">\n<p>Read: 再异步读取该文件(async read)</p>\n</li>\n</ol>\n<p>我们可以看出, 一次计算可以由多个有依赖关系的子计算组成, 若 Open 陷入阻塞, Runtime 不能调度 Read 填充这段阻塞时期<br>\n因此, 当某个子计算阻塞时, 它所属的最顶层的父计算也应阻塞, 避免 Runtime 调度非法计算<br>\n(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)</p>\n<p>当前 Task 阻塞时, 接管执行权的不能是当前 Task 中的其他子计算, 只能是其他 Task 中的子计算</p>\n<p>总结:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Task 是一个顶层 Future 实例 (即一次顶层异步计算)</p>\n</li>\n<li class=\"lvl-2\">\n<p>一个 Future 可以由多个 Future 组成, 即一个 Future 里可以执行多个 Future</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task_A 阻塞时,接管执行的是其他 Task 中的子计算,不能是 Task_A 中的子计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Task 可以只是一次单独计算</p>\n</li>\n</ul>\n<p>一个 Future, 可理解为是组成一个 Task 的最小单位</p>\n<h2 id=\"ding-yi\" id=\"定义\">定义</h2>\n<p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Future:<br>\n代表一次异步计算</p>\n</li>\n<li class=\"lvl-2\">\n<p>Output: 代表 Future 执行完毕后, 产出的值的类型</p>\n</li>\n<li class=\"lvl-2\">\n<p>poll: 所有执行操作都会放在该函数中, Runtime 会不断调用 poll 来推进 Future 的完成, 其返回值是枚举类型, 代表是否完成</p>\n</li>\n<li class=\"lvl-2\">\n<p>Poll<T>: 枚举类型, 作为 poll 的返回值类型, 其变体有:<br>\n<code>Poll::Pending</code>: 指明该计算处于阻塞, 调度程序在该计算阻塞完毕后, 继续调用 poll(因为之后可能还会阻塞)<br>\n<code>Poll::Ready(T)</code>: 指明该计算执行完毕, 并产出一个类型为 T 的值</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"async\">Async</h1>\n<p>Rust 为我们提供了关键字 async, 方便人们为某次计算实现 Future<br>\n你想一想, 实现了 Future 本身的类型可以是随便某个类型, 毕竟我要的是计算, 而不是结构体啊<br>\nasync, 便是用来创建一个匿名结构体实例, 自动为该结构体实现 Future, 即, 用来创建一个 Future 实例</p>\n<p>来个例子,看看 async 的好处:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以观察到, 使用 async 进行了符合直觉的简化, 这两种函数,实际上是等价的<br>\n看看它们两的返回值:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n<p>注意, 异步函数的调用, 只是返回一个 Future实例<br>\n但并没有开始执行, 它是惰性的, 只有调用 Future 的 poll 方法, 才能推动它的执行, 而调用 poll 的工作, 则交给了运行时(执行器), 而非用户</p>\n<p>这样的好处就在于, 将一次异步计算当作一个变量, 方便传参等工作<br>\n比如, 想舍弃某次异步任务, 只需将对应的 Future 实例给 drop 掉, 使其所有权丢失即可<br>\n如果一旦创建 Future 实例就立刻执行, 就没有这么方便了</p>\n<p>async 的作用就是创建一个 Future 实例, 以下是不同的语法糖:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async fn</code>: 异步函数, 要求返回一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async block</code>: 异步代码块, 创建一个 Future 实例</p>\n</li>\n<li class=\"lvl-2\">\n<p><code>async closure</code>: 异步闭包 (目前是不稳定特性) 创建一个 Future 实例</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n<p>创建一个Future实例, 想必大家已经了解一二, 但如何执行一个Future实例?<br>\n请接着往下看</p>\n<hr>\n<h1 id=\"zhi-xing\">执行</h1>\n<h2 id=\"bei-jing-jie-shao\" id=\"背景介绍\">背景介绍</h2>\n<p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>\n仔细看看 Future 的完整路径, 你会注意到, 它也存在于核心库(core)中, 这意味着, Rust 一定可以提供 Future trait, 即使是嵌入式等环境</p>\n<p>异步运行时, 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序<br>\n因此它是可选的, 你可以凭借 <code>cartes.io</code> 上提供的相关carte, 在不同的环境下使用不同的运行时, 即使在嵌入式等环境, 也能轻松运行异步程序</p>\n<p>在开始下面的章节前, 请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码<br>\n以 <code>async-std</code> 这个虽然不主流, 但和标准库的API一致, 对新人比较友好的 crate 作为例子:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"runtime\" id=\"Runtime\">Runtime</h2>\n<p>我们先来创建一个打印 “hello world” 的 Future吧:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们提到过的 Task (异步任务, Top-level Future, 即顶层的异步计算) 吗?<br>\n<code>async_std::task</code> 提供了大量 API, 用来执行/操控这些 Task</p>\n<p>如这里出现的<code>task::block_on</code>, 传入一个 Future, Runtime 会执行它(调用 poll) 并阻塞调用线程<br>\n该任务执行完毕后产出的值,会作为 <code>block_on</code> 的返回值</p>\n<p>我们执行了一个 Task, 且这个 Task 是单个的 Future, 但若我们想执行由多个 子Future 所组成的 Task, 又该怎么办?<br>\n<code>.await</code> 关键字出场了!</p>\n<hr>\n<h1 id=\"await\">Await</h1>\n<p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部, 在某个 Future 变量后面添加 <code>.await</code> 后, 该 Future 就会执行<br>\n但是, 它只是表述这么个逻辑而已, 因为Rust语言本身没有异步运行时(无执行能力)<br>\n真正执行的话, 得将 Future 交给运行时, 带动着执行里面的 子Future</p>\n<p>来看看它的使用:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>.await</code> 是一个标记点, 可理解为是一个 <code>yield point</code>, Runtime 执行到 <code>xxx.await</code> 时,先会执行一次 <code>xxx</code></p>\n<p>一开始会调用一次 poll, 推动执行进度, 通过它的返回值, 即 <code>Poll::Pending</code> 或 <code>Poll::Ready(T)</code><br>\n来决定做以下两件事中的哪一件:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>让其他 Task 接管执行权(yield)</p>\n</li>\n<li class=\"lvl-2\">\n<p>继续执行当前 Task</p>\n</li>\n</ul>\n<p>若为<code>Pending</code>: 则选第一个, 让其他 Task 接管执行权(如IO操作的阻塞期间, 让其他 Task 执行)<br>\n若为<code>Ready</code>: 则选第二个, 继续往下执行(一个 Task 可能由多个 子Future 组成)</p>\n<p>可能有点难理解, 来个简单粗暴理解版:</p>\n<p><code>.await</code> 指明 <code>执行某个Future</code> 这一逻辑<br>\n当 <code>xxx.await</code> 所在的 Task 交给 Runtime 并并执行到 <code>xxx.await</code> 时, <code>xxx</code> 这个 Future实例 会执行</p>\n<p>若它阻塞(这意味着该 Future 所在的 Task 也阻塞), 所以调度程序安排其他 Task, 在该空档期执行<br>\n若不阻塞, 就继续往下执行(可能还会碰见 <code>.await</code> 哟), 直到该 Task 结束</p>\n<hr>\n<h1 id=\"bu-chong\">补充</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>#[async_std::main]</code><br>\n这玩意是个属性宏, 要加在main函数头上, 使得 main 前面能被 async 所修饰<br>\n程序运行时, main 返回的Future, 会自动交给 Runtime 开始运行, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><code>async_std::task::spawn</code><br>\n因为这玩意也很常见, 向其传入 Future, Runtime 会开始运行它, 并返回 <code>async_std::task::JoinHandle</code> 类型的实例<br>\n它实现了 Future, 与标准库中的 <code>JoinHandle</code> 无比相似, 不过 <code>join</code> 相应地改变为了 <code>.await</code><br>\n想让该 handle 代表的 Task 运行完毕, 应在该 handle 前放上 <code>.await</code> 进行修饰哦:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"rust-async-p4: 状态的保存与变换","abbrlink":"posts/rust-async/p4","date":"2021-09-12T06:50:14.000Z","top":9896,"keywords":["Async","异步","Rust"],"_content":"> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n**注**: 参考了 <<Writing an OS in Rust>> 中的 async 篇,可以自己搜索下看看  \n为了更好地理解 `Rust异步`背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:   \n- 多任务: 抢占式与协作式  \n- 状态机  \n- 自引用结构体   \n\n\n现在,让我们开始吧!  \n- - -\n# 两种多任务  \n## 介绍\n抢占式 与 协作式, 是 多任务 的不同分类  \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会  \n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉  \n这是强迫/抢占的    \n\n- 协作式多任务:  \n任务们本身进行协调, 决定CPU的运行权  \n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending  \n自己放弃继续执行, 并通知运行时执行其他Task  \n这是自愿/协作的, Task 们自愿放弃CPU的执行权\n\n## 状态的恢复/保存\n既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时  \n该任务,应当从先前暂停的地方开始, 继续执行  \n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存  \n\n对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:\n\n- 抢占式:  \n因为是强迫切换执行的, 任务会在任意某个时刻被中断  \n任务此时运行到了哪里?我们不知道啊!  \n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间  \n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n- 协作式:  \n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作, 我们称为`yield`    \n\n比如在Rust中, `xxx.await`会执行一个Future  \t\n意味着当程序执行到这里时, 可能会`yield`(poll返回Poll::Pending, 自愿放弃执行权)  \n\n`xxx.await`就是一个`stop/yield point`, 代表执行到此处时, 可能会发生暂停并yield  \n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此, 我们可以准确分配Future执行所需要的最大空间  \n\n其实, 每个`.await(也就是yield point)`, 就代表着`一种状态`(之后会讲)\n\n协作式的好处在于:  \n能自己掌握所有`yield point`, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理  \n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的  \n在任务暂停并转让执行权前, 准确保存`下次继续所需要的状态`, 内存/性能优势很大    \n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n\n- - -\n# 状态机的概念  \n在Rust中的异步, 我们之前也说过, 属于`协作式多任务`  \n而其`状态保存`的实现, 就是利用`状态机(state machine)`来实现  \n\n`状态机(state machine)`一般指`有限状态自动机`, 是一种数学模型  \n\n1. 状态(state):  \n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed\n2. 事件(event):  \n某事件发生后, 会触发相应动作, 可能改变状态  \n比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state)   \n3. 动作 (action):  \n事件发生后, 会触发动作  \n4. 变换 (transition):  \n`State_X=>State_Y`就叫`变换`, 比如门的状态从`Open=>Closed`  \n\n稍微了解下`状态机`的概念即可  \n\n那么现在, 就要看具体代码了  \n\n如果你想亲自运行一下, 先确保你的`Cargo.toml`中的依赖如下:  \n\n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下代码, 读取一个文件的行数  \n你可以通过 `cargo run -- ./src/main.rs` 运行  \n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)  \n\n```rust\nuse std::{\n\tenv::args,\n\tprocess,\n};\nuse async_std::{\n\tprelude::*,\n\tfs::File,\n\tio::{self,BufReader},\n};\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).unwrap_or_else(||{\n\t\teprintln!(\"Fuck you! No path for reading\");\n\t\tprocess::exit(1);\n\t}); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\n\n\nmian()产生一个新实例, 异步运行`open(path)`与`count()`  \t    \n对于编译器, 每一个`.await`其实都代表一种状态  \n\nFuture实例, 实际上是个状态机  \n在这里共有四种状态/阶段(其中包括两个`.await point(yield point)`):  \n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用当前Future的poll推动进度时, 若在`某一阶段`返回了`Poll::Pending`, 则放弃执行权  \n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态`恢复(resume)`, 继续执行  \n\n官方目前似乎采用`Generator(生成器)`为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态  \n\n**Note 1**:  \nStart状态, 会存储传入函数的参数(如果有参数)\n\n**Note 2**:  \nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义,  且point之后还需要使用的变量`  \n如上段代码中的 `file` 与 `count`就需要被保存, 因为从暂停中恢复后还需要使用  \n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象  \n所以不需要特殊的持久化操作\n\n- - - \n# 自引用结构体  \n## 保存引用\n当每个状态存储数据时,  可能会导致发生`自引用`, 比如:  \n\n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n\n这里有三个状态: `Start`, `Yield1`, `Done`, 而在`Yield1`这个状态下, 存储的数据如下:  \n\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3], \n    element: *const i32, // 数组最后一个元素的地址\n}\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```\n\n等等, 你可能会对上面的代码有疑惑:  \n不是说, 状态只需要保存 `在yield point之前定义,  并且该point之后还需要使用的变量` 吗  \n上面的代码, 只有element这个引用需要被保存吧?  \n\n这是因为, 它是`引用`嘛! 没了`引用`背后的实际数据, 那它还有啥用, 不就是`悬垂引用`了吗?  \n因此我们还得保存, `该引用`指向的背后数据: `arr`, 并**一起**存储在同个`struct(代表同一状态)`中  \n像这种 `结构体内部的指针, 指向结构体本身`, 就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下, 成员element指向了成员arr  \n\n## 内存移动问题\n如上所述,  这可能导致悬垂引用的产生, 若该struct实例的`内存地址发生改变`, 如使用 `std::mem`, 让struct实例的内存地址发生移动  \n以上面的那段代码为例, 如下:  \n\n- arr:  \n内存地址会跟着结构体实例而改变, 但是,  `值仍然是 [1, 2, 3]`\n- element:  \n内存地址会跟着结构体实例而改变, 但是, 值仍然是`先前arr的地址`, `注意, 是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n官方提出了`std::pin::Pin(trait)` 来解决自引用结构体方面的悬垂指针/引用问题 \n\n其实你听名字也很好理解, `Pin(中文意思是钉子)`的作用是, 防止内存地址发生改变(给爷钉死吧!)  \n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了  \n\n欲知后事如何,  且听下回分解  \n~~(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~  \n","source":"_posts/rust/async/p4-状态的保存与变换.md","raw":"---\ntitle: \"rust-async-p4: 状态的保存与变换\"\nabbrlink: posts/rust-async/p4\ndate: 2021-09-12 14:50:14\ntop: 9896\ntags: [Rust, Async]\nkeywords: [Async, 异步, Rust]\n---\n> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n同系列传送门: [rust-async](/categories/rust-async)\n\n# 开篇\n**注**: 参考了 <<Writing an OS in Rust>> 中的 async 篇,可以自己搜索下看看  \n为了更好地理解 `Rust异步`背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:   \n- 多任务: 抢占式与协作式  \n- 状态机  \n- 自引用结构体   \n\n\n现在,让我们开始吧!  \n- - -\n# 两种多任务  \n## 介绍\n抢占式 与 协作式, 是 多任务 的不同分类  \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会  \n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉  \n这是强迫/抢占的    \n\n- 协作式多任务:  \n任务们本身进行协调, 决定CPU的运行权  \n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending  \n自己放弃继续执行, 并通知运行时执行其他Task  \n这是自愿/协作的, Task 们自愿放弃CPU的执行权\n\n## 状态的恢复/保存\n既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时  \n该任务,应当从先前暂停的地方开始, 继续执行  \n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存  \n\n对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:\n\n- 抢占式:  \n因为是强迫切换执行的, 任务会在任意某个时刻被中断  \n任务此时运行到了哪里?我们不知道啊!  \n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)    \n\n反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间  \n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大  \n\n- 协作式:  \n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作, 我们称为`yield`    \n\n比如在Rust中, `xxx.await`会执行一个Future  \t\n意味着当程序执行到这里时, 可能会`yield`(poll返回Poll::Pending, 自愿放弃执行权)  \n\n`xxx.await`就是一个`stop/yield point`, 代表执行到此处时, 可能会发生暂停并yield  \n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此, 我们可以准确分配Future执行所需要的最大空间  \n\n其实, 每个`.await(也就是yield point)`, 就代表着`一种状态`(之后会讲)\n\n协作式的好处在于:  \n能自己掌握所有`yield point`, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理  \n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的  \n在任务暂停并转让执行权前, 准确保存`下次继续所需要的状态`, 内存/性能优势很大    \n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行  \n\n- - -\n# 状态机的概念  \n在Rust中的异步, 我们之前也说过, 属于`协作式多任务`  \n而其`状态保存`的实现, 就是利用`状态机(state machine)`来实现  \n\n`状态机(state machine)`一般指`有限状态自动机`, 是一种数学模型  \n\n1. 状态(state):  \n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed\n2. 事件(event):  \n某事件发生后, 会触发相应动作, 可能改变状态  \n比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state)   \n3. 动作 (action):  \n事件发生后, 会触发动作  \n4. 变换 (transition):  \n`State_X=>State_Y`就叫`变换`, 比如门的状态从`Open=>Closed`  \n\n稍微了解下`状态机`的概念即可  \n\n那么现在, 就要看具体代码了  \n\n如果你想亲自运行一下, 先确保你的`Cargo.toml`中的依赖如下:  \n\n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下代码, 读取一个文件的行数  \n你可以通过 `cargo run -- ./src/main.rs` 运行  \n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)  \n\n```rust\nuse std::{\n\tenv::args,\n\tprocess,\n};\nuse async_std::{\n\tprelude::*,\n\tfs::File,\n\tio::{self,BufReader},\n};\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).unwrap_or_else(||{\n\t\teprintln!(\"Fuck you! No path for reading\");\n\t\tprocess::exit(1);\n\t}); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\n\n\nmian()产生一个新实例, 异步运行`open(path)`与`count()`  \t    \n对于编译器, 每一个`.await`其实都代表一种状态  \n\nFuture实例, 实际上是个状态机  \n在这里共有四种状态/阶段(其中包括两个`.await point(yield point)`):  \n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用当前Future的poll推动进度时, 若在`某一阶段`返回了`Poll::Pending`, 则放弃执行权  \n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态`恢复(resume)`, 继续执行  \n\n官方目前似乎采用`Generator(生成器)`为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态  \n\n**Note 1**:  \nStart状态, 会存储传入函数的参数(如果有参数)\n\n**Note 2**:  \nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义,  且point之后还需要使用的变量`  \n如上段代码中的 `file` 与 `count`就需要被保存, 因为从暂停中恢复后还需要使用  \n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象  \n所以不需要特殊的持久化操作\n\n- - - \n# 自引用结构体  \n## 保存引用\n当每个状态存储数据时,  可能会导致发生`自引用`, 比如:  \n\n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n\n这里有三个状态: `Start`, `Yield1`, `Done`, 而在`Yield1`这个状态下, 存储的数据如下:  \n\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3], \n    element: *const i32, // 数组最后一个元素的地址\n}\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```\n\n等等, 你可能会对上面的代码有疑惑:  \n不是说, 状态只需要保存 `在yield point之前定义,  并且该point之后还需要使用的变量` 吗  \n上面的代码, 只有element这个引用需要被保存吧?  \n\n这是因为, 它是`引用`嘛! 没了`引用`背后的实际数据, 那它还有啥用, 不就是`悬垂引用`了吗?  \n因此我们还得保存, `该引用`指向的背后数据: `arr`, 并**一起**存储在同个`struct(代表同一状态)`中  \n像这种 `结构体内部的指针, 指向结构体本身`, 就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下, 成员element指向了成员arr  \n\n## 内存移动问题\n如上所述,  这可能导致悬垂引用的产生, 若该struct实例的`内存地址发生改变`, 如使用 `std::mem`, 让struct实例的内存地址发生移动  \n以上面的那段代码为例, 如下:  \n\n- arr:  \n内存地址会跟着结构体实例而改变, 但是,  `值仍然是 [1, 2, 3]`\n- element:  \n内存地址会跟着结构体实例而改变, 但是, 值仍然是`先前arr的地址`, `注意, 是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n官方提出了`std::pin::Pin(trait)` 来解决自引用结构体方面的悬垂指针/引用问题 \n\n其实你听名字也很好理解, `Pin(中文意思是钉子)`的作用是, 防止内存地址发生改变(给爷钉死吧!)  \n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了  \n\n欲知后事如何,  且听下回分解  \n~~(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~  \n","slug":"rust/async/p4-状态的保存与变换","published":1,"updated":"2021-09-12T06:50:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gw001n6aijb19i2rfd","content":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>注</strong>: 参考了 &lt;<Writing an OS in Rust>&gt; 中的 async 篇,可以自己搜索下看看<br>\n为了更好地理解 <code>Rust异步</code>背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>多任务: 抢占式与协作式</p>\n</li>\n<li class=\"lvl-2\">\n<p>状态机</p>\n</li>\n<li class=\"lvl-2\">\n<p>自引用结构体</p>\n</li>\n</ul>\n<p>现在,让我们开始吧!</p>\n<hr>\n<h1 id=\"liang-chong-duo-ren-wu\">两种多任务</h1>\n<h2 id=\"jie-shao\" id=\"介绍\">介绍</h2>\n<p>抢占式 与 协作式, 是 多任务 的不同分类</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式多任务:<br>\n操作系统决定CPU的运行权<br>\n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会<br>\n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉<br>\n这是强迫/抢占的</p>\n</li>\n<li class=\"lvl-2\">\n<p>协作式多任务:<br>\n任务们本身进行协调, 决定CPU的运行权<br>\n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending<br>\n自己放弃继续执行, 并通知运行时执行其他Task<br>\n这是自愿/协作的, Task 们自愿放弃CPU的执行权</p>\n</li>\n</ul>\n<h2 id=\"zhuang-tai-de-hui-fu-bao-cun\" id=\"状态的恢复-保存\">状态的恢复/保存</h2>\n<p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>\n该任务,应当从先前暂停的地方开始, 继续执行<br>\n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存</p>\n<p>对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式:<br>\n因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>\n任务此时运行到了哪里?我们不知道啊!<br>\n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)</p>\n</li>\n</ul>\n<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>\n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>协作式:<br>\n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>\n这种放弃执行权的操作, 我们称为<code>yield</code></p>\n</li>\n</ul>\n<p>比如在Rust中, <code>xxx.await</code>会执行一个Future  \t<br>\n意味着当程序执行到这里时, 可能会<code>yield</code>(poll返回Poll::Pending, 自愿放弃执行权)</p>\n<p><code>xxx.await</code>就是一个<code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>\n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>\n因此, 我们可以准确分配Future执行所需要的最大空间</p>\n<p>其实, 每个<code>.await(也就是yield point)</code>, 就代表着<code>一种状态</code>(之后会讲)</p>\n<p>协作式的好处在于:<br>\n能自己掌握所有<code>yield point</code>, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理<br>\n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的<br>\n在任务暂停并转让执行权前, 准确保存<code>下次继续所需要的状态</code>, 内存/性能优势很大<br>\n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行</p>\n<hr>\n<h1 id=\"zhuang-tai-ji-de-gai-nian\">状态机的概念</h1>\n<p>在Rust中的异步, 我们之前也说过, 属于<code>协作式多任务</code><br>\n而其<code>状态保存</code>的实现, 就是利用<code>状态机(state machine)</code>来实现</p>\n<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>, 是一种数学模型</p>\n<ol>\n<li class=\"lvl-3\">\n<p>状态(state):<br>\n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed</p>\n</li>\n<li class=\"lvl-3\">\n<p>事件(event):<br>\n某事件发生后, 会触发相应动作, 可能改变状态<br>\n比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p>\n</li>\n<li class=\"lvl-3\">\n<p>动作 (action):<br>\n事件发生后, 会触发动作</p>\n</li>\n<li class=\"lvl-3\">\n<p>变换 (transition):<br>\n<code>State_X=&gt;State_Y</code>就叫<code>变换</code>, 比如门的状态从<code>Open=&gt;Closed</code></p>\n</li>\n</ol>\n<p>稍微了解下<code>状态机</code>的概念即可</p>\n<p>那么现在, 就要看具体代码了</p>\n<p>如果你想亲自运行一下, 先确保你的<code>Cargo.toml</code>中的依赖如下:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>如下代码, 读取一个文件的行数<br>\n你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>\n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    env::args,</span><br><span class=\"line\">    process,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> async_std::&#123;</span><br><span class=\"line\">    prelude::*,</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).unwrap_or_else(||&#123;</span><br><span class=\"line\">        eprintln!(<span class=\"string\">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class=\"line\">        process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n<p>mian()产生一个新实例, 异步运行<code>open(path)</code>与<code>count()</code>  \t<br>\n对于编译器, 每一个<code>.await</code>其实都代表一种状态</p>\n<p>Future实例, 实际上是个状态机<br>\n在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Start: 此Future刚开始执行</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield1: 第一个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield2: 第二个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Done: 此Future执行完毕</p>\n</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>\n执行器调用当前Future的poll推动进度时, 若在<code>某一阶段</code>返回了<code>Poll::Pending</code>, 则放弃执行权<br>\n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态<code>恢复(resume)</code>, 继续执行</p>\n<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态</p>\n<p><strong>Note 1</strong>:<br>\nStart状态, 会存储传入函数的参数(如果有参数)</p>\n<p><strong>Note 2</strong>:<br>\nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的</p>\n<p><strong>Note 3</strong>:<br>\n怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br>\n<code>某个yield point之前定义,  且point之后还需要使用的变量</code><br>\n如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存, 因为从暂停中恢复后还需要使用<br>\n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>\n所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"zi-yin-yong-jie-gou-ti\">自引用结构体</h1>\n<h2 id=\"bao-cun-yin-yong\" id=\"保存引用\">保存引用</h2>\n<p>当每个状态存储数据时,  可能会导致发生<code>自引用</code>, 比如:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code>, 而在<code>Yield1</code>这个状态下, 存储的数据如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Yield1State</span></span> &#123;</span><br><span class=\"line\">    arr: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>], </span><br><span class=\"line\">    element: *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>, <span class=\"comment\">// 数组最后一个元素的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 状态的实例</span></span><br><span class=\"line\">Yield1State &#123;</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">    element: &amp;arr[<span class=\"number\">2</span>] <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等等, 你可能会对上面的代码有疑惑:<br>\n不是说, 状态只需要保存 <code>在yield point之前定义,  并且该point之后还需要使用的变量</code> 吗<br>\n上面的代码, 只有element这个引用需要被保存吧?</p>\n<p>这是因为, 它是<code>引用</code>嘛! 没了<code>引用</code>背后的实际数据, 那它还有啥用, 不就是<code>悬垂引用</code>了吗?<br>\n因此我们还得保存, <code>该引用</code>指向的背后数据: <code>arr</code>, 并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中<br>\n像这种 <code>结构体内部的指针, 指向结构体本身</code>, 就叫 <code>自引用结构</code></p>\n<p>比如上面代码: 同一结构体下, 成员element指向了成员arr</p>\n<h2 id=\"nei-cun-yi-dong-wen-ti\" id=\"内存移动问题\">内存移动问题</h2>\n<p>如上所述,  这可能导致悬垂引用的产生, 若该struct实例的<code>内存地址发生改变</code>, 如使用 <code>std::mem</code>, 让struct实例的内存地址发生移动<br>\n以上面的那段代码为例, 如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>arr:<br>\n内存地址会跟着结构体实例而改变, 但是,  <code>值仍然是 [1, 2, 3]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>element:<br>\n内存地址会跟着结构体实例而改变, 但是, 值仍然是<code>先前arr的地址</code>, <code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)<br>\n官方提出了<code>std::pin::Pin(trait)</code> 来解决自引用结构体方面的悬垂指针/引用问题</p>\n<p>其实你听名字也很好理解, <code>Pin(中文意思是钉子)</code>的作用是, 防止内存地址发生改变(给爷钉死吧!)<br>\n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了</p>\n<p>欲知后事如何,  且听下回分解<br>\n<s>(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>\n","site":{"data":{}},"length":3801,"excerpt":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-async\">rust-async</a></p>\n<h1 id=\"kai-pian\">开篇</h1>\n<p><strong>注</strong>: 参考了 &lt;<Writing an OS in Rust>&gt; 中的 async 篇,可以自己搜索下看看<br>\n为了更好地理解 <code>Rust异步</code>背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>多任务: 抢占式与协作式</p>\n</li>\n<li class=\"lvl-2\">\n<p>状态机</p>\n</li>\n<li class=\"lvl-2\">\n<p>自引用结构体</p>\n</li>\n</ul>\n<p>现在,让我们开始吧!</p>\n<hr>\n<h1 id=\"liang-chong-duo-ren-wu\">两种多任务</h1>\n<h2 id=\"jie-shao\" id=\"介绍\">介绍</h2>\n<p>抢占式 与 协作式, 是 多任务 的不同分类</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式多任务:<br>\n操作系统决定CPU的运行权<br>\n比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会<br>\n各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉<br>\n这是强迫/抢占的</p>\n</li>\n<li class=\"lvl-2\">\n<p>协作式多任务:<br>\n任务们本身进行协调, 决定CPU的运行权<br>\n比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending<br>\n自己放弃继续执行, 并通知运行时执行其他Task<br>\n这是自愿/协作的, Task 们自愿放弃CPU的执行权</p>\n</li>\n</ul>\n<h2 id=\"zhuang-tai-de-hui-fu-bao-cun\" id=\"状态的恢复-保存\">状态的恢复/保存</h2>\n<p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br>\n该任务,应当从先前暂停的地方开始, 继续执行<br>\n因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存</p>\n<p>对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>抢占式:<br>\n因为是强迫切换执行的, 任务会在任意某个时刻被中断<br>\n任务此时运行到了哪里?我们不知道啊!<br>\n那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack)</p>\n</li>\n</ul>\n<p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br>\n但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>协作式:<br>\n因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br>\n这种放弃执行权的操作, 我们称为<code>yield</code></p>\n</li>\n</ul>\n<p>比如在Rust中, <code>xxx.await</code>会执行一个Future  \t<br>\n意味着当程序执行到这里时, 可能会<code>yield</code>(poll返回Poll::Pending, 自愿放弃执行权)</p>\n<p><code>xxx.await</code>就是一个<code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br>\n瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>\n因此, 我们可以准确分配Future执行所需要的最大空间</p>\n<p>其实, 每个<code>.await(也就是yield point)</code>, 就代表着<code>一种状态</code>(之后会讲)</p>\n<p>协作式的好处在于:<br>\n能自己掌握所有<code>yield point</code>, 从而精打细算地选择最优的策略,  而非让操作系统为你暗地里处理<br>\n毕竟机器定义的分配策略,  总是没有比不过我们特意设计的<br>\n在任务暂停并转让执行权前, 准确保存<code>下次继续所需要的状态</code>, 内存/性能优势很大<br>\n但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行</p>\n<hr>\n<h1 id=\"zhuang-tai-ji-de-gai-nian\">状态机的概念</h1>\n<p>在Rust中的异步, 我们之前也说过, 属于<code>协作式多任务</code><br>\n而其<code>状态保存</code>的实现, 就是利用<code>状态机(state machine)</code>来实现</p>\n<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>, 是一种数学模型</p>\n<ol>\n<li class=\"lvl-3\">\n<p>状态(state):<br>\n比如有一扇门, 它的状态就处于以下两种之一: Open or Closed</p>\n</li>\n<li class=\"lvl-3\">\n<p>事件(event):<br>\n某事件发生后, 会触发相应动作, 可能改变状态<br>\n比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)</p>\n</li>\n<li class=\"lvl-3\">\n<p>动作 (action):<br>\n事件发生后, 会触发动作</p>\n</li>\n<li class=\"lvl-3\">\n<p>变换 (transition):<br>\n<code>State_X=&gt;State_Y</code>就叫<code>变换</code>, 比如门的状态从<code>Open=&gt;Closed</code></p>\n</li>\n</ol>\n<p>稍微了解下<code>状态机</code>的概念即可</p>\n<p>那么现在, 就要看具体代码了</p>\n<p>如果你想亲自运行一下, 先确保你的<code>Cargo.toml</code>中的依赖如下:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>如下代码, 读取一个文件的行数<br>\n你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>\n(通过target目录下的可执行文件, 加上参数后运行, 也可以哦)</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    env::args,</span><br><span class=\"line\">    process,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> async_std::&#123;</span><br><span class=\"line\">    prelude::*,</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).unwrap_or_else(||&#123;</span><br><span class=\"line\">        eprintln!(<span class=\"string\">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class=\"line\">        process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n<p>mian()产生一个新实例, 异步运行<code>open(path)</code>与<code>count()</code>  \t<br>\n对于编译器, 每一个<code>.await</code>其实都代表一种状态</p>\n<p>Future实例, 实际上是个状态机<br>\n在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>Start: 此Future刚开始执行</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield1: 第一个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Yield2: 第二个 yield point</p>\n</li>\n<li class=\"lvl-3\">\n<p>Done: 此Future执行完毕</p>\n</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>\n执行器调用当前Future的poll推动进度时, 若在<code>某一阶段</code>返回了<code>Poll::Pending</code>, 则放弃执行权<br>\n当再次调用当前Future的poll推动进度时, 则从上次暂停的状态<code>恢复(resume)</code>, 继续执行</p>\n<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机, 每个状态都会存储一些数据,  便于进入下一个状态</p>\n<p><strong>Note 1</strong>:<br>\nStart状态, 会存储传入函数的参数(如果有参数)</p>\n<p><strong>Note 2</strong>:<br>\nDone状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能,  也不应该的</p>\n<p><strong>Note 3</strong>:<br>\n怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br>\n<code>某个yield point之前定义,  且point之后还需要使用的变量</code><br>\n如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存, 因为从暂停中恢复后还需要使用<br>\n其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br>\n所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"zi-yin-yong-jie-gou-ti\">自引用结构体</h1>\n<h2 id=\"bao-cun-yin-yong\" id=\"保存引用\">保存引用</h2>\n<p>当每个状态存储数据时,  可能会导致发生<code>自引用</code>, 比如:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code>, 而在<code>Yield1</code>这个状态下, 存储的数据如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Yield1State</span></span> &#123;</span><br><span class=\"line\">    arr: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>], </span><br><span class=\"line\">    element: *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>, <span class=\"comment\">// 数组最后一个元素的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 状态的实例</span></span><br><span class=\"line\">Yield1State &#123;</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">    element: &amp;arr[<span class=\"number\">2</span>] <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等等, 你可能会对上面的代码有疑惑:<br>\n不是说, 状态只需要保存 <code>在yield point之前定义,  并且该point之后还需要使用的变量</code> 吗<br>\n上面的代码, 只有element这个引用需要被保存吧?</p>\n<p>这是因为, 它是<code>引用</code>嘛! 没了<code>引用</code>背后的实际数据, 那它还有啥用, 不就是<code>悬垂引用</code>了吗?<br>\n因此我们还得保存, <code>该引用</code>指向的背后数据: <code>arr</code>, 并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中<br>\n像这种 <code>结构体内部的指针, 指向结构体本身</code>, 就叫 <code>自引用结构</code></p>\n<p>比如上面代码: 同一结构体下, 成员element指向了成员arr</p>\n<h2 id=\"nei-cun-yi-dong-wen-ti\" id=\"内存移动问题\">内存移动问题</h2>\n<p>如上所述,  这可能导致悬垂引用的产生, 若该struct实例的<code>内存地址发生改变</code>, 如使用 <code>std::mem</code>, 让struct实例的内存地址发生移动<br>\n以上面的那段代码为例, 如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>arr:<br>\n内存地址会跟着结构体实例而改变, 但是,  <code>值仍然是 [1, 2, 3]</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>element:<br>\n内存地址会跟着结构体实例而改变, 但是, 值仍然是<code>先前arr的地址</code>, <code>注意, 是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)<br>\n官方提出了<code>std::pin::Pin(trait)</code> 来解决自引用结构体方面的悬垂指针/引用问题</p>\n<p>其实你听名字也很好理解, <code>Pin(中文意思是钉子)</code>的作用是, 防止内存地址发生改变(给爷钉死吧!)<br>\n但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了</p>\n<p>欲知后事如何,  且听下回分解<br>\n<s>(疯狂省略,  因为我累死了, 多么希望赶紧结束这一P啊 ! !)</s></p>"},{"title":"rust-gtk4-p1: 系列说明","abbrlink":"posts/rust-gtk4/p1","date":"2021-10-23T12:18:17.000Z","top":9699,"keywords":["Rust","GUI","Gtk4"],"_content":"> 欢迎大家来到 Rust 的 gkt-rs 系列\n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# 系列说明\n[Gtk](https://www.gtk.org/), 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序  \n\nRust语言自是其中之一, 具有相关的绑定库: [gtk-rs](https://gtk-rs.org/) (gtk官方网页所指定)  \n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了  \n\n不定期更新, 毕竟我只有周末才能碰到电脑  \n~~(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)~~\n\n- - -\n# 参考资料\n资料正在持续更新ing. . .\n1. 书籍\n- [GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/) (官方书籍)\n\n- [Gtk4 Tutorial](https://toshiocp.github.io/Gtk4-tutorial/) (由社区编写的gtk4教学书籍)\n\n2. 博客/文档\n- [Rust Vs GUI](https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html)\n- [GObject Introspection](https://gi.readthedocs.io/en/latest/#gobject-introspection)\n- [GNOME Developer Doc/Tutorials](https://developer.gnome.org/documentation/tutorials.html)\n- - -\n# 环境配置\n首先请参照 [GTK官方页面](https://www.gtk.org/docs/installations/) , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:  \n\n- Fedora, 及其衍生:  \n\n```bash\nsudo dnf install gtk4-devel gcc\n```\n\n- Debian, 及其衍生:\n\n```bash\nsudo apt install libgtk-4-dev build-essential\n```\n\n- Arch, 及其衍生:\n\n```bash\nsudo pacman -S gtk4 base-devel\n```\n\nWindows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 ~~(无视即可)~~  \n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可  \n\n请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk  \n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","source":"_posts/rust/gtk4/p1-系列说明.md","raw":"---\ntitle: \"rust-gtk4-p1: 系列说明\"\nabbrlink: posts/rust-gtk4/p1\ndate: 2021-10-23 20:18:17\ntop: 9699\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Gtk4]\n---\n> 欢迎大家来到 Rust 的 gkt-rs 系列\n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# 系列说明\n[Gtk](https://www.gtk.org/), 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序  \n\nRust语言自是其中之一, 具有相关的绑定库: [gtk-rs](https://gtk-rs.org/) (gtk官方网页所指定)  \n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了  \n\n不定期更新, 毕竟我只有周末才能碰到电脑  \n~~(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)~~\n\n- - -\n# 参考资料\n资料正在持续更新ing. . .\n1. 书籍\n- [GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/) (官方书籍)\n\n- [Gtk4 Tutorial](https://toshiocp.github.io/Gtk4-tutorial/) (由社区编写的gtk4教学书籍)\n\n2. 博客/文档\n- [Rust Vs GUI](https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html)\n- [GObject Introspection](https://gi.readthedocs.io/en/latest/#gobject-introspection)\n- [GNOME Developer Doc/Tutorials](https://developer.gnome.org/documentation/tutorials.html)\n- - -\n# 环境配置\n首先请参照 [GTK官方页面](https://www.gtk.org/docs/installations/) , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:  \n\n- Fedora, 及其衍生:  \n\n```bash\nsudo dnf install gtk4-devel gcc\n```\n\n- Debian, 及其衍生:\n\n```bash\nsudo apt install libgtk-4-dev build-essential\n```\n\n- Arch, 及其衍生:\n\n```bash\nsudo pacman -S gtk4 base-devel\n```\n\nWindows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 ~~(无视即可)~~  \n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可  \n\n请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk  \n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系, 毕竟我也在学习中  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","slug":"rust/gtk4/p1-系列说明","published":1,"updated":"2021-10-23T12:18:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86gx001q6aij8r3511rt","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p><a href=\"https://www.gtk.org/\">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序</p>\n<p>Rust语言自是其中之一, 具有相关的绑定库: <a href=\"https://gtk-rs.org/\">gtk-rs</a> (gtk官方网页所指定)<br>\n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了</p>\n<p>不定期更新, 毕竟我只有周末才能碰到电脑<br>\n<s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<p>资料正在持续更新ing. . .</p>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://gtk-rs.org/gtk4-rs/stable/latest/book/\">GUI development with Rust and GTK 4</a> (官方书籍)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://toshiocp.github.io/Gtk4-tutorial/\">Gtk4 Tutorial</a> (由社区编写的gtk4教学书籍)</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客/文档</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html\">Rust Vs GUI</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://gi.readthedocs.io/en/latest/#gobject-introspection\">GObject Introspection</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials.html\">GNOME Developer Doc/Tutorials</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-jing-pei-zhi\">环境配置</h1>\n<p>首先请参照 <a href=\"https://www.gtk.org/docs/installations/\">GTK官方页面</a> , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Fedora, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf install gtk4-devel gcc</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Debian, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install libgtk-4-dev build-essential</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Arch, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gtk4 base-devel</span><br></pre></td></tr></table></figure>\n<p>Windows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 <s>(无视即可)</s><br>\n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可</p>\n<p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":750,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p><a href=\"https://www.gtk.org/\">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成, 由于是使用C语言编写, 各类语言都能使用它开发GUI程序</p>\n<p>Rust语言自是其中之一, 具有相关的绑定库: <a href=\"https://gtk-rs.org/\">gtk-rs</a> (gtk官方网页所指定)<br>\n同时, 非常建议你使用Linux作为开发环境, Gtk可以说是Linux平台下开发GUI程序的最佳选择之一了</p>\n<p>不定期更新, 毕竟我只有周末才能碰到电脑<br>\n<s>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</s></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<p>资料正在持续更新ing. . .</p>\n<ol>\n<li class=\"lvl-3\">\n<p>书籍</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://gtk-rs.org/gtk4-rs/stable/latest/book/\">GUI development with Rust and GTK 4</a> (官方书籍)</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://toshiocp.github.io/Gtk4-tutorial/\">Gtk4 Tutorial</a> (由社区编写的gtk4教学书籍)</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>博客/文档</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html\">Rust Vs GUI</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://gi.readthedocs.io/en/latest/#gobject-introspection\">GObject Introspection</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials.html\">GNOME Developer Doc/Tutorials</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-jing-pei-zhi\">环境配置</h1>\n<p>首先请参照 <a href=\"https://www.gtk.org/docs/installations/\">GTK官方页面</a> , 下载 GTK4, 下面是我为了方便读者, 复制粘贴过来的:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Fedora, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo dnf install gtk4-devel gcc</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Debian, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install libgtk-4-dev build-essential</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Arch, 及其衍生:</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gtk4 base-devel</span><br></pre></td></tr></table></figure>\n<p>Windows系统下, 建议使用WSL2, 在Linux环境下开发, 亲测可以做GUI, 虽然目前还有警告 <s>(无视即可)</s><br>\n比如, 使用 Arch 作为 WSL2, 那么可以按照上面的方法, 直接安装即可</p>\n<p>请自己查找资料, 善用搜索引擎与官方文档, 配置Gtk</p>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系, 毕竟我也在学习中<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"},{"title":"rust-gtk4-p2: 创建窗口","abbrlink":"posts/rust-gtk4/p2","date":"2021-11-07T02:16:57.000Z","top":9698,"keywords":["Rust","GUI","Gtk4"],"_content":"> 让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧  \n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# 背景了解  \n## GTK\nGTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n在gtk3后, 由于GI([GObject Introspection](https://gi.readthedocs.io/en/latest/)) 的应用, 可以轻松地, 创建其他语言的绑定  \n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript... ~~(不会真的有人用C语言写Gtk吧?)~~  \n\n基本上名气稍微大点的语言, 都有对应的GTK绑定    \n\n## gtk-rs\n目前有个项目, 叫做 [gtk-rs](https://gtk-rs.org/), 负责GTK的Rust绑定, 在 [crates.io](https://crates.io/) 上搜索 gtk, 所看到的 [gtk](https://crates.io/crates/gtk) 与 [gtk4](https://crates.io/crates/gtk4), 就属于gtk-rs\n\ngtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身  \n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上  \n\n- - -\n\n# 项目配置\n首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 如下:  \n\n```toml\n[dependencies]\ngtk = {version = \"0.3.1\", package = \"gtk4\"}\n```\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4)  \n下面就是正式的编码环节了\n\n- - -\n\n# 基础知识\n一个GTK4应用的创建, 需要用到 `gtk::Application`  \n同时还需 `use gtk::prelude::*`, 原因与 [std::prelude](https://doc.rust-lang.org/std/prelude/index.html) 一样  \n\n先创建一个应用, 它目前连窗口也没有:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.run();\n}\n```\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\n- [application_id](https://developer.gnome.org/documentation/tutorials/application-id.html):  \n每个GTK应用, 都带有一个id, 即 `application_id`, 它必须是全世界唯一的, 一般使用反域名作为id, 如 \"org.gnome.gedit\"  \n`app_id` 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!  \n\n- [Builder Pattern (一种Rust中常见的设计模式)](http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html):  \n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: `application_id(id: &str)`  \n在gtk4中, 它被高频次地使用, 最后调用的 `build` 会生成比如窗口, 按钮等部件的实例  \n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话\n\n- - -\n\n# 信号量\n当你跃跃欲试, `cargo run` 之后, 会看到:  \n\n```bash\nGLib-GIO-WARNING : Your application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal.  \nIt should do one of these.\n```\n\n靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n当然, 现在还无法执行, 请注意 `build_ui` 函数中的 `todo!()`, 我们还没有填充这个函数!  \n因为我想逐步地讲解一下... 先来讲什么是 signal 吗:  \n\n当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度  \n比如窗口打开, 按钮被点击, 拖动控件...这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了  \n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了  \n\n- 我们把处理函数, 称之为 `handler`\n- 我们将为 signal 绑定一个 handler 的过程, 称之为 `connect`\n\nGtk 的理念是: App只关心在特定的时候需要做的事情  \n`事件发送的时间` , 即 signal 什么时候发送已经定好了, 至于 `事情的内容`, 即 handler 的具体实现, 由开发者自己负责    \n\n下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:  \n\n- startup: \n在App第一次启动时被调用, 用于与UI显示无关的初始化任务  \n- shutdown: \n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C\n- activate:\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口  \n- open\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件  \n\n正如上面第三个信号所说, 一个GtkApp至少得有一个窗口  \n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口  \n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化  \n\n这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象\n\n- - - \n\n# 创建空白窗口\n\n回到之前的代码, 如下:\n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n```\nYour application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal. \n```\n\n现在你应该明白, 为什么之前会报出这个警告了吧? `connect_xxxx`, 代表着连接某个 signal , 即实现对应的虚函数/handler  \n\n`connect_activate`, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 `&Application`  \n我们创建的这个函数, 名为 `build_ui`, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这...啧, 不太聪明?  \n\n直接上 `build_ui` 的代码, 注意 use 那边多了东西:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .build();\n    win.present();\n}\n```\n\n我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它  \n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 `My App`  \n\n在App启动之后的某时刻, `activate` 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现  \n但现在, 我们已经将它覆盖成自己的 `build_ui` 了, 因此警告不再出现  \n\n- - -\n\n# 新增按钮\n\n让我们再创建一个按钮, 提示信息是 `Press me!`, 在按下之后, 变成显示 `Hello World!`:  \n\n```rust\nuse gtk::{prelude::*, Button};\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let btn = Button::builder().label(\"Press me!\").build();\n    btn.connect_clicked(|btn| btn.set_label(\"Hello World!\"));\n\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .child(&btn)\n        .build();\n\n    win.present();\n}\n```\n\n我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已  \n\n之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler  \n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理  \n\n然后, 我们在使用 `Builder Pattern` 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中  \n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲  \n\n- - - \n\n# 补充\n\n- 设置间距:  \n运行先前的代码, 你会发现按钮占满了整个窗口  \n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:\n\n```rust\nlet btn = Button::builder()\n    .label(\"Press me!\")\n    .margin_top(12)\n    .margin_bottom(12)\n    .margin_start(12)\n    .margin_end(12)\n    .build();\n```\n\n- 透明设置:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .opacity(0.8)         // 窗口不透明度, 越低越透明, 越高越不透明\n    .build();\n```\n\n- 默认高宽:\n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .default_height(100)\n    .default_width(200)\n    .build();\n```\n\n至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 :)  ","source":"_posts/rust/gtk4/p2-创建窗口.md","raw":"---\ntitle: \"rust-gtk4-p2: 创建窗口\"\nabbrlink: posts/rust-gtk4/p2\ndate: 2021-11-07 10:16:57\ntop: 9698\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Gtk4]\n---\n> 让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧  \n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# 背景了解  \n## GTK\nGTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n在gtk3后, 由于GI([GObject Introspection](https://gi.readthedocs.io/en/latest/)) 的应用, 可以轻松地, 创建其他语言的绑定  \n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript... ~~(不会真的有人用C语言写Gtk吧?)~~  \n\n基本上名气稍微大点的语言, 都有对应的GTK绑定    \n\n## gtk-rs\n目前有个项目, 叫做 [gtk-rs](https://gtk-rs.org/), 负责GTK的Rust绑定, 在 [crates.io](https://crates.io/) 上搜索 gtk, 所看到的 [gtk](https://crates.io/crates/gtk) 与 [gtk4](https://crates.io/crates/gtk4), 就属于gtk-rs\n\ngtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身  \n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上  \n\n- - -\n\n# 项目配置\n首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 如下:  \n\n```toml\n[dependencies]\ngtk = {version = \"0.3.1\", package = \"gtk4\"}\n```\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4)  \n下面就是正式的编码环节了\n\n- - -\n\n# 基础知识\n一个GTK4应用的创建, 需要用到 `gtk::Application`  \n同时还需 `use gtk::prelude::*`, 原因与 [std::prelude](https://doc.rust-lang.org/std/prelude/index.html) 一样  \n\n先创建一个应用, 它目前连窗口也没有:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.run();\n}\n```\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\n- [application_id](https://developer.gnome.org/documentation/tutorials/application-id.html):  \n每个GTK应用, 都带有一个id, 即 `application_id`, 它必须是全世界唯一的, 一般使用反域名作为id, 如 \"org.gnome.gedit\"  \n`app_id` 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!  \n\n- [Builder Pattern (一种Rust中常见的设计模式)](http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html):  \n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: `application_id(id: &str)`  \n在gtk4中, 它被高频次地使用, 最后调用的 `build` 会生成比如窗口, 按钮等部件的实例  \n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话\n\n- - -\n\n# 信号量\n当你跃跃欲试, `cargo run` 之后, 会看到:  \n\n```bash\nGLib-GIO-WARNING : Your application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal.  \nIt should do one of these.\n```\n\n靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n当然, 现在还无法执行, 请注意 `build_ui` 函数中的 `todo!()`, 我们还没有填充这个函数!  \n因为我想逐步地讲解一下... 先来讲什么是 signal 吗:  \n\n当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度  \n比如窗口打开, 按钮被点击, 拖动控件...这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了  \n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了  \n\n- 我们把处理函数, 称之为 `handler`\n- 我们将为 signal 绑定一个 handler 的过程, 称之为 `connect`\n\nGtk 的理念是: App只关心在特定的时候需要做的事情  \n`事件发送的时间` , 即 signal 什么时候发送已经定好了, 至于 `事情的内容`, 即 handler 的具体实现, 由开发者自己负责    \n\n下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:  \n\n- startup: \n在App第一次启动时被调用, 用于与UI显示无关的初始化任务  \n- shutdown: \n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C\n- activate:\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口  \n- open\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件  \n\n正如上面第三个信号所说, 一个GtkApp至少得有一个窗口  \n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口  \n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化  \n\n这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象\n\n- - - \n\n# 创建空白窗口\n\n回到之前的代码, 如下:\n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n\ttodo!()\n}\n```\n\n```\nYour application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal. \n```\n\n现在你应该明白, 为什么之前会报出这个警告了吧? `connect_xxxx`, 代表着连接某个 signal , 即实现对应的虚函数/handler  \n\n`connect_activate`, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 `&Application`  \n我们创建的这个函数, 名为 `build_ui`, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这...啧, 不太聪明?  \n\n直接上 `build_ui` 的代码, 注意 use 那边多了东西:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .build();\n    win.present();\n}\n```\n\n我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它  \n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 `My App`  \n\n在App启动之后的某时刻, `activate` 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现  \n但现在, 我们已经将它覆盖成自己的 `build_ui` 了, 因此警告不再出现  \n\n- - -\n\n# 新增按钮\n\n让我们再创建一个按钮, 提示信息是 `Press me!`, 在按下之后, 变成显示 `Hello World!`:  \n\n```rust\nuse gtk::{prelude::*, Button};\nuse gtk::{Application, ApplicationWindow};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    let btn = Button::builder().label(\"Press me!\").build();\n    btn.connect_clicked(|btn| btn.set_label(\"Hello World!\"));\n\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My App\")\n        .child(&btn)\n        .build();\n\n    win.present();\n}\n```\n\n我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已  \n\n之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler  \n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理  \n\n然后, 我们在使用 `Builder Pattern` 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中  \n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲  \n\n- - - \n\n# 补充\n\n- 设置间距:  \n运行先前的代码, 你会发现按钮占满了整个窗口  \n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:\n\n```rust\nlet btn = Button::builder()\n    .label(\"Press me!\")\n    .margin_top(12)\n    .margin_bottom(12)\n    .margin_start(12)\n    .margin_end(12)\n    .build();\n```\n\n- 透明设置:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .opacity(0.8)         // 窗口不透明度, 越低越透明, 越高越不透明\n    .build();\n```\n\n- 默认高宽:\n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .default_height(100)\n    .default_width(200)\n    .build();\n```\n\n至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 :)  ","slug":"rust/gtk4/p2-创建窗口","published":1,"updated":"2021-11-07T02:16:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86hg003k6aijgp0180zh","content":"<blockquote>\n<p>让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"bei-jing-liao-jie\">背景了解</h1>\n<h2 id=\"gtk\" id=\"GTK\">GTK</h2>\n<p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写<br>\n在gtk3后, 由于GI(<a href=\"https://gi.readthedocs.io/en/latest/\">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定<br>\n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript… <s>(不会真的有人用C语言写Gtk吧?)</s></p>\n<p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p>\n<h2 id=\"gtk-rs\" id=\"gtk-rs\">gtk-rs</h2>\n<p>目前有个项目, 叫做 <a href=\"https://gtk-rs.org/\">gtk-rs</a>, 负责GTK的Rust绑定, 在 <a href=\"https://crates.io/\">crates.io</a> 上搜索 gtk, 所看到的 <a href=\"https://crates.io/crates/gtk\">gtk</a> 与 <a href=\"https://crates.io/crates/gtk4\">gtk4</a>, 就属于gtk-rs</p>\n<p>gtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身<br>\n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上</p>\n<hr>\n<h1 id=\"xiang-mu-pei-zhi\">项目配置</h1>\n<p>首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 如下:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">gtk</span> = &#123;version = <span class=\"string\">&quot;0.3.1&quot;</span>, package = <span class=\"string\">&quot;gtk4&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4)<br>\n下面就是正式的编码环节了</p>\n<hr>\n<h1 id=\"ji-chu-zhi-shi\">基础知识</h1>\n<p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>\n同时还需 <code>use gtk::prelude::*</code>, 原因与 <a href=\"https://doc.rust-lang.org/std/prelude/index.html\">std::prelude</a> 一样</p>\n<p>先创建一个应用, 它目前连窗口也没有:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单吧? 但别急着运行, 先看看下面两处:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials/application-id.html\">application_id</a>:<br>\n每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的, 一般使用反域名作为id, 如 “org.gnome.gedit”<br>\n<code>app_id</code> 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html\">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>\n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: <code>application_id(id: &amp;str)</code><br>\n在gtk4中, 它被高频次地使用, 最后调用的 <code>build</code> 会生成比如窗口, 按钮等部件的实例<br>\n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"xin-hao-liang\">信号量</h1>\n<p>当你跃跃欲试, <code>cargo run</code> 之后, 会看到:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLib-GIO-WARNING : Your application does not implement g_application_activate()</span><br><span class=\"line\">and has no handlers connected to the <span class=\"string\">&#x27;activate&#x27;</span> signal.  </span><br><span class=\"line\">It should <span class=\"keyword\">do</span> one of these.</span><br></pre></td></tr></table></figure>\n<p>靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然, 现在还无法执行, 请注意 <code>build_ui</code> 函数中的 <code>todo!()</code>, 我们还没有填充这个函数!<br>\n因为我想逐步地讲解一下… 先来讲什么是 signal 吗:</p>\n<p>当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度<br>\n比如窗口打开, 按钮被点击, 拖动控件…这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了<br>\n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们把处理函数, 称之为 <code>handler</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>我们将为 signal 绑定一个 handler 的过程, 称之为 <code>connect</code></p>\n</li>\n</ul>\n<p>Gtk 的理念是: App只关心在特定的时候需要做的事情<br>\n<code>事件发送的时间</code> , 即 signal 什么时候发送已经定好了, 至于 <code>事情的内容</code>, 即 handler 的具体实现, 由开发者自己负责</p>\n<p>下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>startup:<br>\n在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>shutdown:<br>\n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p>\n</li>\n<li class=\"lvl-2\">\n<p>activate:<br>\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p>open<br>\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p>\n</li>\n</ul>\n<p>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>\n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口<br>\n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化</p>\n<p>这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象</p>\n<hr>\n<h1 id=\"chuang-jian-kong-bai-chuang-kou\">创建空白窗口</h1>\n<p>回到之前的代码, 如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Your <span class=\"built_in\">application</span> <span class=\"keyword\">does</span> <span class=\"keyword\">not</span> implement g_application_activate()</span><br><span class=\"line\"><span class=\"keyword\">and</span> has no handlers connected <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> &#x27;<span class=\"built_in\">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure>\n<p>现在你应该明白, 为什么之前会报出这个警告了吧? <code>connect_xxxx</code>, 代表着连接某个 signal , 即实现对应的虚函数/handler</p>\n<p><code>connect_activate</code>, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 <code>&amp;Application</code><br>\n我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这…啧, 不太聪明?</p>\n<p>直接上 <code>build_ui</code> 的代码, 注意 use 那边多了东西:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它<br>\n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 <code>My App</code></p>\n<p>在App启动之后的某时刻, <code>activate</code> 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现<br>\n但现在, 我们已经将它覆盖成自己的 <code>build_ui</code> 了, 因此警告不再出现</p>\n<hr>\n<h1 id=\"xin-zeng-an-niu\">新增按钮</h1>\n<p>让我们再创建一个按钮, 提示信息是 <code>Press me!</code>, 在按下之后, 变成显示 <code>Hello World!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;prelude::*, Button&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn = Button::builder().label(<span class=\"string\">&quot;Press me!&quot;</span>).build();</span><br><span class=\"line\">    btn.connect_clicked(|btn| btn.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;btn)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已</p>\n<p>之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler<br>\n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理</p>\n<p>然后, 我们在使用 <code>Builder Pattern</code> 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中<br>\n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲</p>\n<hr>\n<h1 id=\"bu-chong\">补充</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设置间距:<br>\n运行先前的代码, 你会发现按钮占满了整个窗口<br>\n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = Button::builder()</span><br><span class=\"line\">    .label(<span class=\"string\">&quot;Press me!&quot;</span>)</span><br><span class=\"line\">    .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_bottom(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>透明设置:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .opacity(<span class=\"number\">0.8</span>)         <span class=\"comment\">// 窗口不透明度, 越低越透明, 越高越不透明</span></span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认高宽:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .default_height(<span class=\"number\">100</span>)</span><br><span class=\"line\">    .default_width(<span class=\"number\">200</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<p>至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 😃</p>\n","site":{"data":{}},"length":4980,"excerpt":"<blockquote>\n<p>让我们使用 Gtk 创建窗口, 了解下 app_id, 构造者模式, 信号量, handler 等概念吧</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"bei-jing-liao-jie\">背景了解</h1>\n<h2 id=\"gtk\" id=\"GTK\">GTK</h2>\n<p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写<br>\n在gtk3后, 由于GI(<a href=\"https://gi.readthedocs.io/en/latest/\">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定<br>\n这使你能利用不同语言编写GUI, 比如Rust, Nim, Vala, Python, Javascript… <s>(不会真的有人用C语言写Gtk吧?)</s></p>\n<p>基本上名气稍微大点的语言, 都有对应的GTK绑定</p>\n<h2 id=\"gtk-rs\" id=\"gtk-rs\">gtk-rs</h2>\n<p>目前有个项目, 叫做 <a href=\"https://gtk-rs.org/\">gtk-rs</a>, 负责GTK的Rust绑定, 在 <a href=\"https://crates.io/\">crates.io</a> 上搜索 gtk, 所看到的 <a href=\"https://crates.io/crates/gtk\">gtk</a> 与 <a href=\"https://crates.io/crates/gtk4\">gtk4</a>, 就属于gtk-rs</p>\n<p>gtk4这个crate, 是Rust语言的绑定, 而非同纯C编写的那个gtk4本身<br>\n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本, 不然crate会装不上</p>\n<hr>\n<h1 id=\"xiang-mu-pei-zhi\">项目配置</h1>\n<p>首先, 你需要创建一个新项目, 随后修改 Cargo.toml, 如下:</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">gtk</span> = &#123;version = <span class=\"string\">&quot;0.3.1&quot;</span>, package = <span class=\"string\">&quot;gtk4&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写, 随后, 请run一下, 安装依赖 (请确保安装了gtk4)<br>\n下面就是正式的编码环节了</p>\n<hr>\n<h1 id=\"ji-chu-zhi-shi\">基础知识</h1>\n<p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>\n同时还需 <code>use gtk::prelude::*</code>, 原因与 <a href=\"https://doc.rust-lang.org/std/prelude/index.html\">std::prelude</a> 一样</p>\n<p>先创建一个应用, 它目前连窗口也没有:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很简单吧? 但别急着运行, 先看看下面两处:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://developer.gnome.org/documentation/tutorials/application-id.html\">application_id</a>:<br>\n每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的, 一般使用反域名作为id, 如 “org.gnome.gedit”<br>\n<code>app_id</code> 作为App的唯一标识符, 用于App之间的通信与识别, 因此要慎重考虑, 最好第一次就定好, 避免之后的麻烦!</p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html\">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>\n我们利用它进行链式构造, 让构造的过程更加清晰, 这里我们在链式中, 指定了程序的id: <code>application_id(id: &amp;str)</code><br>\n在gtk4中, 它被高频次地使用, 最后调用的 <code>build</code> 会生成比如窗口, 按钮等部件的实例<br>\n当然, 也可以通过编写XML文件, 来构造对应的部件, 指定其布局, 但这是后话</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"xin-hao-liang\">信号量</h1>\n<p>当你跃跃欲试, <code>cargo run</code> 之后, 会看到:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLib-GIO-WARNING : Your application does not implement g_application_activate()</span><br><span class=\"line\">and has no handlers connected to the <span class=\"string\">&#x27;activate&#x27;</span> signal.  </span><br><span class=\"line\">It should <span class=\"keyword\">do</span> one of these.</span><br></pre></td></tr></table></figure>\n<p>靠, 这是啥子玩意儿? 实际上, 我们还要添加一个名为 activate 的信号量(Signal):</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然, 现在还无法执行, 请注意 <code>build_ui</code> 函数中的 <code>todo!()</code>, 我们还没有填充这个函数!<br>\n因为我想逐步地讲解一下… 先来讲什么是 signal 吗:</p>\n<p>当某件事情发生时, signal 就会被发送, 交由Gtk的全局处理系统, 由它进行调度<br>\n比如窗口打开, 按钮被点击, 拖动控件…这些事件都会发送一个 signal 来告诉处理系统, 让它知道有事情发生了<br>\n你可以为每个 signal 绑定一个函数, 当处理系统接受到某个 signal, 就可以调用对应的处理函数了</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>我们把处理函数, 称之为 <code>handler</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>我们将为 signal 绑定一个 handler 的过程, 称之为 <code>connect</code></p>\n</li>\n</ul>\n<p>Gtk 的理念是: App只关心在特定的时候需要做的事情<br>\n<code>事件发送的时间</code> , 即 signal 什么时候发送已经定好了, 至于 <code>事情的内容</code>, 即 handler 的具体实现, 由开发者自己负责</p>\n<p>下面是四个待响应的信号, 也对应着四个待实现的虚函数/handler:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>startup:<br>\n在App第一次启动时被调用, 用于与UI显示无关的初始化任务</p>\n</li>\n<li class=\"lvl-2\">\n<p>shutdown:<br>\n在App结束时调用, 清理资源, 进行善后, 不过这好像对Rust没啥用? Drop能自动清理, 但毕竟源码是C</p>\n</li>\n<li class=\"lvl-2\">\n<p>activate:<br>\nGtkApp总得有至少一个窗口, 该函数决定如何显示/绘制窗口</p>\n</li>\n<li class=\"lvl-2\">\n<p>open<br>\n当App需要打开某个文件时被执行, 文件会在新窗口显示, 比如浏览器打开了pdf文件</p>\n</li>\n</ul>\n<p>正如上面第三个信号所说, 一个GtkApp至少得有一个窗口<br>\n当某个App试图打开第二个窗口, Gtk全局系统, 会发送 signal(activate/open) 给第一个窗口<br>\n所有的初始化工作都应在startup中完成, 哪怕是第二个窗口相关的初始化</p>\n<p>这些只是Gtk给我们的 signal 中最为常见的几个, 实际上还有很多信号, 帮你自定义设计App, 本节后面, 会再帮你加深下印象</p>\n<hr>\n<h1 id=\"chuang-jian-kong-bai-chuang-kou\">创建空白窗口</h1>\n<p>回到之前的代码, 如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Your <span class=\"built_in\">application</span> <span class=\"keyword\">does</span> <span class=\"keyword\">not</span> implement g_application_activate()</span><br><span class=\"line\"><span class=\"keyword\">and</span> has no handlers connected <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> &#x27;<span class=\"built_in\">activate</span>&#x27; signal. </span><br></pre></td></tr></table></figure>\n<p>现在你应该明白, 为什么之前会报出这个警告了吧? <code>connect_xxxx</code>, 代表着连接某个 signal , 即实现对应的虚函数/handler</p>\n<p><code>connect_activate</code>, 要求传入一个具有静态lifetime的函数作为参数, 且被传入函数只有唯一的参数, 其类型是 <code>&amp;Application</code><br>\n我们创建的这个函数, 名为 <code>build_ui</code>, 正是为了消除该警告, 真正显示窗口, 毕竟一个GUI程序若无任何显示, 这…啧, 不太聪明?</p>\n<p>直接上 <code>build_ui</code> 的代码, 注意 use 那边多了东西:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用builder模式, 指定了窗口对应的App是谁, 标题是啥, 并在最后显示它<br>\n如果你处于GNOME-DE, 并启用了相关主题, 将会看见一个具有对应主题的空白窗口, 标题是 <code>My App</code></p>\n<p>在App启动之后的某时刻, <code>activate</code> 信号对应的虚函数被调用, 之前因为没有实现它, 一个警告出现<br>\n但现在, 我们已经将它覆盖成自己的 <code>build_ui</code> 了, 因此警告不再出现</p>\n<hr>\n<h1 id=\"xin-zeng-an-niu\">新增按钮</h1>\n<p>让我们再创建一个按钮, 提示信息是 <code>Press me!</code>, 在按下之后, 变成显示 <code>Hello World!</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;prelude::*, Button&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn = Button::builder().label(<span class=\"string\">&quot;Press me!&quot;</span>).build();</span><br><span class=\"line\">    btn.connect_clicked(|btn| btn.set_label(<span class=\"string\">&quot;Hello World!&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;btn)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我在这里使用Button, 而不是Label, 单纯是为了复习先前学过的概念, 仅此而已</p>\n<p>之前说过, 我们可以 connect 的 signal 远不止那四个, 比如这里的 connect_clicked, 就代表按钮被点击后的handler<br>\n点击事情发生时, 本来就能啥也不做, 因此即使不调用 connect_clicked 也不会出现警告, 不像 activate 强制要求你处理</p>\n<p>然后, 我们在使用 <code>Builder Pattern</code> 构造窗口时, 调用child, 将该按钮的引用传入, 让按钮也出现在窗口中<br>\n注意: 这里会使得按钮的强引用数量+1, 因为Button是GObject的子类, 而GObject具有引用计数的特点, 下节会讲</p>\n<hr>\n<h1 id=\"bu-chong\">补充</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设置间距:<br>\n运行先前的代码, 你会发现按钮占满了整个窗口<br>\n我们可以在链式构造一个按钮时, 顺带着设置它与四周的间距, 代码很简单, 如下:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> btn = Button::builder()</span><br><span class=\"line\">    .label(<span class=\"string\">&quot;Press me!&quot;</span>)</span><br><span class=\"line\">    .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_bottom(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>透明设置:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .opacity(<span class=\"number\">0.8</span>)         <span class=\"comment\">// 窗口不透明度, 越低越透明, 越高越不透明</span></span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>默认高宽:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .default_height(<span class=\"number\">100</span>)</span><br><span class=\"line\">    .default_width(<span class=\"number\">200</span>)</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n<p>至此, 本小节结束, 又要愉快地鸽鸽鸽了呢 😃</p>"},{"title":"rust-gtk4-p3: GObject-内存管理","abbrlink":"posts/rust-gtk4/p3","date":"2022-03-30T04:01:22.000Z","top":9697,"keywords":["Rust","GUI","Gtk4"],"_content":"> 来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏  \n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# Widget\n任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念  \n再比如, `Button(按钮)`, `Container(容器)`, 都属于 `Widget`  \n\n[Widget Gallery](https://docs.gtk.org/gtk4/visual_index.html) 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 `Widget`  \n\n我们甚至能自定义出新的Widget, 通过`继承/子类化`, 因为 Gtk 是面向对象的GUI框架  \n例如 `Button`, 其继承树如下:  \n\n```\nGObject\n└── Widget\n    └── Button\n```\n\nGObject, 也就是 `gtk::glib::object::Object`, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性  \n举个例子, GObject 具有 `引用计数` 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存  \n\n接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n- - -\n\n# 错误实现\n首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 :)  \n\n为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?  \n下面是代码, 已经讲过的概念不再重复:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow, Button, Orientation};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    // 创建两个按钮, 设置Label\n    let btn_inc = Button::builder()\n        .label(\"Increase\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n    let btn_dec = Button::builder()\n        .label(\"Decrease\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n\n    // `Clicked` 事件发生后的处理函数\n    // 出于简单演示的目的, 这里只是单纯的加减数字而已\n    let mut num = 0;\n    btn_inc.connect_clicked(|_| {\n        num += 1;\n    });\n    btn_dec.connect_clicked(|_| {\n        num -= 1;\n    });\n\n    // 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下\n    // 因此, 从上往下第一个是btn_inc, 第二个是btn_dec\n    let gtk_box = gtk::Box::builder()\n        .orientation(Orientation::Vertical)\n        .build();\n    gtk_box.append(&btn_inc);\n    gtk_box.append(&btn_dec);\n\n    // 窗口只能设置一个child, 因此把容器添加进去\n    // 随后在容器中添加很多 widget, 达到全添加进去的目的\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My Gtk App\")\n        .child(&gtk_box)\n        .build();\n    win.present();\n}\n```\n\n显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错  \n如果看下 `connect_clicked` 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime  \n\n道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?  \n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量  \n\n我们可以选择为闭包添加前缀, 即添加关键字 `move`, 让被闭包捕获的变量, 其所有权转移到闭包中  \n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?  \n\n但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!  \n有没有什么办法, 让这两个闭包都能拥有num的所有权?  \n\n请看下面的正确实现, 通过引用计数的方式 :)\n- - -\n\n# 引用计数\n\n嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 ~~(GUI框架好像都是单线程的?)~~  \n那就可以使用 `std::rc::Rc` 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权  \n\n多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 `std::cell::Cell`  \n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 `Rc<Cell<i32>>`  \n\n:::tips\n**提示**  \n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell  \n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解\n:::\n\n下面是代码, 请务必记得use一下:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nlet num_clone = num.clone();\n\nbtn_inc.connect_clicked(|_| {\n    num_clone.set(num_clone.get() + 1);\n});\nbtn_dec.connect_clicked(|_| {\n    num.set(num.get() - 1);\n});\n```\n\n感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过  \n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?  \n\n让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全  \n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值  \n\n在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T>  \n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量  \n\n但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?  \n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作  \n\n- - -\n\n# clone!\nYeah, 这个宏的名字就叫clone: `glib::clone`, 你可以查看对应的文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n请务必注意use必须像下面这样写, 你得先 `use gtk::glib`, 随后 `use glib::clone`:  \n\n```rust\nuse std::cell::Cell;\nuse std::rc::Rc;\n\nuse glib::clone;\nuse gtk::prelude::*;   // 这里\nuse gtk::{glib, Application, ApplicationWindow, Button, Orientation};  // 这里\n```\n\n如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n使用 `clone!` 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)  \n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存  \n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回  \n\n懂了基础的原理后 ~~(我个人喜欢把读者当傻子, 因此尽量提一嘴)~~, 我们来看看上面这段代码:  \n\n- 在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建  \n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num  \n\n- 两个闭包中, 我们都创建了另一个按钮的 strong-ref  \n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec  \n\n::: tips\n**注意:**  \n`clone!`, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 `()` 值  \n详情请见文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n::: \n\n\n至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:  \n循环引用导致内存泄漏!  \n\n- - -\n\n# 循环引用\nRust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在  \n~~(大佬们可能一眼就看出来哪里循环引用了...)~~\n\n贴一份刚刚的代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref  \n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存  \n这就是 `循环引用`\n\n由于 `循环引用`, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 `内存泄漏`  \n\n如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @weak btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@weak btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 `btn_inc`/`btn_dec`  \n在闭包中, 对这两个btn都是弱引用, 当 `build_ui` 调用完毕后, 它们应该会自动drop掉 (因为作用域)  \n\n但若改成 weak-ref, `btn_inc`/`btn_dec` 不会因缺少 strong-ref 而出现问题吗?  \n答案是不会, 原因是以下两段代码  \n\n\n- 第一段:  \n\n```rust\nlet gtk_box = gtk::Box::builder()\n    .orientation(Orientation::Vertical)\n    .build();\ngtk_box.append(&btn_inc);\ngtk_box.append(&btn_dec);\n```\n\n- 第二段:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .child(&gtk_box)\n    .build();\nwin.present();\n```\n\n第一段中, `btn_inc`/`btn_dec` 的引用交给了 `append()`  \n第二段中, `gtk_box` 的引用交给了 `child()`  \n\n还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性  \n`append()`, `child()`, 都保持了对这些 Widget 的强引用, 保持了它们的活性:  \n`gtk_box` 持有对 `btn` 的 strong-ref, `win` 持有对 `gtk_box` 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着  \nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着  \n\n总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已  \n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!  \n\n本节到此结束, 要鸽一会了, 我们下节见 :)","source":"_posts/rust/gtk4/p3-GObject-内存管理.md","raw":"---\ntitle: \"rust-gtk4-p3: GObject-内存管理\"\nabbrlink: posts/rust-gtk4/p3\ndate: 2022-03-30 12:01:22\ntop: 9697\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Gtk4]\n---\n> 来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏  \n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# Widget\n任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念  \n再比如, `Button(按钮)`, `Container(容器)`, 都属于 `Widget`  \n\n[Widget Gallery](https://docs.gtk.org/gtk4/visual_index.html) 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 `Widget`  \n\n我们甚至能自定义出新的Widget, 通过`继承/子类化`, 因为 Gtk 是面向对象的GUI框架  \n例如 `Button`, 其继承树如下:  \n\n```\nGObject\n└── Widget\n    └── Button\n```\n\nGObject, 也就是 `gtk::glib::object::Object`, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性  \n举个例子, GObject 具有 `引用计数` 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存  \n\n接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n- - -\n\n# 错误实现\n首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 :)  \n\n为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?  \n下面是代码, 已经讲过的概念不再重复:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::{Application, ApplicationWindow, Button, Orientation};\n\nconst APP_ID: &str = \"xyz.jedsek.myapp\";\n\nfn main() {\n    let app = Application::builder().application_id(APP_ID).build();\n    app.connect_activate(build_ui);\n    app.run();\n}\n\nfn build_ui(app: &Application) {\n    // 创建两个按钮, 设置Label\n    let btn_inc = Button::builder()\n        .label(\"Increase\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n    let btn_dec = Button::builder()\n        .label(\"Decrease\")\n        .margin_top(12)\n        .margin_bottom(20)\n        .margin_start(12)\n        .margin_end(12)\n        .build();\n\n    // `Clicked` 事件发生后的处理函数\n    // 出于简单演示的目的, 这里只是单纯的加减数字而已\n    let mut num = 0;\n    btn_inc.connect_clicked(|_| {\n        num += 1;\n    });\n    btn_dec.connect_clicked(|_| {\n        num -= 1;\n    });\n\n    // 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下\n    // 因此, 从上往下第一个是btn_inc, 第二个是btn_dec\n    let gtk_box = gtk::Box::builder()\n        .orientation(Orientation::Vertical)\n        .build();\n    gtk_box.append(&btn_inc);\n    gtk_box.append(&btn_dec);\n\n    // 窗口只能设置一个child, 因此把容器添加进去\n    // 随后在容器中添加很多 widget, 达到全添加进去的目的\n    let win = ApplicationWindow::builder()\n        .application(app)\n        .title(\"My Gtk App\")\n        .child(&gtk_box)\n        .build();\n    win.present();\n}\n```\n\n显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错  \n如果看下 `connect_clicked` 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime  \n\n道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?  \n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量  \n\n我们可以选择为闭包添加前缀, 即添加关键字 `move`, 让被闭包捕获的变量, 其所有权转移到闭包中  \n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?  \n\n但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!  \n有没有什么办法, 让这两个闭包都能拥有num的所有权?  \n\n请看下面的正确实现, 通过引用计数的方式 :)\n- - -\n\n# 引用计数\n\n嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 ~~(GUI框架好像都是单线程的?)~~  \n那就可以使用 `std::rc::Rc` 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权  \n\n多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 `std::cell::Cell`  \n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 `Rc<Cell<i32>>`  \n\n:::tips\n**提示**  \n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell  \n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解\n:::\n\n下面是代码, 请务必记得use一下:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nlet num_clone = num.clone();\n\nbtn_inc.connect_clicked(|_| {\n    num_clone.set(num_clone.get() + 1);\n});\nbtn_dec.connect_clicked(|_| {\n    num.set(num.get() - 1);\n});\n```\n\n感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过  \n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?  \n\n让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:  \n\n- 创建一个窗口, 上面有两个按钮 `btn_inc`, `btn_dec`, 刚刚开始分别显示 `Increase` 与 `Decrease`, 会加减初始值为零的数字  \n- 按下 `btn_inc`, 则将数字加一, 随后在 `btn_dec` 上显示该数字  \n- 按下 `btn_dec`, 则将数字减一, 随后在 `btn_inc` 上显示该数字  \n\n我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全  \n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值  \n\n在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T>  \n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量  \n\n但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?  \n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作  \n\n- - -\n\n# clone!\nYeah, 这个宏的名字就叫clone: `glib::clone`, 你可以查看对应的文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n请务必注意use必须像下面这样写, 你得先 `use gtk::glib`, 随后 `use glib::clone`:  \n\n```rust\nuse std::cell::Cell;\nuse std::rc::Rc;\n\nuse glib::clone;\nuse gtk::prelude::*;   // 这里\nuse gtk::{glib, Application, ApplicationWindow, Button, Orientation};  // 这里\n```\n\n如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n使用 `clone!` 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)  \n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存  \n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回  \n\n懂了基础的原理后 ~~(我个人喜欢把读者当傻子, 因此尽量提一嘴)~~, 我们来看看上面这段代码:  \n\n- 在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建  \n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num  \n\n- 两个闭包中, 我们都创建了另一个按钮的 strong-ref  \n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec  \n\n::: tips\n**注意:**  \n`clone!`, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 `()` 值  \n详情请见文档: [glib::clone](https://docs.rs/glib/latest/glib/macro.clone.html)  \n::: \n\n\n至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:  \n循环引用导致内存泄漏!  \n\n- - -\n\n# 循环引用\nRust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在  \n~~(大佬们可能一眼就看出来哪里循环引用了...)~~\n\n贴一份刚刚的代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @strong btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@strong btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref  \n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存  \n这就是 `循环引用`\n\n由于 `循环引用`, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 `内存泄漏`  \n\n如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:  \n\n```rust\nlet num = Rc::new(Cell::new(0));\nbtn_inc.connect_clicked(clone!(@weak num, @weak btn_dec => move |_| {\n    num.set(num.get() + 1);\n    btn_dec.set_label(&num.get().to_string());\n}));\nbtn_dec.connect_clicked(clone!(@weak btn_inc => move |_| {\n    num.set(num.get() - 1);\n    btn_inc.set_label(&num.get().to_string());\n}));\n```\n\n嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 `btn_inc`/`btn_dec`  \n在闭包中, 对这两个btn都是弱引用, 当 `build_ui` 调用完毕后, 它们应该会自动drop掉 (因为作用域)  \n\n但若改成 weak-ref, `btn_inc`/`btn_dec` 不会因缺少 strong-ref 而出现问题吗?  \n答案是不会, 原因是以下两段代码  \n\n\n- 第一段:  \n\n```rust\nlet gtk_box = gtk::Box::builder()\n    .orientation(Orientation::Vertical)\n    .build();\ngtk_box.append(&btn_inc);\ngtk_box.append(&btn_dec);\n```\n\n- 第二段:  \n\n```rust\nlet win = ApplicationWindow::builder()\n    .application(app)\n    .title(\"My Gtk App\")\n    .child(&gtk_box)\n    .build();\nwin.present();\n```\n\n第一段中, `btn_inc`/`btn_dec` 的引用交给了 `append()`  \n第二段中, `gtk_box` 的引用交给了 `child()`  \n\n还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性  \n`append()`, `child()`, 都保持了对这些 Widget 的强引用, 保持了它们的活性:  \n`gtk_box` 持有对 `btn` 的 strong-ref, `win` 持有对 `gtk_box` 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着  \nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着  \n\n总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已  \n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!  \n\n本节到此结束, 要鸽一会了, 我们下节见 :)","slug":"rust/gtk4/p3-GObject-内存管理","published":1,"updated":"2022-03-30T04:01:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86hh003l6aij6aep5x9u","content":"<blockquote>\n<p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"widget\">Widget</h1>\n<p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>\n再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p>\n<p><a href=\"https://docs.gtk.org/gtk4/visual_index.html\">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p>\n<p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>\n例如 <code>Button</code>, 其继承树如下:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">GObject</span><br><span class=\"line\">└── Widget</span><br><span class=\"line\">    └── <span class=\"selector-tag\">Button</span></span><br></pre></td></tr></table></figure>\n<p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>\n举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p>\n<p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"cuo-wu-shi-xian\">错误实现</h1>\n<p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p>\n<p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>\n下面是代码, 已经讲过的概念不再重复:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建两个按钮, 设置Label</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_inc = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Increase&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_dec = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Decrease&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// `Clicked` 事件发生后的处理函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">        .orientation(Orientation::Vertical)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">    gtk_box.append(&amp;btn_dec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class=\"line\">    <span class=\"comment\">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;gtk_box)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>\n如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p>\n<p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>\n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p>\n<p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>\n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p>\n<p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>\n有没有什么办法, 让这两个闭包都能拥有num的所有权?</p>\n<p>请看下面的正确实现, 通过引用计数的方式 😃</p>\n<hr>\n<h1 id=\"yin-yong-ji-shu\">引用计数</h1>\n<p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>\n那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p>\n<p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>\n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p>\n<div class=\"tips\">\n<p><strong>提示</strong><br>\n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>\n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p>\n</div>\n<p>下面是代码, 请务必记得use一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> num_clone = num.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num_clone.set(num_clone.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>\n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p>\n<p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>\n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p>\n<p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>\n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p>\n<p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>\n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p>\n<hr>\n<h1 id=\"clone\">clone!</h1>\n<p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a><br>\n请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> glib::clone;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;   <span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class=\"comment\">// 这里</span></span><br></pre></td></tr></table></figure>\n<p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>\n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>\n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p>\n<p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>\n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p>\n</li>\n<li class=\"lvl-2\">\n<p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>\n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n<code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>\n详情请见文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a></p>\n</div>\n<p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>\n循环引用导致内存泄漏!</p>\n<hr>\n<h1 id=\"xun-huan-yin-yong\">循环引用</h1>\n<p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br>\n<s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p>\n<p>贴一份刚刚的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>\n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>\n这就是 <code>循环引用</code></p>\n<p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p>\n<p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>\n在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p>\n<p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>\n答案是不会, 原因是以下两段代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">    .orientation(Orientation::Vertical)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .child(&amp;gtk_box)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">win.present();</span><br></pre></td></tr></table></figure>\n<p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>\n第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p>\n<p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br>\n<code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br>\n<code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>\nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p>\n<p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>\n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p>\n<p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>\n","site":{"data":{}},"length":6010,"excerpt":"<blockquote>\n<p>来看看什么是 Widget, 由此出发, 创建一个双按钮加减数字的经典程序, 探讨内存管理, 防止内存泄漏</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"widget\">Widget</h1>\n<p>任何Gtk应用, 都由许多部件(Widget)组成, 比如窗口、对话框、按钮、多行文本、容器等, 因此 Widget 是个抽象概念<br>\n再比如, <code>Button(按钮)</code>, <code>Container(容器)</code>, 都属于 <code>Widget</code></p>\n<p><a href=\"https://docs.gtk.org/gtk4/visual_index.html\">Widget Gallery</a> 是Gtk提供的网站, 你可以通过浏览它, 更好地选择 <code>Widget</code></p>\n<p>我们甚至能自定义出新的Widget, 通过<code>继承/子类化</code>, 因为 Gtk 是面向对象的GUI框架<br>\n例如 <code>Button</code>, 其继承树如下:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">GObject</span><br><span class=\"line\">└── Widget</span><br><span class=\"line\">    └── <span class=\"selector-tag\">Button</span></span><br></pre></td></tr></table></figure>\n<p>GObject, 也就是 <code>gtk::glib::object::Object</code>, 是 Gtk 对象层级中的基类, 继承 GObject 可以获取其特性<br>\n举个例子, GObject 具有 <code>引用计数</code> 的特性, GObject 的子类对象也具有该特性, 当指向自身的强引用归零时, 自动释放内存</p>\n<p>接下来, 我们就来创建一个双按钮加减数字的程序, 探讨一下相关的注意事项, 这是来自官方书籍中的例子:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"cuo-wu-shi-xian\">错误实现</h1>\n<p>首先请注意, 我都说了这是错误的实现, 接下来的思考是有瑕疵, 未考虑完全的 😃</p>\n<p>为了实现这样一个程序, 我们首先要定义这两个按钮, 并且将它们显示在窗口上, 上一节讲的没忘吧?<br>\n下面是代码, 已经讲过的概念不再重复:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;Application, ApplicationWindow, Button, Orientation&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> APP_ID: &amp;<span class=\"built_in\">str</span> = <span class=\"string\">&quot;xyz.jedsek.myapp&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder().application_id(APP_ID).build();</span><br><span class=\"line\">    app.connect_activate(build_ui);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">build_ui</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建两个按钮, 设置Label</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_inc = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Increase&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> btn_dec = Button::builder()</span><br><span class=\"line\">        .label(<span class=\"string\">&quot;Decrease&quot;</span>)</span><br><span class=\"line\">        .margin_top(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_bottom(<span class=\"number\">20</span>)</span><br><span class=\"line\">        .margin_start(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .margin_end(<span class=\"number\">12</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// `Clicked` 事件发生后的处理函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 出于简单演示的目的, 这里只是单纯的加减数字而已</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">        num -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建容器, 指定其方向为垂直, 即添加元素的位置是上至下</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此, 从上往下第一个是btn_inc, 第二个是btn_dec</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">        .orientation(Orientation::Vertical)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">    gtk_box.append(&amp;btn_dec);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 窗口只能设置一个child, 因此把容器添加进去</span></span><br><span class=\"line\">    <span class=\"comment\">// 随后在容器中添加很多 widget, 达到全添加进去的目的</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">        .application(app)</span><br><span class=\"line\">        .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">        .child(&amp;gtk_box)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    win.present();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显然, 都说了是错误演示, 自然会报错, 而且这里是编译期的报错<br>\n如果看下 <code>connect_clicked</code> 的定义, 会发现它要求传入的闭包, 必须有 'static 的 lifetime</p>\n<p>道理很简单, 鬼知道用户啥时候会点按钮, 调用该回调函数, 要是闭包还活着, num这变量已经没了咋办?<br>\n因此, 闭包有个 'static 的 lifetime, 在编译期就能限制开发者写出不安全的代码, 拒绝活得没闭包久的变量</p>\n<p>我们可以选择为闭包添加前缀, 即添加关键字 <code>move</code>, 让被闭包捕获的变量, 其所有权转移到闭包中<br>\n这样子, 闭包死之前肯定可以一直访问到 num 这个变量, 毕竟所有权都进去了, 还怕它逃不成?</p>\n<p>但问题是, 这样的操作只能满足一个闭包, 我们有两个按钮, 需要写两个回调函数, 而所有权只能转移一次!<br>\n有没有什么办法, 让这两个闭包都能拥有num的所有权?</p>\n<p>请看下面的正确实现, 通过引用计数的方式 😃</p>\n<hr>\n<h1 id=\"yin-yong-ji-shu\">引用计数</h1>\n<p>嘿! 这不就是多所有权问题嘛, 还是在单线程的情况下 <s>(GUI框架好像都是单线程的?)</s><br>\n那就可以使用 <code>std::rc::Rc</code> 这个类型, 通过引用计数, 绕过编译期的检查, 实现多所有权</p>\n<p>多所有权的问题已经达成了, 但我们还需要内部可变性, 因此还需要使用 <code>std::cell::Cell</code><br>\n于是, num变量的类型, 从简单的i32, 变成了一个Wrapper类型, 即 <code>Rc&lt;Cell&lt;i32&gt;&gt;</code></p>\n<div class=\"tips\">\n<p><strong>提示</strong><br>\n对于实现了 Copy 的类型, 请直接使用 Cell, 而非 Refcell<br>\n因为 Cell 简单, 且直接使用 memcpy 来改变值, 效率高易理解</p>\n</div>\n<p>下面是代码, 请务必记得use一下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">let</span> num_clone = num.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">btn_inc.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num_clone.set(num_clone.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">btn_dec.connect_clicked(|_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>感谢强大的编译器与聪明的库作者, 他们逼迫着你, 让你考虑到了这种情况, 不然别想编译通过<br>\n其他语言中可能会轻易出现的Bug, 你无法在Rust中复现, GNOME的软件用Rust进行重写, 可能就因为这?</p>\n<p>让我们将这个初步的代码升个级, 实现本节开篇所描述的程序:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>创建一个窗口, 上面有两个按钮 <code>btn_inc</code>, <code>btn_dec</code>, 刚刚开始分别显示 <code>Increase</code> 与 <code>Decrease</code>, 会加减初始值为零的数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_inc</code>, 则将数字加一, 随后在 <code>btn_dec</code> 上显示该数字</p>\n</li>\n<li class=\"lvl-2\">\n<p>按下 <code>btn_dec</code>, 则将数字减一, 随后在 <code>btn_inc</code> 上显示该数字</p>\n</li>\n</ul>\n<p>我们已经成功实现了按下按钮后数字的加减, 并借由编译器之眼看到了危险, 利用标准库提供的类型, 让程序变得安全<br>\n要做的下一步, 就是让某按钮被按下后, 在另一个按钮上显示当前的数值</p>\n<p>在本节开篇, 提及过Button的继承树: 它继承了GObject, 因此具有引用计数的特点, 相当于Rust中的Rc<T><br>\n因此, 可以复用对付num的方法, 来对付 btn_inc 与 btn_dec, 直接clone, 然后使用被clone出来的这个变量</p>\n<p>但每次都需要手动clone, 创建新变量, 这是不是太麻烦了点?<br>\n所幸 Gtk4 的开发人员, 已经为我们提供了一个过程宏, 专门化简手动clone的繁琐操作</p>\n<hr>\n<h1 id=\"clone\">clone!</h1>\n<p>Yeah, 这个宏的名字就叫clone: <code>glib::clone</code>, 你可以查看对应的文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a><br>\n请务必注意use必须像下面这样写, 你得先 <code>use gtk::glib</code>, 随后 <code>use glib::clone</code>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::Cell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> glib::clone;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;   <span class=\"comment\">// 这里</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::&#123;glib, Application, ApplicationWindow, Button, Orientation&#125;;  <span class=\"comment\">// 这里</span></span><br></pre></td></tr></table></figure>\n<p>如何使用这个宏呢?  如下, 明白怎么写就完事了, 还是蛮简单的:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>使用 <code>clone!</code> 这个宏, 生成了变量的克隆值, 并指定该克隆到底是强引用(strong), 还是弱引用(weak)<br>\n若是strong, 那自然可以直接使用, 毕竟一个Rc类型的变量, 只有强引用数归零时才会释放内存<br>\n若是weak, 变量可能已经释放, 因此会尝试先升级到strong, 变量没死就升级成功, 不然直接从闭包返回</p>\n<p>懂了基础的原理后 <s>(我个人喜欢把读者当傻子, 因此尽量提一嘴)</s>, 我们来看看上面这段代码:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>在第一个闭包中, num 的 weak-ref, 与 btn_dec 的 strong-ref 被创建<br>\n而 num 的所有权被转移到第二个闭包中, 而该闭包的 lifetime 是 'static, 因此 weak-ref 一直可以升级并访问 num</p>\n</li>\n<li class=\"lvl-2\">\n<p>两个闭包中, 我们都创建了另一个按钮的 strong-ref<br>\n我们获取了多所有权, 就像变量 num 一样, 只有单所有权时, 被move到闭包后的变量在之后会被使用, 编译报错, 如 btn_dec</p>\n</li>\n</ul>\n<div class=\"tips\">\n<p><strong>注意:</strong><br>\n<code>clone!</code>, 在尝试升级 weak-ref 时, 若升级失败, 闭包将直接提前返回一个可选值, 若可选值未指定, 则默认返回 <code>()</code> 值<br>\n详情请见文档: <a href=\"https://docs.rs/glib/latest/glib/macro.clone.html\">glib::clone</a></p>\n</div>\n<p>至此, 已经顺利实现了功能, 但仍有个小问题, 那就是:<br>\n循环引用导致内存泄漏!</p>\n<hr>\n<h1 id=\"xun-huan-yin-yong\">循环引用</h1>\n<p>Rust只保障内存安全, 不保障内存不泄漏, 让我们看看问题所在<br>\n<s>(大佬们可能一眼就看出来哪里循环引用了…)</s></p>\n<p>贴一份刚刚的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @strong btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@strong btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>说起来也很简单, 那就是 btn_inc 产生了对 btn_dec 的 strong-ref, btn_dec 也产生了对 btn_inc 的 strong-ref<br>\n两个 strong 互相指向, 导致每个变量的强引用的计数都至少是1, 永远不会归零, 永远不会释放内存<br>\n这就是 <code>循环引用</code></p>\n<p>由于 <code>循环引用</code>, 一小块内存在整个程序运行期间, 永远得不到复用, 这就是 <code>内存泄漏</code></p>\n<p>如何解决这个问题? 非常简单, 把 strong-ref 改成 weak-ref 不就Ok了? 下面是代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num = Rc::new(Cell::new(<span class=\"number\">0</span>));</span><br><span class=\"line\">btn_inc.connect_clicked(clone!(@weak num, @weak btn_dec =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_dec.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\">btn_dec.connect_clicked(clone!(@weak btn_inc =&gt; <span class=\"keyword\">move</span> |_| &#123;</span><br><span class=\"line\">    num.set(num.get() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    btn_inc.set_label(&amp;num.get().to_string());</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n<p>嘿! num 已经被移动到第二个闭包, 因此不用担心它, 现在来看看 <code>btn_inc</code>/<code>btn_dec</code><br>\n在闭包中, 对这两个btn都是弱引用, 当 <code>build_ui</code> 调用完毕后, 它们应该会自动drop掉 (因为作用域)</p>\n<p>但若改成 weak-ref, <code>btn_inc</code>/<code>btn_dec</code> 不会因缺少 strong-ref 而出现问题吗?<br>\n答案是不会, 原因是以下两段代码</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第一段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gtk_box = gtk::<span class=\"built_in\">Box</span>::builder()</span><br><span class=\"line\">    .orientation(Orientation::Vertical)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">gtk_box.append(&amp;btn_inc);</span><br><span class=\"line\">gtk_box.append(&amp;btn_dec);</span><br></pre></td></tr></table></figure>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>第二段:</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> win = ApplicationWindow::builder()</span><br><span class=\"line\">    .application(app)</span><br><span class=\"line\">    .title(<span class=\"string\">&quot;My Gtk App&quot;</span>)</span><br><span class=\"line\">    .child(&amp;gtk_box)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\">win.present();</span><br></pre></td></tr></table></figure>\n<p>第一段中, <code>btn_inc</code>/<code>btn_dec</code> 的引用交给了 <code>append()</code><br>\n第二段中, <code>gtk_box</code> 的引用交给了 <code>child()</code></p>\n<p>还记得我们已经强调过很多遍的事实吗? GObject 具有引用计数的特点, 而这些 Widget 都是其子类, 也具有该特性<br>\n<code>append()</code>, <code>child()</code>, 都保持了对这些 Widget 的强引用, 保持了它们的活性:<br>\n<code>gtk_box</code> 持有对 <code>btn</code> 的 strong-ref, <code>win</code> 持有对 <code>gtk_box</code> 的 strong-ref, 而 win (窗口), 一直显示着, 说明win一直活着<br>\nwin活着, 导致 gtk_box 也会活着, gtk_box 活着, 导致 btn 也会活着</p>\n<p>总而言之, 对待这些 Widget 时, 只需要尽可能地保持 weak-ref, 而对待自己的数据, 则需要多考虑一下, 仅此而已<br>\n尽可能保持 weak-ref, 就能够避免循环引用而导致内存泄漏了!</p>\n<p>本节到此结束, 要鸽一会了, 我们下节见 😃</p>"},{"title":"rust-gtk4-p4: GObject-子类化","abbrlink":"posts/rust-gtk4/p4","hidden":false,"date":"2022-08-09T14:52:26.000Z","top":9696,"keywords":["Rust","GUI","Gtk4"],"_content":"> 本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget\n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# ","source":"_posts/rust/gtk4/p4-GObject-子类化.md","raw":"---\ntitle: \"rust-gtk4-p4: GObject-子类化\"\nabbrlink: posts/rust-gtk4/p4\nhidden: false\ndate: 2022-08-09 22:52:26\ntop: 9696\ntags: [Rust, GUI]\nkeywords: [Rust, GUI, Gtk4]\n---\n> 本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget\n<!-- more -->\n\n同系列传送门: [rust-gtk4](/categories/rust-gtk4)\nGNOME入坑指南: [gnome-guide](/posts/gnome/guide)\n\n# ","slug":"rust/gtk4/p4-GObject-子类化","published":1,"updated":"2022-08-09T14:52:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86hi003n6aij81h6c3rg","content":"<blockquote>\n<p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"\"></h1>\n","site":{"data":{}},"length":76,"excerpt":"<blockquote>\n<p>本节将学习如何使用子类化(Subclassing), 从而定制自己的 Widget</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-gtk4\">rust-gtk4</a><br>\nGNOME入坑指南: <a href=\"/posts/gnome/guide\">gnome-guide</a></p>\n<h1 id=\"\"></h1>"},{"title":"rust-tui-p1: 系列说明","abbrlink":"posts/rust-tui/p1","hidden":false,"date":"2022-06-19T04:59:50.000Z","top":9799,"keywords":["Terminal","终端","TUI","Rust"],"_content":"> 欢迎大家来到 Rust 的 TUI 系列\n<!-- more -->\n\n同系列传送门: [rust-tui](/categories/rust-tui)\n\n# 系列说明\n本系列会介绍一下什么是 `TUI(Text-based User Interface)`  \n当然, 还会介绍Rust中的两个crate: `tui` && `crossterm`  \n\n- - -\n# 参考资料\n1. 博客:\n- [Playing with tui-rs](https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/)\n- [Building a command-line interface in Rust](https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/)\n2. 文档:\n- [tui-rs](https://docs.rs/tui/latest/tui/)\n- [crossterm](https://docs.rs/crossterm/latest/crossterm/)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","source":"_posts/rust/tui/p1-系列说明.md","raw":"---\ntitle: \"rust-tui-p1: 系列说明\"\nabbrlink: posts/rust-tui/p1\nhidden: false\ndate: 2022-06-19 12:59:50\ntop: 9799\ntags: [Rust, TUI]\nkeywords: [Terminal, 终端, TUI, Rust]\n---\n> 欢迎大家来到 Rust 的 TUI 系列\n<!-- more -->\n\n同系列传送门: [rust-tui](/categories/rust-tui)\n\n# 系列说明\n本系列会介绍一下什么是 `TUI(Text-based User Interface)`  \n当然, 还会介绍Rust中的两个crate: `tui` && `crossterm`  \n\n- - -\n# 参考资料\n1. 博客:\n- [Playing with tui-rs](https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/)\n- [Building a command-line interface in Rust](https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/)\n2. 文档:\n- [tui-rs](https://docs.rs/tui/latest/tui/)\n- [crossterm](https://docs.rs/crossterm/latest/crossterm/)\n\n- - -\n# 欢迎骚扰\n发现错误的话, 请及时跟我联系  \n你可以通过博客侧边栏上的联系方式找到我~~  \n\n最后, 谢谢你的观看 :)","slug":"rust/tui/p1-系列说明","published":1,"updated":"2022-06-19T04:59:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagz86hi003p6aijff0ihton","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 TUI 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>同系列传送门: <a href=\"/categories/rust-tui\">rust-tui</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>\n当然, 还会介绍Rust中的两个crate: <code>tui</code> &amp;&amp; <code>crossterm</code></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>博客:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/\">Playing with tui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/\">Building a command-line interface in Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文档:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/tui/latest/tui/\">tui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/crossterm/latest/crossterm/\">crossterm</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>\n","site":{"data":{}},"length":245,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 TUI 系列</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"/categories/rust-tui\">rust-tui</a></p>\n<h1 id=\"xi-lie-shuo-ming\">系列说明</h1>\n<p>本系列会介绍一下什么是 <code>TUI(Text-based User Interface)</code><br>\n当然, 还会介绍Rust中的两个crate: <code>tui</code> &amp;&amp; <code>crossterm</code></p>\n<hr>\n<h1 id=\"can-kao-zi-liao\">参考资料</h1>\n<ol>\n<li class=\"lvl-3\">\n<p>博客:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://monkeypatch.io/blog/2021/2021-05-31-rust-tui/\">Playing with tui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://blog.logrocket.com/rust-and-tui-building-a-command-line-interface-in-rust/\">Building a command-line interface in Rust</a></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>文档:</p>\n</li>\n</ol>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/tui/latest/tui/\">tui-rs</a></p>\n</li>\n<li class=\"lvl-2\">\n<p><a href=\"https://docs.rs/crossterm/latest/crossterm/\">crossterm</a></p>\n</li>\n</ul>\n<hr>\n<h1 id=\"huan-ying-sao-rao\">欢迎骚扰</h1>\n<p>发现错误的话, 请及时跟我联系<br>\n你可以通过博客侧边栏上的联系方式找到我~~</p>\n<p>最后, 谢谢你的观看 😃</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clagz86fj00016aijdib1h5cv","tag_id":"clagz86fs00046aijf21oakvj","_id":"clagz86fz00096aijh6jr1jsc"},{"post_id":"clagz86fq00036aij5llma27l","tag_id":"clagz86fy00086aij1ujn4ddg","_id":"clagz86g5000e6aijgbmv9gyx"},{"post_id":"clagz86fu00056aijc4iicmb0","tag_id":"clagz86fy00086aij1ujn4ddg","_id":"clagz86g8000i6aij117o7qhm"},{"post_id":"clagz86fw00066aij3fqwcxzu","tag_id":"clagz86fy00086aij1ujn4ddg","_id":"clagz86gb000m6aij5v576z74"},{"post_id":"clagz86fx00076aij2tve51pa","tag_id":"clagz86fy00086aij1ujn4ddg","_id":"clagz86gc000p6aijhoyw2day"},{"post_id":"clagz86gf000t6aij3oy452ds","tag_id":"clagz86ge000r6aij4ic166u8","_id":"clagz86gh000w6aijgylf0ptt"},{"post_id":"clagz86gc000o6aij66yp4wai","tag_id":"clagz86ge000r6aij4ic166u8","_id":"clagz86gi000y6aij0ti73n1p"},{"post_id":"clagz86gg000u6aij3dd2avjj","tag_id":"clagz86ge000r6aij4ic166u8","_id":"clagz86gj00116aij5w493bb3"},{"post_id":"clagz86gd000q6aij13by565k","tag_id":"clagz86ge000r6aij4ic166u8","_id":"clagz86gk00136aijertrd4wc"},{"post_id":"clagz86ge000s6aij9frf2k7h","tag_id":"clagz86ge000r6aij4ic166u8","_id":"clagz86gm00166aij99fx8r7w"},{"post_id":"clagz86gh000x6aijbk70gs6a","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86gr001e6aij748tf1jq"},{"post_id":"clagz86gh000x6aijbk70gs6a","tag_id":"clagz86gn00196aijccot1rvm","_id":"clagz86gs001g6aijddw4etjc"},{"post_id":"clagz86gi000z6aij8uyfh2zr","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86gx001p6aijheh21zu2"},{"post_id":"clagz86gi000z6aij8uyfh2zr","tag_id":"clagz86gs001h6aij42kfh692","_id":"clagz86gx001r6aij31sr25os"},{"post_id":"clagz86gi000z6aij8uyfh2zr","tag_id":"clagz86gu001k6aijg64sc3jf","_id":"clagz86gy001t6aij8e6a8xm4"},{"post_id":"clagz86gj00126aij8rrg5sjr","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86gz001v6aijcpqmd7k9"},{"post_id":"clagz86gj00126aij8rrg5sjr","tag_id":"clagz86gn00196aijccot1rvm","_id":"clagz86gz001w6aij68pq3r1i"},{"post_id":"clagz86gk00146aij79ii8p59","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h0001z6aijf6ut9clh"},{"post_id":"clagz86gk00146aij79ii8p59","tag_id":"clagz86gn00196aijccot1rvm","_id":"clagz86h000206aijgylr09yl"},{"post_id":"clagz86gm00176aijdt8ohrv6","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h000226aij19on06ck"},{"post_id":"clagz86gm00176aijdt8ohrv6","tag_id":"clagz86gn00196aijccot1rvm","_id":"clagz86h000236aijg24qgnmu"},{"post_id":"clagz86gn00186aij34gz1s7u","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h100256aij543uhiic"},{"post_id":"clagz86gn00186aij34gz1s7u","tag_id":"clagz86gn00196aijccot1rvm","_id":"clagz86h100266aij2n1sa164"},{"post_id":"clagz86go001a6aijbjg66hln","tag_id":"clagz86h000246aij6reze5js","_id":"clagz86h2002a6aijfee15yl9"},{"post_id":"clagz86go001a6aijbjg66hln","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h2002b6aij5vutcenr"},{"post_id":"clagz86go001a6aijbjg66hln","tag_id":"clagz86h100276aije48d8mk2","_id":"clagz86h2002d6aijc7jwe1vn"},{"post_id":"clagz86go001a6aijbjg66hln","tag_id":"clagz86h100286aija90ve4fz","_id":"clagz86h2002e6aijf7tb0pvk"},{"post_id":"clagz86gp001b6aij3b1egey8","tag_id":"clagz86h000246aij6reze5js","_id":"clagz86h3002h6aije2imh5q4"},{"post_id":"clagz86gp001b6aij3b1egey8","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h3002i6aijh39ibpxf"},{"post_id":"clagz86gp001b6aij3b1egey8","tag_id":"clagz86h100276aije48d8mk2","_id":"clagz86h4002k6aij7qgt7gcs"},{"post_id":"clagz86gp001b6aij3b1egey8","tag_id":"clagz86h100286aija90ve4fz","_id":"clagz86h4002l6aijeoz55ef2"},{"post_id":"clagz86gq001d6aijbem24q4x","tag_id":"clagz86h000246aij6reze5js","_id":"clagz86h4002o6aijflffbs5l"},{"post_id":"clagz86gq001d6aijbem24q4x","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h5002p6aij2n4sc055"},{"post_id":"clagz86gq001d6aijbem24q4x","tag_id":"clagz86h100276aije48d8mk2","_id":"clagz86h5002r6aij3kxa2o8q"},{"post_id":"clagz86gq001d6aijbem24q4x","tag_id":"clagz86h100286aija90ve4fz","_id":"clagz86h5002s6aij4pgqbw6f"},{"post_id":"clagz86gr001f6aij6qogh8u1","tag_id":"clagz86h000246aij6reze5js","_id":"clagz86h6002v6aijc09ng3x9"},{"post_id":"clagz86gr001f6aij6qogh8u1","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h6002w6aija6pd6imc"},{"post_id":"clagz86gr001f6aij6qogh8u1","tag_id":"clagz86h100276aije48d8mk2","_id":"clagz86h6002y6aij12sx6wkf"},{"post_id":"clagz86gr001f6aij6qogh8u1","tag_id":"clagz86h100286aija90ve4fz","_id":"clagz86h6002z6aij3nhddpod"},{"post_id":"clagz86gs001i6aijbrcy8mjy","tag_id":"clagz86h000246aij6reze5js","_id":"clagz86h700326aijc2g68eop"},{"post_id":"clagz86gs001i6aijbrcy8mjy","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h700336aijgrom1bj1"},{"post_id":"clagz86gs001i6aijbrcy8mjy","tag_id":"clagz86h100276aije48d8mk2","_id":"clagz86h800356aije4wp98f6"},{"post_id":"clagz86gs001i6aijbrcy8mjy","tag_id":"clagz86h100286aija90ve4fz","_id":"clagz86h800366aijexul90ed"},{"post_id":"clagz86gt001j6aij8owodhd4","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h800386aij740h8pus"},{"post_id":"clagz86gt001j6aij8owodhd4","tag_id":"clagz86h700316aijgu8a8tqg","_id":"clagz86h800396aij55enhl2m"},{"post_id":"clagz86gu001l6aijdxrn7py7","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h9003b6aijbtksbbt7"},{"post_id":"clagz86gu001l6aijdxrn7py7","tag_id":"clagz86h700316aijgu8a8tqg","_id":"clagz86h9003c6aij3w3wa4tx"},{"post_id":"clagz86gv001m6aijggsm80zu","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h9003e6aijfe8i8q1w"},{"post_id":"clagz86gv001m6aijggsm80zu","tag_id":"clagz86h700316aijgu8a8tqg","_id":"clagz86h9003f6aij3n9k3k2y"},{"post_id":"clagz86gw001n6aijb19i2rfd","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h9003g6aij7htk9gt3"},{"post_id":"clagz86gw001n6aijb19i2rfd","tag_id":"clagz86h700316aijgu8a8tqg","_id":"clagz86h9003h6aijcpc4f209"},{"post_id":"clagz86gx001q6aij8r3511rt","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86h9003i6aijadhdas5d"},{"post_id":"clagz86gx001q6aij8r3511rt","tag_id":"clagz86h9003d6aijb0ry4psc","_id":"clagz86h9003j6aijg43a6i3g"},{"post_id":"clagz86hg003k6aijgp0180zh","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86hh003m6aij41889zhn"},{"post_id":"clagz86hg003k6aijgp0180zh","tag_id":"clagz86h9003d6aijb0ry4psc","_id":"clagz86hi003o6aij23xsfyw9"},{"post_id":"clagz86hh003l6aij6aep5x9u","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86hj003q6aij2s653xrj"},{"post_id":"clagz86hh003l6aij6aep5x9u","tag_id":"clagz86h9003d6aijb0ry4psc","_id":"clagz86hj003s6aij0n2y900m"},{"post_id":"clagz86hi003n6aij81h6c3rg","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86hk003t6aijfp7s7l0i"},{"post_id":"clagz86hi003n6aij81h6c3rg","tag_id":"clagz86h9003d6aijb0ry4psc","_id":"clagz86hk003u6aijelxa0k0q"},{"post_id":"clagz86hi003p6aijff0ihton","tag_id":"clagz86gl00156aij46u4cn2u","_id":"clagz86hk003v6aij9mbebycx"},{"post_id":"clagz86hi003p6aijff0ihton","tag_id":"clagz86hj003r6aij6sj16bw0","_id":"clagz86hk003w6aijexnn6n30"}],"Tag":[{"name":"GNOME","_id":"clagz86fs00046aijf21oakvj"},{"name":"高中信息技术","_id":"clagz86fy00086aij1ujn4ddg"},{"name":"Haskell","_id":"clagz86ge000r6aij4ic166u8"},{"name":"Rust","_id":"clagz86gl00156aij46u4cn2u"},{"name":"Macro","_id":"clagz86gn00196aijccot1rvm"},{"name":"Clap","_id":"clagz86gs001h6aij42kfh692"},{"name":"CLI","_id":"clagz86gu001k6aijg64sc3jf"},{"name":"GStreamer","_id":"clagz86h000246aij6reze5js"},{"name":"Video","_id":"clagz86h100276aije48d8mk2"},{"name":"Audio","_id":"clagz86h100286aija90ve4fz"},{"name":"Async","_id":"clagz86h700316aijgu8a8tqg"},{"name":"GUI","_id":"clagz86h9003d6aijb0ry4psc"},{"name":"TUI","_id":"clagz86hj003r6aij6sj16bw0"}]}}