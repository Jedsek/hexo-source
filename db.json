{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/blue.jpg","path":"images/blue.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/cursor/fireworks.js","path":"js/cursor/fireworks.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/default.yaml","path":"lib/fastclick/default.yaml","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/index.js","path":"lib/fastclick/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/package.json","path":"lib/fastclick/package.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/likely.js","path":"lib/fastclick/lib/likely.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/needmoreshare.js","path":"lib/fastclick/lib/needmoreshare.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/sharejs.js","path":"lib/fastclick/lib/sharejs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/guestbook/index.md","hash":"41fffd1e3623486ebbe587089c81174968b4b422","modified":1641011328146},{"_id":"source/categories/index.md","hash":"8847d493bd556a79b32adcdd4afaa1d094562116","modified":1641011328146},{"_id":"source/_posts/categories/manjaro.md","hash":"5c21d206c9874d679744ff1aae7f56cda87740f5","modified":1641011328146},{"_id":"source/_posts/categories/novels.md","hash":"c251674f23dda0e5fad613aeade201a238b845b8","modified":1641011328146},{"_id":"source/_posts/novels/small-bug.md","hash":"251761e01d1b61607fc7c4752edd4b0268218433","modified":1641011328146},{"_id":"source/_posts/rs-dm/rs-dm-p1-系列说明.md","hash":"349f1f2e30a439ac5deb427a37d1b746cd0970f4","modified":1641011328146},{"_id":"source/_posts/rs-dm/rs-dm-p2-从println开始.md","hash":"4fd95e3149e3cb996a8e42bbefc41bf8969a7586","modified":1641011328146},{"_id":"source/_posts/rs-dm/rs-dm-p3-声明与使用.md","hash":"39b298e548ee69d95a42eb0cbc420a735deaab66","modified":1641011328146},{"_id":"source/_posts/rs-dm/rs-dm-p4-重复.md","hash":"993eaf79b75b580864a3446634b2cc98e2956672","modified":1641011328146},{"_id":"source/_posts/rs-dm/rs-dm-p5-卫生性.md","hash":"d848e5506e99eed5119e17b5eed567bbb8a588be","modified":1641011328146},{"_id":"source/_posts/rs-gtk4/rs-gtk4-p1-系列说明.md","hash":"58ccad1b05626165c4f64b68ba463e427357a1da","modified":1641011328146},{"_id":"source/_posts/rs-gtk4/rs-gtk4-p2-创建HelloWorld的GUI窗口.md","hash":"392b218c9c56a0c4f2289185d5f8e3295d927e01","modified":1641011328146},{"_id":"source/_posts/rs-async/rs-async-p1-系列说明.md","hash":"3d19c485a44d2596f5be3372b789f3cd64eaa064","modified":1641011328146},{"_id":"source/_posts/rs-async/rs-async-p3-Future.md","hash":"429f6ef59c85a5b9a0970016b0e75c626159a349","modified":1641011328146},{"_id":"source/_posts/rs-async/rs-async-p2-异步简介.md","hash":"ad0ecac7e9d9da5cff02f65df5dea7bf2b0fedeb","modified":1641011328146},{"_id":"source/_posts/rs-async/rs-async-p4-状态的保存与变换.md","hash":"86cde32f8606bf17d7dcebdc347416482341766f","modified":1641011328146},{"_id":"source/_posts/categories/rust/rust-async.md","hash":"06dc409365c76099f521d41130c19a8d46766b60","modified":1641011328146},{"_id":"source/_posts/categories/rust/rust-decl-macro.md","hash":"b07d7997afa68faa83a738ac5af4ef068d539ac4","modified":1641011328146},{"_id":"source/_posts/categories/rust/rust-gtk4.md","hash":"308fb6ce28a1de92a45549fa3bb555cc2a2bbd6b","modified":1641011328146},{"_id":"source/_posts/manjaro/p1/manjaro-p1-安装.md","hash":"a34ccc9bd54c4d7a4933131a69a0dc52a46115eb","modified":1641011328146},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1641011328146},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1641011328146},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1641011328146},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1641011328146},{"_id":"themes/next/package.json","hash":"0fdce9f5b80e6757be715953a19c46acfa00f2e7","modified":1641011328149},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1641011328149},{"_id":"themes/next/_vendors.yml","hash":"5949493e1390c34e094aee96489db37b4c3ad2ee","modified":1641011328146},{"_id":"themes/next/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1641011328146},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1641011328146},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1641011328146},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1641011328146},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1641011328146},{"_id":"themes/next/_config.yml","hash":"000e98f1bdea9b566eef643706c8b15cc00ed489","modified":1641011328146},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1641011328146},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1641011328146},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1641011328146},{"_id":"themes/next/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1641011328146},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1641011328146},{"_id":"themes/next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1641011328146},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1641011328146},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1641011328146},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1641011328146},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1641011328146},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1641011328146},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1641011328146},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1641011328146},{"_id":"themes/next/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1641011328146},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1641011328146},{"_id":"themes/next/languages/zh-CN.yml","hash":"0431094bd3a50a169401eb3b5c904187f377cf84","modified":1641011328146},{"_id":"themes/next/layout/_layout.njk","hash":"8640dadad7505b16451887153bc118ee278ed92e","modified":1641011328146},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1641011328149},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1641011328146},{"_id":"themes/next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1641011328149},{"_id":"themes/next/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1641011328149},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1641011328149},{"_id":"themes/next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1641011328149},{"_id":"themes/next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1641011328149},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1641011328152},{"_id":"themes/next/layout/_custom/custom.njk","hash":"dbd1329789b1c458cd0e2310e67d6bd43d02e991","modified":1641011328146},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1641011328149},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1641011328149},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1641011328149},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1641011328149},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1641011328149},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1641011328149},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1641011328149},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1641011328149},{"_id":"themes/next/layout/_partials/comments.njk","hash":"c12f8a7497596441503f2541d2f746f2ee7dd594","modified":1641011328149},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1641011328149},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1641011328149},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1641011328149},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1641011328149},{"_id":"themes/next/layout/_macro/post.njk","hash":"b92d6c77d4b349c5d56fb8e0a44b578c194ef466","modified":1641011328149},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1641011328149},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1641011328149},{"_id":"themes/next/scripts/events/index.js","hash":"1ce12eda88fa5df7e76ec7b78b8463fc6618410c","modified":1641011328149},{"_id":"themes/next/scripts/filters/minify.js","hash":"0af64049db8188d5f8cc226b353e0d7909819feb","modified":1641011328149},{"_id":"themes/next/scripts/filters/post.js","hash":"ab8bb12e4d55640b1ac4252514468ce37ebcb0b0","modified":1641011328149},{"_id":"themes/next/scripts/filters/locals.js","hash":"0cd7da6755459d60779f0a7ccf311e26e184d55d","modified":1641011328149},{"_id":"themes/next/scripts/helpers/engine.js","hash":"b9785bc737470e9b8e910e7da9e8c45c2ead58fa","modified":1641011328149},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1641011328149},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1641011328149},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"9a07f2d979fc8fe0c5e07d48304187b9b03ea7ff","modified":1641011328149},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1641011328149},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1641011328149},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1641011328149},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1641011328149},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1641011328149},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1641011328149},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1641011328149},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1641011328149},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1641011328149},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1641011328149},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1641011328149},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1641011328152},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1641011328149},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1641011328149},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1641011328152},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1641011328152},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1641011328152},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1641011328152},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1641011328152},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1641011328152},{"_id":"themes/next/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1641011328152},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1641011328152},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1641011328152},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1641011328152},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1641011328152},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1641011328152},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1641011328152},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1641011328152},{"_id":"themes/next/source/css/main.styl","hash":"c19239e9c1fa114ce468b83345dcccc9e4caba3a","modified":1641011328152},{"_id":"themes/next/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":1641011328152},{"_id":"themes/next/source/css/_mixins.styl","hash":"acef5acc728f24cb657be8d7010d836b4d556b0e","modified":1641011328152},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1641011328152},{"_id":"themes/next/source/css/_colors.styl","hash":"2d464c451fac10669c0c0d25b1694c7cf85bd25e","modified":1641011328149},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1641011328152},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1641011328152},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1641011328152},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1641011328152},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1641011328152},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1641011328152},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1641011328152},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1641011328152},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1641011328152},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1641011328152},{"_id":"themes/next/source/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1641011328152},{"_id":"themes/next/source/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1641011328152},{"_id":"themes/next/source/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1641011328152},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1641011328149},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1641011328152},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1641011328149},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1641011328149},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1641011328149},{"_id":"themes/next/source/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1641011328152},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1641011328149},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1641011328149},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1641011328149},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"d82c24136bbd3443b85f07f5579845833b594684","modified":1641011328149},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1641011328149},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1641011328149},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1641011328149},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1641011328149},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1641011328149},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1641011328149},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1641011328149},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1641011328149},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1641011328149},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1641011328149},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1641011328149},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1641011328149},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1641011328149},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1641011328149},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"9167e429a459686c9fc140790124a46d677e6b15","modified":1641011328149},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"d3c094aaef1431fbc9df333529a7b1789ccd134c","modified":1641011328149},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1641011328149},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1641011328149},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1641011328149},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1641011328149},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1641011328149},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1641011328149},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1641011328149},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1641011328149},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"9a6b0ec5befb0950902e12dac0be5808d43cf1e5","modified":1641011328149},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"7384e6390067ef2a84e7310d6adb3f6104ed62e2","modified":1641011328149},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1641011328149},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1641011328149},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1641011328149},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1641011328149},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1641011328149},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"471dcbe22d0dbe043dcf25a1a1c17ca76aa9a548","modified":1641011328149},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1641011328149},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b0ced2583fdd505da3ef27a9db9c55cc7b936732","modified":1641011328149},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"4ca45b8638dbfbb3a1ec633c4e1d078dfa9086dc","modified":1641011328149},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"08dac57e15c9f06c7cf54884b045f2362595f9d2","modified":1641011328149},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"9a2e4b22a56736c5327c09d08eb219cf7608b76f","modified":1641011328149},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1641011328149},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"aa05e6b3d613a756178b8ba06832ad27499d4c14","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1641011328149},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1641011328149},{"_id":"themes/next/source/css/_custom/iconfont.css","hash":"5600c428da7bbb7c0c09d070cb52354e91be3bf7","modified":1641034119596},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1641011328152},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1641011328152},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1641011328152},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1641011328152},{"_id":"themes/next/source/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1641011328152},{"_id":"themes/next/source/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1641011328152},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1641011328152},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1641011328152},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1641011328152},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f5d2103db73a05b20f0bc2e35fdb21996ac28960","modified":1641034552052},{"_id":"themes/next/source/lib/fastclick/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1641011328152},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1641011328152},{"_id":"themes/next/source/lib/fastclick/default.yaml","hash":"63abbb8255bab5ea7a4f45de3bcf14b574d41fa6","modified":1641011328152},{"_id":"themes/next/source/lib/fastclick/package.json","hash":"6a30089543e4b639e85d857c4ca70897ae2e1432","modified":1641011328152},{"_id":"themes/next/source/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1641011328152},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1641011328152},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1641011328152},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1641011328149},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1641011328152},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1641011328152},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2e58cb90a77d3dd16e02b8949808b4b16453828c","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1641011328152},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1641011328149},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1641011328152},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1641011328152},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1641011328152},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1641011328152},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1641011328152},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1641011328152},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1641011328152},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1641011328152},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1641011328152},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1641011328152},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1641011328152},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1641011328152},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1641011328152},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1641011328152},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1641011328152},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1641011328152},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1641011328152},{"_id":"themes/next/source/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1641011328152},{"_id":"themes/next/source/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1641011328152},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1641011328149},{"_id":"themes/next/source/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1641011328152},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"b1bcc5f9357a9f8b8d6f8f285f073aaf3157f9db","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"c8e95e8ac4cbdba01cb93e9e0569b45603e41bc6","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"ea351936d71e0b6259febac3d7d56d1be6927bf9","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"b1c99f34d65f994c89940bb7cdff4e36779ceb5d","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1641011328149},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"650ed4ad6df1b6ff04647e7b6d568304e4d3ed2e","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1641011328149},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"0b3e2696eca39781c3524b2c5a2555ebc616e6e8","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1641011328149},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"9b34143aec49e390e18f380026a45096f7477722","modified":1641011328152},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1641011328152},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1641011328152},{"_id":"themes/next/source/images/blue.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1641011328152},{"_id":"public/atom.xml","hash":"a3aa7ec7d9673a146a8db00b0c0a806d75a16d4d","modified":1641029960336},{"_id":"public/search.xml","hash":"69711ca4add64d401b09ee50ab99b34640ba46f0","modified":1641029960336},{"_id":"public/guestbook/index.html","hash":"8ea8a3ee1c977f4af1f0869d85ae4873812ae571","modified":1641029960336},{"_id":"public/categories/index.html","hash":"e4a5f41a64187fee431e069e0fb4bbfae2e0c6da","modified":1641029960336},{"_id":"public/categories/novels.html","hash":"7171f0ec84e21d72eece1f1846e8fcbec6a16265","modified":1641029960336},{"_id":"public/categories/manjaro.html","hash":"69b7c94b746ccc83069ee3249cf68ccc0ea63f2d","modified":1641029960336},{"_id":"public/categories/rust-gtk4.html","hash":"efb51e65d453c468b9ab1bc1abae85b7ec81f9b2","modified":1641029960336},{"_id":"public/categories/rust-decl-macro.html","hash":"61a547d92ec5fd0cc2017f27fb47f62a32d0ceef","modified":1641029960336},{"_id":"public/categories/rust-async.html","hash":"97d414d3d356862ec07b2c3877319802a13600bc","modified":1641029960336},{"_id":"public/archives/page/2/index.html","hash":"82c33af9667f04b959ef6a729e551df5563fc2fe","modified":1641029960336},{"_id":"public/archives/2021/page/2/index.html","hash":"168c6be09d43d82efed3c9a027bd1e88ef76b349","modified":1641029960336},{"_id":"public/archives/2021/10/index.html","hash":"70e73494f66ee8e4aaa817c86b182c46e883e893","modified":1641029960336},{"_id":"public/archives/2021/11/index.html","hash":"1f4f555747a06007734841afc65492d6b958742e","modified":1641029960336},{"_id":"public/archives/2021/12/index.html","hash":"1cd5a4566e1c4f23815552cb84b00b4b248a14e6","modified":1641029960336},{"_id":"public/tags/novel/index.html","hash":"82e94fa744a31f906710d36d0bb1eb9fab032e00","modified":1641029960336},{"_id":"public/tags/rust/page/2/index.html","hash":"f270027c5e5fcc568080a5b5acdfb5dc95676e2e","modified":1641029960336},{"_id":"public/tags/gui/index.html","hash":"7d668bbd7dfac3ab44807c81485441a39f75ca8c","modified":1641029960336},{"_id":"public/tags/manjaro/index.html","hash":"216ebee609c39cf7ac4ffacc1e8d9b0834ed8848","modified":1641029960336},{"_id":"public/posts/manjaro-p1.html","hash":"cb5ce8d28912007d1d40d8279482de8fb684a433","modified":1641029960336},{"_id":"public/posts/rs-gtk4-p2.html","hash":"53c68a8adf92a0e4ffa4197ef07b7e4b764aac3a","modified":1641029960336},{"_id":"public/posts/novel-small-bug.html","hash":"87f0eb5111314a9f5e674c8978630ebe325807d8","modified":1641029960336},{"_id":"public/posts/rs-gtk4-p1.html","hash":"c74f519a6cc3ab4d7a1ee78423028c56d31b9fdb","modified":1641029960336},{"_id":"public/posts/rs-decl-macro-p5.html","hash":"9a76736dbb301e62f811ac2ecf2b3851d8cf4603","modified":1641029960336},{"_id":"public/posts/rs-decl-macro-p4.html","hash":"e07deacadf1559c1c8463fc432ff8c690698d82d","modified":1641029960336},{"_id":"public/posts/rs-decl-macro-p3.html","hash":"4736128adb98a5426bdb33f45aae0bc87a11ebfb","modified":1641029960336},{"_id":"public/posts/rs-decl-macro-p2.html","hash":"4a0d4d8efae48719b6c21c72d2c6ea526a07cc62","modified":1641029960336},{"_id":"public/posts/rs-decl-macro-p1.html","hash":"9b59d8067d02a3df16398941c2180b18680e74f3","modified":1641029960336},{"_id":"public/posts/rs-async-p4.html","hash":"5e5597f4683ee62c2acb793afff584636d3d1a94","modified":1641029960336},{"_id":"public/posts/rs-async-p3.html","hash":"6b31ad16bfe07bba553cabd1b9035872768d79ef","modified":1641029960336},{"_id":"public/posts/rs-async-p2.html","hash":"944890943d5e2734924535b31da0f7ca9e802c3f","modified":1641029960336},{"_id":"public/posts/rs-async-p1.html","hash":"15caf78201a963957b40c125493f3e44e7c135e7","modified":1641029960336},{"_id":"public/archives/index.html","hash":"a60ea73ec8c822d29f1c1c5b29e7e52cb8c8ad2f","modified":1641029960336},{"_id":"public/archives/2021/index.html","hash":"14733c74c19a7491849727ed17b3bb8abd27e9e5","modified":1641029960336},{"_id":"public/archives/2021/09/index.html","hash":"2e5a863eddee8ecea8661f1b76aaa141f464e994","modified":1641029960336},{"_id":"public/page/2/index.html","hash":"53ce18c6ddef2950a6e55d45bf949136a2de3506","modified":1641029960336},{"_id":"public/index.html","hash":"8e93d8ef96559796bd515033ea7b5c3c0716c86c","modified":1641029960336},{"_id":"public/tags/rust/index.html","hash":"8b0e75f63983efaccd340f8ffd17182e9946ac04","modified":1641029960336},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1641029960336},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1641029960336},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1641029960336},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1641029960336},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1641029960336},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1641029960336},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1641029960336},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1641029960336},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1641029960336},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1641029960336},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1641029960336},{"_id":"public/js/pjax.js","hash":"0523cb1946907687c53999e2ce7cfe1831da6476","modified":1641029960336},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1641029960336},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1641029960336},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1641029960336},{"_id":"public/js/cursor/fireworks.js","hash":"e55c0abff5d0c1d48fe4eebb04cc703ec1b090e1","modified":1641029960336},{"_id":"public/js/utils.js","hash":"370d417d76a897f09c11a49d2c8c8b723921bd9a","modified":1641029960336},{"_id":"public/js/schemes/muse.js","hash":"62f4638674c92dfb72454fee38751d0227d3d225","modified":1641029960336},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1641029960336},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1641029960336},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1641029960336},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1641029960336},{"_id":"public/lib/fastclick/index.js","hash":"762eb5ff1acef8c38f04d2ca545d790586e52a79","modified":1641029960336},{"_id":"public/lib/fastclick/default.json","hash":"5427a63d19b4b034a3a74e9ee6fcb8ae11b230df","modified":1641029960336},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1641029960336},{"_id":"public/lib/fastclick/package.json","hash":"1d7632f6e738677af1a67398ce09ab93e175740f","modified":1641029960336},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1641029960336},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1641029960336},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1641029960336},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1641029960336},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1641029960336},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1641029960336},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1641029960336},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1641029960336},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1641029960336},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1641029960336},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1641029960336},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1641029960336},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1641029960336},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1641029960336},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1641029960336},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1641029960336},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1641029960336},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1641029960336},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1641029960336},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1641029960336},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1641029960336},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1641029960336},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1641029960336},{"_id":"public/lib/fastclick/lib/likely.js","hash":"abc3fb2c04aee2233c98859ddab454e99607e5ee","modified":1641029960336},{"_id":"public/lib/fastclick/lib/sharejs.js","hash":"efc21fb57ed70857cf06748e008e8ac0f3cbe5f0","modified":1641029960336},{"_id":"public/lib/fastclick/lib/needmoreshare.js","hash":"598f95e9ee0a5308869c6fe742d3d766e55fe6c9","modified":1641029960336},{"_id":"public/css/main.css","hash":"899df4a517794d5d24c2234ec384aff7e11d3f2a","modified":1641029960336},{"_id":"public/images/blue.jpg","hash":"3bdb5b112cb443cac55cfc2872b83f8d5b4b27ac","modified":1641029960336}],"Category":[],"Data":[],"Page":[{"title":"guestbook","date":"2021-11-06T12:38:45.000Z","comments":1,"_content":"这是一个留言板~~~  \n欢迎留言, 欢迎纠错与互相探讨  \n~~(别忘了我是个大菜鸡, 错了别骂我呜呜呜呜呜)~~  \n\n对了, 留言前得先登录Github才行哦  \n匿名用户的功能实在懒得搞了  ","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2021-11-06 20:38:45\ncomments: true\n---\n这是一个留言板~~~  \n欢迎留言, 欢迎纠错与互相探讨  \n~~(别忘了我是个大菜鸡, 错了别骂我呜呜呜呜呜)~~  \n\n对了, 留言前得先登录Github才行哦  \n匿名用户的功能实在懒得搞了  ","updated":"2021-11-06T12:38:45.000Z","path":"guestbook/index.html","layout":"page","_id":"ckxvmv9me0000jaqyb1ba1tn1","content":"<p>这是一个留言板~~~<br>欢迎留言, 欢迎纠错与互相探讨<br><del>(别忘了我是个大菜鸡, 错了别骂我呜呜呜呜呜)</del>  </p>\n<p>对了, 留言前得先登录Github才行哦<br>匿名用户的功能实在懒得搞了  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一个留言板~~~<br>欢迎留言, 欢迎纠错与互相探讨<br><del>(别忘了我是个大菜鸡, 错了别骂我呜呜呜呜呜)</del>  </p>\n<p>对了, 留言前得先登录Github才行哦<br>匿名用户的功能实在懒得搞了  </p>\n"},{"title":"分类","comments":0,"abbrlink":"categories","hidden":true,"date":"2021-09-12T06:59:09.000Z","_content":"- [rust-async](https://jedsek.github.io/categories/rust-async)\n- [rust-decl-macro](https://jedsek.github.io/categories/rust-decl-macro)\n- [rust-gtk4](https://jedsek.github.io/categories/rust-gtk4)\n- [manjaro](https://jedsek.github.io/categories/manjaro)\n- [novels](https://jedsek.github.io/categories/novels)","source":"categories/index.md","raw":"---\ntitle: 分类\ncomments: false\nabbrlink: categories\nhidden: true\ndate: 2021-09-12 14:59:09\n---\n- [rust-async](https://jedsek.github.io/categories/rust-async)\n- [rust-decl-macro](https://jedsek.github.io/categories/rust-decl-macro)\n- [rust-gtk4](https://jedsek.github.io/categories/rust-gtk4)\n- [manjaro](https://jedsek.github.io/categories/manjaro)\n- [novels](https://jedsek.github.io/categories/novels)","updated":"2021-09-12T06:59:09.000Z","path":"categories/index.html","layout":"page","_id":"ckxvmv9mj0002jaqy7ykr4wpz","content":"<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-async\">rust-async</a></li>\n<li><a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro</a></li>\n<li><a href=\"https://jedsek.github.io/categories/rust-gtk4\">rust-gtk4</a></li>\n<li><a href=\"https://jedsek.github.io/categories/manjaro\">manjaro</a></li>\n<li><a href=\"https://jedsek.github.io/categories/novels\">novels</a></li>\n</ul>\n<!-- flag of hidden posts -->","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-async\">rust-async</a></li>\n<li><a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro</a></li>\n<li><a href=\"https://jedsek.github.io/categories/rust-gtk4\">rust-gtk4</a></li>\n<li><a href=\"https://jedsek.github.io/categories/manjaro\">manjaro</a></li>\n<li><a href=\"https://jedsek.github.io/categories/novels\">novels</a></li>\n</ul>\n","sitemap":false}],"Post":[{"title":"manjaro","comments":0,"abbrlink":"categories/manjaro","hidden":true,"date":"2021-12-04T14:45:22.000Z","top":null,"keywords":null,"_content":"","source":"_posts/categories/manjaro.md","raw":"---\ntitle: manjaro\ncomments: false\nabbrlink: categories/manjaro\nhidden: true\ndate: 2021-12-04 22:45:22\ntop:\ntags:\ncategories:\nkeywords:\n---\n","slug":"categories/manjaro","published":1,"updated":"2021-12-04T14:45:22.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mg0001jaqy8o959q82","content":"<!-- flag of hidden posts -->","site":{"data":{}},"excerpt":"","more":"","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Dec 04 2021 22:45:22 GMT+0800 (中国标准时间)","title":"manjaro","path":"categories/manjaro.html","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2021-12-04T14:45:22.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-12-04T14:45:22.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"novels","comments":0,"abbrlink":"categories/novels","hidden":true,"date":"2021-12-04T14:47:31.000Z","top":null,"keywords":null,"_content":"- [渺小之虫](http://jedsek.github.io/posts/novel-small-bug)\n","source":"_posts/categories/novels.md","raw":"---\ntitle: novels\ncomments: false\nabbrlink: categories/novels\nhidden: true\ndate: 2021-12-04 22:47:31\ntop:\ntags:\ncategories:\nkeywords:\n---\n- [渺小之虫](http://jedsek.github.io/posts/novel-small-bug)\n","slug":"categories/novels","published":1,"updated":"2021-12-04T14:47:31.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mk0003jaqy1sl3b351","content":"<ul>\n<li><a href=\"http://jedsek.github.io/posts/novel-small-bug\">渺小之虫</a></li>\n</ul>\n<!-- flag of hidden posts -->","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"http://jedsek.github.io/posts/novel-small-bug\">渺小之虫</a></li>\n</ul>\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Dec 04 2021 22:47:31 GMT+0800 (中国标准时间)","title":"novels","path":"categories/novels.html","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2021-12-04T14:47:31.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-12-04T14:47:31.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"渺小之虫","comments":0,"date":"2021-11-27T16:22:04.000Z","abbrlink":"posts/novel-small-bug","top":null,"keywords":"novel","_content":"\n# 序\n神, 亦或是那未知的伟大存在, 开启了这方世界的倒计时  \n本自认属于伟大文明的虫子们, 终是在夜幕将至时, 认清了自身的渺小  \n\n渺小的虫子, 实在太过渺小, 生死也不过一瞬  \n<!-- more -->\n萨满们位于昏暗中跳神做法, 以低沉声调, 发出古怪音节, ","source":"_posts/novels/small-bug.md","raw":"---\ntitle: 渺小之虫\ncomments: false\ndate: 2021-11-28 00:22:04\nabbrlink: posts/novel-small-bug\ntop: \ntags: novel\nkeywords: novel\n---\n\n# 序\n神, 亦或是那未知的伟大存在, 开启了这方世界的倒计时  \n本自认属于伟大文明的虫子们, 终是在夜幕将至时, 认清了自身的渺小  \n\n渺小的虫子, 实在太过渺小, 生死也不过一瞬  \n<!-- more -->\n萨满们位于昏暗中跳神做法, 以低沉声调, 发出古怪音节, ","slug":"novels/small-bug","published":1,"updated":"2021-11-27T16:22:04.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9ml0004jaqygxpoa3cw","content":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>神, 亦或是那未知的伟大存在, 开启了这方世界的倒计时<br>本自认属于伟大文明的虫子们, 终是在夜幕将至时, 认清了自身的渺小  </p>\n<p>渺小的虫子, 实在太过渺小, 生死也不过一瞬  </p>\n<span id=\"more\"></span>\n<p>萨满们位于昏暗中跳神做法, 以低沉声调, 发出古怪音节, </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>神, 亦或是那未知的伟大存在, 开启了这方世界的倒计时<br>本自认属于伟大文明的虫子们, 终是在夜幕将至时, 认清了自身的渺小  </p>\n<p>渺小的虫子, 实在太过渺小, 生死也不过一瞬  </p>","more":"<p>萨满们位于昏暗中跳神做法, 以低沉声调, 发出古怪音节, </p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Nov 28 2021 00:22:04 GMT+0800 (中国标准时间)","title":"渺小之虫","path":"posts/novel-small-bug.html","eyeCatchImage":null,"excerpt":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>神, 亦或是那未知的伟大存在, 开启了这方世界的倒计时<br>本自认属于伟大文明的虫子们, 终是在夜幕将至时, 认清了自身的渺小  </p>\n<p>渺小的虫子, 实在太过渺小, 生死也不过一瞬  </p>","date":{"_isAMomentObject":true,"_i":"2021-11-27T16:22:04.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-11-27T16:22:04.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["novel"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-dm-p2-从println开始","comments":0,"abbrlink":"posts/rs-decl-macro-p2","date":"2021-09-19T14:50:27.000Z","top":9898,"keywords":["macro","声明宏","Rust"],"_content":"> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 开篇  \n大家应该都用过一个宏  \n它就是`println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑:  \n为什么后面要跟个感叹号?  \n为什么括号里面的参数可以不一样?  \n\n亲爱的TRPl在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 的时候  \n告诉过你: 名字后加个感叹号,就是个`宏(macro)`  \n注: macro 的读音: [ˈmækroʊ]\n\n可是macro到底是啥?  \n~~(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)~~  \n\n- - -\n# 查看定义  \n让我们按住Ctrl,鼠标左键点击println!  \n(以 VSCode 为例)  \n\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现根本看不懂这一大堆鬼画符......  \n但看不懂根本没关系,后面几节过后,你肯定懂了  \n现在只需明白的,是大致结构:  \n\n1. 我们将`macro_rules!`放在`println`前面,说明后者是个宏 \n(`macro_rules!`当作特定语法即可)  \n\n2. 之后用花括号包起来,里面是该宏的具体定义  \n\n问题来了,关键是`println`的具体定义  \n花括号内,到底在讲述着啥?  \n\n请容许我来帮你粗暴地类比一下`match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro有点像是match,能根据不同参数,展开不同的代码  \n在macro最外层的花括号中,有许多匹配分支  \n\nmatch表达式,称呼每个匹配分支为`arm`  \n逗号分割它们彼此,或者不用逗号而用花括号包裹来分割  \n最后一个arm可省略逗号  \n\nmacro,则称呼每个匹配分支为`rule`(明白为什么使用`macro_rules!`创建宏了吗)  \n必须使用花括号包裹,使用分号分隔彼此  \n最后一个rule可省略分号  \n\n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可  \n现在再来看看 `println`,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\n\nfn main() {}\n```\n\n2. 然后创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {}\n```\n\n3. 调用时, 要做到: 宏名+感叹号+传参:  \n(传入的参数,若与任何rule都不匹配,则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知  \n相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  ","source":"_posts/rs-dm/rs-dm-p2-从println开始.md","raw":"---\ntitle: rs-dm-p2-从println开始\ncomments: false\nabbrlink: posts/rs-decl-macro-p2\ndate: 2021-09-19 22:50:27\ntop: 9898\ntags: rust\nkeywords: [macro, 声明宏, Rust]\n---\n> 我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  \n<!-- more -->\n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 开篇  \n大家应该都用过一个宏  \n它就是`println!`:  \n\n```rust \nfn main() {\n\tlet s = \"Rush B!!!!\";\n\tprintln!(\"{}\",s);\n\tprintln!()\n}\n```\n\n当你刚刚接触它的时候, 可能会感到些许疑惑:  \n为什么后面要跟个感叹号?  \n为什么括号里面的参数可以不一样?  \n\n亲爱的TRPl在教你写 [Hello World!](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F) 的时候  \n告诉过你: 名字后加个感叹号,就是个`宏(macro)`  \n注: macro 的读音: [ˈmækroʊ]\n\n可是macro到底是啥?  \n~~(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)~~  \n\n- - -\n# 查看定义  \n让我们按住Ctrl,鼠标左键点击println!  \n(以 VSCode 为例)  \n\n\n```rust\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n\n// 你可能会看到, 在 println! 的上面\n// 有着类似下面的玩意:  \n// \n// #[macro_export]\n// #[stable(feature = \"rust1\", since = \"1.0.0\")]\n// #[allow_internal_unstable(print_internals, format_args_nl)]\n// \n// 这些也属于宏, 不过是 `过程宏`\n// 而该系列要讲的是 `声明宏`, 因此略过\n```\n\n你悲催地发现根本看不懂这一大堆鬼画符......  \n但看不懂根本没关系,后面几节过后,你肯定懂了  \n现在只需明白的,是大致结构:  \n\n1. 我们将`macro_rules!`放在`println`前面,说明后者是个宏 \n(`macro_rules!`当作特定语法即可)  \n\n2. 之后用花括号包起来,里面是该宏的具体定义  \n\n问题来了,关键是`println`的具体定义  \n花括号内,到底在讲述着啥?  \n\n请容许我来帮你粗暴地类比一下`match表达式 && macro`:  \n\n```rust\n// match\nmatch num {\n\t1 => \"1\".repeat(10),\n\t2 => {\n\t\t\"2\".repeat(10)\n\t}\n\t_ => panic!(\"Fuck you! I just want the  numer 1 or 2\")\n}\n\n// macro\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n```\n\nmacro有点像是match,能根据不同参数,展开不同的代码  \n在macro最外层的花括号中,有许多匹配分支  \n\nmatch表达式,称呼每个匹配分支为`arm`  \n逗号分割它们彼此,或者不用逗号而用花括号包裹来分割  \n最后一个arm可省略逗号  \n\nmacro,则称呼每个匹配分支为`rule`(明白为什么使用`macro_rules!`创建宏了吗)  \n必须使用花括号包裹,使用分号分隔彼此  \n最后一个rule可省略分号  \n\n你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可  \n现在再来看看 `println`,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  \n\n```rust\n// 定义部分\nmacro_rules! println {\n\t// 空参时, 只输出换行符\n    () => ($crate::print!(\"\\n\"));\n\n\t// 有参时, 输出参数, 并换行\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n// 使用部分\nlet s = \"xxx\";\nprintln!(\"{}\",s);\nprintln!();\n```\n- - -\n# 总结  \n\n1. 创建一个假设叫xxx的macro,花括号包裹具体定义:  \n\n```rust\nmacro_rules! xxx {}\n\nfn main() {}\n```\n\n2. 然后创建两个匹配分支:  \n(匹配空参 => 不做任何事)  \n(匹配123 => 打印123)  \n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {}\n```\n\n3. 调用时, 要做到: 宏名+感叹号+传参:  \n(传入的参数,若与任何rule都不匹配,则报错)\n\n```rust\nmacro_rules! xxx {\n\t() => {};\n\t(123) => {println!(\"123\")}\n}\n\nfn main() {\n\txxx!();      // Nothing\n\txxx!(123);   // println!(\"123\");\n}\n```\n\n本节只是为了留个大致印象, 建立一个整体结构的认知  \n相信你肯定还有一些疑惑, 后面会比较系统地讲解  \n咱们下期见  ","slug":"rs-dm/rs-dm-p2-从println开始","published":1,"updated":"2021-09-19T14:50:27.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mn0005jaqyal1mfjjm","content":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  </p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>大家应该都用过一个宏<br>它就是<code>println!</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>为什么后面要跟个感叹号?<br>为什么括号里面的参数可以不一样?  </p>\n<p>亲爱的TRPl在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 的时候<br>告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>注: macro 的读音: [ˈmækroʊ]</p>\n<p>可是macro到底是啥?<br><del>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</del>  </p>\n<hr>\n<h1 id=\"查看定义\"><a href=\"#查看定义\" class=\"headerlink\" title=\"查看定义\"></a>查看定义</h1><p>让我们按住Ctrl,鼠标左键点击println!<br>(以 VSCode 为例)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n\n<p>你悲催地发现根本看不懂这一大堆鬼画符……<br>但看不懂根本没关系,后面几节过后,你肯定懂了<br>现在只需明白的,是大致结构:  </p>\n<ol>\n<li><p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏<br>(<code>macro_rules!</code>当作特定语法即可)  </p>\n</li>\n<li><p>之后用花括号包起来,里面是该宏的具体定义  </p>\n</li>\n</ol>\n<p>问题来了,关键是<code>println</code>的具体定义<br>花括号内,到底在讲述着啥?  </p>\n<p>请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>macro有点像是match,能根据不同参数,展开不同的代码<br>在macro最外层的花括号中,有许多匹配分支  </p>\n<p>match表达式,称呼每个匹配分支为<code>arm</code><br>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割<br>最后一个arm可省略逗号  </p>\n<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)<br>必须使用花括号包裹,使用分号分隔彼此<br>最后一个rule可省略分号  </p>\n<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>创建一个假设叫xxx的macro,花括号包裹具体定义:  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>然后创建两个匹配分支:<br>(匹配空参 =&gt; 不做任何事)<br>(匹配123 =&gt; 打印123)  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>调用时, 要做到: 宏名+感叹号+传参:<br>(传入的参数,若与任何rule都不匹配,则报错)</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>咱们下期见  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  </p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>大家应该都用过一个宏<br>它就是<code>println!</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">&quot;Rush B!!!!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当你刚刚接触它的时候, 可能会感到些许疑惑:<br>为什么后面要跟个感叹号?<br>为什么括号里面的参数可以不一样?  </p>\n<p>亲爱的TRPl在教你写 <a href=\"https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F\">Hello World!</a> 的时候<br>告诉过你: 名字后加个感叹号,就是个<code>宏(macro)</code><br>注: macro 的读音: [ˈmækroʊ]</p>\n<p>可是macro到底是啥?<br><del>(算了算了,反正只要会用就行了,于是你点击了该网页的叉叉)</del>  </p>\n<hr>\n<h1 id=\"查看定义\"><a href=\"#查看定义\" class=\"headerlink\" title=\"查看定义\"></a>查看定义</h1><p>让我们按住Ctrl,鼠标左键点击println!<br>(以 VSCode 为例)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你可能会看到, 在 println! 的上面</span></span><br><span class=\"line\"><span class=\"comment\">// 有着类似下面的玩意:  </span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// #[macro_export]</span></span><br><span class=\"line\"><span class=\"comment\">// #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]</span></span><br><span class=\"line\"><span class=\"comment\">// #[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 这些也属于宏, 不过是 `过程宏`</span></span><br><span class=\"line\"><span class=\"comment\">// 而该系列要讲的是 `声明宏`, 因此略过</span></span><br></pre></td></tr></table></figure>\n\n<p>你悲催地发现根本看不懂这一大堆鬼画符……<br>但看不懂根本没关系,后面几节过后,你肯定懂了<br>现在只需明白的,是大致结构:  </p>\n<ol>\n<li><p>我们将<code>macro_rules!</code>放在<code>println</code>前面,说明后者是个宏<br>(<code>macro_rules!</code>当作特定语法即可)  </p>\n</li>\n<li><p>之后用花括号包起来,里面是该宏的具体定义  </p>\n</li>\n</ol>\n<p>问题来了,关键是<code>println</code>的具体定义<br>花括号内,到底在讲述着啥?  </p>\n<p>请容许我来帮你粗暴地类比一下<code>match表达式 &amp;&amp; macro</code>:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// match</span></span><br><span class=\"line\"><span class=\"keyword\">match</span> num &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;1&quot;</span>.repeat(<span class=\"number\">10</span>),</span><br><span class=\"line\">    <span class=\"number\">2</span> =&gt; &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;2&quot;</span>.repeat(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _ =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;Fuck you! I just want the  numer 1 or 2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// macro</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>macro有点像是match,能根据不同参数,展开不同的代码<br>在macro最外层的花括号中,有许多匹配分支  </p>\n<p>match表达式,称呼每个匹配分支为<code>arm</code><br>逗号分割它们彼此,或者不用逗号而用花括号包裹来分割<br>最后一个arm可省略逗号  </p>\n<p>macro,则称呼每个匹配分支为<code>rule</code>(明白为什么使用<code>macro_rules!</code>创建宏了吗)<br>必须使用花括号包裹,使用分号分隔彼此<br>最后一个rule可省略分号  </p>\n<p>你并不需搞清所有细节,现在先不用试图记忆具体语法,有印象即可<br>现在再来看看 <code>println</code>,是不是稍微有点感觉了(看不懂的地方依然直接跳即可):  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义部分</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 空参时, 只输出换行符</span></span><br><span class=\"line\">    () =&gt; ($crate::<span class=\"built_in\">print!</span>(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 有参时, 输出参数, 并换行</span></span><br><span class=\"line\">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class=\"line\">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>();</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>创建一个假设叫xxx的macro,花括号包裹具体定义:  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>然后创建两个匹配分支:<br>(匹配空参 =&gt; 不做任何事)<br>(匹配123 =&gt; 打印123)  </li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>调用时, 要做到: 宏名+感叹号+传参:<br>(传入的参数,若与任何rule都不匹配,则报错)</li>\n</ol>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> xxx &#123;</span><br><span class=\"line\">    () =&gt; &#123;&#125;;</span><br><span class=\"line\">    (<span class=\"number\">123</span>) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;123&quot;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    xxx!();      <span class=\"comment\">// Nothing</span></span><br><span class=\"line\">    xxx!(<span class=\"number\">123</span>);   <span class=\"comment\">// println!(&quot;123&quot;);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本节只是为了留个大致印象, 建立一个整体结构的认知<br>相信你肯定还有一些疑惑, 后面会比较系统地讲解<br>咱们下期见  </p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Sep 19 2021 22:50:27 GMT+0800 (中国标准时间)","title":"rs-dm-p2-从println开始","path":"posts/rs-decl-macro-p2.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>我们从熟悉的 println! 开始, 了解下声明宏的大致结构吧  </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-19T14:50:27.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-19T14:50:27.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-dm-p1-系列说明","comments":0,"abbrlink":"posts/rs-decl-macro-p1","date":"2021-09-19T13:51:27.000Z","top":9899,"keywords":["macro","声明宏","Rust"],"_content":"> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n<!-- more -->\n# 系列说明:  \n**注: 请注意是声明宏**\n传送门如下:  \n- [博客: Rust声明宏系列](https://jedsek.github.io/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n`博客`的更新速度,快于`视频`  \n`博客`若经过重写,则会抽时间更新`视频`  \n\n此系列,我们将学习Rust中的`声明宏`  \n- - - \n# 参考资料\n1. 书籍\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. 文章  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n\n- - -\n# 欢迎骚扰  \n1. 发现错误的话, 请及时跟我联系  \n2. 可以通过博客侧边栏上的联系方式找到我  \n3. 欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","source":"_posts/rs-dm/rs-dm-p1-系列说明.md","raw":"---\ntitle: rs-dm-p1-系列说明\ncomments: false\nabbrlink: posts/rs-decl-macro-p1\ndate: 2021-09-19 21:51:27\ntop: 9899\ntags: rust\nkeywords: [macro, 声明宏, Rust]\n---\n> 欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  \n<!-- more -->\n# 系列说明:  \n**注: 请注意是声明宏**\n传送门如下:  \n- [博客: Rust声明宏系列](https://jedsek.github.io/categories/rust-decl-macro) \n- [B站视频: Rust编程语言-声明宏](https://www.bilibili.com/video/BV1Wv411W7FH?p=1)\n\n`博客`的更新速度,快于`视频`  \n`博客`若经过重写,则会抽时间更新`视频`  \n\n此系列,我们将学习Rust中的`声明宏`  \n- - - \n# 参考资料\n1. 书籍\n- [宏小册](https://zjp-cn.github.io/tlborm/)  \n- [RustPrimer](https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html)\n- [TRPL](https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html)\n2. 文章  \n- [【译】Rust宏: 教程与示例 (一)](https://zhuanlan.zhihu.com/p/353421021)\n- [【译】Rust宏: 教程与示例 (二)](https://zhuanlan.zhihu.com/p/356427780)\n\n- - -\n# 欢迎骚扰  \n1. 发现错误的话, 请及时跟我联系  \n2. 可以通过博客侧边栏上的联系方式找到我  \n3. 欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n","slug":"rs-dm/rs-dm-p1-系列说明","published":1,"updated":"2021-09-19T13:51:27.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mq0007jaqyao733se9","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  </p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"系列说明\"><a href=\"#系列说明\" class=\"headerlink\" title=\"系列说明:\"></a>系列说明:</h1><p><strong>注: 请注意是声明宏</strong><br>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-decl-macro\">博客: Rust声明宏系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<p><code>博客</code>的更新速度,快于<code>视频</code><br><code>博客</code>若经过重写,则会抽时间更新<code>视频</code>  </p>\n<p>此系列,我们将学习Rust中的<code>声明宏</code>  </p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li>书籍</li>\n</ol>\n<ul>\n<li><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a>  </li>\n<li><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></li>\n<li><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></li>\n</ul>\n<ol start=\"2\">\n<li>文章  </li>\n</ol>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><ol>\n<li>发现错误的话, 请及时跟我联系  </li>\n<li>可以通过博客侧边栏上的联系方式找到我  </li>\n<li>欢迎在留言版中留言, 本人会定期查看  </li>\n</ol>\n<p>最后, 谢谢你的观看 :)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  </p>\n</blockquote>","more":"<h1 id=\"系列说明\"><a href=\"#系列说明\" class=\"headerlink\" title=\"系列说明:\"></a>系列说明:</h1><p><strong>注: 请注意是声明宏</strong><br>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-decl-macro\">博客: Rust声明宏系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1Wv411W7FH?p=1\">B站视频: Rust编程语言-声明宏</a></li>\n</ul>\n<p><code>博客</code>的更新速度,快于<code>视频</code><br><code>博客</code>若经过重写,则会抽时间更新<code>视频</code>  </p>\n<p>此系列,我们将学习Rust中的<code>声明宏</code>  </p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li>书籍</li>\n</ol>\n<ul>\n<li><a href=\"https://zjp-cn.github.io/tlborm/\">宏小册</a>  </li>\n<li><a href=\"https://rustcc.gitbooks.io/rustprimer/content/macro/macro.html\">RustPrimer</a></li>\n<li><a href=\"https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html\">TRPL</a></li>\n</ul>\n<ol start=\"2\">\n<li>文章  </li>\n</ol>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353421021\">【译】Rust宏: 教程与示例 (一)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/356427780\">【译】Rust宏: 教程与示例 (二)</a></li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><ol>\n<li>发现错误的话, 请及时跟我联系  </li>\n<li>可以通过博客侧边栏上的联系方式找到我  </li>\n<li>欢迎在留言版中留言, 本人会定期查看  </li>\n</ol>\n<p>最后, 谢谢你的观看 :)</p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Sep 19 2021 21:51:27 GMT+0800 (中国标准时间)","title":"rs-dm-p1-系列说明","path":"posts/rs-decl-macro-p1.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 声明宏(declarative-macro) 系列  </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-19T13:51:27.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-19T13:51:27.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-dm-p3-声明与使用","comments":0,"abbrlink":"posts/rs-decl-macro-p3","date":"2021-09-20T12:06:15.000Z","top":9897,"keywords":["macro","声明宏","Rust"],"_content":"> 正式系统的关于 macro 的 声明与使用\n<!-- more -->  \n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 框架建立\n前一节,我们大概清楚了macro的结构  \n现在让我们再来简单复习一遍:  \n1. `macro_rules!(这是特点语法)`来创建一个macro\n2. `rule(s)(匹配分支,以 \"参数=>展开代码\" 的形式)`放在最外层的花括号内  \n3. 调用宏时,宏名+感叹号+括号内传参,比如: `println!(some_str)`  \n\n现在稍微深入一点:  \n一个 `rule` 可以被这样抽象地表示: (matcher)=>(transcriber)   \n它由三个重要的部分组成:\n\n- `matcher (匹配器)`: \n用来匹配传入的参数  \n\n- `metavariable/literal (元变量/字面量)`: \n绑定传入的代码片段,出现于 `matcher`\n- `transcriber (转录器)`: \n用来在宏匹配成功后,进行代码替换\n\n以`println!`为例子,我们向其传入了一些参数,它给我们打印到标准输出上  \n因为原本的`println!`涉及到`卫生性`,`重复语法`,`路径作用域`等,不适合新鸟阅读,所以我抽象了它:  \n\n```rust\nmacro_rules! println {\n    (/* 空参匹配 */) => (/* `换行` 的代码 */);\n    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)\n}\n```\n\n`println`由两个`rule`组成,每个的形式都是: `matcher=>transcriber`  \n从上往下,每个rule的`matcher`会与传入参数尝试匹配  \n匹配时, 括号具有多样性, 请看下面  \n\n1. 匹配规则:  \n- 匹配到: 就替换为`transcriber`里面的代码  \n- 匹配不到: 所有`matcher`都无法与`传入参数`进行匹配,则编译报错  \n\n2. 括号多样性: \n- 概念: `matcher`与`transcriber`的括号,可以是(),[],{}三种之一  \n- 定义时: 比如, rule可写成 `[pattern]=>{expansion}`  \n- 调用时: 一样遵从该规则, 比如 `vec![0, 1,2,3]` 与 `pritnln!(\"xx\")`\n\n而`metavariable/literal`则出现在`matcher`中,用于匹配并捕获代码片段  \n在对应的`transcriber`中,则可以操控这些`元值`,即操控捕获到的代码片段  \n\n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n- - -\n# 两种宏参数\n是时候引入一些新的东西了, 顺便加深下你的印象  \n\n## 元变量  \n元变量, 即Metavariable  \n让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\n\nfn main() {\n\tmy_macro!(1);\n\tmy_macro!(1, 2);\n}\n\n/* 宏全部展开后, 可以理解为下面: \nfn main() {\n    1;\n    1 + 2;\n}\n*/\n```\n\n你会注意到,每个rule之间的参数, 其声明都有点奇怪:  \n比如: `$a:expr` -> `$+参数标识符+类型`  \n\n1. `$` 这个前缀是干嘛的?  \n这显式说明, 它是 `metavariable`, 可以匹配并捕获代码片段, 这里会捕获表达式  \n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗?  \n下面就要讲到啦, 别着急~  \n\n2. 先看看 `expr` 类型:  \n`expr`, 全称为 `expression(表达式)`  \n第一次宏调用时, 传入了 `1(一个字面量)`, 这当然是个expr, 与第一个rule成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为相应的展开代码`  \n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n\n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码  \nmacro就像个code generator: 一段用来生成code的code  \n\n注意: \nmacro实际上, 是将传入部分解析为一个AST节点  \n然后将调用部分, 替换为一个新的AST节点  \n在本节下面, 会更详细地讲讲\n\n## 元字面量  \n元字面量, 即Metaliteral  \n为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n\n\n\n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 -- 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  \n\n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  \n这种固定的参数, 如同token中的字面量一样  \n我姑且称它为 `Literal Token(字面量标记)`, 或者 `Metaliteral (元字面量)`\n(因为我也不知道有什么对应术语, 所以用了 \"姑且\", 知道的麻烦告诉我)  \n\n假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! fuck {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tfuck!(1);       // No\n\tfuck!(a:expr);  // Yes ~~(Oh~)~~\n}\n```\n\n对于定义中的 \"a:expr\"(它是 `MetaLiteral`)  \n传入固定形式的 \"a:expr\" 时才可发生匹配  \n\n切记:  \n当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰  \n\n## 例子\n假设有这么个宏 `map!`(联想一下`vec!`)  \n它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  \n如下:  \n\n```rust\nfn main() {\n\tlet m = map![\n\t\t\"吉良吉影\" => 33,\n\t\t\"空条承太郎\" => 41,\n\t]\n\t// `m` 的类型为: std::collections::HashMap<&str, i32>\n}\n```\n\n我们来写一个这样的宏吧!  \n不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  \n\n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n\n\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key=>Value`  \n来看看两种宏参数在宏中, 发挥着怎样的作用:  \n- `Metavariable`: 将捕获的传入的代码片段绑定到自身  \n并在 `Transcriber` 中被使用, 最后展开为新代码  \n\n- `Metaliteral `: 限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配\n若改成 `map!(\"普通上班族\", 33)`, 则每个rule的 `Matcher` 都无法匹配上  \n(这里只有一个rule, 空匹配的懒得放里面了)  \n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  \n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  \n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册  \n(博客的话, 我周六放学回来慢慢更吧......)\n~~(潜台词是随时会鸽子)~~\n\n- - -\n\n# 本质  \nmacro的本质, 是生成一个AST节点\n可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  \n\n假若由你来设计一个Rust编译器  \n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n\n若我们将每遍扫描并做点事情的过程, 称为`pass`  \npass一次就生成了, 对于很大的源码来说, 这不现实吧  \n\n那我们就pass多次, 将 `从源码编译为目标码` 这个大问题, 分解为一大堆小问题  \n每一次pass都解决一个小问题, 那不就Ok了吗\n\n这种 `中间表示`, 就称为 `IR (Intermediate Representation )`  \n\n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)  \n那是一种代码被抽象后的树状结构  \n比如我们用Rust的enum表示一下:  \n\n```rust\n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  \nenum ASTNode {\n\tInt(i32), \n\tBinaryExpr {\n\t\top: Op,\n\t\tlhs: Box<ASTNode>,\n\t\trhs: Box<ASTNode>,\n\t}\n}\n\n// 二元运算的符号: 这里只抽象了加法\nenum Op {\n\tPlus, \n}\n```\n\n你只需明白AST是对源码封装的一层抽象产物就可以了  \n\n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小  \n但是, 如果源码很大呢? AST已经很复杂了\n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n\n基于AST, 我们可以再来一些`IR`, 层层递进, 以达目的  \n注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛  \n\n`AST`很重要, 是生成目标码的关键, 是代码的骨架  \n而另外的IR, 也是有必要的, 这也增强了可维护性  \n编译器在AST的基础上, 最终生成了目标码    \n\n问: 生成AST需要点啥? 或者说, 它由什么组成?  \n答: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 `token`  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构  \n它将token们联系起来, 表达了代码的骨架  \n这个庞然大物便是 AST 了  \n- - - \n# 回到Macro  \n## Token类型表\n生成AST需要Token协助  \nmacro 中, 其参数的类型, 便是token类型  \n\nmacro要操控传入的token (或AST节点, 等会讲)  \n那么我们总得知道token类型吧, 不然怎知咋操控?  \n\n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 `Metavariable`)  \n\n所以, 辛苦你将下面的记一下  \n稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\n- `ident` -> 标识符,如函数名字,变量名字,关键字  \n- `stmt` -> statemen,语句\n- `expr` -> expression,表达式,如`x`与`1_i32`\n- `literal` -> literal expression,字面量表达式,expr的子集\n- `block` -> 代码块  \n- `pat` -> pattern, 比如在match表达式下的 (pattern) => todo!(),\n- `path` -> 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径\n- `ty` -> type, 如i32,u32,String,Option<T>等  \n- `tt` -> token tree, 之后我会单独再讲解下它的  \n- `item` -> 条目/项, 例如函数定义  \n- `meta` -> 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)\n- `lifetime` -> 生命周期  \n- `vis` -> visibility, 可见性, 比如pub等, 也可能为空  \n\n## TT\n这里有个比较特殊的类型 `tt (Token Tree)`  \n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~  \n\n`tt`,可以捕获`Single Token`,或由(),[],{}及括号包裹起来的东西  \n作为 Token Tree 的根节点, 先让我们来点例子:  \n```rust\nmacro_rules! aa {\n    ($a:tt) => {\n        println!(\"{}\", stringify!($a));\n    };\n}\nfn main() {\n\t// Single Token\n    aa!(123);          // Yes: 123\n    aa!(FuckYou);      // Yes: FuckYou\n    // aa!(Fuck You);     // No\n    // aa!(123 + 11);     // No\n\n\t// (), [], {}\n\taa!([123]);        // Yes: [123]\n\taa!({123 + 123});  // Yes: { 123 + 123 }\n}\n```\n上面的代码, 展示了 `tt` 可以匹配捕获哪些东西  \n再来看看下面的内容, 理解理解它:  \n(我们以`<<xxx>>`, 来表示xxx是一颗 Token Tree)  \n```rust\n// 你的眼中:\n1 + 2 + (3 + 4)\n// tt的眼中:\n<<1>> <<+>> <<2>> <<+>> <<( )>>\n                           |\n                           |\n                   <<3>> <<+>> <<4>>\n```\n这段代码的Token Tree共有5个:  \n1. <<1>>\n2. <<+>>\n3. <<2>>\n4. <<+>>\n5. <<(3 + 4)>>\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree  \n对于第5个, 因为有()包裹, <<(...)>> 作为根节点, 它还有三个子节点(这里正好同层)  \n\n有没有对 `Token后面跟着Tree` 更加理解?  \n\n\n## AST节点\n\nmacro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)  \n比如 `map!` 中, `$key:value` 与 `$val:expr`, 都会被解析为expr类型的AST节点:  \n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n\n\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n\n我们通过使用 macro , 站在了更抽象的视角上  \n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n\n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  \n\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果  \n我直接用 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md) 上面的代码了:  \n\n```rust\nmacro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5)\n    );\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5)\n    );\n}\n```\n\n输出结果会是:  \n```rust\ngot an identifier\ngot an addition\ngot something else\n\ngot something else\ngot something else\ngot something else\n```\n\n比如这里, `match_tokens` 捕获token, 然后将参数解析为一个expr类型的AST节点  \n它不再是token, 而是个AST节点了!  \n\n比如 `5 + 7`, 原本是可以与 `$a:tt + $b:tt` 相匹配, 也可以与 `$a: expr` 匹配  \n但经二次传入后(向 `capture_then_match_tokens`传入的参数又传给 `match_tokens`)  \n`5 + 7` 变成AST表达式节点, 只能与 `$a: expr`, 而不能与 `$a:tt + $b:tt` 匹配  \n\n只有 `tt`, `ident`, `lifetime` 能免遭 AST节点化, 可以好好理解下这块  \n\n总结:  \n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点  \n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏  \n(只要宏展开的AST节点正确即可 :D)\n\n宏展开的结果是个某类型的AST节点, 这相比于C语言的 `#define` 宏, 有什么好处?  \n最直接的好处, 如下 ~~(相当于自动给你加上了括号)~~:\n```rust\n// C语言: 简单的文本替换\n#define SUM(a,b) a+b\nint main(void) {\n\tSUM(2, 2);     // 2 * 2\n\t5 * SUM(2, 2); // 5 * 2 + 2\n\treturn 0;\n}\n\n// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点\nmacro_rules! sum {\n\t($a:expr,$b:expr) => {$a + $b};\n}\nfn main() {\n\tsum!(2,2);     // 2 + 2\n\t5 * sum!(2,2); // 5 * (2 + 2)\n}\n```\n\n\n## 匹配注意点\n在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制  \n即下面要讲的东西, 有时间的也可以去看看 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md)\n### 匹配误区\n来看看下面一段代码:\n```rust\nmacro_rules! aa {\n\t($a: expr) => {};\n\t($a: ident +) => {}\n}\nfn main() {\n\taa!(a);   // Yes\n\taa!(a+);  // No\n}\n```\n\n按照你的直觉, `aa!(a+)` 应该会与第二个 rule 相匹配  \n但是实际上会报这么一个错误:  \n\n```rust\nexpected expression, found end of macro arguments\n// 期望表达式, 却发现宏参数结束了\n```\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \n\n`a (lhs, left hand side)` 能被第一个rule匹配  \n而 `+ (二元加)` 因为可以尾随表达式, 也可以被第一个rule匹配\n但由于缺少 `rhs`, 此时会直接报错, 而不是去尝试匹配下一个rule  \n\n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n### 歧义限制  \n由于一些歧义, 为了向后兼容性与不破坏代码  \n当前对 `Metavariable` 后面可以跟的内容有所限制, 详情可见 [Rust-Reference: 限制](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)  \n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可  \n~~(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)~~  \n~~(因为我也没有全部搞懂)~~  \n\n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n\n那么, 今天就到这了, 谢谢您的观看 :)\n","source":"_posts/rs-dm/rs-dm-p3-声明与使用.md","raw":"---\ntitle: rs-dm-p3-声明与使用\ncomments: false\nabbrlink: posts/rs-decl-macro-p3\ndate: 2021-09-20 20:06:15\ntop: 9897\ntags: rust\nkeywords: [macro, 声明宏, Rust]\n---\n> 正式系统的关于 macro 的 声明与使用\n<!-- more -->  \n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 框架建立\n前一节,我们大概清楚了macro的结构  \n现在让我们再来简单复习一遍:  \n1. `macro_rules!(这是特点语法)`来创建一个macro\n2. `rule(s)(匹配分支,以 \"参数=>展开代码\" 的形式)`放在最外层的花括号内  \n3. 调用宏时,宏名+感叹号+括号内传参,比如: `println!(some_str)`  \n\n现在稍微深入一点:  \n一个 `rule` 可以被这样抽象地表示: (matcher)=>(transcriber)   \n它由三个重要的部分组成:\n\n- `matcher (匹配器)`: \n用来匹配传入的参数  \n\n- `metavariable/literal (元变量/字面量)`: \n绑定传入的代码片段,出现于 `matcher`\n- `transcriber (转录器)`: \n用来在宏匹配成功后,进行代码替换\n\n以`println!`为例子,我们向其传入了一些参数,它给我们打印到标准输出上  \n因为原本的`println!`涉及到`卫生性`,`重复语法`,`路径作用域`等,不适合新鸟阅读,所以我抽象了它:  \n\n```rust\nmacro_rules! println {\n    (/* 空参匹配 */) => (/* `换行` 的代码 */);\n    (/* 有参匹配 */) => (/* `打印参数 + 换行` 的代码 */)\n}\n```\n\n`println`由两个`rule`组成,每个的形式都是: `matcher=>transcriber`  \n从上往下,每个rule的`matcher`会与传入参数尝试匹配  \n匹配时, 括号具有多样性, 请看下面  \n\n1. 匹配规则:  \n- 匹配到: 就替换为`transcriber`里面的代码  \n- 匹配不到: 所有`matcher`都无法与`传入参数`进行匹配,则编译报错  \n\n2. 括号多样性: \n- 概念: `matcher`与`transcriber`的括号,可以是(),[],{}三种之一  \n- 定义时: 比如, rule可写成 `[pattern]=>{expansion}`  \n- 调用时: 一样遵从该规则, 比如 `vec![0, 1,2,3]` 与 `pritnln!(\"xx\")`\n\n而`metavariable/literal`则出现在`matcher`中,用于匹配并捕获代码片段  \n在对应的`transcriber`中,则可以操控这些`元值`,即操控捕获到的代码片段  \n\n稍微有点蒙? 我也没让你背哟, 多看多用就会了  \n- - -\n# 两种宏参数\n是时候引入一些新的东西了, 顺便加深下你的印象  \n\n## 元变量  \n元变量, 即Metavariable  \n让我们来看个例子:  \n\n```rust\nmacro_rules! my_macro {\n\t($a: expr) => {\n\t\t$a\n\t};\n\n\t($a: expr, $b: expr) => {\n\t\t$a + $b\n\t}\n}\n\nfn main() {\n\tmy_macro!(1);\n\tmy_macro!(1, 2);\n}\n\n/* 宏全部展开后, 可以理解为下面: \nfn main() {\n    1;\n    1 + 2;\n}\n*/\n```\n\n你会注意到,每个rule之间的参数, 其声明都有点奇怪:  \n比如: `$a:expr` -> `$+参数标识符+类型`  \n\n1. `$` 这个前缀是干嘛的?  \n这显式说明, 它是 `metavariable`, 可以匹配并捕获代码片段, 这里会捕获表达式  \n至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗?  \n下面就要讲到啦, 别着急~  \n\n2. 先看看 `expr` 类型:  \n`expr`, 全称为 `expression(表达式)`  \n第一次宏调用时, 传入了 `1(一个字面量)`, 这当然是个expr, 与第一个rule成功匹配  \n这时, `my_macro!(1)` 这个部分, 就会被替换为相应的展开代码`  \n(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  \n\n简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码  \nmacro就像个code generator: 一段用来生成code的code  \n\n注意: \nmacro实际上, 是将传入部分解析为一个AST节点  \n然后将调用部分, 替换为一个新的AST节点  \n在本节下面, 会更详细地讲讲\n\n## 元字面量  \n元字面量, 即Metaliteral  \n为了加深印象与引出 `metaliteral` , 我们来玩个对应游戏:  \n```rust\n($a: expr) => {$a};                     // the first rule\n  |             |  \n  |         \t|\n( 1      )      1                       // pass && expand \n\n\n\n($a: expr, $b: expr) => { $a + $b};    // the second rule\n  |      |  |              |    |\n  |      |  |              |    |\n( 1      ,  2      ) =>    1 +  2      // pass && expand\n```\n\n我使用 `|` 来联系 `形参 -- 实参`  \n你会惊讶的发现, 传参时的对应关系们, 除了 `$a -- 1` 与 `$b -- 2`, 还有个 `, -- ,`  \n\n对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参  \n这种固定的参数, 如同token中的字面量一样  \n我姑且称它为 `Literal Token(字面量标记)`, 或者 `Metaliteral (元字面量)`\n(因为我也不知道有什么对应术语, 所以用了 \"姑且\", 知道的麻烦告诉我)  \n\n假若 rule 中的参数没有 $前缀 进行区分:  \n\n```rust\nmacro_rules! fuck {\n\t(a:expr) => {\n\t\t\n\t};\n}\nfn main() {\n\tfuck!(1);       // No\n\tfuck!(a:expr);  // Yes ~~(Oh~)~~\n}\n```\n\n对于定义中的 \"a:expr\"(它是 `MetaLiteral`)  \n传入固定形式的 \"a:expr\" 时才可发生匹配  \n\n切记:  \n当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰  \n\n## 例子\n假设有这么个宏 `map!`(联想一下`vec!`)  \n它能根据 `=>` 判断出 `Key/Value`, 然后生成一个 `HashMap`  \n如下:  \n\n```rust\nfn main() {\n\tlet m = map![\n\t\t\"吉良吉影\" => 33,\n\t\t\"空条承太郎\" => 41,\n\t]\n\t// `m` 的类型为: std::collections::HashMap<&str, i32>\n}\n```\n\n我们来写一个这样的宏吧!  \n不过我们还未学习 `重复语法`, 无法写出接收可变参数的 `map!`, 所以现在只讨论简陋版:  \n\n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n\n\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n这就是一个简陋的DSL, 你定义了创建HashMap的新语法: `Key=>Value`  \n来看看两种宏参数在宏中, 发挥着怎样的作用:  \n- `Metavariable`: 将捕获的传入的代码片段绑定到自身  \n并在 `Transcriber` 中被使用, 最后展开为新代码  \n\n- `Metaliteral `: 限定了匹配, 传入的代码片段, 必须以 => 分割, 才能成功匹配\n若改成 `map!(\"普通上班族\", 33)`, 则每个rule的 `Matcher` 都无法匹配上  \n(这里只有一个rule, 空匹配的懒得放里面了)  \n\n其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码  \n考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已  \n之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册  \n(博客的话, 我周六放学回来慢慢更吧......)\n~~(潜台词是随时会鸽子)~~\n\n- - -\n\n# 本质  \nmacro的本质, 是生成一个AST节点\n可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  \n\n假若由你来设计一个Rust编译器  \n首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  \n\n若我们将每遍扫描并做点事情的过程, 称为`pass`  \npass一次就生成了, 对于很大的源码来说, 这不现实吧  \n\n那我们就pass多次, 将 `从源码编译为目标码` 这个大问题, 分解为一大堆小问题  \n每一次pass都解决一个小问题, 那不就Ok了吗\n\n这种 `中间表示`, 就称为 `IR (Intermediate Representation )`  \n\n我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)  \n那是一种代码被抽象后的树状结构  \n比如我们用Rust的enum表示一下:  \n\n```rust\n// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  \nenum ASTNode {\n\tInt(i32), \n\tBinaryExpr {\n\t\top: Op,\n\t\tlhs: Box<ASTNode>,\n\t\trhs: Box<ASTNode>,\n\t}\n}\n\n// 二元运算的符号: 这里只抽象了加法\nenum Op {\n\tPlus, \n}\n```\n\n你只需明白AST是对源码封装的一层抽象产物就可以了  \n\n对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小  \n但是, 如果源码很大呢? AST已经很复杂了\n那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  \n\n基于AST, 我们可以再来一些`IR`, 层层递进, 以达目的  \n注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛  \n\n`AST`很重要, 是生成目标码的关键, 是代码的骨架  \n而另外的IR, 也是有必要的, 这也增强了可维护性  \n编译器在AST的基础上, 最终生成了目标码    \n\n问: 生成AST需要点啥? 或者说, 它由什么组成?  \n答: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 `token`  \n\n在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构  \n它将token们联系起来, 表达了代码的骨架  \n这个庞然大物便是 AST 了  \n- - - \n# 回到Macro  \n## Token类型表\n生成AST需要Token协助  \nmacro 中, 其参数的类型, 便是token类型  \n\nmacro要操控传入的token (或AST节点, 等会讲)  \n那么我们总得知道token类型吧, 不然怎知咋操控?  \n\n只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 `Metavariable`)  \n\n所以, 辛苦你将下面的记一下  \n稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  \n\n- `ident` -> 标识符,如函数名字,变量名字,关键字  \n- `stmt` -> statemen,语句\n- `expr` -> expression,表达式,如`x`与`1_i32`\n- `literal` -> literal expression,字面量表达式,expr的子集\n- `block` -> 代码块  \n- `pat` -> pattern, 比如在match表达式下的 (pattern) => todo!(),\n- `path` -> 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径\n- `ty` -> type, 如i32,u32,String,Option<T>等  \n- `tt` -> token tree, 之后我会单独再讲解下它的  \n- `item` -> 条目/项, 例如函数定义  \n- `meta` -> 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)\n- `lifetime` -> 生命周期  \n- `vis` -> visibility, 可见性, 比如pub等, 也可能为空  \n\n## TT\n这里有个比较特殊的类型 `tt (Token Tree)`  \n从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗~~(废话)~~  \n\n`tt`,可以捕获`Single Token`,或由(),[],{}及括号包裹起来的东西  \n作为 Token Tree 的根节点, 先让我们来点例子:  \n```rust\nmacro_rules! aa {\n    ($a:tt) => {\n        println!(\"{}\", stringify!($a));\n    };\n}\nfn main() {\n\t// Single Token\n    aa!(123);          // Yes: 123\n    aa!(FuckYou);      // Yes: FuckYou\n    // aa!(Fuck You);     // No\n    // aa!(123 + 11);     // No\n\n\t// (), [], {}\n\taa!([123]);        // Yes: [123]\n\taa!({123 + 123});  // Yes: { 123 + 123 }\n}\n```\n上面的代码, 展示了 `tt` 可以匹配捕获哪些东西  \n再来看看下面的内容, 理解理解它:  \n(我们以`<<xxx>>`, 来表示xxx是一颗 Token Tree)  \n```rust\n// 你的眼中:\n1 + 2 + (3 + 4)\n// tt的眼中:\n<<1>> <<+>> <<2>> <<+>> <<( )>>\n                           |\n                           |\n                   <<3>> <<+>> <<4>>\n```\n这段代码的Token Tree共有5个:  \n1. <<1>>\n2. <<+>>\n3. <<2>>\n4. <<+>>\n5. <<(3 + 4)>>\n\n对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree  \n对于第5个, 因为有()包裹, <<(...)>> 作为根节点, 它还有三个子节点(这里正好同层)  \n\n有没有对 `Token后面跟着Tree` 更加理解?  \n\n\n## AST节点\n\nmacro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)  \n比如 `map!` 中, `$key:value` 与 `$val:expr`, 都会被解析为expr类型的AST节点:  \n```rust\nmacro_rules! map {\n\t($key:expr => $val:expr) => {{\n\t\tlet mut m = std::collections::HashMap::<_,_>::new();\n\t\tm.insert($key, $val);\n\t\tm\n\t}};\n}\nfn main() {\n\tlet m = map!(\"普通上班族\" => 33);\n\tprintln!(\"{:?}\",m);\n}\n\n\n/* 展开后, 可以看作是:\nfn main() {\n    let m = {\n        let mut m = std::collections::HashMap::<_,_>::new();\n        m.insert(\"普通上班族\", 33);\n        m\n    };\n    println!(\"{:?}\",m);\n}\n*/\n```\n\n我们通过使用 macro , 站在了更抽象的视角上  \n操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    \n\n这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  \n\n值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果  \n我直接用 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md) 上面的代码了:  \n\n```rust\nmacro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5)\n    );\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5)\n    );\n}\n```\n\n输出结果会是:  \n```rust\ngot an identifier\ngot an addition\ngot something else\n\ngot something else\ngot something else\ngot something else\n```\n\n比如这里, `match_tokens` 捕获token, 然后将参数解析为一个expr类型的AST节点  \n它不再是token, 而是个AST节点了!  \n\n比如 `5 + 7`, 原本是可以与 `$a:tt + $b:tt` 相匹配, 也可以与 `$a: expr` 匹配  \n但经二次传入后(向 `capture_then_match_tokens`传入的参数又传给 `match_tokens`)  \n`5 + 7` 变成AST表达式节点, 只能与 `$a: expr`, 而不能与 `$a:tt + $b:tt` 匹配  \n\n只有 `tt`, `ident`, `lifetime` 能免遭 AST节点化, 可以好好理解下这块  \n\n总结:  \n宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点  \n这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏  \n(只要宏展开的AST节点正确即可 :D)\n\n宏展开的结果是个某类型的AST节点, 这相比于C语言的 `#define` 宏, 有什么好处?  \n最直接的好处, 如下 ~~(相当于自动给你加上了括号)~~:\n```rust\n// C语言: 简单的文本替换\n#define SUM(a,b) a+b\nint main(void) {\n\tSUM(2, 2);     // 2 * 2\n\t5 * SUM(2, 2); // 5 * 2 + 2\n\treturn 0;\n}\n\n// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点\nmacro_rules! sum {\n\t($a:expr,$b:expr) => {$a + $b};\n}\nfn main() {\n\tsum!(2,2);     // 2 + 2\n\t5 * sum!(2,2); // 5 * (2 + 2)\n}\n```\n\n\n## 匹配注意点\n在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制  \n即下面要讲的东西, 有时间的也可以去看看 [宏小册](https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md)\n### 匹配误区\n来看看下面一段代码:\n```rust\nmacro_rules! aa {\n\t($a: expr) => {};\n\t($a: ident +) => {}\n}\nfn main() {\n\taa!(a);   // Yes\n\taa!(a+);  // No\n}\n```\n\n按照你的直觉, `aa!(a+)` 应该会与第二个 rule 相匹配  \n但是实际上会报这么一个错误:  \n\n```rust\nexpected expression, found end of macro arguments\n// 期望表达式, 却发现宏参数结束了\n```\n\n你会发现实际上都是在与第一个rule尝试着进行匹配:  \n\n`a (lhs, left hand side)` 能被第一个rule匹配  \n而 `+ (二元加)` 因为可以尾随表达式, 也可以被第一个rule匹配\n但由于缺少 `rhs`, 此时会直接报错, 而不是去尝试匹配下一个rule  \n\n这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  \n### 歧义限制  \n由于一些歧义, 为了向后兼容性与不破坏代码  \n当前对 `Metavariable` 后面可以跟的内容有所限制, 详情可见 [Rust-Reference: 限制](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)  \n这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可  \n~~(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)~~  \n~~(因为我也没有全部搞懂)~~  \n\n当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  \n\n那么, 今天就到这了, 谢谢您的观看 :)\n","slug":"rs-dm/rs-dm-p3-声明与使用","published":1,"updated":"2021-09-20T12:06:15.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mr0008jaqy73jw4eeo","content":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>\n<span id=\"more\"></span>  \n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"框架建立\"><a href=\"#框架建立\" class=\"headerlink\" title=\"框架建立\"></a>框架建立</h1><p>前一节,我们大概清楚了macro的结构<br>现在让我们再来简单复习一遍:  </p>\n<ol>\n<li><code>macro_rules!(这是特点语法)</code>来创建一个macro</li>\n<li><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内  </li>\n<li>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code>  </li>\n</ol>\n<p>现在稍微深入一点:<br>一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber)<br>它由三个重要的部分组成:</p>\n<ul>\n<li><p><code>matcher (匹配器)</code>:<br>用来匹配传入的参数  </p>\n</li>\n<li><p><code>metavariable/literal (元变量/字面量)</code>:<br>绑定传入的代码片段,出现于 <code>matcher</code></p>\n</li>\n<li><p><code>transcriber (转录器)</code>:<br>用来在宏匹配成功后,进行代码替换</p>\n</li>\n</ul>\n<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    (<span class=\"comment\">/* 空参匹配 */</span>) =&gt; (<span class=\"comment\">/* `换行` 的代码 */</span>);</span><br><span class=\"line\">    (<span class=\"comment\">/* 有参匹配 */</span>) =&gt; (<span class=\"comment\">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code><br>从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配<br>匹配时, 括号具有多样性, 请看下面  </p>\n<ol>\n<li>匹配规则:  </li>\n</ol>\n<ul>\n<li>匹配到: 就替换为<code>transcriber</code>里面的代码  </li>\n<li>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错  </li>\n</ul>\n<ol start=\"2\">\n<li>括号多样性: </li>\n</ol>\n<ul>\n<li>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一  </li>\n<li>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code>  </li>\n<li>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></li>\n</ul>\n<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段  </p>\n<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了  </p>\n<hr>\n<h1 id=\"两种宏参数\"><a href=\"#两种宏参数\" class=\"headerlink\" title=\"两种宏参数\"></a>两种宏参数</h1><p>是时候引入一些新的东西了, 顺便加深下你的印象  </p>\n<h2 id=\"元变量\"><a href=\"#元变量\" class=\"headerlink\" title=\"元变量\"></a>元变量</h2><p>元变量, 即Metavariable<br>让我们来看个例子:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    1;</span></span><br><span class=\"line\"><span class=\"comment\">    1 + 2;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code>  </p>\n<ol>\n<li><p><code>$</code> 这个前缀是干嘛的?<br>这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗?<br>下面就要讲到啦, 别着急~  </p>\n</li>\n<li><p>先看看 <code>expr</code> 类型:<br><code>expr</code>, 全称为 <code>expression(表达式)</code><br>第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  </p>\n</li>\n</ol>\n<p>简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>macro就像个code generator: 一段用来生成code的code  </p>\n<p>注意:<br>macro实际上, 是将传入部分解析为一个AST节点<br>然后将调用部分, 替换为一个新的AST节点<br>在本节下面, 会更详细地讲讲</p>\n<h2 id=\"元字面量\"><a href=\"#元字面量\" class=\"headerlink\" title=\"元字面量\"></a>元字面量</h2><p>元字面量, 即Metaliteral<br>为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n\n<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code>  </p>\n<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>这种固定的参数, 如同token中的字面量一样<br>我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)  </p>\n<p>假若 rule 中的参数没有 $前缀 进行区分:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> fuck &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    fuck!(<span class=\"number\">1</span>);       <span class=\"comment\">// No</span></span><br><span class=\"line\">    fuck!(a:expr);  <span class=\"comment\">// Yes ~~(Oh~)~~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>)<br>传入固定形式的 “a:expr” 时才可发生匹配  </p>\n<p>切记:<br>当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰  </p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map![</span><br><span class=\"line\">        <span class=\"string\">&quot;吉良吉影&quot;</span> =&gt; <span class=\"number\">33</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;空条承太郎&quot;</span> =&gt; <span class=\"number\">41</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来写一个这样的宏吧!<br>不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>来看看两种宏参数在宏中, 发挥着怎样的作用:  </p>\n<ul>\n<li><p><code>Metavariable</code>: 将捕获的传入的代码片段绑定到自身<br>并在 <code>Transcriber</code> 中被使用, 最后展开为新代码  </p>\n</li>\n<li><p><code>Metaliteral </code>: 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配<br>若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>(这里只有一个rule, 空匹配的懒得放里面了)  </p>\n</li>\n</ul>\n<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>(博客的话, 我周六放学回来慢慢更吧……)<br><del>(潜台词是随时会鸽子)</del></p>\n<hr>\n<h1 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h1><p>macro的本质, 是生成一个AST节点<br>可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  </p>\n<p>假若由你来设计一个Rust编译器<br>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  </p>\n<p>若我们将每遍扫描并做点事情的过程, 称为<code>pass</code><br>pass一次就生成了, 对于很大的源码来说, 这不现实吧  </p>\n<p>那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题<br>每一次pass都解决一个小问题, 那不就Ok了吗</p>\n<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code>  </p>\n<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)<br>那是一种代码被抽象后的树状结构<br>比如我们用Rust的enum表示一下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASTNode</span></span> &#123;</span><br><span class=\"line\">    Int(<span class=\"built_in\">i32</span>), </span><br><span class=\"line\">    BinaryExpr &#123;</span><br><span class=\"line\">        op: Op,</span><br><span class=\"line\">        lhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">        rhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Op</span></span> &#123;</span><br><span class=\"line\">    Plus, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你只需明白AST是对源码封装的一层抽象产物就可以了  </p>\n<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小<br>但是, 如果源码很大呢? AST已经很复杂了<br>那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  </p>\n<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的<br>注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛  </p>\n<p><code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架<br>而另外的IR, 也是有必要的, 这也增强了可维护性<br>编译器在AST的基础上, 最终生成了目标码    </p>\n<p>问: 生成AST需要点啥? 或者说, 它由什么组成?<br>答: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code>  </p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>它将token们联系起来, 表达了代码的骨架<br>这个庞然大物便是 AST 了  </p>\n<hr>\n<h1 id=\"回到Macro\"><a href=\"#回到Macro\" class=\"headerlink\" title=\"回到Macro\"></a>回到Macro</h1><h2 id=\"Token类型表\"><a href=\"#Token类型表\" class=\"headerlink\" title=\"Token类型表\"></a>Token类型表</h2><p>生成AST需要Token协助<br>macro 中, 其参数的类型, 便是token类型  </p>\n<p>macro要操控传入的token (或AST节点, 等会讲)<br>那么我们总得知道token类型吧, 不然怎知咋操控?  </p>\n<p>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)  </p>\n<p>所以, 辛苦你将下面的记一下<br>稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  </p>\n<ul>\n<li><code>ident</code> -&gt; 标识符,如函数名字,变量名字,关键字  </li>\n<li><code>stmt</code> -&gt; statemen,语句</li>\n<li><code>expr</code> -&gt; expression,表达式,如<code>x</code>与<code>1_i32</code></li>\n<li><code>literal</code> -&gt; literal expression,字面量表达式,expr的子集</li>\n<li><code>block</code> -&gt; 代码块  </li>\n<li><code>pat</code> -&gt; pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),</li>\n<li><code>path</code> -&gt; 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径</li>\n<li><code>ty</code> -&gt; type, 如i32,u32,String,Option<T>等  </li>\n<li><code>tt</code> -&gt; token tree, 之后我会单独再讲解下它的  </li>\n<li><code>item</code> -&gt; 条目/项, 例如函数定义  </li>\n<li><code>meta</code> -&gt; 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)</li>\n<li><code>lifetime</code> -&gt; 生命周期  </li>\n<li><code>vis</code> -&gt; visibility, 可见性, 比如pub等, 也可能为空  </li>\n</ul>\n<h2 id=\"TT\"><a href=\"#TT\" class=\"headerlink\" title=\"TT\"></a>TT</h2><p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗<del>(废话)</del>  </p>\n<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>作为 Token Tree 的根节点, 先让我们来点例子:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a:tt) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($a));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Single Token</span></span><br><span class=\"line\">    aa!(<span class=\"number\">123</span>);          <span class=\"comment\">// Yes: 123</span></span><br><span class=\"line\">    aa!(FuckYou);      <span class=\"comment\">// Yes: FuckYou</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(Fuck You);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(123 + 11);     // No</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// (), [], &#123;&#125;</span></span><br><span class=\"line\">    aa!([<span class=\"number\">123</span>]);        <span class=\"comment\">// Yes: [123]</span></span><br><span class=\"line\">    aa!(&#123;<span class=\"number\">123</span> + <span class=\"number\">123</span>&#125;);  <span class=\"comment\">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>再来看看下面的内容, 理解理解它:<br>(我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示xxx是一颗 Token Tree)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你的眼中:</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span> + (<span class=\"number\">3</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// tt的眼中:</span></span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                   &lt;&lt;<span class=\"number\">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的Token Tree共有5个:  </p>\n<ol>\n<li>&lt;&lt;1&gt;&gt;</li>\n<li>&lt;&lt;+&gt;&gt;</li>\n<li>&lt;&lt;2&gt;&gt;</li>\n<li>&lt;&lt;+&gt;&gt;</li>\n<li>&lt;&lt;(3 + 4)&gt;&gt;</li>\n</ol>\n<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)  </p>\n<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?  </p>\n<h2 id=\"AST节点\"><a href=\"#AST节点\" class=\"headerlink\" title=\"AST节点\"></a>AST节点</h2><p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过使用 macro , 站在了更抽象的视角上<br>操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    </p>\n<p>这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  </p>\n<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果<br>我直接用 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a> 上面的代码了:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class=\"line\">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> match_tokens &#123;</span><br><span class=\"line\">    ($a:tt + $b:tt) =&gt; &#123;<span class=\"string\">&quot;got an addition&quot;</span>&#125;;</span><br><span class=\"line\">    (($i:ident)) =&gt; &#123;<span class=\"string\">&quot;got an identifier&quot;</span>&#125;;</span><br><span class=\"line\">    ($($other:tt)*) =&gt; &#123;<span class=\"string\">&quot;got something else&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;</span>,</span><br><span class=\"line\">        match_tokens!((caravan)),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;</span>,</span><br><span class=\"line\">        capture_then_match_tokens!((caravan)),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果会是:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">got an identifier</span><br><span class=\"line\">got an addition</span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\"></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br></pre></td></tr></table></figure>\n\n<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点<br>它不再是token, 而是个AST节点了!  </p>\n<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br><code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配  </p>\n<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块  </p>\n<p>总结:<br>宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏<br>(只要宏展开的AST节点正确即可 :D)</p>\n<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>最直接的好处, 如下 <del>(相当于自动给你加上了括号)</del>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言: 简单的文本替换</span></span><br><span class=\"line\">#define SUM(a,b) a+b</span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>);     <span class=\"comment\">// 2 * 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 5 * 2 + 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>);     <span class=\"comment\">// 2 + 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 5 * (2 + 2)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"匹配注意点\"><a href=\"#匹配注意点\" class=\"headerlink\" title=\"匹配注意点\"></a>匹配注意点</h2><p>在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制<br>即下面要讲的东西, 有时间的也可以去看看 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a></p>\n<h3 id=\"匹配误区\"><a href=\"#匹配误区\" class=\"headerlink\" title=\"匹配误区\"></a>匹配误区</h3><p>来看看下面一段代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    aa!(a);   <span class=\"comment\">// Yes</span></span><br><span class=\"line\">    aa!(a+);  <span class=\"comment\">// No</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配<br>但是实际上会报这么一个错误:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expected expression, found end of <span class=\"keyword\">macro</span> arguments</span><br><span class=\"line\"><span class=\"comment\">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>\n\n<p>你会发现实际上都是在与第一个rule尝试着进行匹配:  </p>\n<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配<br>但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule  </p>\n<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  </p>\n<h3 id=\"歧义限制\"><a href=\"#歧义限制\" class=\"headerlink\" title=\"歧义限制\"></a>歧义限制</h3><p>由于一些歧义, 为了向后兼容性与不破坏代码<br>当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">Rust-Reference: 限制</a><br>这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br><del>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)</del><br><del>(因为我也没有全部搞懂)</del>  </p>\n<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  </p>\n<p>那么, 今天就到这了, 谢谢您的观看 :)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"框架建立\"><a href=\"#框架建立\" class=\"headerlink\" title=\"框架建立\"></a>框架建立</h1><p>前一节,我们大概清楚了macro的结构<br>现在让我们再来简单复习一遍:  </p>\n<ol>\n<li><code>macro_rules!(这是特点语法)</code>来创建一个macro</li>\n<li><code>rule(s)(匹配分支,以 &quot;参数=&gt;展开代码&quot; 的形式)</code>放在最外层的花括号内  </li>\n<li>调用宏时,宏名+感叹号+括号内传参,比如: <code>println!(some_str)</code>  </li>\n</ol>\n<p>现在稍微深入一点:<br>一个 <code>rule</code> 可以被这样抽象地表示: (matcher)=&gt;(transcriber)<br>它由三个重要的部分组成:</p>\n<ul>\n<li><p><code>matcher (匹配器)</code>:<br>用来匹配传入的参数  </p>\n</li>\n<li><p><code>metavariable/literal (元变量/字面量)</code>:<br>绑定传入的代码片段,出现于 <code>matcher</code></p>\n</li>\n<li><p><code>transcriber (转录器)</code>:<br>用来在宏匹配成功后,进行代码替换</p>\n</li>\n</ul>\n<p>以<code>println!</code>为例子,我们向其传入了一些参数,它给我们打印到标准输出上<br>因为原本的<code>println!</code>涉及到<code>卫生性</code>,<code>重复语法</code>,<code>路径作用域</code>等,不适合新鸟阅读,所以我抽象了它:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> println &#123;</span><br><span class=\"line\">    (<span class=\"comment\">/* 空参匹配 */</span>) =&gt; (<span class=\"comment\">/* `换行` 的代码 */</span>);</span><br><span class=\"line\">    (<span class=\"comment\">/* 有参匹配 */</span>) =&gt; (<span class=\"comment\">/* `打印参数 + 换行` 的代码 */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>println</code>由两个<code>rule</code>组成,每个的形式都是: <code>matcher=&gt;transcriber</code><br>从上往下,每个rule的<code>matcher</code>会与传入参数尝试匹配<br>匹配时, 括号具有多样性, 请看下面  </p>\n<ol>\n<li>匹配规则:  </li>\n</ol>\n<ul>\n<li>匹配到: 就替换为<code>transcriber</code>里面的代码  </li>\n<li>匹配不到: 所有<code>matcher</code>都无法与<code>传入参数</code>进行匹配,则编译报错  </li>\n</ul>\n<ol start=\"2\">\n<li>括号多样性: </li>\n</ol>\n<ul>\n<li>概念: <code>matcher</code>与<code>transcriber</code>的括号,可以是(),[],{}三种之一  </li>\n<li>定义时: 比如, rule可写成 <code>[pattern]=&gt;&#123;expansion&#125;</code>  </li>\n<li>调用时: 一样遵从该规则, 比如 <code>vec![0, 1,2,3]</code> 与 <code>pritnln!(&quot;xx&quot;)</code></li>\n</ul>\n<p>而<code>metavariable/literal</code>则出现在<code>matcher</code>中,用于匹配并捕获代码片段<br>在对应的<code>transcriber</code>中,则可以操控这些<code>元值</code>,即操控捕获到的代码片段  </p>\n<p>稍微有点蒙? 我也没让你背哟, 多看多用就会了  </p>\n<hr>\n<h1 id=\"两种宏参数\"><a href=\"#两种宏参数\" class=\"headerlink\" title=\"两种宏参数\"></a>两种宏参数</h1><p>是时候引入一些新的东西了, 顺便加深下你的印象  </p>\n<h2 id=\"元变量\"><a href=\"#元变量\" class=\"headerlink\" title=\"元变量\"></a>元变量</h2><p>元变量, 即Metavariable<br>让我们来看个例子:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> my_macro &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;</span><br><span class=\"line\">        $a</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ($a: expr, $b: expr) =&gt; &#123;</span><br><span class=\"line\">        $a + $b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>);</span><br><span class=\"line\">    my_macro!(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 宏全部展开后, 可以理解为下面: </span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    1;</span></span><br><span class=\"line\"><span class=\"comment\">    1 + 2;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>你会注意到,每个rule之间的参数, 其声明都有点奇怪:<br>比如: <code>$a:expr</code> -&gt; <code>$+参数标识符+类型</code>  </p>\n<ol>\n<li><p><code>$</code> 这个前缀是干嘛的?<br>这显式说明, 它是 <code>metavariable</code>, 可以匹配并捕获代码片段, 这里会捕获表达式<br>至于为何要特意加$前缀来说明, 像函数参数那样直接用不行吗?<br>下面就要讲到啦, 别着急~  </p>\n</li>\n<li><p>先看看 <code>expr</code> 类型:<br><code>expr</code>, 全称为 <code>expression(表达式)</code><br>第一次宏调用时, 传入了 <code>1(一个字面量)</code>, 这当然是个expr, 与第一个rule成功匹配<br>这时, <code>my_macro!(1)</code> 这个部分, 就会被替换为相应的展开代码`<br>(matcher(匹配器),metavariable(元变量),transcriber(转录器)都用到了呢)  </p>\n</li>\n</ol>\n<p>简单来讲, macro的本质, 就是匹配捕获传入参数, 将调用部分替换/展开为相应代码<br>macro就像个code generator: 一段用来生成code的code  </p>\n<p>注意:<br>macro实际上, 是将传入部分解析为一个AST节点<br>然后将调用部分, 替换为一个新的AST节点<br>在本节下面, 会更详细地讲讲</p>\n<h2 id=\"元字面量\"><a href=\"#元字面量\" class=\"headerlink\" title=\"元字面量\"></a>元字面量</h2><p>元字面量, 即Metaliteral<br>为了加深印象与引出 <code>metaliteral</code> , 我们来玩个对应游戏:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">($a: expr) =&gt; &#123;$a&#125;;                     <span class=\"comment\">// the first rule</span></span><br><span class=\"line\">  |             |  </span><br><span class=\"line\">  |         \t|</span><br><span class=\"line\">( <span class=\"number\">1</span>      )      <span class=\"number\">1</span>                       <span class=\"comment\">// pass &amp;&amp; expand </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">($a: expr, $b: expr) =&gt; &#123; $a + $b&#125;;    <span class=\"comment\">// the second rule</span></span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">  |      |  |              |    |</span><br><span class=\"line\">( <span class=\"number\">1</span>      ,  <span class=\"number\">2</span>      ) =&gt;    <span class=\"number\">1</span> +  <span class=\"number\">2</span>      <span class=\"comment\">// pass &amp;&amp; expand</span></span><br></pre></td></tr></table></figure>\n\n<p>我使用 <code>|</code> 来联系 <code>形参 -- 实参</code><br>你会惊讶的发现, 传参时的对应关系们, 除了 <code>$a -- 1</code> 与 <code>$b -- 2</code>, 还有个 <code>, -- ,</code>  </p>\n<p>对于第二个rule, 它的定义中, 分割两个expr的逗号本身, 也是形参<br>这种固定的参数, 如同token中的字面量一样<br>我姑且称它为 <code>Literal Token(字面量标记)</code>, 或者 <code>Metaliteral (元字面量)</code><br>(因为我也不知道有什么对应术语, 所以用了 “姑且”, 知道的麻烦告诉我)  </p>\n<p>假若 rule 中的参数没有 $前缀 进行区分:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> fuck &#123;</span><br><span class=\"line\">    (a:expr) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    fuck!(<span class=\"number\">1</span>);       <span class=\"comment\">// No</span></span><br><span class=\"line\">    fuck!(a:expr);  <span class=\"comment\">// Yes ~~(Oh~)~~</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于定义中的 “a:expr”(它是 <code>MetaLiteral</code>)<br>传入固定形式的 “a:expr” 时才可发生匹配  </p>\n<p>切记:<br>当你想绑定一段代码片段,参数名前,必须加上$进行前缀修饰  </p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>假设有这么个宏 <code>map!</code>(联想一下<code>vec!</code>)<br>它能根据 <code>=&gt;</code> 判断出 <code>Key/Value</code>, 然后生成一个 <code>HashMap</code><br>如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map![</span><br><span class=\"line\">        <span class=\"string\">&quot;吉良吉影&quot;</span> =&gt; <span class=\"number\">33</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;空条承太郎&quot;</span> =&gt; <span class=\"number\">41</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// `m` 的类型为: std::collections::HashMap&lt;&amp;str, i32&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来写一个这样的宏吧!<br>不过我们还未学习 <code>重复语法</code>, 无法写出接收可变参数的 <code>map!</code>, 所以现在只讨论简陋版:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>这就是一个简陋的DSL, 你定义了创建HashMap的新语法: <code>Key=&gt;Value</code><br>来看看两种宏参数在宏中, 发挥着怎样的作用:  </p>\n<ul>\n<li><p><code>Metavariable</code>: 将捕获的传入的代码片段绑定到自身<br>并在 <code>Transcriber</code> 中被使用, 最后展开为新代码  </p>\n</li>\n<li><p><code>Metaliteral </code>: 限定了匹配, 传入的代码片段, 必须以 =&gt; 分割, 才能成功匹配<br>若改成 <code>map!(&quot;普通上班族&quot;, 33)</code>, 则每个rule的 <code>Matcher</code> 都无法匹配上<br>(这里只有一个rule, 空匹配的懒得放里面了)  </p>\n</li>\n</ul>\n<p>其实说了这么多, 简单讲就是一个对应游戏, 对应上的话, 就会替换为一些代码<br>考虑的事: 匹配的语法美不美观, 简不简单, 然后将复杂的代码隐藏, 就这样而已<br>之后会考虑讲几个小例子: 比如我在B站上已经录过的递推序列生成器教程, 源自宏小册<br>(博客的话, 我周六放学回来慢慢更吧……)<br><del>(潜台词是随时会鸽子)</del></p>\n<hr>\n<h1 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h1><p>macro的本质, 是生成一个AST节点<br>可以配套看看我在B站上宏视频, 视频讲得很浅, 容易理解  </p>\n<p>假若由你来设计一个Rust编译器<br>首先, 不同的人写代码的风格不同, 那么你如何分析不同源码, 并生成目标码?  </p>\n<p>若我们将每遍扫描并做点事情的过程, 称为<code>pass</code><br>pass一次就生成了, 对于很大的源码来说, 这不现实吧  </p>\n<p>那我们就pass多次, 将 <code>从源码编译为目标码</code> 这个大问题, 分解为一大堆小问题<br>每一次pass都解决一个小问题, 那不就Ok了吗</p>\n<p>这种 <code>中间表示</code>, 就称为 <code>IR (Intermediate Representation )</code>  </p>\n<p>我们可以先把源码抽象为AST(抽象语法树, Abstract Syntax Tree)<br>那是一种代码被抽象后的树状结构<br>比如我们用Rust的enum表示一下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该枚举: 一个AST节点可以是Int表达式或二元运算表达式  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASTNode</span></span> &#123;</span><br><span class=\"line\">    Int(<span class=\"built_in\">i32</span>), </span><br><span class=\"line\">    BinaryExpr &#123;</span><br><span class=\"line\">        op: Op,</span><br><span class=\"line\">        lhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">        rhs: <span class=\"built_in\">Box</span>&lt;ASTNode&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二元运算的符号: 这里只抽象了加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Op</span></span> &#123;</span><br><span class=\"line\">    Plus, </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你只需明白AST是对源码封装的一层抽象产物就可以了  </p>\n<p>对于很少的源码, 已经可以直接转换为目标码了, 毕竟这时候AST也小<br>但是, 如果源码很大呢? AST已经很复杂了<br>那就再抽象一层吧, 向目标语言逐渐靠拢, 比如向汇编靠拢, 提高性能  </p>\n<p>基于AST, 我们可以再来一些<code>IR</code>, 层层递进, 以达目的<br>注意,是一些,而不是一个,这很好理解,因为一层可能还是不够嘛  </p>\n<p><code>AST</code>很重要, 是生成目标码的关键, 是代码的骨架<br>而另外的IR, 也是有必要的, 这也增强了可维护性<br>编译器在AST的基础上, 最终生成了目标码    </p>\n<p>问: 生成AST需要点啥? 或者说, 它由什么组成?<br>答: 由 expr(表达式), stmt(语句), ;(标点符号) 等组成, 这些都叫做 <code>token</code>  </p>\n<p>在这些小玩意的基础上, 组成一个更加庞大复杂的整体结构<br>它将token们联系起来, 表达了代码的骨架<br>这个庞然大物便是 AST 了  </p>\n<hr>\n<h1 id=\"回到Macro\"><a href=\"#回到Macro\" class=\"headerlink\" title=\"回到Macro\"></a>回到Macro</h1><h2 id=\"Token类型表\"><a href=\"#Token类型表\" class=\"headerlink\" title=\"Token类型表\"></a>Token类型表</h2><p>生成AST需要Token协助<br>macro 中, 其参数的类型, 便是token类型  </p>\n<p>macro要操控传入的token (或AST节点, 等会讲)<br>那么我们总得知道token类型吧, 不然怎知咋操控?  </p>\n<p>只有规定宏参数的类型, 才能保证macro达到我们想要的目的 (这里指 <code>Metavariable</code>)  </p>\n<p>所以, 辛苦你将下面的记一下<br>稍微记下, 有印象即可, 多用几下保证你熟悉得不行:  </p>\n<ul>\n<li><code>ident</code> -&gt; 标识符,如函数名字,变量名字,关键字  </li>\n<li><code>stmt</code> -&gt; statemen,语句</li>\n<li><code>expr</code> -&gt; expression,表达式,如<code>x</code>与<code>1_i32</code></li>\n<li><code>literal</code> -&gt; literal expression,字面量表达式,expr的子集</li>\n<li><code>block</code> -&gt; 代码块  </li>\n<li><code>pat</code> -&gt; pattern, 比如在match表达式下的 (pattern) =&gt; todo!(),</li>\n<li><code>path</code> -&gt; 路径, 注意这里不指文件路径, 而是类似 std::io::stdin 的路径</li>\n<li><code>ty</code> -&gt; type, 如i32,u32,String,Option<T>等  </li>\n<li><code>tt</code> -&gt; token tree, 之后我会单独再讲解下它的  </li>\n<li><code>item</code> -&gt; 条目/项, 例如函数定义  </li>\n<li><code>meta</code> -&gt; 元条目/项, 比如#[allow(unsued)], meta就对应allow(unused)</li>\n<li><code>lifetime</code> -&gt; 生命周期  </li>\n<li><code>vis</code> -&gt; visibility, 可见性, 比如pub等, 也可能为空  </li>\n</ul>\n<h2 id=\"TT\"><a href=\"#TT\" class=\"headerlink\" title=\"TT\"></a>TT</h2><p>这里有个比较特殊的类型 <code>tt (Token Tree)</code><br>从字面上的意思来讲, 就是由Token组成的树(数据结构上的树)呗<del>(废话)</del>  </p>\n<p><code>tt</code>,可以捕获<code>Single Token</code>,或由(),[],{}及括号包裹起来的东西<br>作为 Token Tree 的根节点, 先让我们来点例子:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a:tt) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"built_in\">stringify!</span>($a));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Single Token</span></span><br><span class=\"line\">    aa!(<span class=\"number\">123</span>);          <span class=\"comment\">// Yes: 123</span></span><br><span class=\"line\">    aa!(FuckYou);      <span class=\"comment\">// Yes: FuckYou</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(Fuck You);     // No</span></span><br><span class=\"line\">    <span class=\"comment\">// aa!(123 + 11);     // No</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// (), [], &#123;&#125;</span></span><br><span class=\"line\">    aa!([<span class=\"number\">123</span>]);        <span class=\"comment\">// Yes: [123]</span></span><br><span class=\"line\">    aa!(&#123;<span class=\"number\">123</span> + <span class=\"number\">123</span>&#125;);  <span class=\"comment\">// Yes: &#123; 123 + 123 &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码, 展示了 <code>tt</code> 可以匹配捕获哪些东西<br>再来看看下面的内容, 理解理解它:<br>(我们以<code>&lt;&lt;xxx&gt;&gt;</code>, 来表示xxx是一颗 Token Tree)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你的眼中:</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span> + (<span class=\"number\">3</span> + <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// tt的眼中:</span></span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">2</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;( )&gt;&gt;</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                           |</span><br><span class=\"line\">                   &lt;&lt;<span class=\"number\">3</span>&gt;&gt; &lt;&lt;+&gt;&gt; &lt;&lt;<span class=\"number\">4</span>&gt;&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码的Token Tree共有5个:  </p>\n<ol>\n<li>&lt;&lt;1&gt;&gt;</li>\n<li>&lt;&lt;+&gt;&gt;</li>\n<li>&lt;&lt;2&gt;&gt;</li>\n<li>&lt;&lt;+&gt;&gt;</li>\n<li>&lt;&lt;(3 + 4)&gt;&gt;</li>\n</ol>\n<p>对于前面4个, 都是Single Token, 也就是只有根节点自己的Tree<br>对于第5个, 因为有()包裹, &lt;&lt;(…)&gt;&gt; 作为根节点, 它还有三个子节点(这里正好同层)  </p>\n<p>有没有对 <code>Token后面跟着Tree</code> 更加理解?  </p>\n<h2 id=\"AST节点\"><a href=\"#AST节点\" class=\"headerlink\" title=\"AST节点\"></a>AST节点</h2><p>macro 会将传入的token, 解析为对应类型的AST节点(除了少量token类型, 等下会讲)<br>比如 <code>map!</code> 中, <code>$key:value</code> 与 <code>$val:expr</code>, 都会被解析为expr类型的AST节点:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> map &#123;</span><br><span class=\"line\">    ($key:expr =&gt; $val:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> m = std::collections::HashMap::&lt;_,_&gt;::new();</span><br><span class=\"line\">        m.insert($key, $val);</span><br><span class=\"line\">        m</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> m = map!(<span class=\"string\">&quot;普通上班族&quot;</span> =&gt; <span class=\"number\">33</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 展开后, 可以看作是:</span></span><br><span class=\"line\"><span class=\"comment\">fn main() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    let m = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        let mut m = std::collections::HashMap::&lt;_,_&gt;::new();</span></span><br><span class=\"line\"><span class=\"comment\">        m.insert(&quot;普通上班族&quot;, 33);</span></span><br><span class=\"line\"><span class=\"comment\">        m</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">    println!(&quot;&#123;:?&#125;&quot;,m);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过使用 macro , 站在了更抽象的视角上<br>操控传入的token(或解析token后形成的AST节点), 组成新AST节点(生成新代码)    </p>\n<p>这可以大量简化手写量, 如std中向宏传入特定类型, 自动生成为它们实现trait的代码  </p>\n<p>值得注意的是, 宏将传入参数给AST节点化时, 有时意味着会产生不期望的结果<br>我直接用 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a> 上面的代码了:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> capture_then_match_tokens &#123;</span><br><span class=\"line\">    ($e:expr) =&gt; &#123;match_tokens!($e)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> match_tokens &#123;</span><br><span class=\"line\">    ($a:tt + $b:tt) =&gt; &#123;<span class=\"string\">&quot;got an addition&quot;</span>&#125;;</span><br><span class=\"line\">    (($i:ident)) =&gt; &#123;<span class=\"string\">&quot;got an identifier&quot;</span>&#125;;</span><br><span class=\"line\">    ($($other:tt)*) =&gt; &#123;<span class=\"string\">&quot;got something else&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;\\n&quot;</span>,</span><br><span class=\"line\">        match_tokens!((caravan)),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;\\n&#123;&#125;\\n&#123;&#125;&quot;</span>,</span><br><span class=\"line\">        capture_then_match_tokens!((caravan)),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">3</span> + <span class=\"number\">6</span>),</span><br><span class=\"line\">        capture_then_match_tokens!(<span class=\"number\">5</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果会是:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">got an identifier</span><br><span class=\"line\">got an addition</span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\"></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br><span class=\"line\">got something <span class=\"keyword\">else</span></span><br></pre></td></tr></table></figure>\n\n<p>比如这里, <code>match_tokens</code> 捕获token, 然后将参数解析为一个expr类型的AST节点<br>它不再是token, 而是个AST节点了!  </p>\n<p>比如 <code>5 + 7</code>, 原本是可以与 <code>$a:tt + $b:tt</code> 相匹配, 也可以与 <code>$a: expr</code> 匹配<br>但经二次传入后(向 <code>capture_then_match_tokens</code>传入的参数又传给 <code>match_tokens</code>)<br><code>5 + 7</code> 变成AST表达式节点, 只能与 <code>$a: expr</code>, 而不能与 <code>$a:tt + $b:tt</code> 匹配  </p>\n<p>只有 <code>tt</code>, <code>ident</code>, <code>lifetime</code> 能免遭 AST节点化, 可以好好理解下这块  </p>\n<p>总结:<br>宏将一些捕获的token给AST节点化, 随后又展开为一个新AST节点<br>这个新的AST节点, 会用来替换宏调用部分的AST节点, 因此你可以在很多地方调用宏<br>(只要宏展开的AST节点正确即可 :D)</p>\n<p>宏展开的结果是个某类型的AST节点, 这相比于C语言的 <code>#define</code> 宏, 有什么好处?<br>最直接的好处, 如下 <del>(相当于自动给你加上了括号)</del>:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C语言: 简单的文本替换</span></span><br><span class=\"line\">#define SUM(a,b) a+b</span><br><span class=\"line\">int main(void) &#123;</span><br><span class=\"line\">    SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>);     <span class=\"comment\">// 2 * 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * SUM(<span class=\"number\">2</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 5 * 2 + 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Rust语言: 根据上下文推测宏调用的AST节点应被展开为expr类型的AST节点</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($a:expr,$b:expr) =&gt; &#123;$a + $b&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>);     <span class=\"comment\">// 2 + 2</span></span><br><span class=\"line\">    <span class=\"number\">5</span> * sum!(<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 5 * (2 + 2)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"匹配注意点\"><a href=\"#匹配注意点\" class=\"headerlink\" title=\"匹配注意点\"></a>匹配注意点</h2><p>在我们传参时, 有个很常见的误解, 与为了以后宏的发展而有的限制<br>即下面要讲的东西, 有时间的也可以去看看 <a href=\"https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/mbe-min-captures-and-expansion-redux.md\">宏小册</a></p>\n<h3 id=\"匹配误区\"><a href=\"#匹配误区\" class=\"headerlink\" title=\"匹配误区\"></a>匹配误区</h3><p>来看看下面一段代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> aa &#123;</span><br><span class=\"line\">    ($a: expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">    ($a: ident +) =&gt; &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    aa!(a);   <span class=\"comment\">// Yes</span></span><br><span class=\"line\">    aa!(a+);  <span class=\"comment\">// No</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照你的直觉, <code>aa!(a+)</code> 应该会与第二个 rule 相匹配<br>但是实际上会报这么一个错误:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expected expression, found end of <span class=\"keyword\">macro</span> arguments</span><br><span class=\"line\"><span class=\"comment\">// 期望表达式, 却发现宏参数结束了</span></span><br></pre></td></tr></table></figure>\n\n<p>你会发现实际上都是在与第一个rule尝试着进行匹配:  </p>\n<p><code>a (lhs, left hand side)</code> 能被第一个rule匹配<br>而 <code>+ (二元加)</code> 因为可以尾随表达式, 也可以被第一个rule匹配<br>但由于缺少 <code>rhs</code>, 此时会直接报错, 而不是去尝试匹配下一个rule  </p>\n<p>这避免了某些情况下, 发生不期望的匹配, 但你却不知, 因此rule的顺序很重要  </p>\n<h3 id=\"歧义限制\"><a href=\"#歧义限制\" class=\"headerlink\" title=\"歧义限制\"></a>歧义限制</h3><p>由于一些歧义, 为了向后兼容性与不破坏代码<br>当前对 <code>Metavariable</code> 后面可以跟的内容有所限制, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">Rust-Reference: 限制</a><br>这里只需稍微看看, 留个印象, 实际使用时, 若在此方面报错, 则根据编译器的提示来改即可<br><del>(别问我为什么 xxx 类型后面, 加 yyy 这个符号不允许)</del><br><del>(因为我也没有全部搞懂)</del>  </p>\n<p>当然, 随着Rust声明宏的逐渐完善, 限制会逐渐减少(虽然也不多)  </p>\n<p>那么, 今天就到这了, 谢谢您的观看 :)</p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Mon Sep 20 2021 20:06:15 GMT+0800 (中国标准时间)","title":"rs-dm-p3-声明与使用","path":"posts/rs-decl-macro-p3.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>正式系统的关于 macro 的 声明与使用</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-20T12:06:15.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-20T12:06:15.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-dm-p4-重复","comments":0,"abbrlink":"posts/rs-decl-macro-p4","date":"2021-10-09T14:36:00.000Z","top":9896,"keywords":["macro","声明宏","Rust"],"_content":"> 宏中非常重要的语法: 重复(repetition)\n<!-- more -->\n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 介绍\n`重复 (Repetition)` 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n\n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n- Matcher: 将一段指定的模式, 重复地匹配与捕获\n- Transcriber: 将一段指定的模式, 重复地展开\n\n~~(废话, Rust的声明宏不就这两个主要部分嘛)~~  \n\n假设你要设计一个宏, 进行求和(参数个数不确定):  \n\n```rust\n// Examples:\nassert_eq!( 0,  sum!() );\nassert_eq!( 15, sum!(1,2,3,4,5) );\n```\n  \n让我们来看看, 如何使用重复吧\n\n# 语法  \n关键在于参数的个数不确定, 因此我们应使用重复语法:  \n```rust\nmacro_rules! sum {\n\t($($a:expr),*) => {\n\t\t0 $(+ $a)*\n\t}\n}\nfn main() {\n\tsum!();          // 0\n\tsum!(5);         // 5\n\tsum!(1,2,3,4,5); // 15\n}\n```\n\n伪代码表示:  \n```rust\n$( Pattern )   Sep    RepOp\n$(   模式   )  分隔符  重复符号\n```\n\n它可以被分为三个部分:  \n- 模式(Pattern): \n被包裹于 `$( )`, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n\n- 分隔符(Separator): \n用来分割重复的模式, 比如 `vec![1,2,3]` 中的逗号  \n\n- 重复符号(Repetition Operator): \n对模式匹配次数, 进行说明限制, 不符合就编译报错  \n\n\n以 `sum!` 为例子  \n它在第二个rule中用到了重复:  \n- In Matcher: \n模式: `$a:expr` 是重复的模式, 表示重复地匹配与捕获expr  \n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配  \n次数: *号, 说明了重复模式的个数, 它被限制为>=0  \n\n- In Transcriber: \n模式: `+ $a` 是重复模式, 比如传入 `1,2,3,4,5` 时, 会被展开为 `0+1+2+3+4+5`  \n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep\n次数:\t 同 Matcher  \n\n`$()` 与 `RepOp` 是必填的, `Sep` 是可选的  \n\nRepOp 有三种可选项, 有点像正则:\n- `*` 表示 模式匹配的次数 >= 0  \n记忆法-> 该符号看上去像是一个点, 联想为0\n- `+` 表示 模式匹配的次数 >= 1\n记忆法-> 联想为正数, 那就>=1\n- `?` 表示 模式匹配的次数 = 0 or 1  \n记忆法-> 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n1. 当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  \n2. Sep 是有限制的, [p3](https://jedsek.github.io/posts/rs-dm-p3#%E6%AD%A7%E4%B9%89%E9%99%90%E5%88%B6) 提到过, 详情可见 [rust-reference](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)\n\n以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看  ","source":"_posts/rs-dm/rs-dm-p4-重复.md","raw":"---\ntitle: rs-dm-p4-重复\ncomments: false\nabbrlink: posts/rs-decl-macro-p4\ndate: 2021-10-09 22:36:00\ntop: 9896\ntags: rust\nkeywords: [macro, 声明宏, Rust]\n---\n> 宏中非常重要的语法: 重复(repetition)\n<!-- more -->\n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 介绍\n`重复 (Repetition)` 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  \n\n该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  \n- Matcher: 将一段指定的模式, 重复地匹配与捕获\n- Transcriber: 将一段指定的模式, 重复地展开\n\n~~(废话, Rust的声明宏不就这两个主要部分嘛)~~  \n\n假设你要设计一个宏, 进行求和(参数个数不确定):  \n\n```rust\n// Examples:\nassert_eq!( 0,  sum!() );\nassert_eq!( 15, sum!(1,2,3,4,5) );\n```\n  \n让我们来看看, 如何使用重复吧\n\n# 语法  \n关键在于参数的个数不确定, 因此我们应使用重复语法:  \n```rust\nmacro_rules! sum {\n\t($($a:expr),*) => {\n\t\t0 $(+ $a)*\n\t}\n}\nfn main() {\n\tsum!();          // 0\n\tsum!(5);         // 5\n\tsum!(1,2,3,4,5); // 15\n}\n```\n\n伪代码表示:  \n```rust\n$( Pattern )   Sep    RepOp\n$(   模式   )  分隔符  重复符号\n```\n\n它可以被分为三个部分:  \n- 模式(Pattern): \n被包裹于 `$( )`, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  \n\n- 分隔符(Separator): \n用来分割重复的模式, 比如 `vec![1,2,3]` 中的逗号  \n\n- 重复符号(Repetition Operator): \n对模式匹配次数, 进行说明限制, 不符合就编译报错  \n\n\n以 `sum!` 为例子  \n它在第二个rule中用到了重复:  \n- In Matcher: \n模式: `$a:expr` 是重复的模式, 表示重复地匹配与捕获expr  \n分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配  \n次数: *号, 说明了重复模式的个数, 它被限制为>=0  \n\n- In Transcriber: \n模式: `+ $a` 是重复模式, 比如传入 `1,2,3,4,5` 时, 会被展开为 `0+1+2+3+4+5`  \n分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep\n次数:\t 同 Matcher  \n\n`$()` 与 `RepOp` 是必填的, `Sep` 是可选的  \n\nRepOp 有三种可选项, 有点像正则:\n- `*` 表示 模式匹配的次数 >= 0  \n记忆法-> 该符号看上去像是一个点, 联想为0\n- `+` 表示 模式匹配的次数 >= 1\n记忆法-> 联想为正数, 那就>=1\n- `?` 表示 模式匹配的次数 = 0 or 1  \n记忆法-> 问号表示疑问, 代表 有 or 没有  \n\n有一些注意点:  \n1. 当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  \n2. Sep 是有限制的, [p3](https://jedsek.github.io/posts/rs-dm-p3#%E6%AD%A7%E4%B9%89%E9%99%90%E5%88%B6) 提到过, 详情可见 [rust-reference](https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions)\n\n以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看  ","slug":"rs-dm/rs-dm-p4-重复","published":1,"updated":"2021-10-09T14:36:00.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9ms0009jaqy5xnyfu69","content":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  </p>\n<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  </p>\n<ul>\n<li>Matcher: 将一段指定的模式, 重复地匹配与捕获</li>\n<li>Transcriber: 将一段指定的模式, 重复地展开</li>\n</ul>\n<p><del>(废话, Rust的声明宏不就这两个主要部分嘛)</del>  </p>\n<p>假设你要设计一个宏, 进行求和(参数个数不确定):  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Examples:</span></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">0</span>,  sum!() );</span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">15</span>, sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) );</span><br></pre></td></tr></table></figure>\n<p>让我们来看看, 如何使用重复吧</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><p>关键在于参数的个数不确定, 因此我们应使用重复语法:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($a:expr),*) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> $(+ $a)*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();          <span class=\"comment\">// 0</span></span><br><span class=\"line\">    sum!(<span class=\"number\">5</span>);         <span class=\"comment\">// 5</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>伪代码表示:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$( Pattern )   Sep    RepOp</span><br><span class=\"line\">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>\n\n<p>它可以被分为三个部分:  </p>\n<ul>\n<li><p>模式(Pattern):<br>被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  </p>\n</li>\n<li><p>分隔符(Separator):<br>用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号  </p>\n</li>\n<li><p>重复符号(Repetition Operator):<br>对模式匹配次数, 进行说明限制, 不符合就编译报错  </p>\n</li>\n</ul>\n<p>以 <code>sum!</code> 为例子<br>它在第二个rule中用到了重复:  </p>\n<ul>\n<li><p>In Matcher:<br>模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0  </p>\n</li>\n<li><p>In Transcriber:<br>模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>次数:     同 Matcher  </p>\n</li>\n</ul>\n<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的  </p>\n<p>RepOp 有三种可选项, 有点像正则:</p>\n<ul>\n<li><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>记忆法-&gt; 该符号看上去像是一个点, 联想为0</li>\n<li><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>记忆法-&gt; 联想为正数, 那就&gt;=1</li>\n<li><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>记忆法-&gt; 问号表示疑问, 代表 有 or 没有  </li>\n</ul>\n<p>有一些注意点:  </p>\n<ol>\n<li>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  </li>\n<li>Sep 是有限制的, <a href=\"https://jedsek.github.io/posts/rs-dm-p3#%E6%AD%A7%E4%B9%89%E9%99%90%E5%88%B6\">p3</a> 提到过, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">rust-reference</a></li>\n</ol>\n<p>以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p><code>重复 (Repetition)</code> 是宏中无比重要的核心级语法, 想发挥宏的强大就必须用到它  </p>\n<p>该语法, 可以重复一段模式(一些Token), 出现在以下两个地方:  </p>\n<ul>\n<li>Matcher: 将一段指定的模式, 重复地匹配与捕获</li>\n<li>Transcriber: 将一段指定的模式, 重复地展开</li>\n</ul>\n<p><del>(废话, Rust的声明宏不就这两个主要部分嘛)</del>  </p>\n<p>假设你要设计一个宏, 进行求和(参数个数不确定):  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Examples:</span></span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">0</span>,  sum!() );</span><br><span class=\"line\"><span class=\"built_in\">assert_eq!</span>( <span class=\"number\">15</span>, sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>) );</span><br></pre></td></tr></table></figure>\n<p>让我们来看看, 如何使用重复吧</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><p>关键在于参数的个数不确定, 因此我们应使用重复语法:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($a:expr),*) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span> $(+ $a)*</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    sum!();          <span class=\"comment\">// 0</span></span><br><span class=\"line\">    sum!(<span class=\"number\">5</span>);         <span class=\"comment\">// 5</span></span><br><span class=\"line\">    sum!(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>伪代码表示:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$( Pattern )   Sep    RepOp</span><br><span class=\"line\">$(   模式   )  分隔符  重复符号</span><br></pre></td></tr></table></figure>\n\n<p>它可以被分为三个部分:  </p>\n<ul>\n<li><p>模式(Pattern):<br>被包裹于 <code>$( )</code>, 用于匹配捕获(在Matcher), 或重复展开(在Transcriber)  </p>\n</li>\n<li><p>分隔符(Separator):<br>用来分割重复的模式, 比如 <code>vec![1,2,3]</code> 中的逗号  </p>\n</li>\n<li><p>重复符号(Repetition Operator):<br>对模式匹配次数, 进行说明限制, 不符合就编译报错  </p>\n</li>\n</ul>\n<p>以 <code>sum!</code> 为例子<br>它在第二个rule中用到了重复:  </p>\n<ul>\n<li><p>In Matcher:<br>模式: <code>$a:expr</code> 是重复的模式, 表示重复地匹配与捕获expr<br>分割: 每个模式之间用逗号分割, 表示传参时要传入逗号进行匹配<br>次数: *号, 说明了重复模式的个数, 它被限制为&gt;=0  </p>\n</li>\n<li><p>In Transcriber:<br>模式: <code>+ $a</code> 是重复模式, 比如传入 <code>1,2,3,4,5</code> 时, 会被展开为 <code>0+1+2+3+4+5</code><br>分割: 没添加分割符号, 表示展开时, 每个模式之间不会添加sep<br>次数:     同 Matcher  </p>\n</li>\n</ul>\n<p><code>$()</code> 与 <code>RepOp</code> 是必填的, <code>Sep</code> 是可选的  </p>\n<p>RepOp 有三种可选项, 有点像正则:</p>\n<ul>\n<li><code>*</code> 表示 模式匹配的次数 &gt;= 0<br>记忆法-&gt; 该符号看上去像是一个点, 联想为0</li>\n<li><code>+</code> 表示 模式匹配的次数 &gt;= 1<br>记忆法-&gt; 联想为正数, 那就&gt;=1</li>\n<li><code>?</code> 表示 模式匹配的次数 = 0 or 1<br>记忆法-&gt; 问号表示疑问, 代表 有 or 没有  </li>\n</ul>\n<p>有一些注意点:  </p>\n<ol>\n<li>当 RepOp 为 ? 时, 不可以添加 Sep(因为最多也就匹配到一次, 你怎么分割?)  </li>\n<li>Sep 是有限制的, <a href=\"https://jedsek.github.io/posts/rs-dm-p3#%E6%AD%A7%E4%B9%89%E9%99%90%E5%88%B6\">p3</a> 提到过, 详情可见 <a href=\"https://doc.rust-lang.org/stable/reference/macros-by-example.html#follow-set-ambiguity-restrictions\">rust-reference</a></li>\n</ol>\n<p>以后想到了再补充一些东西, 先到这里吧, 谢谢您的观看  </p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Oct 09 2021 22:36:00 GMT+0800 (中国标准时间)","title":"rs-dm-p4-重复","path":"posts/rs-decl-macro-p4.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>宏中非常重要的语法: 重复(repetition)</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-10-09T14:36:00.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-10-09T14:36:00.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-gtk4-p1-系列说明","comments":0,"abbrlink":"posts/rs-gtk4-p1","date":"2021-10-23T12:18:17.000Z","top":9799,"keywords":["rust","gui","gtk4"],"_content":"> 欢迎大家来到 Rust 的 gkt-rs 系列\n<!-- more -->\n# 系列说明\n[Gtk](https://www.gtk.org/), 是一个著名的GUI库, 是 GNOME 项目的关键组成  \n由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发  \n\nRust语言自是其中之一, 具有相关的绑定库: [gtk-rs](https://gtk-rs.org/) (gtk官方网页所指定)  \n同时, 非常建议你使用Linux作为开发环境, 因为GTK专注于Linux版本  \n\n我也是 gtk-rs 的新手, 依靠发表博客来巩固所学  \n顺便也能帮助和我一样的新鸟们 (老鸟别笑我啊喂!)  \n\n\n不定期更新, 毕竟我只有周末才能碰到电脑  \n~~(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)~~\n\n同系列传送门: [rust-gtk4系列](https://jedsek.github.io/categories/rust-gtk4)\n\n- - -\n# 参考资料\n资料正在持续更新ing. . .\n1. 书籍\n- [GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/)\n2. 博客/文档\n- [Rust Vs GUI](https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html)\n- [GObject Introspection](https://gi.readthedocs.io/en/latest/#gobject-introspection)\n- [GNOME Developer Doc/Tutorials](https://developer.gnome.org/documentation/tutorials.html)\n- - -\n# 环境配置\n首先请参照 [GTK官方页面](https://www.gtk.org/docs/installations/) , 根据相应操作系统, 下载 GTK(版本是GTK4)  \n\n本人的操作系统为manjaro 选择它是因为不需过多操心配置方面  \n\nubuntu系统, 听说2021版已经使用gnome作为桌面环境了(gnome用gtk写的)  \n\nwindows系统建议使用archlinux版的wsl(亲测可以做gui, 虽然目前还有点问题)  \n比如wsl下安装gtk4, 只需一行:  \n\n```bash\nsudo pacman -S gtk4\n```\n\n其他系统, 请自己找下资料, 善用搜索引擎与官方文档  \n\n本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进  \n\n- - -\n# 欢迎骚扰\n1. 发现错误的话, 请及时跟我联系  \n2. 可以通过博客侧边栏上的联系方式找到我  \n3. 欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n\n\n","source":"_posts/rs-gtk4/rs-gtk4-p1-系列说明.md","raw":"---\ntitle: rs-gtk4-p1-系列说明\ncomments: false\nabbrlink: posts/rs-gtk4-p1\ndate: 2021-10-23 20:18:17\ntop: 9799\ntags: [rust, gui]\nkeywords: [rust, gui, gtk4]\n---\n> 欢迎大家来到 Rust 的 gkt-rs 系列\n<!-- more -->\n# 系列说明\n[Gtk](https://www.gtk.org/), 是一个著名的GUI库, 是 GNOME 项目的关键组成  \n由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发  \n\nRust语言自是其中之一, 具有相关的绑定库: [gtk-rs](https://gtk-rs.org/) (gtk官方网页所指定)  \n同时, 非常建议你使用Linux作为开发环境, 因为GTK专注于Linux版本  \n\n我也是 gtk-rs 的新手, 依靠发表博客来巩固所学  \n顺便也能帮助和我一样的新鸟们 (老鸟别笑我啊喂!)  \n\n\n不定期更新, 毕竟我只有周末才能碰到电脑  \n~~(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)~~\n\n同系列传送门: [rust-gtk4系列](https://jedsek.github.io/categories/rust-gtk4)\n\n- - -\n# 参考资料\n资料正在持续更新ing. . .\n1. 书籍\n- [GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/)\n2. 博客/文档\n- [Rust Vs GUI](https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html)\n- [GObject Introspection](https://gi.readthedocs.io/en/latest/#gobject-introspection)\n- [GNOME Developer Doc/Tutorials](https://developer.gnome.org/documentation/tutorials.html)\n- - -\n# 环境配置\n首先请参照 [GTK官方页面](https://www.gtk.org/docs/installations/) , 根据相应操作系统, 下载 GTK(版本是GTK4)  \n\n本人的操作系统为manjaro 选择它是因为不需过多操心配置方面  \n\nubuntu系统, 听说2021版已经使用gnome作为桌面环境了(gnome用gtk写的)  \n\nwindows系统建议使用archlinux版的wsl(亲测可以做gui, 虽然目前还有点问题)  \n比如wsl下安装gtk4, 只需一行:  \n\n```bash\nsudo pacman -S gtk4\n```\n\n其他系统, 请自己找下资料, 善用搜索引擎与官方文档  \n\n本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进  \n\n- - -\n# 欢迎骚扰\n1. 发现错误的话, 请及时跟我联系  \n2. 可以通过博客侧边栏上的联系方式找到我  \n3. 欢迎在留言版中留言, 本人会定期查看  \n\n最后, 谢谢你的观看 :)\n\n\n","slug":"rs-gtk4/rs-gtk4-p1-系列说明","published":1,"updated":"2021-10-23T12:18:17.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mt000cjaqyg0af1n6n","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"系列说明\"><a href=\"#系列说明\" class=\"headerlink\" title=\"系列说明\"></a>系列说明</h1><p><a href=\"https://www.gtk.org/\">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成<br>由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发  </p>\n<p>Rust语言自是其中之一, 具有相关的绑定库: <a href=\"https://gtk-rs.org/\">gtk-rs</a> (gtk官方网页所指定)<br>同时, 非常建议你使用Linux作为开发环境, 因为GTK专注于Linux版本  </p>\n<p>我也是 gtk-rs 的新手, 依靠发表博客来巩固所学<br>顺便也能帮助和我一样的新鸟们 (老鸟别笑我啊喂!)  </p>\n<p>不定期更新, 毕竟我只有周末才能碰到电脑<br><del>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</del></p>\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-gtk4\">rust-gtk4系列</a></p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>资料正在持续更新ing. . .</p>\n<ol>\n<li>书籍</li>\n</ol>\n<ul>\n<li><a href=\"https://gtk-rs.org/gtk4-rs/stable/latest/book/\">GUI development with Rust and GTK 4</a></li>\n</ul>\n<ol start=\"2\">\n<li>博客/文档</li>\n</ol>\n<ul>\n<li><a href=\"https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html\">Rust Vs GUI</a></li>\n<li><a href=\"https://gi.readthedocs.io/en/latest/#gobject-introspection\">GObject Introspection</a></li>\n<li><a href=\"https://developer.gnome.org/documentation/tutorials.html\">GNOME Developer Doc/Tutorials</a></li>\n</ul>\n<hr>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><p>首先请参照 <a href=\"https://www.gtk.org/docs/installations/\">GTK官方页面</a> , 根据相应操作系统, 下载 GTK(版本是GTK4)  </p>\n<p>本人的操作系统为manjaro 选择它是因为不需过多操心配置方面  </p>\n<p>ubuntu系统, 听说2021版已经使用gnome作为桌面环境了(gnome用gtk写的)  </p>\n<p>windows系统建议使用archlinux版的wsl(亲测可以做gui, 虽然目前还有点问题)<br>比如wsl下安装gtk4, 只需一行:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gtk4</span><br></pre></td></tr></table></figure>\n\n<p>其他系统, 请自己找下资料, 善用搜索引擎与官方文档  </p>\n<p>本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进  </p>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><ol>\n<li>发现错误的话, 请及时跟我联系  </li>\n<li>可以通过博客侧边栏上的联系方式找到我  </li>\n<li>欢迎在留言版中留言, 本人会定期查看  </li>\n</ol>\n<p>最后, 谢谢你的观看 :)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>","more":"<h1 id=\"系列说明\"><a href=\"#系列说明\" class=\"headerlink\" title=\"系列说明\"></a>系列说明</h1><p><a href=\"https://www.gtk.org/\">Gtk</a>, 是一个著名的GUI库, 是 GNOME 项目的关键组成<br>由于其语言绑定的特色, 可以让各类语言使用它, 来进行开发  </p>\n<p>Rust语言自是其中之一, 具有相关的绑定库: <a href=\"https://gtk-rs.org/\">gtk-rs</a> (gtk官方网页所指定)<br>同时, 非常建议你使用Linux作为开发环境, 因为GTK专注于Linux版本  </p>\n<p>我也是 gtk-rs 的新手, 依靠发表博客来巩固所学<br>顺便也能帮助和我一样的新鸟们 (老鸟别笑我啊喂!)  </p>\n<p>不定期更新, 毕竟我只有周末才能碰到电脑<br><del>(而且, 空洞骑士, CSGO, 老滚5, 巫师3, 人类一败涂地它们不香吗?)</del></p>\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-gtk4\">rust-gtk4系列</a></p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>资料正在持续更新ing. . .</p>\n<ol>\n<li>书籍</li>\n</ol>\n<ul>\n<li><a href=\"https://gtk-rs.org/gtk4-rs/stable/latest/book/\">GUI development with Rust and GTK 4</a></li>\n</ul>\n<ol start=\"2\">\n<li>博客/文档</li>\n</ol>\n<ul>\n<li><a href=\"https://turbomack.github.io/posts/2019-07-28-rust-vs-gui.html\">Rust Vs GUI</a></li>\n<li><a href=\"https://gi.readthedocs.io/en/latest/#gobject-introspection\">GObject Introspection</a></li>\n<li><a href=\"https://developer.gnome.org/documentation/tutorials.html\">GNOME Developer Doc/Tutorials</a></li>\n</ul>\n<hr>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><p>首先请参照 <a href=\"https://www.gtk.org/docs/installations/\">GTK官方页面</a> , 根据相应操作系统, 下载 GTK(版本是GTK4)  </p>\n<p>本人的操作系统为manjaro 选择它是因为不需过多操心配置方面  </p>\n<p>ubuntu系统, 听说2021版已经使用gnome作为桌面环境了(gnome用gtk写的)  </p>\n<p>windows系统建议使用archlinux版的wsl(亲测可以做gui, 虽然目前还有点问题)<br>比如wsl下安装gtk4, 只需一行:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gtk4</span><br></pre></td></tr></table></figure>\n\n<p>其他系统, 请自己找下资料, 善用搜索引擎与官方文档  </p>\n<p>本文发布在2021的下半年, 希望当你看见本文时, gtk在这方面能有所长进  </p>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><ol>\n<li>发现错误的话, 请及时跟我联系  </li>\n<li>可以通过博客侧边栏上的联系方式找到我  </li>\n<li>欢迎在留言版中留言, 本人会定期查看  </li>\n</ol>\n<p>最后, 谢谢你的观看 :)</p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Oct 23 2021 20:18:17 GMT+0800 (中国标准时间)","title":"rs-gtk4-p1-系列说明","path":"posts/rs-gtk4-p1.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 gkt-rs 系列</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-10-23T12:18:17.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-10-23T12:18:17.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust","gui"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-dm-p5-卫生性","comments":0,"abbrlink":"posts/rs-decl-macro-p5","date":"2021-10-16T06:04:12.000Z","top":9895,"keywords":["macro","声明宏","Rust"],"_content":"> 本节将介绍宏的 卫生性(hygienic)\n<!-- more -->\n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 开篇\n什么是 卫生性(Hygienic) 呢?\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染  \n如果你是第一次接触此概念, 我不信你不会懵逼  \n不过实际上, 这个概念理解起来不算困难  \n\n让我们先来讨论一个问题, 请看下面的代码:\n```rust\nmacro_rules! create_var {\n\t() => {\n\t\tlet a = 1;\n\t};\n}\nfn main() {\n\tcreate_var!();\n\tprintln!(\"{}\",a);\n}\n```\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","source":"_posts/rs-dm/rs-dm-p5-卫生性.md","raw":"---\ntitle: rs-dm-p5-卫生性\ncomments: false\nabbrlink: posts/rs-decl-macro-p5\ndate: 2021-10-16 14:04:12\ntop: 9895\ntags: rust\nkeywords: [macro, 声明宏, Rust]\n---\n> 本节将介绍宏的 卫生性(hygienic)\n<!-- more -->\n\n同系列传送门: [rust-decl-macro系列](https://jedsek.github.io/categories/rust-decl-macro)\n\n# 开篇\n什么是 卫生性(Hygienic) 呢?\n简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染  \n如果你是第一次接触此概念, 我不信你不会懵逼  \n不过实际上, 这个概念理解起来不算困难  \n\n让我们先来讨论一个问题, 请看下面的代码:\n```rust\nmacro_rules! create_var {\n\t() => {\n\t\tlet a = 1;\n\t};\n}\nfn main() {\n\tcreate_var!();\n\tprintln!(\"{}\",a);\n}\n```\n你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  \n","slug":"rs-dm/rs-dm-p5-卫生性","published":1,"updated":"2021-10-16T06:04:12.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mt000djaqy80oddm4y","content":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>什么是 卫生性(Hygienic) 呢?<br>简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>如果你是第一次接触此概念, 我不信你不会懵逼<br>不过实际上, 这个概念理解起来不算困难  </p>\n<p>让我们先来讨论一个问题, 请看下面的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_var &#123;</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_var!();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-decl-macro\">rust-decl-macro系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>什么是 卫生性(Hygienic) 呢?<br>简单来说,就是标识符(ident)在宏的处理与展开时,是无歧义的,不被同名标识符污染<br>如果你是第一次接触此概念, 我不信你不会懵逼<br>不过实际上, 这个概念理解起来不算困难  </p>\n<p>让我们先来讨论一个问题, 请看下面的代码:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_var &#123;</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    create_var!();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以复制该段代码, 然后运行, 将得到一个编译错误, 提示找不到a  </p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Oct 16 2021 14:04:12 GMT+0800 (中国标准时间)","title":"rs-dm-p5-卫生性","path":"posts/rs-decl-macro-p5.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>本节将介绍宏的 卫生性(hygienic)</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-10-16T06:04:12.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-10-16T06:04:12.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-gtk4-p2-创建HelloWorld窗口","comments":0,"abbrlink":"posts/rs-gtk4-p2","date":"2021-11-07T02:16:57.000Z","top":9798,"keywords":["rust","gui","gtk4"],"_content":"> 让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧\n<!-- more -->\n\n同系列传送门: [rust-gtk4系列](https://jedsek.github.io/categories/rust-gtk4)\n\n# 背景  \n## GTK是什么\nGTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n\n其特点之一, 是能轻松地创建绑定:  \n在gtk3后, 由于GI([GObject Introspection](https://gi.readthedocs.io/en/latest/)) 的应用, 可以轻松地, 创建其他语言的绑定  \n\n这使你能利用不同语言编写GUI  \n比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言  \n而不是用C去编写(用C会很繁杂, 不清晰)  \n\n基本上名气稍微大点的语言, 都有对应的GTK绑定    \n## gtk-rs\n目前有个项目, 叫做 [gtk-rs](https://gtk-rs.org/), 负责GTK的Rust语言绑定  \n你在 crates.io 上搜索 gtk, 所看到的 [gtk](https://crates.io/crates/gtk) 与 [gtk4](https://crates.io/crates/gtk4), 就属于gtk-rs项目\n\n前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍  \ngtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)  \n\n对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)  \n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本  \n不然crate会装不上  \n- - -\n# 配置\n首先, 你需要创建一个新项目  \n随后修改 Cargo.toml, 如下:  \n\n```toml\n[dependencies]\ngtk = {version = \"0.3.1\", package = \"gtk4\"}\n```\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写 (这是个惯例)  \n随后, 请run一下, 安装依赖 (请确保安装了gtk4)  \n\n下面就是正式的编码环节了\n- - -\n# 编写\n一个GTK4应用的创建, 需要用到 `gtk::Application`  \n同时, 我们还需 `use gtk::prelude::*`  \n原因与 [std::prelude](https://doc.rust-lang.org/std/prelude/index.html) 或 std::io::prelude 一样  \n\n先创建一个应用, 它目前连窗口也没有:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\nfn main() {\n    let app = Application::builder()\n        .application_id(\"io.github.jedsek.myapp\")\n        .build();\n    app.run();\n}\n```\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\n- [Builder Pattern (一种Rust中常见的设计模式)](http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html):  \n这个无需多言, 我们可以利用它, 进行链式构造, 让构造的过程更加清晰  \n在这里, 我们只调用了一次链式函数: application_id(id: &str)  \n比如 [std::fs::OpenOptions](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html) 就使用了构造者模式  \n在学习gtk4时, 它将被较高频次地使用, 最后使用 build 生成\n\n- [application_id](https://developer.gnome.org/documentation/tutorials/application-id.html):  \n每个GTK应用, 都带有一个id, 即 `application_id`, 它必须是全世界唯一的  \n一般使用反域名, 作为id  \n比如 “org.gnome.gedit” , \"io.github.jedsek.myapp\"  \n\n但当你跃跃欲试, cargo run之后, 会看到:  \n\n```\nGLib-GIO-WARNING : Your application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal.  \nIt should do one of these.\n```\n\n我们实际上还要添加一个名为 activate 的信号量(Signal)  \n信号量的概念之后会再讲，现在只需明白, 你得像下面这样写:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\nfn main() {\n    let app = Application::builder()\n        .application_id(\"io.github.jedsek.demo\")\n        .build();\n    app.connect_activate(on_activate);\n    app.run();\n}\n\nfn on_activate(app: &Application) {\n\ttodo!()\n}\n```\n\n请容许我对上面的东西来点小小的解释:  \n当一个gtk应用开始运行之\n\n","source":"_posts/rs-gtk4/rs-gtk4-p2-创建HelloWorld的GUI窗口.md","raw":"---\ntitle: rs-gtk4-p2-创建HelloWorld窗口\ncomments: false\nabbrlink: posts/rs-gtk4-p2\ndate: 2021-11-07 10:16:57\ntop: 9798\ntags: [rust, gui]\nkeywords: [rust, gui, gtk4]\n---\n> 让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧\n<!-- more -->\n\n同系列传送门: [rust-gtk4系列](https://jedsek.github.io/categories/rust-gtk4)\n\n# 背景  \n## GTK是什么\nGTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  \n\n其特点之一, 是能轻松地创建绑定:  \n在gtk3后, 由于GI([GObject Introspection](https://gi.readthedocs.io/en/latest/)) 的应用, 可以轻松地, 创建其他语言的绑定  \n\n这使你能利用不同语言编写GUI  \n比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言  \n而不是用C去编写(用C会很繁杂, 不清晰)  \n\n基本上名气稍微大点的语言, 都有对应的GTK绑定    \n## gtk-rs\n目前有个项目, 叫做 [gtk-rs](https://gtk-rs.org/), 负责GTK的Rust语言绑定  \n你在 crates.io 上搜索 gtk, 所看到的 [gtk](https://crates.io/crates/gtk) 与 [gtk4](https://crates.io/crates/gtk4), 就属于gtk-rs项目\n\n前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍  \ngtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)  \n\n对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)  \n所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本  \n不然crate会装不上  \n- - -\n# 配置\n首先, 你需要创建一个新项目  \n随后修改 Cargo.toml, 如下:  \n\n```toml\n[dependencies]\ngtk = {version = \"0.3.1\", package = \"gtk4\"}\n```\n\n我们将 gtk4(crate), 重命名为 gtk, 方便之后编写 (这是个惯例)  \n随后, 请run一下, 安装依赖 (请确保安装了gtk4)  \n\n下面就是正式的编码环节了\n- - -\n# 编写\n一个GTK4应用的创建, 需要用到 `gtk::Application`  \n同时, 我们还需 `use gtk::prelude::*`  \n原因与 [std::prelude](https://doc.rust-lang.org/std/prelude/index.html) 或 std::io::prelude 一样  \n\n先创建一个应用, 它目前连窗口也没有:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\nfn main() {\n    let app = Application::builder()\n        .application_id(\"io.github.jedsek.myapp\")\n        .build();\n    app.run();\n}\n```\n\n很简单吧? 但别急着运行, 先看看下面两处:  \n\n- [Builder Pattern (一种Rust中常见的设计模式)](http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html):  \n这个无需多言, 我们可以利用它, 进行链式构造, 让构造的过程更加清晰  \n在这里, 我们只调用了一次链式函数: application_id(id: &str)  \n比如 [std::fs::OpenOptions](https://doc.rust-lang.org/std/fs/struct.OpenOptions.html) 就使用了构造者模式  \n在学习gtk4时, 它将被较高频次地使用, 最后使用 build 生成\n\n- [application_id](https://developer.gnome.org/documentation/tutorials/application-id.html):  \n每个GTK应用, 都带有一个id, 即 `application_id`, 它必须是全世界唯一的  \n一般使用反域名, 作为id  \n比如 “org.gnome.gedit” , \"io.github.jedsek.myapp\"  \n\n但当你跃跃欲试, cargo run之后, 会看到:  \n\n```\nGLib-GIO-WARNING : Your application does not implement g_application_activate()\nand has no handlers connected to the 'activate' signal.  \nIt should do one of these.\n```\n\n我们实际上还要添加一个名为 activate 的信号量(Signal)  \n信号量的概念之后会再讲，现在只需明白, 你得像下面这样写:  \n\n```rust\nuse gtk::prelude::*;\nuse gtk::Application;\nfn main() {\n    let app = Application::builder()\n        .application_id(\"io.github.jedsek.demo\")\n        .build();\n    app.connect_activate(on_activate);\n    app.run();\n}\n\nfn on_activate(app: &Application) {\n\ttodo!()\n}\n```\n\n请容许我对上面的东西来点小小的解释:  \n当一个gtk应用开始运行之\n\n","slug":"rs-gtk4/rs-gtk4-p2-创建HelloWorld的GUI窗口","published":1,"updated":"2021-11-07T02:16:57.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mv000fjaqyf0xeauda","content":"<blockquote>\n<p>让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-gtk4\">rust-gtk4系列</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><h2 id=\"GTK是什么\"><a href=\"#GTK是什么\" class=\"headerlink\" title=\"GTK是什么\"></a>GTK是什么</h2><p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  </p>\n<p>其特点之一, 是能轻松地创建绑定:<br>在gtk3后, 由于GI(<a href=\"https://gi.readthedocs.io/en/latest/\">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定  </p>\n<p>这使你能利用不同语言编写GUI<br>比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言<br>而不是用C去编写(用C会很繁杂, 不清晰)  </p>\n<p>基本上名气稍微大点的语言, 都有对应的GTK绑定    </p>\n<h2 id=\"gtk-rs\"><a href=\"#gtk-rs\" class=\"headerlink\" title=\"gtk-rs\"></a>gtk-rs</h2><p>目前有个项目, 叫做 <a href=\"https://gtk-rs.org/\">gtk-rs</a>, 负责GTK的Rust语言绑定<br>你在 crates.io 上搜索 gtk, 所看到的 <a href=\"https://crates.io/crates/gtk\">gtk</a> 与 <a href=\"https://crates.io/crates/gtk4\">gtk4</a>, 就属于gtk-rs项目</p>\n<p>前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍<br>gtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)  </p>\n<p>对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)<br>所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本<br>不然crate会装不上  </p>\n<hr>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>首先, 你需要创建一个新项目<br>随后修改 Cargo.toml, 如下:  </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">gtk</span> = &#123;version = <span class=\"string\">&quot;0.3.1&quot;</span>, package = <span class=\"string\">&quot;gtk4&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写 (这是个惯例)<br>随后, 请run一下, 安装依赖 (请确保安装了gtk4)  </p>\n<p>下面就是正式的编码环节了</p>\n<hr>\n<h1 id=\"编写\"><a href=\"#编写\" class=\"headerlink\" title=\"编写\"></a>编写</h1><p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>同时, 我们还需 <code>use gtk::prelude::*</code><br>原因与 <a href=\"https://doc.rust-lang.org/std/prelude/index.html\">std::prelude</a> 或 std::io::prelude 一样  </p>\n<p>先创建一个应用, 它目前连窗口也没有:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder()</span><br><span class=\"line\">        .application_id(<span class=\"string\">&quot;io.github.jedsek.myapp&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单吧? 但别急着运行, 先看看下面两处:  </p>\n<ul>\n<li><p><a href=\"http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html\">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>这个无需多言, 我们可以利用它, 进行链式构造, 让构造的过程更加清晰<br>在这里, 我们只调用了一次链式函数: application_id(id: &amp;str)<br>比如 <a href=\"https://doc.rust-lang.org/std/fs/struct.OpenOptions.html\">std::fs::OpenOptions</a> 就使用了构造者模式<br>在学习gtk4时, 它将被较高频次地使用, 最后使用 build 生成</p>\n</li>\n<li><p><a href=\"https://developer.gnome.org/documentation/tutorials/application-id.html\">application_id</a>:<br>每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的<br>一般使用反域名, 作为id<br>比如 “org.gnome.gedit” , “io.github.jedsek.myapp”  </p>\n</li>\n</ul>\n<p>但当你跃跃欲试, cargo run之后, 会看到:  </p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLib-GIO-<span class=\"builtin-name\">WARNING</span> : Your application does <span class=\"keyword\">not</span> implement g_application_activate()</span><br><span class=\"line\"><span class=\"keyword\">and</span> has <span class=\"literal\">no</span> handlers connected <span class=\"keyword\">to</span> the <span class=\"string\">&#x27;activate&#x27;</span> signal.  </span><br><span class=\"line\">It should <span class=\"keyword\">do</span> one of these.</span><br></pre></td></tr></table></figure>\n\n<p>我们实际上还要添加一个名为 activate 的信号量(Signal)<br>信号量的概念之后会再讲，现在只需明白, 你得像下面这样写:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder()</span><br><span class=\"line\">        .application_id(<span class=\"string\">&quot;io.github.jedsek.demo&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    app.connect_activate(on_activate);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">on_activate</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请容许我对上面的东西来点小小的解释:<br>当一个gtk应用开始运行之</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-gtk4\">rust-gtk4系列</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><h2 id=\"GTK是什么\"><a href=\"#GTK是什么\" class=\"headerlink\" title=\"GTK是什么\"></a>GTK是什么</h2><p>GTK, 简单来说是个有名的GUI库, 开源免费, 用C编写  </p>\n<p>其特点之一, 是能轻松地创建绑定:<br>在gtk3后, 由于GI(<a href=\"https://gi.readthedocs.io/en/latest/\">GObject Introspection</a>) 的应用, 可以轻松地, 创建其他语言的绑定  </p>\n<p>这使你能利用不同语言编写GUI<br>比如, 你能用vala/js/python/rust/nim, 甚至自创的编程语言<br>而不是用C去编写(用C会很繁杂, 不清晰)  </p>\n<p>基本上名气稍微大点的语言, 都有对应的GTK绑定    </p>\n<h2 id=\"gtk-rs\"><a href=\"#gtk-rs\" class=\"headerlink\" title=\"gtk-rs\"></a>gtk-rs</h2><p>目前有个项目, 叫做 <a href=\"https://gtk-rs.org/\">gtk-rs</a>, 负责GTK的Rust语言绑定<br>你在 crates.io 上搜索 gtk, 所看到的 <a href=\"https://crates.io/crates/gtk\">gtk</a> 与 <a href=\"https://crates.io/crates/gtk4\">gtk4</a>, 就属于gtk-rs项目</p>\n<p>前者对应gtk3, 六年前就在维护, 所以下载量比gtk4多好几倍<br>gtk4这个crate, 则是在不久前开始维护的 (毕竟gtk4也才出现)  </p>\n<p>对了, gtk4这个crate是Rust语言绑定, 而非gtk4本身(那个纯C写的)<br>所以进行接下来的步骤前, 请确保环境内, 已有gtk4本身的正确版本<br>不然crate会装不上  </p>\n<hr>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>首先, 你需要创建一个新项目<br>随后修改 Cargo.toml, 如下:  </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">gtk</span> = &#123;version = <span class=\"string\">&quot;0.3.1&quot;</span>, package = <span class=\"string\">&quot;gtk4&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将 gtk4(crate), 重命名为 gtk, 方便之后编写 (这是个惯例)<br>随后, 请run一下, 安装依赖 (请确保安装了gtk4)  </p>\n<p>下面就是正式的编码环节了</p>\n<hr>\n<h1 id=\"编写\"><a href=\"#编写\" class=\"headerlink\" title=\"编写\"></a>编写</h1><p>一个GTK4应用的创建, 需要用到 <code>gtk::Application</code><br>同时, 我们还需 <code>use gtk::prelude::*</code><br>原因与 <a href=\"https://doc.rust-lang.org/std/prelude/index.html\">std::prelude</a> 或 std::io::prelude 一样  </p>\n<p>先创建一个应用, 它目前连窗口也没有:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder()</span><br><span class=\"line\">        .application_id(<span class=\"string\">&quot;io.github.jedsek.myapp&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单吧? 但别急着运行, 先看看下面两处:  </p>\n<ul>\n<li><p><a href=\"http://chuxiuhong.com/chuxiuhong-rust-patterns-zh/patterns/builder.html\">Builder Pattern (一种Rust中常见的设计模式)</a>:<br>这个无需多言, 我们可以利用它, 进行链式构造, 让构造的过程更加清晰<br>在这里, 我们只调用了一次链式函数: application_id(id: &amp;str)<br>比如 <a href=\"https://doc.rust-lang.org/std/fs/struct.OpenOptions.html\">std::fs::OpenOptions</a> 就使用了构造者模式<br>在学习gtk4时, 它将被较高频次地使用, 最后使用 build 生成</p>\n</li>\n<li><p><a href=\"https://developer.gnome.org/documentation/tutorials/application-id.html\">application_id</a>:<br>每个GTK应用, 都带有一个id, 即 <code>application_id</code>, 它必须是全世界唯一的<br>一般使用反域名, 作为id<br>比如 “org.gnome.gedit” , “io.github.jedsek.myapp”  </p>\n</li>\n</ul>\n<p>但当你跃跃欲试, cargo run之后, 会看到:  </p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLib-GIO-<span class=\"builtin-name\">WARNING</span> : Your application does <span class=\"keyword\">not</span> implement g_application_activate()</span><br><span class=\"line\"><span class=\"keyword\">and</span> has <span class=\"literal\">no</span> handlers connected <span class=\"keyword\">to</span> the <span class=\"string\">&#x27;activate&#x27;</span> signal.  </span><br><span class=\"line\">It should <span class=\"keyword\">do</span> one of these.</span><br></pre></td></tr></table></figure>\n\n<p>我们实际上还要添加一个名为 activate 的信号量(Signal)<br>信号量的概念之后会再讲，现在只需明白, 你得像下面这样写:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> gtk::prelude::*;</span><br><span class=\"line\"><span class=\"keyword\">use</span> gtk::Application;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> app = Application::builder()</span><br><span class=\"line\">        .application_id(<span class=\"string\">&quot;io.github.jedsek.demo&quot;</span>)</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">    app.connect_activate(on_activate);</span><br><span class=\"line\">    app.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">on_activate</span></span>(app: &amp;Application) &#123;</span><br><span class=\"line\">    todo!()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请容许我对上面的东西来点小小的解释:<br>当一个gtk应用开始运行之</p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Nov 07 2021 10:16:57 GMT+0800 (中国标准时间)","title":"rs-gtk4-p2-创建HelloWorld窗口","path":"posts/rs-gtk4-p2.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>让我们从创建一个 显示HelloWorld的GTK窗口 开始旅途吧</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-11-07T02:16:57.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-11-07T02:16:57.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust","gui"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-async-p1-系列说明","comments":0,"abbrlink":"posts/rs-async-p1","date":"2021-09-12T03:43:19.000Z","top":9999,"keywords":["async","异步","Rust"],"_content":"> 欢迎大家来到 Rust 的 异步(async) 系列  \n<!-- more -->\n# 系列说明  \n传送门如下:  \n- [博客: Rust异步系列](https://jedsek.github.io/categories/rust-async) \n- [B站视频: Rust编程语言-异步(Async)](https://www.bilibili.com/video/BV1uh41167Np)\n\n`博客`的更新速度,快于`视频`  \n`博客`若经过重写,则会抽时间更新`视频`     \n\n此系列,我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n\n不过介于本人能力有限,更底层一些的东西可能理解的不是很到位,为不误导,需要补些知识  \n因此该系列花费时间可能会很久\n- - - \n# 资料来源\n1. 书籍  \n- [async-book](https://rust-lang.github.io/async-book/**)\n- [async_std/tutorials](https://book.async.rs/overview/async-std)\n- [tokio/tutorials](https://tokio.rs/tokio/tutorial)\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n2. 博客\n- [Withoutboats's blogs](https://without.boats/blog/)  \n______________ \n\n# 欢迎骚扰  \n1. 发现错误的话,请及时跟我联系,毕竟我也在学习\n2. 可以通过博客侧边栏上的联系方式找到我  \n3. 欢迎在留言版中留言,本人会定期查看  \n\n最后,谢谢你的观看 :)","source":"_posts/rs-async/rs-async-p1-系列说明.md","raw":"---\ntitle: rs-async-p1-系列说明\ncomments: false\nabbrlink: posts/rs-async-p1\ndate: 2021-09-12 11:43:19\ntop: 9999\ntags: rust  \nkeywords: [async, 异步, Rust]\n---\n> 欢迎大家来到 Rust 的 异步(async) 系列  \n<!-- more -->\n# 系列说明  \n传送门如下:  \n- [博客: Rust异步系列](https://jedsek.github.io/categories/rust-async) \n- [B站视频: Rust编程语言-异步(Async)](https://www.bilibili.com/video/BV1uh41167Np)\n\n`博客`的更新速度,快于`视频`  \n`博客`若经过重写,则会抽时间更新`视频`     \n\n此系列,我们将学习Rust中的 `异步 (Async)`  \n当然也会介绍异步方面的相关概念咯\n\n不过介于本人能力有限,更底层一些的东西可能理解的不是很到位,为不误导,需要补些知识  \n因此该系列花费时间可能会很久\n- - - \n# 资料来源\n1. 书籍  \n- [async-book](https://rust-lang.github.io/async-book/**)\n- [async_std/tutorials](https://book.async.rs/overview/async-std)\n- [tokio/tutorials](https://tokio.rs/tokio/tutorial)\n- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)\n\n2. 博客\n- [Withoutboats's blogs](https://without.boats/blog/)  \n______________ \n\n# 欢迎骚扰  \n1. 发现错误的话,请及时跟我联系,毕竟我也在学习\n2. 可以通过博客侧边栏上的联系方式找到我  \n3. 欢迎在留言版中留言,本人会定期查看  \n\n最后,谢谢你的观看 :)","slug":"rs-async/rs-async-p1-系列说明","published":1,"updated":"2021-09-12T03:43:19.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mw000hjaqyabz5hxdh","content":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列  </p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"系列说明\"><a href=\"#系列说明\" class=\"headerlink\" title=\"系列说明\"></a>系列说明</h1><p>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-async\">博客: Rust异步系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1uh41167Np\">B站视频: Rust编程语言-异步(Async)</a></li>\n</ul>\n<p><code>博客</code>的更新速度,快于<code>视频</code><br><code>博客</code>若经过重写,则会抽时间更新<code>视频</code>     </p>\n<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>当然也会介绍异步方面的相关概念咯</p>\n<p>不过介于本人能力有限,更底层一些的东西可能理解的不是很到位,为不误导,需要补些知识<br>因此该系列花费时间可能会很久</p>\n<hr>\n<h1 id=\"资料来源\"><a href=\"#资料来源\" class=\"headerlink\" title=\"资料来源\"></a>资料来源</h1><ol>\n<li>书籍  </li>\n</ol>\n<ul>\n<li><a href=\"https://rust-lang.github.io/async-book/**\">async-book</a></li>\n<li><a href=\"https://book.async.rs/overview/async-std\">async_std/tutorials</a></li>\n<li><a href=\"https://tokio.rs/tokio/tutorial\">tokio/tutorials</a></li>\n<li><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></li>\n</ul>\n<ol start=\"2\">\n<li>博客</li>\n</ol>\n<ul>\n<li><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a>  </li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><ol>\n<li>发现错误的话,请及时跟我联系,毕竟我也在学习</li>\n<li>可以通过博客侧边栏上的联系方式找到我  </li>\n<li>欢迎在留言版中留言,本人会定期查看  </li>\n</ol>\n<p>最后,谢谢你的观看 :)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列  </p>\n</blockquote>","more":"<h1 id=\"系列说明\"><a href=\"#系列说明\" class=\"headerlink\" title=\"系列说明\"></a>系列说明</h1><p>传送门如下:  </p>\n<ul>\n<li><a href=\"https://jedsek.github.io/categories/rust-async\">博客: Rust异步系列</a> </li>\n<li><a href=\"https://www.bilibili.com/video/BV1uh41167Np\">B站视频: Rust编程语言-异步(Async)</a></li>\n</ul>\n<p><code>博客</code>的更新速度,快于<code>视频</code><br><code>博客</code>若经过重写,则会抽时间更新<code>视频</code>     </p>\n<p>此系列,我们将学习Rust中的 <code>异步 (Async)</code><br>当然也会介绍异步方面的相关概念咯</p>\n<p>不过介于本人能力有限,更底层一些的东西可能理解的不是很到位,为不误导,需要补些知识<br>因此该系列花费时间可能会很久</p>\n<hr>\n<h1 id=\"资料来源\"><a href=\"#资料来源\" class=\"headerlink\" title=\"资料来源\"></a>资料来源</h1><ol>\n<li>书籍  </li>\n</ol>\n<ul>\n<li><a href=\"https://rust-lang.github.io/async-book/**\">async-book</a></li>\n<li><a href=\"https://book.async.rs/overview/async-std\">async_std/tutorials</a></li>\n<li><a href=\"https://tokio.rs/tokio/tutorial\">tokio/tutorials</a></li>\n<li><a href=\"https://cfsamson.github.io/books-futures-explained/\">Futures Explained in 200 Lines of Rust</a></li>\n</ul>\n<ol start=\"2\">\n<li>博客</li>\n</ol>\n<ul>\n<li><a href=\"https://without.boats/blog/\">Withoutboats’s blogs</a>  </li>\n</ul>\n<hr>\n<h1 id=\"欢迎骚扰\"><a href=\"#欢迎骚扰\" class=\"headerlink\" title=\"欢迎骚扰\"></a>欢迎骚扰</h1><ol>\n<li>发现错误的话,请及时跟我联系,毕竟我也在学习</li>\n<li>可以通过博客侧边栏上的联系方式找到我  </li>\n<li>欢迎在留言版中留言,本人会定期查看  </li>\n</ol>\n<p>最后,谢谢你的观看 :)</p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Sep 12 2021 11:43:19 GMT+0800 (中国标准时间)","title":"rs-async-p1-系列说明","path":"posts/rs-async-p1.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>欢迎大家来到 Rust 的 异步(async) 系列  </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-12T03:43:19.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-12T03:43:19.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-async-p2-异步简介","comments":0,"abbrlink":"posts/rs-async-p2","date":"2021-09-12T04:04:09.000Z","top":9998,"keywords":["async","异步","Rust"],"_content":"> 来简单介绍一下异步吧  \n<!-- more -->\n\n同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)\n\n# 开篇\n\n**异步编程** (Asynchronous programming)  \n是一种**并发编程模型** \n\n特点是通过少量`OS_thread(系统线程)`  \n即可运行大量`并发任务`  \n在某些场景下,可以疯狂压榨cpu的性能\n~~(好吧,有点废话......)~~\n- - -\n# 模型对比\n为何选择异步,它的优势有哪些?  \n\n对于这个问题,我们将对比**异步**与其他**并发模型**  \n以此来告诉大家,为什么选择异步:  \n\n1.`OS Thread (系统线程)`  \n由操作系统提供线程,进行并发,如std::thread  \nGood_1:  \n简单易使用,建模能力强,足够传统  \nGood_2:  \n操作系统就是运行时,与C语言交互方便  \nBad_1:  \n数据同步困难,易发生数据竞争  \nBad_2:  \n小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低\n\n\n2.`Green Thread (绿色线程)`  \n它几乎与系统线程一样,不过`Runtime(运行时,jvm/.net听说过吗?)`从操作系统变为了程序本身  \n绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程  \nGood:  \n这意味着,程序本身对绿色线程有绝对的管理权  \n所以内存分配等方面的粒度更细,根据任务大小调度内存  \n因此堆栈大小,能够随时间推移而增长  \n并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务  \nBad_1:  \n它是程序本身实现模拟出来的线程,Runtime较巨大  \n运行时会一直存在,即使你不用该特性,导致拖累全局程序性能  \n并且难以与C库交互  \n这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象  \n它无法在语言层面被Rust支持  \nBad_2:  \n绿色线程在不同平台上,其实现可能不同  \n对多平台的支持/维护/改进得靠实现者保证  \n\n`OS Thread`与`Green Thread`与Rust关系比较大:  \n一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的  \n\n- - -\n# 异步\n我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !     \n ~~(没把你憋坏吧伙计?)~~  \n \n我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一  \n假设我们正在单线程下,读取文件,并进行一个计算:  \n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read(file);\n\n// 进行一个计算\ncompute()\n```\n以上面代码为例子,我们会读取 `file` 获取 `data`   \n期间,我们的程序,做不了任何其他事情  \n只有等待`IO操作(Input/Output, 输入/输出)`完毕,我们才能进行接下来的 `compute`  \n\n`读取文件`,属于`IO操作`  \n众所周知,IO操作很耗时,等待它完成的时间可能会很长  \n\n有没有什么办法加快速度?  \n没错,系统线程yyds:\n\n```rust\n// 定义文件\nlet file = /*  */\n\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n\n// 使用join阻塞调用线程, 确保句柄线程执行结束\nlet data = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n因为两个任务`read`与`compute`是独立的,无依赖性  \n所以我们`spawn`了两个线程  \n第一个: 用于读取文件,获取数据\n第二个: 用于在读取文件的同时,执行着 `compute`    \n虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销   \n而异步,就是只依靠单线程,也能够完成上面的操作  \n\n单线程中的异步(伪)代码如下:\n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read_async(file);\n\n// 进行一个计算\ncompute_async()\n```\n\n你会注意到:  \n`read` -> `read_async`  \n`compute` -> `compute_async`  \n\n我用伪代码表示,这两个操作变成了异步操作  \n你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念  \n如下:    \n\n- `read`:  \n它会阻塞调用线程,等待该操作完毕后  \n才继续往下执行`compute`  \n\n阻塞期间是几乎不需要cpu参与运行的  \n程序此时傻乎乎地等待阻塞结束  \n无疑是对性能的浪费,对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时,会运行`compute_async`  \n线程由`read_async`接管变为由`compute_async`接管  \n当阻塞时间结束,则程序继续变为运行`read_async`\n\n`read_async`阻塞时,程序是不会傻傻等待的:  \n\n若检测到它处于阻塞,无法取得进展    \n则会运行其他异步任务,由其他异步任务接管线程  \n\n总而言之,异步操作,其实就是:  \n若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)  \n使得cpu一直处于运算,性能被极限压榨  \n\n异步操作,就像是可以随意`start/stop`一般  \n调度程序能够对它们进行调度,决定当前要运算哪个操作  \n确保不会因为阻塞而傻傻等待\n\n只需单线程,就可以做到同时运行多个 `Task(异步任务)`  \n异步当然也不排斥多线程:  \n一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?\n\n- - -\n\n# 尾声\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技  \n所以cpu对IO操作的压力较小/没有, IO时能进行其他运算  \n只需要最后接收数据时, 出个场就行了  \n\n所以我们的程序不需要在等待输入输出时就那样等着  \n给它们找事情, 让它们闲不下来吧!  \n\n","source":"_posts/rs-async/rs-async-p2-异步简介.md","raw":"---\ntitle: rs-async-p2-异步简介\ncomments: false\nabbrlink: posts/rs-async-p2\ndate: 2021-09-12 12:04:09\ntop: 9998\ntags: rust\nkeywords: [async, 异步, Rust]\n---\n> 来简单介绍一下异步吧  \n<!-- more -->\n\n同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)\n\n# 开篇\n\n**异步编程** (Asynchronous programming)  \n是一种**并发编程模型** \n\n特点是通过少量`OS_thread(系统线程)`  \n即可运行大量`并发任务`  \n在某些场景下,可以疯狂压榨cpu的性能\n~~(好吧,有点废话......)~~\n- - -\n# 模型对比\n为何选择异步,它的优势有哪些?  \n\n对于这个问题,我们将对比**异步**与其他**并发模型**  \n以此来告诉大家,为什么选择异步:  \n\n1.`OS Thread (系统线程)`  \n由操作系统提供线程,进行并发,如std::thread  \nGood_1:  \n简单易使用,建模能力强,足够传统  \nGood_2:  \n操作系统就是运行时,与C语言交互方便  \nBad_1:  \n数据同步困难,易发生数据竞争  \nBad_2:  \n小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低\n\n\n2.`Green Thread (绿色线程)`  \n它几乎与系统线程一样,不过`Runtime(运行时,jvm/.net听说过吗?)`从操作系统变为了程序本身  \n绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程  \nGood:  \n这意味着,程序本身对绿色线程有绝对的管理权  \n所以内存分配等方面的粒度更细,根据任务大小调度内存  \n因此堆栈大小,能够随时间推移而增长  \n并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务  \nBad_1:  \n它是程序本身实现模拟出来的线程,Runtime较巨大  \n运行时会一直存在,即使你不用该特性,导致拖累全局程序性能  \n并且难以与C库交互  \n这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象  \n它无法在语言层面被Rust支持  \nBad_2:  \n绿色线程在不同平台上,其实现可能不同  \n对多平台的支持/维护/改进得靠实现者保证  \n\n`OS Thread`与`Green Thread`与Rust关系比较大:  \n一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的  \n\n- - -\n# 异步\n我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !     \n ~~(没把你憋坏吧伙计?)~~  \n \n我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一  \n假设我们正在单线程下,读取文件,并进行一个计算:  \n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read(file);\n\n// 进行一个计算\ncompute()\n```\n以上面代码为例子,我们会读取 `file` 获取 `data`   \n期间,我们的程序,做不了任何其他事情  \n只有等待`IO操作(Input/Output, 输入/输出)`完毕,我们才能进行接下来的 `compute`  \n\n`读取文件`,属于`IO操作`  \n众所周知,IO操作很耗时,等待它完成的时间可能会很长  \n\n有没有什么办法加快速度?  \n没错,系统线程yyds:\n\n```rust\n// 定义文件\nlet file = /*  */\n\n// 为每个读取任务新建线程, 并获取句柄\nlet handle_a = thread::spawan(|| read(file) );\nlet handle_b = thread::spawan(|| compute() );\n\n// 使用join阻塞调用线程, 确保句柄线程执行结束\nlet data = handle_a.join().unwrap();\nhandle_b.join().unwrap();\n```\n\n因为两个任务`read`与`compute`是独立的,无依赖性  \n所以我们`spawn`了两个线程  \n第一个: 用于读取文件,获取数据\n第二个: 用于在读取文件的同时,执行着 `compute`    \n虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销   \n而异步,就是只依靠单线程,也能够完成上面的操作  \n\n单线程中的异步(伪)代码如下:\n```rust\n// 定义文件\nlet file = /*  */\n\n// 读取文件, 获取数据 \nlet data = read_async(file);\n\n// 进行一个计算\ncompute_async()\n```\n\n你会注意到:  \n`read` -> `read_async`  \n`compute` -> `compute_async`  \n\n我用伪代码表示,这两个操作变成了异步操作  \n你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念  \n如下:    \n\n- `read`:  \n它会阻塞调用线程,等待该操作完毕后  \n才继续往下执行`compute`  \n\n阻塞期间是几乎不需要cpu参与运行的  \n程序此时傻乎乎地等待阻塞结束  \n无疑是对性能的浪费,对cpu的不尊重  \n\n- `read_async`:  \n它处于阻塞时,会运行`compute_async`  \n线程由`read_async`接管变为由`compute_async`接管  \n当阻塞时间结束,则程序继续变为运行`read_async`\n\n`read_async`阻塞时,程序是不会傻傻等待的:  \n\n若检测到它处于阻塞,无法取得进展    \n则会运行其他异步任务,由其他异步任务接管线程  \n\n总而言之,异步操作,其实就是:  \n若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)  \n使得cpu一直处于运算,性能被极限压榨  \n\n异步操作,就像是可以随意`start/stop`一般  \n调度程序能够对它们进行调度,决定当前要运算哪个操作  \n确保不会因为阻塞而傻傻等待\n\n只需单线程,就可以做到同时运行多个 `Task(异步任务)`  \n异步当然也不排斥多线程:  \n一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?\n\n- - -\n\n# 尾声\nQ:  \n阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?  \nA:  \n现代电脑发展出了一些分担IO操作压力的高科技  \n所以cpu对IO操作的压力较小/没有, IO时能进行其他运算  \n只需要最后接收数据时, 出个场就行了  \n\n所以我们的程序不需要在等待输入输出时就那样等着  \n给它们找事情, 让它们闲不下来吧!  \n\n","slug":"rs-async/rs-async-p2-异步简介","published":1,"updated":"2021-09-12T04:04:09.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mx000kjaqyfqha8gl0","content":"<blockquote>\n<p>来简单介绍一下异步吧  </p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-async\">rust-async系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p><strong>异步编程</strong> (Asynchronous programming)<br>是一种<strong>并发编程模型</strong> </p>\n<p>特点是通过少量<code>OS_thread(系统线程)</code><br>即可运行大量<code>并发任务</code><br>在某些场景下,可以疯狂压榨cpu的性能<br><del>(好吧,有点废话……)</del></p>\n<hr>\n<h1 id=\"模型对比\"><a href=\"#模型对比\" class=\"headerlink\" title=\"模型对比\"></a>模型对比</h1><p>为何选择异步,它的优势有哪些?  </p>\n<p>对于这个问题,我们将对比<strong>异步</strong>与其他<strong>并发模型</strong><br>以此来告诉大家,为什么选择异步:  </p>\n<p>1.<code>OS Thread (系统线程)</code><br>由操作系统提供线程,进行并发,如std::thread<br>Good_1:<br>简单易使用,建模能力强,足够传统<br>Good_2:<br>操作系统就是运行时,与C语言交互方便<br>Bad_1:<br>数据同步困难,易发生数据竞争<br>Bad_2:<br>小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低</p>\n<p>2.<code>Green Thread (绿色线程)</code><br>它几乎与系统线程一样,不过<code>Runtime(运行时,jvm/.net听说过吗?)</code>从操作系统变为了程序本身<br>绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程<br>Good:<br>这意味着,程序本身对绿色线程有绝对的管理权<br>所以内存分配等方面的粒度更细,根据任务大小调度内存<br>因此堆栈大小,能够随时间推移而增长<br>并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务<br>Bad_1:<br>它是程序本身实现模拟出来的线程,Runtime较巨大<br>运行时会一直存在,即使你不用该特性,导致拖累全局程序性能<br>并且难以与C库交互<br>这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象<br>它无法在语言层面被Rust支持<br>Bad_2:<br>绿色线程在不同平台上,其实现可能不同<br>对多平台的支持/维护/改进得靠实现者保证  </p>\n<p><code>OS Thread</code>与<code>Green Thread</code>与Rust关系比较大:<br>一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的  </p>\n<hr>\n<h1 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h1><p>我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !<br> <del>(没把你憋坏吧伙计?)</del>  </p>\n<p>我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一<br>假设我们正在单线程下,读取文件,并进行一个计算:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>以上面代码为例子,我们会读取 <code>file</code> 获取 <code>data</code><br>期间,我们的程序,做不了任何其他事情<br>只有等待<code>IO操作(Input/Output, 输入/输出)</code>完毕,我们才能进行接下来的 <code>compute</code>  </p>\n<p><code>读取文件</code>,属于<code>IO操作</code><br>众所周知,IO操作很耗时,等待它完成的时间可能会很长  </p>\n<p>有没有什么办法加快速度?<br>没错,系统线程yyds:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n\n<p>因为两个任务<code>read</code>与<code>compute</code>是独立的,无依赖性<br>所以我们<code>spawn</code>了两个线程<br>第一个: 用于读取文件,获取数据<br>第二个: 用于在读取文件的同时,执行着 <code>compute</code><br>虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销<br>而异步,就是只依靠单线程,也能够完成上面的操作  </p>\n<p>单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read_async(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到:<br><code>read</code> -&gt; <code>read_async</code><br><code>compute</code> -&gt; <code>compute_async</code>  </p>\n<p>我用伪代码表示,这两个操作变成了异步操作<br>你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念<br>如下:    </p>\n<ul>\n<li><code>read</code>:<br>它会阻塞调用线程,等待该操作完毕后<br>才继续往下执行<code>compute</code>  </li>\n</ul>\n<p>阻塞期间是几乎不需要cpu参与运行的<br>程序此时傻乎乎地等待阻塞结束<br>无疑是对性能的浪费,对cpu的不尊重  </p>\n<ul>\n<li><code>read_async</code>:<br>它处于阻塞时,会运行<code>compute_async</code><br>线程由<code>read_async</code>接管变为由<code>compute_async</code>接管<br>当阻塞时间结束,则程序继续变为运行<code>read_async</code></li>\n</ul>\n<p><code>read_async</code>阻塞时,程序是不会傻傻等待的:  </p>\n<p>若检测到它处于阻塞,无法取得进展<br>则会运行其他异步任务,由其他异步任务接管线程  </p>\n<p>总而言之,异步操作,其实就是:<br>若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>使得cpu一直处于运算,性能被极限压榨  </p>\n<p>异步操作,就像是可以随意<code>start/stop</code>一般<br>调度程序能够对它们进行调度,决定当前要运算哪个操作<br>确保不会因为阻塞而傻傻等待</p>\n<p>只需单线程,就可以做到同时运行多个 <code>Task(异步任务)</code><br>异步当然也不排斥多线程:<br>一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?</p>\n<hr>\n<h1 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h1><p>Q:<br>阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>A:<br>现代电脑发展出了一些分担IO操作压力的高科技<br>所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>只需要最后接收数据时, 出个场就行了  </p>\n<p>所以我们的程序不需要在等待输入输出时就那样等着<br>给它们找事情, 让它们闲不下来吧!  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>来简单介绍一下异步吧  </p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-async\">rust-async系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p><strong>异步编程</strong> (Asynchronous programming)<br>是一种<strong>并发编程模型</strong> </p>\n<p>特点是通过少量<code>OS_thread(系统线程)</code><br>即可运行大量<code>并发任务</code><br>在某些场景下,可以疯狂压榨cpu的性能<br><del>(好吧,有点废话……)</del></p>\n<hr>\n<h1 id=\"模型对比\"><a href=\"#模型对比\" class=\"headerlink\" title=\"模型对比\"></a>模型对比</h1><p>为何选择异步,它的优势有哪些?  </p>\n<p>对于这个问题,我们将对比<strong>异步</strong>与其他<strong>并发模型</strong><br>以此来告诉大家,为什么选择异步:  </p>\n<p>1.<code>OS Thread (系统线程)</code><br>由操作系统提供线程,进行并发,如std::thread<br>Good_1:<br>简单易使用,建模能力强,足够传统<br>Good_2:<br>操作系统就是运行时,与C语言交互方便<br>Bad_1:<br>数据同步困难,易发生数据竞争<br>Bad_2:<br>小型任务数量巨大时,若分别开一个线程,所需内存与创建线程开销巨大,性价比极低</p>\n<p>2.<code>Green Thread (绿色线程)</code><br>它几乎与系统线程一样,不过<code>Runtime(运行时,jvm/.net听说过吗?)</code>从操作系统变为了程序本身<br>绿色线程只是由程序本身模拟出来的,类似系统线程的小型线程<br>Good:<br>这意味着,程序本身对绿色线程有绝对的管理权<br>所以内存分配等方面的粒度更细,根据任务大小调度内存<br>因此堆栈大小,能够随时间推移而增长<br>并且创建/销毁/切换线程的代价又低又快,轻松创建成千上万个绿色线程,来处理任务<br>Bad_1:<br>它是程序本身实现模拟出来的线程,Runtime较巨大<br>运行时会一直存在,即使你不用该特性,导致拖累全局程序性能<br>并且难以与C库交互<br>这也是Rust在1.0版本前删去绿色线程的主要原因,贯彻了零成本抽象<br>它无法在语言层面被Rust支持<br>Bad_2:<br>绿色线程在不同平台上,其实现可能不同<br>对多平台的支持/维护/改进得靠实现者保证  </p>\n<p><code>OS Thread</code>与<code>Green Thread</code>与Rust关系比较大:<br>一个是Rust支持的传统并发,一个是Rust在1.0之后便舍弃的  </p>\n<hr>\n<h1 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h1><p>我们终于要介绍异步()了 ! 乌拉乌拉乌拉 ! ! !<br> <del>(没把你憋坏吧伙计?)</del>  </p>\n<p>我们以IO操作为例子,毕竟这也是异步大放光彩的地方之一<br>假设我们正在单线程下,读取文件,并进行一个计算:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute()</span><br></pre></td></tr></table></figure>\n<p>以上面代码为例子,我们会读取 <code>file</code> 获取 <code>data</code><br>期间,我们的程序,做不了任何其他事情<br>只有等待<code>IO操作(Input/Output, 输入/输出)</code>完毕,我们才能进行接下来的 <code>compute</code>  </p>\n<p><code>读取文件</code>,属于<code>IO操作</code><br>众所周知,IO操作很耗时,等待它完成的时间可能会很长  </p>\n<p>有没有什么办法加快速度?<br>没错,系统线程yyds:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每个读取任务新建线程, 并获取句柄</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_a = thread::spawan(|| read(file) );</span><br><span class=\"line\"><span class=\"keyword\">let</span> handle_b = thread::spawan(|| compute() );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用join阻塞调用线程, 确保句柄线程执行结束</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = handle_a.join().unwrap();</span><br><span class=\"line\">handle_b.join().unwrap();</span><br></pre></td></tr></table></figure>\n\n<p>因为两个任务<code>read</code>与<code>compute</code>是独立的,无依赖性<br>所以我们<code>spawn</code>了两个线程<br>第一个: 用于读取文件,获取数据<br>第二个: 用于在读取文件的同时,执行着 <code>compute</code><br>虽然速度上来了,但是代价也有,那就是额外创建两个线程的开销<br>而异步,就是只依靠单线程,也能够完成上面的操作  </p>\n<p>单线程中的异步(伪)代码如下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义文件</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> file = <span class=\"comment\">/*  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件, 获取数据 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = read_async(file);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行一个计算</span></span><br><span class=\"line\">compute_async()</span><br></pre></td></tr></table></figure>\n\n<p>你会注意到:<br><code>read</code> -&gt; <code>read_async</code><br><code>compute</code> -&gt; <code>compute_async</code>  </p>\n<p>我用伪代码表示,这两个操作变成了异步操作<br>你无需关注这是如何变成异步版本的,这里只是为了说明异步的概念<br>如下:    </p>\n<ul>\n<li><code>read</code>:<br>它会阻塞调用线程,等待该操作完毕后<br>才继续往下执行<code>compute</code>  </li>\n</ul>\n<p>阻塞期间是几乎不需要cpu参与运行的<br>程序此时傻乎乎地等待阻塞结束<br>无疑是对性能的浪费,对cpu的不尊重  </p>\n<ul>\n<li><code>read_async</code>:<br>它处于阻塞时,会运行<code>compute_async</code><br>线程由<code>read_async</code>接管变为由<code>compute_async</code>接管<br>当阻塞时间结束,则程序继续变为运行<code>read_async</code></li>\n</ul>\n<p><code>read_async</code>阻塞时,程序是不会傻傻等待的:  </p>\n<p>若检测到它处于阻塞,无法取得进展<br>则会运行其他异步任务,由其他异步任务接管线程  </p>\n<p>总而言之,异步操作,其实就是:<br>若当前异步操作处于阻塞,则可能运行其他异步操作(如果有其他非阻塞的异步操作)<br>使得cpu一直处于运算,性能被极限压榨  </p>\n<p>异步操作,就像是可以随意<code>start/stop</code>一般<br>调度程序能够对它们进行调度,决定当前要运算哪个操作<br>确保不会因为阻塞而傻傻等待</p>\n<p>只需单线程,就可以做到同时运行多个 <code>Task(异步任务)</code><br>异步当然也不排斥多线程:<br>一个线程就能压榨出高性能,多个线程被压榨出来的性能岂不是更高?</p>\n<hr>\n<h1 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h1><p>Q:<br>阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br>A:<br>现代电脑发展出了一些分担IO操作压力的高科技<br>所以cpu对IO操作的压力较小/没有, IO时能进行其他运算<br>只需要最后接收数据时, 出个场就行了  </p>\n<p>所以我们的程序不需要在等待输入输出时就那样等着<br>给它们找事情, 让它们闲不下来吧!  </p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Sep 12 2021 12:04:09 GMT+0800 (中国标准时间)","title":"rs-async-p2-异步简介","path":"posts/rs-async-p2.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>来简单介绍一下异步吧  </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-12T04:04:09.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-12T04:04:09.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-async-p3-Future","comments":0,"abbrlink":"posts/rs-async-p3","date":"2021-09-12T05:56:48.000Z","top":9997,"keywords":["async","异步","Rust"],"_content":"> Rust 中的 Future/async/.await 说明  \n<!-- more -->  \n\n同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)\n\n# 开篇\n大家好! 我们上一节已经知晓异步的基础概念   \n现在,来看看Rust中的异步语法吧    \n\n在本节,我们会知晓以下三个概念的大致含义:  \n(暂时不涉及背后原理,原理之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n开始旅途吧  \n- - -\n# Future\n## 概念\n`Future`,一个标准/核心库中的trait  \n其完整路径为`std/core::future::Future`   \n\n此节我只会讲它的大致含义,原理则放到后面几节专门来讲 ~~(原理太难, 一节根本不够)~~  \n\n\n在Rust中,一个实现了Future(trait)的类型  \n该类型的实例(有时候直接被简称为 `一个Future实例`)便代表 `一次异步计算`  \n可以将其交给`Runtime(运行时)`,从而异步执行   \n\n`异步执行`, 也就是指:    \n当其他异步任务阻塞时,当前异步任务有机会执行  \n或当前异步任务阻塞时,其他异步任务有机会执行  \n总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别,举个例子你就明白了:  \n\n  \n假设有这么个父计算, 由两个子计算组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出,一次计算, 是可以由多个子计算组成的  \n同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期  \n因为`子计算们可能存在依赖关系` (在这里的例子中也确实存在) \n\n\n因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算  \n(我们将`最顶层的父计算(top-level Future, 即最顶层的Future实例)`称为`Task(任务)`)  \n\n`当前Task`阻塞时,接管执行权的,不能是当前Task中的`其他子计算`  \n只能是`其他Task中的子计算`  \n\n来点总结吧:  \n- Task是一个顶层Future实例 (即一次顶层异步计算) \n\n- 一个Future可以由多个Future组成,即一个Future里可以执行多个Future\n- Task_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算\n- Task可以只是一次单独计算\n\n`一个Future (一次异步计算)`  \n可理解为,是组成`一个Task (一个异步任务)`的最小单位 \n\n了解到了那么一点点后,现在来正式看看呗 ?  \n## 定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output:  \n代表该Future,异步执行完毕后,产出的值的类型   \n- poll:  \n所有执行操作都会放在该函数中  \nRuntime 会不断调用`poll函数`来推进`该异步计算`的完成  \n每次poll的返回值是一个枚举变体,代表是否完成\n- Poll<T>:  \n枚举类型,作为poll函数的返回值类型,其变体有:  \n`Poll::Pending`:  \n指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)     \n`Poll::Ready(T)`: \n指明该计算执行完毕,并产出一个类型为T的值   \n\n若只是普通使用者,并不需了解`Future的定义`背后之原理  \n但若不了解它,又如何为某类型实现 Future 呢?  \n\n别急,Rust为我们提供了关键字`async`,接着往下看吧   \n- - -\n# Async  \n`async`: 一个关键字  \n用来创建`一个匿名结构体的实例, 该结构体实现了Future`  \n即,它用来创建一个 `Future实例`  \n\n来个例子,看看async的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n\n\n// 2 \nstruct HelloStr;\n\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\n\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到,使用 async 进行了符合直觉的简化  \n这两种函数,实际上是等价的  \n\n看看它们两的返回值,如下:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n\n\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n\n注意,异步函数的调用,只是返回一个 Future实例  \n**但并没有开始执行, 它是惰性的**  \n**只有调用Future的poll方法, 才能推动它的执行**  \n**而调用poll方法的工作, 则交给了运行时(执行器)**  \n\n这样的好处就在于:  \n将一个异步计算看作一个变量,方便了传参等工作  \n\n比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可\n\nasync的作用就是创建一个Future实例:  \n- `async fn`: 异步函数, 要求返回一个 Future实例   \n- `async block`: 异步代码块, 创建一个 Future实例  \n- `async closure`: 异步闭包, (目前是不稳定特性) 创建一个 Future实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二  \n但是如何执行一个Future实例?  \n\n请接着往下看\n- - -\n# 执行\n## 背景介绍  \nRust本身并不提供 `异步运行时 (async runtime)`, 以便语言内核精小, 便于进化/迭代/维护  \n异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n\n可以仔细看看 Future 的完整路径: std::future/core::Future  \n注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) \n\n这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义  \n再加上异步运行时是可选的, 凭借 `cartes.io` 上提供的异步运行时相关的carte  \n在嵌入式环境下, 也能够轻松运行异步程序   \n\n在正式开始之前\n请确保你已经在 `Cargo.toml` 中添加了如下代码:   \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n以 `async-std` 这个比较主流, 对新人友好的 `异步运行时crate` 为例子   \n我们指定了版本, 并且启用了 `attributes` 这个特性  \n\n## Runtime执行\n\n我们先来创建一个 `打印 \"hello world\" 的Future` 吧  \n并且使用 `async-std` 这个异步运行时环境来执行它:   \n\n```rust\nuse async_std::task;\n\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n还记得我们在本节开始不久,就提到过的`异步任务 (Top-level Future, 即顶层的异步计算)` 吗?  \nasync_std::task,该模块,为我们提供了大量api,来执行/操控 这些 `Task`  \n\n比如这里出现的`task::block_on`:  \n传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程  \n该任务执行完毕后产出的值,会作为`block_on`的返回值  \n\n我们执行了一个Task,并且这个Task是单个的Future  \n但若我们想执行由多个子Future所组成的Task,又该怎么办?  \n\n`.await` 关键字出场了! \n\n- - -\n# Await  \n`.await` 只能出现在 `async fn/block` 内部  \n在某个Future实例的后面,增加`.await`,那么`该Future实例`则会执行  \n但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future   \n\n来看看它的使用:  \n```rust\nuse async_std::task;\n\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await`是一个标记点,可以理解为是一个`yield point`  \nRuntime执行到`xxx.await`时,先会执行一次`xxx`  \n\n\n一开始,会调用一次poll函数,推动执行进度  \n通过它的返回值,`Poll<T>枚举的变体`,即`Pending`或`Ready(T)`  \n来决定: \n1. 让其他Task接管执行权(yield)  \n2. 该Future执行完毕,继续执行当前Task  \n\n若为`Ready`: 则选 `2`,继续往下执行(一个Task可能是由多个Future所组成)  \n若为`Pending`: 则选 `1`,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)  \n\n稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:  \n\n`.await`会指明`执行某个Future` 这一逻辑  \n当`xxx.await`所在的Task交给Runtime执行,并执行到`xxx.await` 时    \n`xxx` 这个Future实例会执行  \n\n若它阻塞(这意味着该Future所在的Task也阻塞)  \n所以调度程序安排其他Task,在该空档期执行  \n若不阻塞,就继续往下执行(可能还有碰见`.await`哟), 直到该Task结束   \n\n- - -  \n\n# 补充\n- `#[async_std::main]`  \n这玩意无比常见,是个属性宏,要加在main函数头上  \n使得main前面能被async所修饰  \n程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见,所以就讲一讲:  \n向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例\n它实现了Future,与标准库中的`JoinHandle`无比相似  \n不过那个运行Thread,而这个运行Task,`join`相应地变成`.await`  \n想让该handle代表的Task运行完毕,应该在该handle前放上`.await`,如下:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n\n","source":"_posts/rs-async/rs-async-p3-Future.md","raw":"---\ntitle: rs-async-p3-Future\ncomments: false\nabbrlink: posts/rs-async-p3\ndate: 2021-09-12 13:56:48\ntop: 9997\ntags: rust\nkeywords: [async, 异步, Rust]\n---\n> Rust 中的 Future/async/.await 说明  \n<!-- more -->  \n\n同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)\n\n# 开篇\n大家好! 我们上一节已经知晓异步的基础概念   \n现在,来看看Rust中的异步语法吧    \n\n在本节,我们会知晓以下三个概念的大致含义:  \n(暂时不涉及背后原理,原理之后专门出好几节来讲)   \n\n- Future (trait)  \n- async (keyword)\n- .await (keyword)\n\n开始旅途吧  \n- - -\n# Future\n## 概念\n`Future`,一个标准/核心库中的trait  \n其完整路径为`std/core::future::Future`   \n\n此节我只会讲它的大致含义,原理则放到后面几节专门来讲 ~~(原理太难, 一节根本不够)~~  \n\n\n在Rust中,一个实现了Future(trait)的类型  \n该类型的实例(有时候直接被简称为 `一个Future实例`)便代表 `一次异步计算`  \n可以将其交给`Runtime(运行时)`,从而异步执行   \n\n`异步执行`, 也就是指:    \n当其他异步任务阻塞时,当前异步任务有机会执行  \n或当前异步任务阻塞时,其他异步任务有机会执行  \n总而言之,阻塞时期执行其他任务,不给cpu空闲的机会\n\n\n**注意两个名词的区别:**  \n- `异步 计算`  \n- `异步 任务`\n\n两者有着区别,举个例子你就明白了:  \n\n  \n假设有这么个父计算, 由两个子计算组成:   \n1. Open: 先异步打开一个文件(async open)  \n2. Read: 再异步读取该文件(async read)   \n \n我们可以看出,一次计算, 是可以由多个子计算组成的  \n同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期  \n因为`子计算们可能存在依赖关系` (在这里的例子中也确实存在) \n\n\n因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算  \n(我们将`最顶层的父计算(top-level Future, 即最顶层的Future实例)`称为`Task(任务)`)  \n\n`当前Task`阻塞时,接管执行权的,不能是当前Task中的`其他子计算`  \n只能是`其他Task中的子计算`  \n\n来点总结吧:  \n- Task是一个顶层Future实例 (即一次顶层异步计算) \n\n- 一个Future可以由多个Future组成,即一个Future里可以执行多个Future\n- Task_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算\n- Task可以只是一次单独计算\n\n`一个Future (一次异步计算)`  \n可理解为,是组成`一个Task (一个异步任务)`的最小单位 \n\n了解到了那么一点点后,现在来正式看看呗 ?  \n## 定义  \n\n让我们来看看它的定义:\n```rust   \npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n```\n下面简单了解一下:  \n\n- Future:  \n代表一次异步计算  \n\n- Output:  \n代表该Future,异步执行完毕后,产出的值的类型   \n- poll:  \n所有执行操作都会放在该函数中  \nRuntime 会不断调用`poll函数`来推进`该异步计算`的完成  \n每次poll的返回值是一个枚举变体,代表是否完成\n- Poll<T>:  \n枚举类型,作为poll函数的返回值类型,其变体有:  \n`Poll::Pending`:  \n指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)     \n`Poll::Ready(T)`: \n指明该计算执行完毕,并产出一个类型为T的值   \n\n若只是普通使用者,并不需了解`Future的定义`背后之原理  \n但若不了解它,又如何为某类型实现 Future 呢?  \n\n别急,Rust为我们提供了关键字`async`,接着往下看吧   \n- - -\n# Async  \n`async`: 一个关键字  \n用来创建`一个匿名结构体的实例, 该结构体实现了Future`  \n即,它用来创建一个 `Future实例`  \n\n来个例子,看看async的好处:   \n\n```rust\n// 1 \nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\n\n\n// 2 \nstruct HelloStr;\n\nimpl Future for HelloStr {\n\ttype Output = String;\n\tfn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n\t\tlet str = String::from(\"Hello! World!\");\n\t\tPoll::Ready(str)\n\t}\n}\n\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr\n}\n```\n\n你可以观察到,使用 async 进行了符合直觉的简化  \n这两种函数,实际上是等价的  \n\n看看它们两的返回值,如下:  \n\n```rust\n// 1\nasync fn hello_str_1() -> String { \n\tString::from(\"Hello! World!\")\n}\nhello_str_1() // 返回值为 `impl Future<Output = String>`\n\n\n// 2\nfn hello_str_2() -> impl Future<Output = String> {\n\tHelloStr // Future<Output = String> 的实例\n}\nhello_str_2() // 返回值为 `impl Future<Output = String>`  \n```\n\n\n注意,异步函数的调用,只是返回一个 Future实例  \n**但并没有开始执行, 它是惰性的**  \n**只有调用Future的poll方法, 才能推动它的执行**  \n**而调用poll方法的工作, 则交给了运行时(执行器)**  \n\n这样的好处就在于:  \n将一个异步计算看作一个变量,方便了传参等工作  \n\n比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可\n\nasync的作用就是创建一个Future实例:  \n- `async fn`: 异步函数, 要求返回一个 Future实例   \n- `async block`: 异步代码块, 创建一个 Future实例  \n- `async closure`: 异步闭包, (目前是不稳定特性) 创建一个 Future实例  \n\n```rust\n// 1\n// 返回值为 `impl Future<Output = String>`\nasync fn hello() -> String {\n\tString::from(\"Hello\")\n}\n\n// 2\n// 该代码块创建了类型为 `impl Future<Output = i32>` 的实例\nasync {\n\tlet a = 1_i32;\n\ta\n}\n\n// `async block` 也可以使用move  \n// 获得其中使用的变量的所有权  \nlet s = String::new();\nasync move {\n\t&s \n}\ns; // Error: use of moved value\n\n// 3\n// 闭包因为不稳定, 我也懒得讲了......\n```\n\n创建一个Future实例, 想必大家已经了解一二  \n但是如何执行一个Future实例?  \n\n请接着往下看\n- - -\n# 执行\n## 背景介绍  \nRust本身并不提供 `异步运行时 (async runtime)`, 以便语言内核精小, 便于进化/迭代/维护  \n异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  \n\n可以仔细看看 Future 的完整路径: std::future/core::Future  \n注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) \n\n这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义  \n再加上异步运行时是可选的, 凭借 `cartes.io` 上提供的异步运行时相关的carte  \n在嵌入式环境下, 也能够轻松运行异步程序   \n\n在正式开始之前\n请确保你已经在 `Cargo.toml` 中添加了如下代码:   \n\n```toml\n[dependencies]\nasync-std = { version = \"1.9\", features = [\"attributes\"] }\n```\n\n以 `async-std` 这个比较主流, 对新人友好的 `异步运行时crate` 为例子   \n我们指定了版本, 并且启用了 `attributes` 这个特性  \n\n## Runtime执行\n\n我们先来创建一个 `打印 \"hello world\" 的Future` 吧  \n并且使用 `async-std` 这个异步运行时环境来执行它:   \n\n```rust\nuse async_std::task;\n\nasync fn hello_world() { \n\tprintln!(\"Hello wrold!\");\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n还记得我们在本节开始不久,就提到过的`异步任务 (Top-level Future, 即顶层的异步计算)` 吗?  \nasync_std::task,该模块,为我们提供了大量api,来执行/操控 这些 `Task`  \n\n比如这里出现的`task::block_on`:  \n传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程  \n该任务执行完毕后产出的值,会作为`block_on`的返回值  \n\n我们执行了一个Task,并且这个Task是单个的Future  \n但若我们想执行由多个子Future所组成的Task,又该怎么办?  \n\n`.await` 关键字出场了! \n\n- - -\n# Await  \n`.await` 只能出现在 `async fn/block` 内部  \n在某个Future实例的后面,增加`.await`,那么`该Future实例`则会执行  \n但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)  \n真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future   \n\n来看看它的使用:  \n```rust\nuse async_std::task;\n\nasync fn hello() {  \n\tprint!(\"Hello \");\n}\nasync fn world() {\n\tprintln!(\"world!\");\n}\nasync fn hello_world() { \n\thello().await;\n\tworld().await;\n}\n\nfn main() { \n\tlet fut = hello_world();\n\ttask::block_on(fut);\n}\n```\n\n`.await`是一个标记点,可以理解为是一个`yield point`  \nRuntime执行到`xxx.await`时,先会执行一次`xxx`  \n\n\n一开始,会调用一次poll函数,推动执行进度  \n通过它的返回值,`Poll<T>枚举的变体`,即`Pending`或`Ready(T)`  \n来决定: \n1. 让其他Task接管执行权(yield)  \n2. 该Future执行完毕,继续执行当前Task  \n\n若为`Ready`: 则选 `2`,继续往下执行(一个Task可能是由多个Future所组成)  \n若为`Pending`: 则选 `1`,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)  \n\n稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:  \n\n`.await`会指明`执行某个Future` 这一逻辑  \n当`xxx.await`所在的Task交给Runtime执行,并执行到`xxx.await` 时    \n`xxx` 这个Future实例会执行  \n\n若它阻塞(这意味着该Future所在的Task也阻塞)  \n所以调度程序安排其他Task,在该空档期执行  \n若不阻塞,就继续往下执行(可能还有碰见`.await`哟), 直到该Task结束   \n\n- - -  \n\n# 补充\n- `#[async_std::main]`  \n这玩意无比常见,是个属性宏,要加在main函数头上  \n使得main前面能被async所修饰  \n程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:  \n\n```rust\n#[async_std::main]\nasync fn main() {\n    hello_world().await\n}\n\n// 等价于:\nfn main() {\n    async_std::task::block_on( async {\n        hello_world().await\n    })\n}\n```\n\n\n- `async_std::task::spawn`  \n因为这玩意也很常见,所以就讲一讲:  \n向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例\n它实现了Future,与标准库中的`JoinHandle`无比相似  \n不过那个运行Thread,而这个运行Task,`join`相应地变成`.await`  \n想让该handle代表的Task运行完毕,应该在该handle前放上`.await`,如下:  \n\n```rust  \nuse async_std::task;\n#[async_std::main]\nasync fn main() { \n    let handle = task::spawn(async {\n        1 + 1\n    });\n    let two:i32 = handle.await;\n}\n```\n\n","slug":"rs-async/rs-async-p3-Future","published":1,"updated":"2021-09-12T05:56:48.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9my000mjaqy5n710e6i","content":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明  </p>\n</blockquote>\n<span id=\"more\"></span>  \n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-async\">rust-async系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>大家好! 我们上一节已经知晓异步的基础概念<br>现在,来看看Rust中的异步语法吧    </p>\n<p>在本节,我们会知晓以下三个概念的大致含义:<br>(暂时不涉及背后原理,原理之后专门出好几节来讲)   </p>\n<ul>\n<li>Future (trait)  </li>\n<li>async (keyword)</li>\n<li>.await (keyword)</li>\n</ul>\n<p>开始旅途吧  </p>\n<hr>\n<h1 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><code>Future</code>,一个标准/核心库中的trait<br>其完整路径为<code>std/core::future::Future</code>   </p>\n<p>此节我只会讲它的大致含义,原理则放到后面几节专门来讲 <del>(原理太难, 一节根本不够)</del>  </p>\n<p>在Rust中,一个实现了Future(trait)的类型<br>该类型的实例(有时候直接被简称为 <code>一个Future实例</code>)便代表 <code>一次异步计算</code><br>可以将其交给<code>Runtime(运行时)</code>,从而异步执行   </p>\n<p><code>异步执行</code>, 也就是指:<br>当其他异步任务阻塞时,当前异步任务有机会执行<br>或当前异步任务阻塞时,其他异步任务有机会执行<br>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong>  </p>\n<ul>\n<li><code>异步 计算</code>  </li>\n<li><code>异步 任务</code></li>\n</ul>\n<p>两者有着区别,举个例子你就明白了:  </p>\n<p>假设有这么个父计算, 由两个子计算组成:   </p>\n<ol>\n<li>Open: 先异步打开一个文件(async open)  </li>\n<li>Read: 再异步读取该文件(async read)   </li>\n</ol>\n<p>我们可以看出,一次计算, 是可以由多个子计算组成的<br>同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期<br>因为<code>子计算们可能存在依赖关系</code> (在这里的例子中也确实存在) </p>\n<p>因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算<br>(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)  </p>\n<p><code>当前Task</code>阻塞时,接管执行权的,不能是当前Task中的<code>其他子计算</code><br>只能是<code>其他Task中的子计算</code>  </p>\n<p>来点总结吧:  </p>\n<ul>\n<li><p>Task是一个顶层Future实例 (即一次顶层异步计算) </p>\n</li>\n<li><p>一个Future可以由多个Future组成,即一个Future里可以执行多个Future</p>\n</li>\n<li><p>Task_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算</p>\n</li>\n<li><p>Task可以只是一次单独计算</p>\n</li>\n</ul>\n<p><code>一个Future (一次异步计算)</code><br>可理解为,是组成<code>一个Task (一个异步任务)</code>的最小单位 </p>\n<p>了解到了那么一点点后,现在来正式看看呗 ?  </p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:  </p>\n<ul>\n<li><p>Future:<br>代表一次异步计算  </p>\n</li>\n<li><p>Output:<br>代表该Future,异步执行完毕后,产出的值的类型   </p>\n</li>\n<li><p>poll:<br>所有执行操作都会放在该函数中<br>Runtime 会不断调用<code>poll函数</code>来推进<code>该异步计算</code>的完成<br>每次poll的返回值是一个枚举变体,代表是否完成</p>\n</li>\n<li><p>Poll<T>:<br>枚举类型,作为poll函数的返回值类型,其变体有:<br><code>Poll::Pending</code>:<br>指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)<br><code>Poll::Ready(T)</code>:<br>指明该计算执行完毕,并产出一个类型为T的值   </p>\n</li>\n</ul>\n<p>若只是普通使用者,并不需了解<code>Future的定义</code>背后之原理<br>但若不了解它,又如何为某类型实现 Future 呢?  </p>\n<p>别急,Rust为我们提供了关键字<code>async</code>,接着往下看吧   </p>\n<hr>\n<h1 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h1><p><code>async</code>: 一个关键字<br>用来创建<code>一个匿名结构体的实例, 该结构体实现了Future</code><br>即,它用来创建一个 <code>Future实例</code>  </p>\n<p>来个例子,看看async的好处:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以观察到,使用 async 进行了符合直觉的简化<br>这两种函数,实际上是等价的  </p>\n<p>看看它们两的返回值,如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n\n\n<p>注意,异步函数的调用,只是返回一个 Future实例<br><strong>但并没有开始执行, 它是惰性的</strong><br><strong>只有调用Future的poll方法, 才能推动它的执行</strong><br><strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong>  </p>\n<p>这样的好处就在于:<br>将一个异步计算看作一个变量,方便了传参等工作  </p>\n<p>比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可</p>\n<p>async的作用就是创建一个Future实例:  </p>\n<ul>\n<li><code>async fn</code>: 异步函数, 要求返回一个 Future实例   </li>\n<li><code>async block</code>: 异步代码块, 创建一个 Future实例  </li>\n<li><code>async closure</code>: 异步闭包, (目前是不稳定特性) 创建一个 Future实例  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个Future实例, 想必大家已经了解一二<br>但是如何执行一个Future实例?  </p>\n<p>请接着往下看</p>\n<hr>\n<h1 id=\"执行\"><a href=\"#执行\" class=\"headerlink\" title=\"执行\"></a>执行</h1><h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  </p>\n<p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) </p>\n<p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>在嵌入式环境下, 也能够轻松运行异步程序   </p>\n<p>在正式开始之前<br>请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:   </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>我们指定了版本, 并且启用了 <code>attributes</code> 这个特性  </p>\n<h2 id=\"Runtime执行\"><a href=\"#Runtime执行\" class=\"headerlink\" title=\"Runtime执行\"></a>Runtime执行</h2><p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>并且使用 <code>async-std</code> 这个异步运行时环境来执行它:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们在本节开始不久,就提到过的<code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>async_std::task,该模块,为我们提供了大量api,来执行/操控 这些 <code>Task</code>  </p>\n<p>比如这里出现的<code>task::block_on</code>:<br>传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程<br>该任务执行完毕后产出的值,会作为<code>block_on</code>的返回值  </p>\n<p>我们执行了一个Task,并且这个Task是单个的Future<br>但若我们想执行由多个子Future所组成的Task,又该怎么办?  </p>\n<p><code>.await</code> 关键字出场了! </p>\n<hr>\n<h1 id=\"Await\"><a href=\"#Await\" class=\"headerlink\" title=\"Await\"></a>Await</h1><p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>在某个Future实例的后面,增加<code>.await</code>,那么<code>该Future实例</code>则会执行<br>但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)<br>真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future   </p>\n<p>来看看它的使用:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.await</code>是一个标记点,可以理解为是一个<code>yield point</code><br>Runtime执行到<code>xxx.await</code>时,先会执行一次<code>xxx</code>  </p>\n<p>一开始,会调用一次poll函数,推动执行进度<br>通过它的返回值,<code>Poll&lt;T&gt;枚举的变体</code>,即<code>Pending</code>或<code>Ready(T)</code><br>来决定: </p>\n<ol>\n<li>让其他Task接管执行权(yield)  </li>\n<li>该Future执行完毕,继续执行当前Task  </li>\n</ol>\n<p>若为<code>Ready</code>: 则选 <code>2</code>,继续往下执行(一个Task可能是由多个Future所组成)<br>若为<code>Pending</code>: 则选 <code>1</code>,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)  </p>\n<p>稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:  </p>\n<p><code>.await</code>会指明<code>执行某个Future</code> 这一逻辑<br>当<code>xxx.await</code>所在的Task交给Runtime执行,并执行到<code>xxx.await</code> 时<br><code>xxx</code> 这个Future实例会执行  </p>\n<p>若它阻塞(这意味着该Future所在的Task也阻塞)<br>所以调度程序安排其他Task,在该空档期执行<br>若不阻塞,就继续往下执行(可能还有碰见<code>.await</code>哟), 直到该Task结束   </p>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ul>\n<li><code>#[async_std::main]</code><br>这玩意无比常见,是个属性宏,要加在main函数头上<br>使得main前面能被async所修饰<br>程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><code>async_std::task::spawn</code><br>因为这玩意也很常见,所以就讲一讲:<br>向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例<br>它实现了Future,与标准库中的<code>JoinHandle</code>无比相似<br>不过那个运行Thread,而这个运行Task,<code>join</code>相应地变成<code>.await</code><br>想让该handle代表的Task运行完毕,应该在该handle前放上<code>.await</code>,如下:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明  </p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-async\">rust-async系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p>大家好! 我们上一节已经知晓异步的基础概念<br>现在,来看看Rust中的异步语法吧    </p>\n<p>在本节,我们会知晓以下三个概念的大致含义:<br>(暂时不涉及背后原理,原理之后专门出好几节来讲)   </p>\n<ul>\n<li>Future (trait)  </li>\n<li>async (keyword)</li>\n<li>.await (keyword)</li>\n</ul>\n<p>开始旅途吧  </p>\n<hr>\n<h1 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><code>Future</code>,一个标准/核心库中的trait<br>其完整路径为<code>std/core::future::Future</code>   </p>\n<p>此节我只会讲它的大致含义,原理则放到后面几节专门来讲 <del>(原理太难, 一节根本不够)</del>  </p>\n<p>在Rust中,一个实现了Future(trait)的类型<br>该类型的实例(有时候直接被简称为 <code>一个Future实例</code>)便代表 <code>一次异步计算</code><br>可以将其交给<code>Runtime(运行时)</code>,从而异步执行   </p>\n<p><code>异步执行</code>, 也就是指:<br>当其他异步任务阻塞时,当前异步任务有机会执行<br>或当前异步任务阻塞时,其他异步任务有机会执行<br>总而言之,阻塞时期执行其他任务,不给cpu空闲的机会</p>\n<p><strong>注意两个名词的区别:</strong>  </p>\n<ul>\n<li><code>异步 计算</code>  </li>\n<li><code>异步 任务</code></li>\n</ul>\n<p>两者有着区别,举个例子你就明白了:  </p>\n<p>假设有这么个父计算, 由两个子计算组成:   </p>\n<ol>\n<li>Open: 先异步打开一个文件(async open)  </li>\n<li>Read: 再异步读取该文件(async read)   </li>\n</ol>\n<p>我们可以看出,一次计算, 是可以由多个子计算组成的<br>同时, 若Open陷入阻塞,Runtime不能调度Read填充这段阻塞时期<br>因为<code>子计算们可能存在依赖关系</code> (在这里的例子中也确实存在) </p>\n<p>因此,当某个子计算阻塞时,它所属的最顶层的父计算也应阻塞,避免Runtime调度非法计算<br>(我们将<code>最顶层的父计算(top-level Future, 即最顶层的Future实例)</code>称为<code>Task(任务)</code>)  </p>\n<p><code>当前Task</code>阻塞时,接管执行权的,不能是当前Task中的<code>其他子计算</code><br>只能是<code>其他Task中的子计算</code>  </p>\n<p>来点总结吧:  </p>\n<ul>\n<li><p>Task是一个顶层Future实例 (即一次顶层异步计算) </p>\n</li>\n<li><p>一个Future可以由多个Future组成,即一个Future里可以执行多个Future</p>\n</li>\n<li><p>Task_A阻塞时,接管执行的是其他Task中的子计算,不能是Task_A中的子计算</p>\n</li>\n<li><p>Task可以只是一次单独计算</p>\n</li>\n</ul>\n<p><code>一个Future (一次异步计算)</code><br>可理解为,是组成<code>一个Task (一个异步任务)</code>的最小单位 </p>\n<p>了解到了那么一点点后,现在来正式看看呗 ?  </p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>让我们来看看它的定义:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Future</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简单了解一下:  </p>\n<ul>\n<li><p>Future:<br>代表一次异步计算  </p>\n</li>\n<li><p>Output:<br>代表该Future,异步执行完毕后,产出的值的类型   </p>\n</li>\n<li><p>poll:<br>所有执行操作都会放在该函数中<br>Runtime 会不断调用<code>poll函数</code>来推进<code>该异步计算</code>的完成<br>每次poll的返回值是一个枚举变体,代表是否完成</p>\n</li>\n<li><p>Poll<T>:<br>枚举类型,作为poll函数的返回值类型,其变体有:<br><code>Poll::Pending</code>:<br>指明该计算处于阻塞,调度程序在该计算阻塞完毕后,继续调用poll(因为之后可能还会阻塞)<br><code>Poll::Ready(T)</code>:<br>指明该计算执行完毕,并产出一个类型为T的值   </p>\n</li>\n</ul>\n<p>若只是普通使用者,并不需了解<code>Future的定义</code>背后之原理<br>但若不了解它,又如何为某类型实现 Future 呢?  </p>\n<p>别急,Rust为我们提供了关键字<code>async</code>,接着往下看吧   </p>\n<hr>\n<h1 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h1><p><code>async</code>: 一个关键字<br>用来创建<code>一个匿名结构体的实例, 该结构体实现了Future</code><br>即,它用来创建一个 <code>Future实例</code>  </p>\n<p>来个例子,看看async的好处:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HelloStr</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> Future <span class=\"keyword\">for</span> HelloStr &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Output</span></span> = <span class=\"built_in\">String</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">poll</span></span>(<span class=\"keyword\">self</span>: Pin&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;, _cx: &amp;<span class=\"keyword\">mut</span> Context&lt;<span class=\"symbol\">&#x27;_</span>&gt;) -&gt; Poll&lt;Self::Output&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"built_in\">str</span> = <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>);</span><br><span class=\"line\">        Poll::Ready(<span class=\"built_in\">str</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以观察到,使用 async 进行了符合直觉的简化<br>这两种函数,实际上是等价的  </p>\n<p>看看它们两的返回值,如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_1</span></span>() -&gt; <span class=\"built_in\">String</span> &#123; </span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello! World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_1() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_str_2</span></span>() -&gt; <span class=\"keyword\">impl</span> Future&lt;Output = <span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">    HelloStr <span class=\"comment\">// Future&lt;Output = String&gt; 的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello_str_2() <span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`  </span></span><br></pre></td></tr></table></figure>\n\n\n<p>注意,异步函数的调用,只是返回一个 Future实例<br><strong>但并没有开始执行, 它是惰性的</strong><br><strong>只有调用Future的poll方法, 才能推动它的执行</strong><br><strong>而调用poll方法的工作, 则交给了运行时(执行器)</strong>  </p>\n<p>这样的好处就在于:<br>将一个异步计算看作一个变量,方便了传参等工作  </p>\n<p>比如,你想舍弃某次异步任务,只需将对应的Future实例给drop掉, 使其所有权丢失即可</p>\n<p>async的作用就是创建一个Future实例:  </p>\n<ul>\n<li><code>async fn</code>: 异步函数, 要求返回一个 Future实例   </li>\n<li><code>async block</code>: 异步代码块, 创建一个 Future实例  </li>\n<li><code>async closure</code>: 异步闭包, (目前是不稳定特性) 创建一个 Future实例  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值为 `impl Future&lt;Output = String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() -&gt; <span class=\"built_in\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span>::from(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 该代码块创建了类型为 `impl Future&lt;Output = i32&gt;` 的实例</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">1_i32</span>;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `async block` 也可以使用move  </span></span><br><span class=\"line\"><span class=\"comment\">// 获得其中使用的变量的所有权  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">String</span>::new();</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">move</span> &#123;</span><br><span class=\"line\">    &amp;s </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s; <span class=\"comment\">// Error: use of moved value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 闭包因为不稳定, 我也懒得讲了......</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个Future实例, 想必大家已经了解一二<br>但是如何执行一个Future实例?  </p>\n<p>请接着往下看</p>\n<hr>\n<h1 id=\"执行\"><a href=\"#执行\" class=\"headerlink\" title=\"执行\"></a>执行</h1><h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>Rust本身并不提供 <code>异步运行时 (async runtime)</code>, 以便语言内核精小, 便于进化/迭代/维护<br>异步运行时 由社区提供, 围绕语言本身提供的定义 (如 Future) 进行扩充, 来支持异步程序  </p>\n<p>可以仔细看看 Future 的完整路径: std::future/core::Future<br>注意到没有, 它也存在于核心库中 (核心库中对异步的支持, 并不只有 Future) </p>\n<p>这意味着只要你能使用Rust, 语言本身就会提供 Future 等定义<br>再加上异步运行时是可选的, 凭借 <code>cartes.io</code> 上提供的异步运行时相关的carte<br>在嵌入式环境下, 也能够轻松运行异步程序   </p>\n<p>在正式开始之前<br>请确保你已经在 <code>Cargo.toml</code> 中添加了如下代码:   </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123; version = <span class=\"string\">&quot;1.9&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 <code>async-std</code> 这个比较主流, 对新人友好的 <code>异步运行时crate</code> 为例子<br>我们指定了版本, 并且启用了 <code>attributes</code> 这个特性  </p>\n<h2 id=\"Runtime执行\"><a href=\"#Runtime执行\" class=\"headerlink\" title=\"Runtime执行\"></a>Runtime执行</h2><p>我们先来创建一个 <code>打印 &quot;hello world&quot; 的Future</code> 吧<br>并且使用 <code>async-std</code> 这个异步运行时环境来执行它:   </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello wrold!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还记得我们在本节开始不久,就提到过的<code>异步任务 (Top-level Future, 即顶层的异步计算)</code> 吗?<br>async_std::task,该模块,为我们提供了大量api,来执行/操控 这些 <code>Task</code>  </p>\n<p>比如这里出现的<code>task::block_on</code>:<br>传入一个Future实例,Runtime会执行它(调用poll方法),并阻塞调用线程<br>该任务执行完毕后产出的值,会作为<code>block_on</code>的返回值  </p>\n<p>我们执行了一个Task,并且这个Task是单个的Future<br>但若我们想执行由多个子Future所组成的Task,又该怎么办?  </p>\n<p><code>.await</code> 关键字出场了! </p>\n<hr>\n<h1 id=\"Await\"><a href=\"#Await\" class=\"headerlink\" title=\"Await\"></a>Await</h1><p><code>.await</code> 只能出现在 <code>async fn/block</code> 内部<br>在某个Future实例的后面,增加<code>.await</code>,那么<code>该Future实例</code>则会执行<br>但是,它只是表述这么个逻辑而已,因为Rust语言本身没有异步运行时(无执行能力)<br>真正执行的话,得将Future实例交给运行时,带动着执行里面的子Future   </p>\n<p>来看看它的使用:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello</span></span>() &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">world</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">hello_world</span></span>() &#123; </span><br><span class=\"line\">    hello().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">    world().<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> fut = hello_world();</span><br><span class=\"line\">    task::block_on(fut);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>.await</code>是一个标记点,可以理解为是一个<code>yield point</code><br>Runtime执行到<code>xxx.await</code>时,先会执行一次<code>xxx</code>  </p>\n<p>一开始,会调用一次poll函数,推动执行进度<br>通过它的返回值,<code>Poll&lt;T&gt;枚举的变体</code>,即<code>Pending</code>或<code>Ready(T)</code><br>来决定: </p>\n<ol>\n<li>让其他Task接管执行权(yield)  </li>\n<li>该Future执行完毕,继续执行当前Task  </li>\n</ol>\n<p>若为<code>Ready</code>: 则选 <code>2</code>,继续往下执行(一个Task可能是由多个Future所组成)<br>若为<code>Pending</code>: 则选 <code>1</code>,让其他任务接管执行权(比如IO操作的阻塞期间,让其他任务执行)  </p>\n<p>稍微有点涉及原理部分,可能有点难理解,来个简单粗暴理解版:  </p>\n<p><code>.await</code>会指明<code>执行某个Future</code> 这一逻辑<br>当<code>xxx.await</code>所在的Task交给Runtime执行,并执行到<code>xxx.await</code> 时<br><code>xxx</code> 这个Future实例会执行  </p>\n<p>若它阻塞(这意味着该Future所在的Task也阻塞)<br>所以调度程序安排其他Task,在该空档期执行<br>若不阻塞,就继续往下执行(可能还有碰见<code>.await</code>哟), 直到该Task结束   </p>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ul>\n<li><code>#[async_std::main]</code><br>这玩意无比常见,是个属性宏,要加在main函数头上<br>使得main前面能被async所修饰<br>程序运行时,main函数返回的Future,会自动交给Runtime开始运行,如下:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    async_std::task::block_on( <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        hello_world().<span class=\"keyword\">await</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><code>async_std::task::spawn</code><br>因为这玩意也很常见,所以就讲一讲:<br>向其传入Future,Runtime会开始运行它,并返回 async_std::task::JoinHandle 的实例<br>它实现了Future,与标准库中的<code>JoinHandle</code>无比相似<br>不过那个运行Thread,而这个运行Task,<code>join</code>相应地变成<code>.await</code><br>想让该handle代表的Task运行完毕,应该在该handle前放上<code>.await</code>,如下:  </li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> async_std::task;</span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> handle = task::spawn(<span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">        <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> two:<span class=\"built_in\">i32</span> = handle.<span class=\"keyword\">await</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Sep 12 2021 13:56:48 GMT+0800 (中国标准时间)","title":"rs-async-p3-Future","path":"posts/rs-async-p3.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>Rust 中的 Future/async/.await 说明  </p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-12T05:56:48.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-12T05:56:48.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rs-async-p4-状态的保存与变换","comments":0,"abbrlink":"posts/rs-async-p4","date":"2021-09-12T06:50:14.000Z","top":9996,"keywords":["async","异步","Rust"],"_content":"> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n\n同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)\n\n# 开篇\n**注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看**  \n为了更好地理解`Rust异步`背后的原理,我们先来了解下一些概念  \n当然,不用太深入,只是小补充而已:   \n- `抢占式/协作式多任务`  \n- `状态机`  \n- `自引用结构体`   \n\n\n现在,让我们开始吧!  \n- - -\n# 两种多任务  \n## 介绍\n`抢占式多任务`与`协作式多任务`,都属于`多任务`  \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会  \n各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种`任务们同时运行`的感觉  \n这是强迫/抢占的    \n\n- 协作式多任务:  \n任务们本身进行协调,决定CPU的运行权  \n比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending  \n自己放弃继续执行,并通知运行时执行其他Task  \n这是自愿/协作的,Task们`自愿放弃CPU的执行权`\n(上文中的`任务`与`Task`请区分一下,前者比后者广泛,后者在这用于Rust的举例)  \n\n## 状态的恢复/保存\n既然任务们能互相切换执行,那么,当再次轮到某任务执行时  \n该任务,应当从先前暂停的地方开始,继续执行  \n因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是`状态保存`  \n\n对于`抢占式`与`协作式`,处理`状态保存`的思路是不一样的:\n\n- 抢占式:  \n因为是强迫切换执行的,任务会在任意某个时刻被中断  \n任务此时运行到了哪里?我们不知道啊!  \n那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)    \n\n反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间  \n但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大  \n\n- 协作式:  \n因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作,我们称为`yield`    \n\n比如在Rust中,`xxx.await`会执行一个Future  \t\n意味着当程序执行到这里时,可能会`yield`(poll返回Poll::Pending,自愿放弃执行权)  \n\n`xxx.await`就是一个`stop/yield point`,代表执行到此处时,可能会发生暂停并yield  \n瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此,我们可以准确分配Future执行所需要的最大空间  \n\n其实,每个`.await(也就是yield point)`,就代表着`一种状态`(之后会讲)\n\n协作式的好处在于:  \n能自己掌握所有`yield point`,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理  \n毕竟机器定义的分配策略, 总是没有比不过我们特意设计的  \n在任务暂停并转让执行权前,准确保存`下次继续所需要的状态`,内存/性能优势很大    \n但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行  \n\n- - -\n# 状态机的概念  \n在Rust中的异步,我们之前也说过,属于`协作式多任务`  \n而其`状态保存`的实现,就是利用`状态机(state machine)`来实现  \n\n`状态机(state machine)`一般指`有限状态自动机`,是一种数学模型  \n\n1. 状态(state):  \n比如有一扇门,它的状态就处于以下两种之一: Open or Closed\n2. 事件(event):  \n某事件发生后,会触发相应动作,可能改变状态  \n比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state)   \n3. 动作 (action):  \n事件发生后,会触发动作  \n4. 变换 (transition):  \n`State_X=>State_Y`就叫`变换`,比如门的状态从`Open=>Closed`  \n\n稍微了解下`状态机`的概念即可  \n\n那么现在,就要看具体代码了  \n\n如果你想亲自运行一下,先确保你的`Cargo.toml`中的依赖如下:  \n\n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下代码,读取一个文件的行数  \n你可以通过 `cargo run -- ./src/main.rs` 运行  \n(通过target目录下的可执行文件,加上参数后运行,也可以哦)  \n\n```rust\nuse std::{\n\tenv::args,\n\tprocess,\n};\nuse async_std::{\n\tprelude::*,\n\tfs::File,\n\tio::{self,BufReader},\n};\n\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).unwrap_or_else(||{\n\t\teprintln!(\"Fuck you! No path for reading\");\n\t\tprocess::exit(1);\n\t}); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\n\n\nmian()产生一个新实例,异步运行`open(path)`与`count()`  \t    \n对于编译器,每一个`.await`其实都代表一种状态  \n\nFuture实例,实际上是个状态机  \n在这里共有四种状态/阶段(其中包括两个`.await point(yield point)`):  \n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用当前Future的poll推动进度时,若在`某一阶段`返回了`Poll::Pending`,则放弃执行权  \n当再次调用当前Future的poll推动进度时,则从上次暂停的状态`恢复(resume)`,继续执行  \n\n官方目前似乎采用`Generator(生成器)`为异步语法生成状态机  \n每一个状态都会存储一些数据, 便于进入下一个状态  \n\n**Note 1**:  \nStart状态,会存储传入函数的参数(如果有参数)\n\n**Note 2**:  \nDone状态下,若进行resume,则可能得到panic!  \n因为恢复已结束的计算是不可能, 也不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义, 且point之后还需要使用的变量`  \n如上段代码中的 `file` 与 `count`就需要被保存,因为从暂停中恢复后还需要使用  \n其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象  \n所以不需要特殊的持久化操作\n\n- - - \n# 自引用结构体  \n## 保存引用\n当每个状态存储数据时,可能会导致发生`自引用`,比如:  \n\n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n\n这里有三个状态: `Start`,`Yield1`,`Done`  \n而在`Yield1`这个状态,存储的数据如下:  \n\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n}\n\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```\n\n等等,你可能会对上面的代码有疑惑:  \n不是说,状态只需要保存 `在yield point之前定义, 并且该point之后还需要使用的变量` 吗  \n上面的代码,只有element这个引用需要被保存吧?  \n\n这是因为,它是`引用`嘛!  \n没了`引用`背后的实际数据,那它还有啥用,不就是`悬垂引用`了吗?  \n\n因此我们还得保存,`该引用`指向的背后数据: `arr`  \n并**一起**存储在同个`struct(代表同一状态)`中  \n\n\n像这种 `结构体内部的指针,指向结构体本身`  \n就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下,成员element指向了成员arr  \n\n## 内存移动问题\n如上所述, 这可能导致悬垂引用的产生:  \n若该struct实例的`内存地址发生改变`  \n(比如使用`std::mem`,让struct实例的内存地址,发生移动)  \n\n以上面的那段代码为例,如下:  \n- arr:  \n内存地址会跟着结构体实例而改变  \n但是, `值仍然是 [1,2,3]`\n\n- element:  \n内存地址会跟着结构体实例而改变  \n但是,值仍然是`先前arr的地址`  \n`注意,是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n\n官方提出了`std::pin::Pin(trait)`  \n来解决自引用结构体方面的悬垂指针/引用问题 \n\n其实你听名字也很好理解:  \n`Pin(中文意思是钉子)`的作用是,防止内存地址发生改变(给爷钉死吧!)  \n\n但是它又是怎么pin住的呢?  \n下一节再慢慢讲吧  \n\n那又是一个值得探讨的话题了  \n欲知后事如何, 且听下回分解  \n\n~~(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~  ","source":"_posts/rs-async/rs-async-p4-状态的保存与变换.md","raw":"---\ntitle: rs-async-p4-状态的保存与变换\ncomments: false\nabbrlink: posts/rs-async-p4\ndate: 2021-09-12 14:50:14\ntop: 9996\ntags: rust\nkeywords: [async, 异步, Rust]\n---\n> 浅显的原理第一篇: 状态的保存/变换\n<!-- more -->\n\n同系列传送门: [rust-async系列](https://jedsek.github.io/categories/rust-async)\n\n# 开篇\n**注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看**  \n为了更好地理解`Rust异步`背后的原理,我们先来了解下一些概念  \n当然,不用太深入,只是小补充而已:   \n- `抢占式/协作式多任务`  \n- `状态机`  \n- `自引用结构体`   \n\n\n现在,让我们开始吧!  \n- - -\n# 两种多任务  \n## 介绍\n`抢占式多任务`与`协作式多任务`,都属于`多任务`  \n\n- 抢占式多任务:  \n操作系统决定CPU的运行权  \n比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会  \n各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种`任务们同时运行`的感觉  \n这是强迫/抢占的    \n\n- 协作式多任务:  \n任务们本身进行协调,决定CPU的运行权  \n比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending  \n自己放弃继续执行,并通知运行时执行其他Task  \n这是自愿/协作的,Task们`自愿放弃CPU的执行权`\n(上文中的`任务`与`Task`请区分一下,前者比后者广泛,后者在这用于Rust的举例)  \n\n## 状态的恢复/保存\n既然任务们能互相切换执行,那么,当再次轮到某任务执行时  \n该任务,应当从先前暂停的地方开始,继续执行  \n因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是`状态保存`  \n\n对于`抢占式`与`协作式`,处理`状态保存`的思路是不一样的:\n\n- 抢占式:  \n因为是强迫切换执行的,任务会在任意某个时刻被中断  \n任务此时运行到了哪里?我们不知道啊!  \n那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)    \n\n反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间  \n但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大  \n\n- 协作式:  \n因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的  \n这种放弃执行权的操作,我们称为`yield`    \n\n比如在Rust中,`xxx.await`会执行一个Future  \t\n意味着当程序执行到这里时,可能会`yield`(poll返回Poll::Pending,自愿放弃执行权)  \n\n`xxx.await`就是一个`stop/yield point`,代表执行到此处时,可能会发生暂停并yield  \n瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)  \n因此,我们可以准确分配Future执行所需要的最大空间  \n\n其实,每个`.await(也就是yield point)`,就代表着`一种状态`(之后会讲)\n\n协作式的好处在于:  \n能自己掌握所有`yield point`,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理  \n毕竟机器定义的分配策略, 总是没有比不过我们特意设计的  \n在任务暂停并转让执行权前,准确保存`下次继续所需要的状态`,内存/性能优势很大    \n但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行  \n\n- - -\n# 状态机的概念  \n在Rust中的异步,我们之前也说过,属于`协作式多任务`  \n而其`状态保存`的实现,就是利用`状态机(state machine)`来实现  \n\n`状态机(state machine)`一般指`有限状态自动机`,是一种数学模型  \n\n1. 状态(state):  \n比如有一扇门,它的状态就处于以下两种之一: Open or Closed\n2. 事件(event):  \n某事件发生后,会触发相应动作,可能改变状态  \n比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state)   \n3. 动作 (action):  \n事件发生后,会触发动作  \n4. 变换 (transition):  \n`State_X=>State_Y`就叫`变换`,比如门的状态从`Open=>Closed`  \n\n稍微了解下`状态机`的概念即可  \n\n那么现在,就要看具体代码了  \n\n如果你想亲自运行一下,先确保你的`Cargo.toml`中的依赖如下:  \n\n```toml\n[dependencies]\nasync-std = {version = \"1\", features = [\"attributes\", \"unstable\"]}\n```\n\n如下代码,读取一个文件的行数  \n你可以通过 `cargo run -- ./src/main.rs` 运行  \n(通过target目录下的可执行文件,加上参数后运行,也可以哦)  \n\n```rust\nuse std::{\n\tenv::args,\n\tprocess,\n};\nuse async_std::{\n\tprelude::*,\n\tfs::File,\n\tio::{self,BufReader},\n};\n\n#[async_std::main]\nasync fn main() -> io::Result<()> {              // Start\n\tlet path = args().nth(1).unwrap_or_else(||{\n\t\teprintln!(\"Fuck you! No path for reading\");\n\t\tprocess::exit(1);\n\t}); \n\tlet file = File::open(path).await?;          // Yield point\n\tlet lines = BufReader::new(file).lines();\n\tlet count = lines.count().await;             // Yield point\n\n\tprintln!(\"This file contains {} lines\",count);\n\tOk(())\n}                                                // Done\n```\n\n\nmian()产生一个新实例,异步运行`open(path)`与`count()`  \t    \n对于编译器,每一个`.await`其实都代表一种状态  \n\nFuture实例,实际上是个状态机  \n在这里共有四种状态/阶段(其中包括两个`.await point(yield point)`):  \n1. Start: 此Future刚开始执行  \n2. Yield1: 第一个 yield point\n3. Yield2: 第二个 yield point\n4. Done: 此Future执行完毕\n\n这些状态的含义是: `表示当前Future执行到了哪一个阶段`  \n执行器调用当前Future的poll推动进度时,若在`某一阶段`返回了`Poll::Pending`,则放弃执行权  \n当再次调用当前Future的poll推动进度时,则从上次暂停的状态`恢复(resume)`,继续执行  \n\n官方目前似乎采用`Generator(生成器)`为异步语法生成状态机  \n每一个状态都会存储一些数据, 便于进入下一个状态  \n\n**Note 1**:  \nStart状态,会存储传入函数的参数(如果有参数)\n\n**Note 2**:  \nDone状态下,若进行resume,则可能得到panic!  \n因为恢复已结束的计算是不可能, 也不应该的  \n\n**Note 3**:  \n怎么判断每个状态需要保存哪些变量? 很简单的一句话:  \n`某个yield point之前定义, 且point之后还需要使用的变量`  \n如上段代码中的 `file` 与 `count`就需要被保存,因为从暂停中恢复后还需要使用  \n其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象  \n所以不需要特殊的持久化操作\n\n- - - \n# 自引用结构体  \n## 保存引用\n当每个状态存储数据时,可能会导致发生`自引用`,比如:  \n\n```rust\nasync fn example() -> i32 {                            // Start\n    let arr = [1, 2, 3];\n    let element = &arr[2];\n    write_file(\"foo.txt\", element.to_string()).await;  // Yield1\n    *element                                           // Done\n}\n```\n\n这里有三个状态: `Start`,`Yield1`,`Done`  \n而在`Yield1`这个状态,存储的数据如下:  \n\n```rust\n// 状态的定义\nstruct Yield1State {\n    arr: [i32; 3],\n    element: *const i32, // 数组最后一个元素的地址\n}\n\n// 状态的实例\nYield1State {\n    arr: [1,2,3],\n    element: &arr[2] as *const i32,\n}\n```\n\n等等,你可能会对上面的代码有疑惑:  \n不是说,状态只需要保存 `在yield point之前定义, 并且该point之后还需要使用的变量` 吗  \n上面的代码,只有element这个引用需要被保存吧?  \n\n这是因为,它是`引用`嘛!  \n没了`引用`背后的实际数据,那它还有啥用,不就是`悬垂引用`了吗?  \n\n因此我们还得保存,`该引用`指向的背后数据: `arr`  \n并**一起**存储在同个`struct(代表同一状态)`中  \n\n\n像这种 `结构体内部的指针,指向结构体本身`  \n就叫 `自引用结构`  \n\n比如上面代码: 同一结构体下,成员element指向了成员arr  \n\n## 内存移动问题\n如上所述, 这可能导致悬垂引用的产生:  \n若该struct实例的`内存地址发生改变`  \n(比如使用`std::mem`,让struct实例的内存地址,发生移动)  \n\n以上面的那段代码为例,如下:  \n- arr:  \n内存地址会跟着结构体实例而改变  \n但是, `值仍然是 [1,2,3]`\n\n- element:  \n内存地址会跟着结构体实例而改变  \n但是,值仍然是`先前arr的地址`  \n`注意,是先前的 ! 而不是后来arr的新地址`\n\n这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  \n\n官方提出了`std::pin::Pin(trait)`  \n来解决自引用结构体方面的悬垂指针/引用问题 \n\n其实你听名字也很好理解:  \n`Pin(中文意思是钉子)`的作用是,防止内存地址发生改变(给爷钉死吧!)  \n\n但是它又是怎么pin住的呢?  \n下一节再慢慢讲吧  \n\n那又是一个值得探讨的话题了  \n欲知后事如何, 且听下回分解  \n\n~~(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)~~  ","slug":"rs-async/rs-async-p4-状态的保存与变换","published":1,"updated":"2021-09-12T06:50:14.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mz000pjaqy6m14af21","content":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-async\">rust-async系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p><strong>注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看</strong><br>为了更好地理解<code>Rust异步</code>背后的原理,我们先来了解下一些概念<br>当然,不用太深入,只是小补充而已:   </p>\n<ul>\n<li><code>抢占式/协作式多任务</code>  </li>\n<li><code>状态机</code>  </li>\n<li><code>自引用结构体</code>   </li>\n</ul>\n<p>现在,让我们开始吧!  </p>\n<hr>\n<h1 id=\"两种多任务\"><a href=\"#两种多任务\" class=\"headerlink\" title=\"两种多任务\"></a>两种多任务</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><code>抢占式多任务</code>与<code>协作式多任务</code>,都属于<code>多任务</code>  </p>\n<ul>\n<li><p>抢占式多任务:<br>操作系统决定CPU的运行权<br>比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会<br>各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种<code>任务们同时运行</code>的感觉<br>这是强迫/抢占的    </p>\n</li>\n<li><p>协作式多任务:<br>任务们本身进行协调,决定CPU的运行权<br>比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending<br>自己放弃继续执行,并通知运行时执行其他Task<br>这是自愿/协作的,Task们<code>自愿放弃CPU的执行权</code><br>(上文中的<code>任务</code>与<code>Task</code>请区分一下,前者比后者广泛,后者在这用于Rust的举例)  </p>\n</li>\n</ul>\n<h2 id=\"状态的恢复-保存\"><a href=\"#状态的恢复-保存\" class=\"headerlink\" title=\"状态的恢复/保存\"></a>状态的恢复/保存</h2><p>既然任务们能互相切换执行,那么,当再次轮到某任务执行时<br>该任务,应当从先前暂停的地方开始,继续执行<br>因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是<code>状态保存</code>  </p>\n<p>对于<code>抢占式</code>与<code>协作式</code>,处理<code>状态保存</code>的思路是不一样的:</p>\n<ul>\n<li>抢占式:<br>因为是强迫切换执行的,任务会在任意某个时刻被中断<br>任务此时运行到了哪里?我们不知道啊!<br>那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)    </li>\n</ul>\n<p>反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间<br>但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大  </p>\n<ul>\n<li>协作式:<br>因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的<br>这种放弃执行权的操作,我们称为<code>yield</code>    </li>\n</ul>\n<p>比如在Rust中,<code>xxx.await</code>会执行一个Future<br>意味着当程序执行到这里时,可能会<code>yield</code>(poll返回Poll::Pending,自愿放弃执行权)  </p>\n<p><code>xxx.await</code>就是一个<code>stop/yield point</code>,代表执行到此处时,可能会发生暂停并yield<br>瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>因此,我们可以准确分配Future执行所需要的最大空间  </p>\n<p>其实,每个<code>.await(也就是yield point)</code>,就代表着<code>一种状态</code>(之后会讲)</p>\n<p>协作式的好处在于:<br>能自己掌握所有<code>yield point</code>,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理<br>毕竟机器定义的分配策略, 总是没有比不过我们特意设计的<br>在任务暂停并转让执行权前,准确保存<code>下次继续所需要的状态</code>,内存/性能优势很大<br>但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行  </p>\n<hr>\n<h1 id=\"状态机的概念\"><a href=\"#状态机的概念\" class=\"headerlink\" title=\"状态机的概念\"></a>状态机的概念</h1><p>在Rust中的异步,我们之前也说过,属于<code>协作式多任务</code><br>而其<code>状态保存</code>的实现,就是利用<code>状态机(state machine)</code>来实现  </p>\n<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>,是一种数学模型  </p>\n<ol>\n<li>状态(state):<br>比如有一扇门,它的状态就处于以下两种之一: Open or Closed</li>\n<li>事件(event):<br>某事件发生后,会触发相应动作,可能改变状态<br>比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)   </li>\n<li>动作 (action):<br>事件发生后,会触发动作  </li>\n<li>变换 (transition):<br><code>State_X=&gt;State_Y</code>就叫<code>变换</code>,比如门的状态从<code>Open=&gt;Closed</code>  </li>\n</ol>\n<p>稍微了解下<code>状态机</code>的概念即可  </p>\n<p>那么现在,就要看具体代码了  </p>\n<p>如果你想亲自运行一下,先确保你的<code>Cargo.toml</code>中的依赖如下:  </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下代码,读取一个文件的行数<br>你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>(通过target目录下的可执行文件,加上参数后运行,也可以哦)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    env::args,</span><br><span class=\"line\">    process,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> async_std::&#123;</span><br><span class=\"line\">    prelude::*,</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).unwrap_or_else(||&#123;</span><br><span class=\"line\">        eprintln!(<span class=\"string\">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class=\"line\">        process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n\n\n<p>mian()产生一个新实例,异步运行<code>open(path)</code>与<code>count()</code><br>对于编译器,每一个<code>.await</code>其实都代表一种状态  </p>\n<p>Future实例,实际上是个状态机<br>在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):  </p>\n<ol>\n<li>Start: 此Future刚开始执行  </li>\n<li>Yield1: 第一个 yield point</li>\n<li>Yield2: 第二个 yield point</li>\n<li>Done: 此Future执行完毕</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>执行器调用当前Future的poll推动进度时,若在<code>某一阶段</code>返回了<code>Poll::Pending</code>,则放弃执行权<br>当再次调用当前Future的poll推动进度时,则从上次暂停的状态<code>恢复(resume)</code>,继续执行  </p>\n<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机<br>每一个状态都会存储一些数据, 便于进入下一个状态  </p>\n<p><strong>Note 1</strong>:<br>Start状态,会存储传入函数的参数(如果有参数)</p>\n<p><strong>Note 2</strong>:<br>Done状态下,若进行resume,则可能得到panic!<br>因为恢复已结束的计算是不可能, 也不应该的  </p>\n<p><strong>Note 3</strong>:<br>怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br><code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存,因为从暂停中恢复后还需要使用<br>其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象<br>所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"自引用结构体\"><a href=\"#自引用结构体\" class=\"headerlink\" title=\"自引用结构体\"></a>自引用结构体</h1><h2 id=\"保存引用\"><a href=\"#保存引用\" class=\"headerlink\" title=\"保存引用\"></a>保存引用</h2><p>当每个状态存储数据时,可能会导致发生<code>自引用</code>,比如:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有三个状态: <code>Start</code>,<code>Yield1</code>,<code>Done</code><br>而在<code>Yield1</code>这个状态,存储的数据如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Yield1State</span></span> &#123;</span><br><span class=\"line\">    arr: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>],</span><br><span class=\"line\">    element: *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>, <span class=\"comment\">// 数组最后一个元素的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 状态的实例</span></span><br><span class=\"line\">Yield1State &#123;</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">    element: &amp;arr[<span class=\"number\">2</span>] <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等,你可能会对上面的代码有疑惑:<br>不是说,状态只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>上面的代码,只有element这个引用需要被保存吧?  </p>\n<p>这是因为,它是<code>引用</code>嘛!<br>没了<code>引用</code>背后的实际数据,那它还有啥用,不就是<code>悬垂引用</code>了吗?  </p>\n<p>因此我们还得保存,<code>该引用</code>指向的背后数据: <code>arr</code><br>并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中  </p>\n<p>像这种 <code>结构体内部的指针,指向结构体本身</code><br>就叫 <code>自引用结构</code>  </p>\n<p>比如上面代码: 同一结构体下,成员element指向了成员arr  </p>\n<h2 id=\"内存移动问题\"><a href=\"#内存移动问题\" class=\"headerlink\" title=\"内存移动问题\"></a>内存移动问题</h2><p>如上所述, 这可能导致悬垂引用的产生:<br>若该struct实例的<code>内存地址发生改变</code><br>(比如使用<code>std::mem</code>,让struct实例的内存地址,发生移动)  </p>\n<p>以上面的那段代码为例,如下:  </p>\n<ul>\n<li><p>arr:<br>内存地址会跟着结构体实例而改变<br>但是, <code>值仍然是 [1,2,3]</code></p>\n</li>\n<li><p>element:<br>内存地址会跟着结构体实例而改变<br>但是,值仍然是<code>先前arr的地址</code><br><code>注意,是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  </p>\n<p>官方提出了<code>std::pin::Pin(trait)</code><br>来解决自引用结构体方面的悬垂指针/引用问题 </p>\n<p>其实你听名字也很好理解:<br><code>Pin(中文意思是钉子)</code>的作用是,防止内存地址发生改变(给爷钉死吧!)  </p>\n<p>但是它又是怎么pin住的呢?<br>下一节再慢慢讲吧  </p>\n<p>那又是一个值得探讨的话题了<br>欲知后事如何, 且听下回分解  </p>\n<p><del>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</del>  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/rust-async\">rust-async系列</a></p>\n<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><p><strong>注: 参考了《Writing an OS in Rust》中的async篇,可以自己搜索下看看</strong><br>为了更好地理解<code>Rust异步</code>背后的原理,我们先来了解下一些概念<br>当然,不用太深入,只是小补充而已:   </p>\n<ul>\n<li><code>抢占式/协作式多任务</code>  </li>\n<li><code>状态机</code>  </li>\n<li><code>自引用结构体</code>   </li>\n</ul>\n<p>现在,让我们开始吧!  </p>\n<hr>\n<h1 id=\"两种多任务\"><a href=\"#两种多任务\" class=\"headerlink\" title=\"两种多任务\"></a>两种多任务</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><code>抢占式多任务</code>与<code>协作式多任务</code>,都属于<code>多任务</code>  </p>\n<ul>\n<li><p>抢占式多任务:<br>操作系统决定CPU的运行权<br>比如,操作系统先让网易云音乐运行一会,再让VSCode运行一会<br>各个程序中的任务们,运行时间很短,但切换速度也很快,造成一种<code>任务们同时运行</code>的感觉<br>这是强迫/抢占的    </p>\n</li>\n<li><p>协作式多任务:<br>任务们本身进行协调,决定CPU的运行权<br>比如Rust中,运行时调用某Task(top-level Future)的poll方法阻塞时,返回Poll::Pending<br>自己放弃继续执行,并通知运行时执行其他Task<br>这是自愿/协作的,Task们<code>自愿放弃CPU的执行权</code><br>(上文中的<code>任务</code>与<code>Task</code>请区分一下,前者比后者广泛,后者在这用于Rust的举例)  </p>\n</li>\n</ul>\n<h2 id=\"状态的恢复-保存\"><a href=\"#状态的恢复-保存\" class=\"headerlink\" title=\"状态的恢复/保存\"></a>状态的恢复/保存</h2><p>既然任务们能互相切换执行,那么,当再次轮到某任务执行时<br>该任务,应当从先前暂停的地方开始,继续执行<br>因此我们应当备份某任务的先前状态,以便于之后的继续执行,这就是<code>状态保存</code>  </p>\n<p>对于<code>抢占式</code>与<code>协作式</code>,处理<code>状态保存</code>的思路是不一样的:</p>\n<ul>\n<li>抢占式:<br>因为是强迫切换执行的,任务会在任意某个时刻被中断<br>任务此时运行到了哪里?我们不知道啊!<br>那么,就只好将任务的所有状态全部保存,包括调用栈(call stack)    </li>\n</ul>\n<p>反正,你只需明白,操作系统强制切换任务,为每个任务分配相对公平的执行时间<br>但是,代价也有,比如不得不为每个任务保存它的所有状态,内存开销大  </p>\n<ul>\n<li>协作式:<br>因为是自愿/协作地切换执行,每个任务会在哪里放弃执行都是清楚的<br>这种放弃执行权的操作,我们称为<code>yield</code>    </li>\n</ul>\n<p>比如在Rust中,<code>xxx.await</code>会执行一个Future<br>意味着当程序执行到这里时,可能会<code>yield</code>(poll返回Poll::Pending,自愿放弃执行权)  </p>\n<p><code>xxx.await</code>就是一个<code>stop/yield point</code>,代表执行到此处时,可能会发生暂停并yield<br>瞧,所有可能yield的地方你都知道,这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br>因此,我们可以准确分配Future执行所需要的最大空间  </p>\n<p>其实,每个<code>.await(也就是yield point)</code>,就代表着<code>一种状态</code>(之后会讲)</p>\n<p>协作式的好处在于:<br>能自己掌握所有<code>yield point</code>,从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理<br>毕竟机器定义的分配策略, 总是没有比不过我们特意设计的<br>在任务暂停并转让执行权前,准确保存<code>下次继续所需要的状态</code>,内存/性能优势很大<br>但坏处也有: 因为这是自愿/协作的,当某个任务出现Bug,永不放弃执行权,其他任务便无法执行  </p>\n<hr>\n<h1 id=\"状态机的概念\"><a href=\"#状态机的概念\" class=\"headerlink\" title=\"状态机的概念\"></a>状态机的概念</h1><p>在Rust中的异步,我们之前也说过,属于<code>协作式多任务</code><br>而其<code>状态保存</code>的实现,就是利用<code>状态机(state machine)</code>来实现  </p>\n<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>,是一种数学模型  </p>\n<ol>\n<li>状态(state):<br>比如有一扇门,它的状态就处于以下两种之一: Open or Closed</li>\n<li>事件(event):<br>某事件发生后,会触发相应动作,可能改变状态<br>比如: 用钥匙锁门(event)=&gt;关门(action)=&gt;门被锁住(state)   </li>\n<li>动作 (action):<br>事件发生后,会触发动作  </li>\n<li>变换 (transition):<br><code>State_X=&gt;State_Y</code>就叫<code>变换</code>,比如门的状态从<code>Open=&gt;Closed</code>  </li>\n</ol>\n<p>稍微了解下<code>状态机</code>的概念即可  </p>\n<p>那么现在,就要看具体代码了  </p>\n<p>如果你想亲自运行一下,先确保你的<code>Cargo.toml</code>中的依赖如下:  </p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">async-std</span> = &#123;version = <span class=\"string\">&quot;1&quot;</span>, features = [<span class=\"string\">&quot;attributes&quot;</span>, <span class=\"string\">&quot;unstable&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下代码,读取一个文件的行数<br>你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br>(通过target目录下的可执行文件,加上参数后运行,也可以哦)  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    env::args,</span><br><span class=\"line\">    process,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> async_std::&#123;</span><br><span class=\"line\">    prelude::*,</span><br><span class=\"line\">    fs::File,</span><br><span class=\"line\">    io::&#123;<span class=\"keyword\">self</span>,BufReader&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[async_std::main]</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() -&gt; io::<span class=\"built_in\">Result</span>&lt;()&gt; &#123;              <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = args().nth(<span class=\"number\">1</span>).unwrap_or_else(||&#123;</span><br><span class=\"line\">        eprintln!(<span class=\"string\">&quot;Fuck you! No path for reading&quot;</span>);</span><br><span class=\"line\">        process::exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = File::open(path).<span class=\"keyword\">await</span>?;          <span class=\"comment\">// Yield point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lines = BufReader::new(file).lines();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = lines.count().<span class=\"keyword\">await</span>;             <span class=\"comment\">// Yield point</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;This file contains &#123;&#125; lines&quot;</span>,count);</span><br><span class=\"line\">    <span class=\"literal\">Ok</span>(())</span><br><span class=\"line\">&#125;                                                <span class=\"comment\">// Done</span></span><br></pre></td></tr></table></figure>\n\n\n<p>mian()产生一个新实例,异步运行<code>open(path)</code>与<code>count()</code><br>对于编译器,每一个<code>.await</code>其实都代表一种状态  </p>\n<p>Future实例,实际上是个状态机<br>在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):  </p>\n<ol>\n<li>Start: 此Future刚开始执行  </li>\n<li>Yield1: 第一个 yield point</li>\n<li>Yield2: 第二个 yield point</li>\n<li>Done: 此Future执行完毕</li>\n</ol>\n<p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br>执行器调用当前Future的poll推动进度时,若在<code>某一阶段</code>返回了<code>Poll::Pending</code>,则放弃执行权<br>当再次调用当前Future的poll推动进度时,则从上次暂停的状态<code>恢复(resume)</code>,继续执行  </p>\n<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机<br>每一个状态都会存储一些数据, 便于进入下一个状态  </p>\n<p><strong>Note 1</strong>:<br>Start状态,会存储传入函数的参数(如果有参数)</p>\n<p><strong>Note 2</strong>:<br>Done状态下,若进行resume,则可能得到panic!<br>因为恢复已结束的计算是不可能, 也不应该的  </p>\n<p><strong>Note 3</strong>:<br>怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br><code>某个yield point之前定义, 且point之后还需要使用的变量</code><br>如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存,因为从暂停中恢复后还需要使用<br>其他的变量,是一次性执行完的,不会出现什么暂停一下,等会继续的现象<br>所以不需要特殊的持久化操作</p>\n<hr>\n<h1 id=\"自引用结构体\"><a href=\"#自引用结构体\" class=\"headerlink\" title=\"自引用结构体\"></a>自引用结构体</h1><h2 id=\"保存引用\"><a href=\"#保存引用\" class=\"headerlink\" title=\"保存引用\"></a>保存引用</h2><p>当每个状态存储数据时,可能会导致发生<code>自引用</code>,比如:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">example</span></span>() -&gt; <span class=\"built_in\">i32</span> &#123;                            <span class=\"comment\">// Start</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &amp;arr[<span class=\"number\">2</span>];</span><br><span class=\"line\">    write_file(<span class=\"string\">&quot;foo.txt&quot;</span>, element.to_string()).<span class=\"keyword\">await</span>;  <span class=\"comment\">// Yield1</span></span><br><span class=\"line\">    *element                                           <span class=\"comment\">// Done</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有三个状态: <code>Start</code>,<code>Yield1</code>,<code>Done</code><br>而在<code>Yield1</code>这个状态,存储的数据如下:  </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态的定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Yield1State</span></span> &#123;</span><br><span class=\"line\">    arr: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>],</span><br><span class=\"line\">    element: *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>, <span class=\"comment\">// 数组最后一个元素的地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 状态的实例</span></span><br><span class=\"line\">Yield1State &#123;</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">    element: &amp;arr[<span class=\"number\">2</span>] <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"built_in\">i32</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等,你可能会对上面的代码有疑惑:<br>不是说,状态只需要保存 <code>在yield point之前定义, 并且该point之后还需要使用的变量</code> 吗<br>上面的代码,只有element这个引用需要被保存吧?  </p>\n<p>这是因为,它是<code>引用</code>嘛!<br>没了<code>引用</code>背后的实际数据,那它还有啥用,不就是<code>悬垂引用</code>了吗?  </p>\n<p>因此我们还得保存,<code>该引用</code>指向的背后数据: <code>arr</code><br>并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中  </p>\n<p>像这种 <code>结构体内部的指针,指向结构体本身</code><br>就叫 <code>自引用结构</code>  </p>\n<p>比如上面代码: 同一结构体下,成员element指向了成员arr  </p>\n<h2 id=\"内存移动问题\"><a href=\"#内存移动问题\" class=\"headerlink\" title=\"内存移动问题\"></a>内存移动问题</h2><p>如上所述, 这可能导致悬垂引用的产生:<br>若该struct实例的<code>内存地址发生改变</code><br>(比如使用<code>std::mem</code>,让struct实例的内存地址,发生移动)  </p>\n<p>以上面的那段代码为例,如下:  </p>\n<ul>\n<li><p>arr:<br>内存地址会跟着结构体实例而改变<br>但是, <code>值仍然是 [1,2,3]</code></p>\n</li>\n<li><p>element:<br>内存地址会跟着结构体实例而改变<br>但是,值仍然是<code>先前arr的地址</code><br><code>注意,是先前的 ! 而不是后来arr的新地址</code></p>\n</li>\n</ul>\n<p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)  </p>\n<p>官方提出了<code>std::pin::Pin(trait)</code><br>来解决自引用结构体方面的悬垂指针/引用问题 </p>\n<p>其实你听名字也很好理解:<br><code>Pin(中文意思是钉子)</code>的作用是,防止内存地址发生改变(给爷钉死吧!)  </p>\n<p>但是它又是怎么pin住的呢?<br>下一节再慢慢讲吧  </p>\n<p>那又是一个值得探讨的话题了<br>欲知后事如何, 且听下回分解  </p>\n<p><del>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</del>  </p>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Sep 12 2021 14:50:14 GMT+0800 (中国标准时间)","title":"rs-async-p4-状态的保存与变换","path":"posts/rs-async-p4.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>浅显的原理第一篇: 状态的保存/变换</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-09-12T06:50:14.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-09-12T06:50:14.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["rust"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rust-async","comments":0,"abbrlink":"categories/rust-async","hidden":true,"date":"2021-12-04T13:23:28.000Z","top":null,"keywords":null,"_content":"\n- [p1: 系列说明](https://jedsek.github.io/posts/rs-async-p1)\n- [p2: 异步简介](https://jedsek.github.io/posts/rs-async-p2)\n- [p3: Future](https://jedsek.github.io/posts/rs-async-p3)\n- [p4: 状态的保存与变换](https://jedsek.github.io/posts/rs-async-p4)\n","source":"_posts/categories/rust/rust-async.md","raw":"---\ntitle: rust-async\ncomments: false\nabbrlink: categories/rust-async\nhidden: true\ndate: 2021-12-04 21:23:28\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n- [p1: 系列说明](https://jedsek.github.io/posts/rs-async-p1)\n- [p2: 异步简介](https://jedsek.github.io/posts/rs-async-p2)\n- [p3: Future](https://jedsek.github.io/posts/rs-async-p3)\n- [p4: 状态的保存与变换](https://jedsek.github.io/posts/rs-async-p4)\n","slug":"categories/rust/rust-async","published":1,"updated":"2021-12-04T13:23:28.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9mz000rjaqyg3pihkk8","content":"<ul>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p1\">p1: 系列说明</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p2\">p2: 异步简介</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p3\">p3: Future</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p4\">p4: 状态的保存与变换</a></li>\n</ul>\n<!-- flag of hidden posts -->","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p1\">p1: 系列说明</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p2\">p2: 异步简介</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p3\">p3: Future</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-async-p4\">p4: 状态的保存与变换</a></li>\n</ul>\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Dec 04 2021 21:23:28 GMT+0800 (中国标准时间)","title":"rust-async","path":"categories/rust-async.html","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2021-12-04T13:23:28.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-12-04T13:23:28.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rust-decl-macro","comments":0,"abbrlink":"categories/rust-decl-macro","hidden":true,"date":"2021-12-04T14:30:59.000Z","top":null,"keywords":null,"_content":"- [p1: 系列说明](https://jedsek.github.io/posts/rs-decl-macro-p1)\n- [p2: 从println!开始](https://jedsek.github.io/posts/rs-decl-macro-p2)\n- [p3: 声明与使用](https://jedsek.github.io/posts/rs-decl-macro-p3)\n- [p4: 重复](https://jedsek.github.io/posts/rs-decl-macro-p4)\n- [p5: 卫生性](https://jedsek.github.io/posts/rs-decl-macro-p5)\n","source":"_posts/categories/rust/rust-decl-macro.md","raw":"---\ntitle: rust-decl-macro\ncomments: false\nabbrlink: categories/rust-decl-macro\nhidden: true\ndate: 2021-12-04 22:30:59\ntop:\ntags:\ncategories:\nkeywords:\n---\n- [p1: 系列说明](https://jedsek.github.io/posts/rs-decl-macro-p1)\n- [p2: 从println!开始](https://jedsek.github.io/posts/rs-decl-macro-p2)\n- [p3: 声明与使用](https://jedsek.github.io/posts/rs-decl-macro-p3)\n- [p4: 重复](https://jedsek.github.io/posts/rs-decl-macro-p4)\n- [p5: 卫生性](https://jedsek.github.io/posts/rs-decl-macro-p5)\n","slug":"categories/rust/rust-decl-macro","published":1,"updated":"2021-12-04T14:30:59.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9n0000ujaqyh4p06z3n","content":"<ul>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p1\">p1: 系列说明</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p2\">p2: 从println!开始</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p3\">p3: 声明与使用</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p4\">p4: 重复</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p5\">p5: 卫生性</a></li>\n</ul>\n<!-- flag of hidden posts -->","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p1\">p1: 系列说明</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p2\">p2: 从println!开始</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p3\">p3: 声明与使用</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p4\">p4: 重复</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-decl-macro-p5\">p5: 卫生性</a></li>\n</ul>\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Dec 04 2021 22:30:59 GMT+0800 (中国标准时间)","title":"rust-decl-macro","path":"categories/rust-decl-macro.html","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2021-12-04T14:30:59.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-12-04T14:30:59.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"rust-gtk4","comments":0,"abbrlink":"categories/rust-gtk4","hidden":true,"date":"2021-12-04T14:34:41.000Z","top":null,"keywords":null,"_content":"\n- [p1: 系列说明](https://jedsek.github.io/posts/rs-gtk4-p1)\n- [p2: 创建HelloWorld窗口](https://jedsek.github.io/posts/rs-gtk4-p2)\n","source":"_posts/categories/rust/rust-gtk4.md","raw":"---\ntitle: rust-gtk4\ncomments: false\nabbrlink: categories/rust-gtk4\nhidden: true\ndate: 2021-12-04 22:34:41\ntop:\ntags:\ncategories:\nkeywords:\n---\n\n- [p1: 系列说明](https://jedsek.github.io/posts/rs-gtk4-p1)\n- [p2: 创建HelloWorld窗口](https://jedsek.github.io/posts/rs-gtk4-p2)\n","slug":"categories/rust/rust-gtk4","published":1,"updated":"2021-12-04T14:34:41.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9n1000wjaqy3qb073hf","content":"<ul>\n<li><a href=\"https://jedsek.github.io/posts/rs-gtk4-p1\">p1: 系列说明</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-gtk4-p2\">p2: 创建HelloWorld窗口</a></li>\n</ul>\n<!-- flag of hidden posts -->","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"https://jedsek.github.io/posts/rs-gtk4-p1\">p1: 系列说明</a></li>\n<li><a href=\"https://jedsek.github.io/posts/rs-gtk4-p2\">p2: 创建HelloWorld窗口</a></li>\n</ul>\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sat Dec 04 2021 22:34:41 GMT+0800 (中国标准时间)","title":"rust-gtk4","path":"categories/rust-gtk4.html","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2021-12-04T14:34:41.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-12-04T14:34:41.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"manjaro-p1-双系统安装","comments":0,"abbrlink":"posts/manjaro-p1","hidden":false,"date":"2021-12-12T09:41:22.000Z","top":9699,"keywords":"manjaro","_content":"> 来看看如何基于Windows系统, 安装第二个操作系统: Manjaro\n<!-- more -->\n\n同系列传送门: [manjaro系列](https://jedsek.github.io/categories/manjaro)\n\n# 介绍\n","source":"_posts/manjaro/p1/manjaro-p1-安装.md","raw":"---\ntitle: manjaro-p1-双系统安装\ncomments: false\nabbrlink: posts/manjaro-p1\nhidden: false\ndate: 2021-12-12 17:41:22\ntop: 9699\ntags: manjaro\nkeywords: manjaro\n---\n> 来看看如何基于Windows系统, 安装第二个操作系统: Manjaro\n<!-- more -->\n\n同系列传送门: [manjaro系列](https://jedsek.github.io/categories/manjaro)\n\n# 介绍\n","slug":"manjaro/p1/manjaro-p1-安装","published":1,"updated":"2021-12-12T09:41:22.000Z","layout":"post","photos":[],"link":"","_id":"ckxvmv9n2000zjaqya90qcv2f","content":"<blockquote>\n<p>来看看如何基于Windows系统, 安装第二个操作系统: Manjaro</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/manjaro\">manjaro系列</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1>","site":{"data":{}},"excerpt":"<blockquote>\n<p>来看看如何基于Windows系统, 安装第二个操作系统: Manjaro</p>\n</blockquote>","more":"<p>同系列传送门: <a href=\"https://jedsek.github.io/categories/manjaro\">manjaro系列</a></p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 12 2021 17:41:22 GMT+0800 (中国标准时间)","title":"manjaro-p1-双系统安装","path":"posts/manjaro-p1.html","eyeCatchImage":null,"excerpt":"<blockquote>\n<p>来看看如何基于Windows系统, 安装第二个操作系统: Manjaro</p>\n</blockquote>","date":{"_isAMomentObject":true,"_i":"2021-12-12T09:41:22.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2021-12-12T09:41:22.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"","tags":["manjaro"],"internalLinks":[],"keywords":[],"keywordsLength":0}}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckxvmv9ml0004jaqygxpoa3cw","tag_id":"ckxvmv9mo0006jaqy4rwvh19s","_id":"ckxvmv9mt000bjaqyamye89zk"},{"post_id":"ckxvmv9mn0005jaqyal1mfjjm","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9mw000gjaqy5nlq7sg8"},{"post_id":"ckxvmv9mt000djaqy80oddm4y","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9mw000ijaqy6pok0fl2"},{"post_id":"ckxvmv9mq0007jaqyao733se9","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9mx000ljaqyh3ij1jsy"},{"post_id":"ckxvmv9mw000hjaqyabz5hxdh","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9my000njaqyeg9q2k8t"},{"post_id":"ckxvmv9mx000kjaqyfqha8gl0","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9mz000qjaqy63cm1g10"},{"post_id":"ckxvmv9mr0008jaqy73jw4eeo","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9n0000sjaqydwspd89y"},{"post_id":"ckxvmv9my000mjaqy5n710e6i","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9n1000vjaqy7wfj2gnf"},{"post_id":"ckxvmv9mz000pjaqy6m14af21","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9n2000xjaqyhs0sg7k5"},{"post_id":"ckxvmv9ms0009jaqy5xnyfu69","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9n20010jaqy4rg95kfi"},{"post_id":"ckxvmv9mt000cjaqyg0af1n6n","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9n30011jaqy0kwyhs7i"},{"post_id":"ckxvmv9mt000cjaqyg0af1n6n","tag_id":"ckxvmv9n0000tjaqyc99wea2u","_id":"ckxvmv9n40013jaqydvm12ewi"},{"post_id":"ckxvmv9mv000fjaqyf0xeauda","tag_id":"ckxvmv9ms000ajaqycs6wbmmx","_id":"ckxvmv9n40014jaqyfkepatee"},{"post_id":"ckxvmv9mv000fjaqyf0xeauda","tag_id":"ckxvmv9n0000tjaqyc99wea2u","_id":"ckxvmv9n40015jaqyg8588s05"},{"post_id":"ckxvmv9n2000zjaqya90qcv2f","tag_id":"ckxvmv9n30012jaqy77hvdp8w","_id":"ckxvmv9n40016jaqy8mi0diwi"}],"Tag":[{"name":"novel","_id":"ckxvmv9mo0006jaqy4rwvh19s"},{"name":"rust","_id":"ckxvmv9ms000ajaqycs6wbmmx"},{"name":"gui","_id":"ckxvmv9n0000tjaqyc99wea2u"},{"name":"manjaro","_id":"ckxvmv9n30012jaqy77hvdp8w"}]}}